[["index.html", "Open API - Daejeon Bus Information with R Open API를 이용한 대전광역시 버스 정보 조회 및 시각화", " Open API - Daejeon Bus Information with R Dae Ho Kim 2020-12-06 Open API를 이용한 대전광역시 버스 정보 조회 및 시각화 data.go.kr에서 제공하는 대전광역시 버스 정보 조회 서비스를 이용하여, 버스 노선 정보의 조회와 운행 중인 실시간 버스 위치 조회 서비스를 이용하여, 이를 시각화한다. 노선 버스의 노선 ID 확인하기 노선별 정류소 정보 조회 노선별 정류소 정보 시각화 운행 중인 버스의 실시간 위치 정보 조회 운행 중인 버스의 실시간 위치 시각화 "],["dj-Bus-ID.html", "Chapter 1 대전광역시 버스 노선 ID 확인하기 1. 패키지 불러오기 1.1 2. 대전광역시의 전체 노선 정보 확인 1.2 3. 106번 버스의 노선 ID 확인", " Chapter 1 대전광역시 버스 노선 ID 확인하기 data.go.kr의 Open API 활용 방법을 학습하기 위해, 현재 대전광역시 운행중인 버스 노선에 대한 정보 조회 방법을 예로 들어본다. (OpenAPI활용가이드_대전광역시_버스정보시스템_v1.0.docx 참고) 1. 패키지 불러오기 library(XML) library(ggmap) ## Loading required package: ggplot2 ## Google&#39;s Terms of Service: https://cloud.google.com/maps-platform/terms/. ## Please cite ggmap if you use it! See citation(&quot;ggmap&quot;) for details. library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 -- ##  tibble 3.0.4  dplyr 1.0.2 ##  tidyr 1.1.2  stringr 1.4.0 ##  readr 1.4.0  forcats 0.5.0 ##  purrr 0.3.4 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() 1.1 2. 대전광역시의 전체 노선 정보 확인 먼저 Open API를 사용하기 위해 data.go.kr에서 발급받은 API Key를 인증받는다. 1.1.1 2-1. API Key 인증받기 API_key &lt;- &quot;XNamCEPA1y........w2oz2Hqld26g%3D%3D&quot; # data.go.kr에서 발급받은 API_key 입력 1.1.2 2-2. 전체 노선정보 조회 1.1.2.1 1) 조회할 노선번호 노선번호(busRtNm)를 106번으로 한다. 대전광역시의 버스 노선정보 조회 서비는 서울특별시와 달리 하나의 데이터 베이스에서 노선번호와 노선ID를 확인할 수 있다. busRtNm &lt;- &quot;106&quot; # 검색할 노선버스 번호를 빈문자로 정한다. 1.1.2.2 2) 노선정보 조회 서비스 URL 노선정보조회 서비스 url을 입력한다. 기본 url : “http://openapitraffic.daejeon.go.kr/api/rest/busRouteInfo/getRouteInfoAll?serviceKey=” &amp;reqPage=1 : 모든 페이지 요구 url &lt;- &quot;http://openapitraffic.daejeon.go.kr/api/rest/busRouteInfo/getRouteInfoAll?serviceKey=&quot; srch_url &lt;- paste0(url, API_key, &quot;&amp;reqPage=1&quot;) srch_url &lt;- paste0() : 인수들을 공란없이 모든 붙임 url : http://openapitraffic.daejeon.go.kr/api/rest/busRouteInfo/getRouteInfoAll =&gt; 버스노선정보 검색 url. ? : API의 인수 연결 serviceKey = : (API의 첫번째 인수) 공공데이터 API Key &amp; : 추가적인 인수의 연결 reqPage=1 : (API의 두번쨰 인수) 버스노선정보 이용자매뉴얼 참고 1.1.2.3 3) 노선정보를 조회 xmlParse() 함수를 이용하여 노선정보 데이터를 다운로드하여, xmlfile에 대입한다. xmlfile &lt;- xmlParse(srch_url) # xmlRoot(xmefile) # 다운받은 결과 모두 출력 xmlfile &lt;- xmlParse(srch_url) : srch_url 사이트에서 정보를 가져와(xmlParse()), 변수 xmlfile에 저장하기. xmlRoot(xmlfile) :xmffile의 내용출력하기(xmlRoot()) 1.1.2.4 4) 조회한 정보를 데이터 프레임 형태로 변환 xmlToDataFrmae() 함수를 이용하여, xmlfile을 데이터 프레임 형태로 변환하여 dj_Bus 변수에 대입한다. dj_Bus &lt;- xmlToDataFrame(getNodeSet(xmlfile, &quot;//itemList&quot;)) str(dj_Bus) ## &#39;data.frame&#39;: 100 obs. of 27 variables: ## $ ALLO_INTERVAL : chr &quot;30&quot; &quot;8&quot; &quot;35&quot; &quot;25&quot; ... ## $ ALLO_INTERVAL_SAT: chr &quot;30&quot; &quot;9&quot; &quot;35&quot; &quot;25&quot; ... ## $ ALLO_INTERVAL_SUN: chr &quot;30&quot; &quot;10&quot; &quot;40&quot; &quot;40&quot; ... ## $ BUSSTOP_CNT : chr &quot;104&quot; &quot;62&quot; &quot;106&quot; &quot;80&quot; ... ## $ END_NODE_ID : chr &quot;8002737&quot; &quot;8001782&quot; &quot;8005970&quot; &quot;8001783&quot; ... ## $ END_STOP_ID : chr &quot;42750&quot; &quot;44800&quot; &quot;82210&quot; &quot;44490&quot; ... ## $ ORIGIN_END : chr &quot;2230&quot; &quot;2230&quot; &quot;2210&quot; &quot;2235&quot; ... ## $ ORIGIN_END_SAT : chr &quot;2230&quot; &quot;2230&quot; &quot;2210&quot; &quot;2235&quot; ... ## $ ORIGIN_END_SUN : chr &quot;2230&quot; &quot;2230&quot; &quot;2210&quot; &quot;2230&quot; ... ## $ ORIGIN_START : chr &quot;0600&quot; &quot;0545&quot; &quot;0555&quot; &quot;0600&quot; ... ## $ ORIGIN_START_SAT : chr &quot;0600&quot; &quot;0545&quot; &quot;0555&quot; &quot;0600&quot; ... ## $ ORIGIN_START_SUN : chr &quot;0630&quot; &quot;0545&quot; &quot;0600&quot; &quot;0600&quot; ... ## $ ROUTE_CD : chr &quot;30300001&quot; &quot;30300002&quot; &quot;30300003&quot; &quot;30300004&quot; ... ## $ ROUTE_NO : chr &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;5&quot; ... ## $ ROUTE_TP : chr &quot;5 &quot; &quot;1 &quot; &quot;5 &quot; &quot;5 &quot; ... ## $ RUN_DIST_HALF : chr &quot;23.907&quot; &quot;29.3505&quot; &quot;22.603&quot; &quot;18.056&quot; ... ## $ RUN_TM : chr &quot;70 &quot; &quot;88 &quot; &quot;70 &quot; &quot;90 &quot; ... ## $ START_NODE_ID : chr &quot;8002736&quot; &quot;8001783&quot; &quot;8005970&quot; &quot;8001783&quot; ... ## $ START_STOP_ID : chr &quot;42740&quot; &quot;44490&quot; &quot;82210&quot; &quot;44490&quot; ... ## $ TURN_END : chr &quot;2220&quot; &quot;2255&quot; &quot;2240&quot; &quot;2230&quot; ... ## $ TURN_END_SAT : chr &quot;2220&quot; &quot;2255&quot; &quot;2240&quot; &quot;2230&quot; ... ## $ TURN_END_SUN : chr &quot;2205&quot; &quot;2255&quot; &quot;2230&quot; &quot;2230&quot; ... ## $ TURN_NODE_ID : chr &quot;8007228&quot; &quot;9002254&quot; &quot;8070009&quot; &quot;8005825&quot; ... ## $ TURN_START : chr &quot;0600&quot; &quot;0545&quot; &quot;0610&quot; &quot;0600&quot; ... ## $ TURN_START_SAT : chr &quot;0600&quot; &quot;0545&quot; &quot;0610&quot; &quot;0600&quot; ... ## $ TURN_START_SUN : chr &quot;0630&quot; &quot;0545&quot; &quot;0615&quot; &quot;0600&quot; ... ## $ TURN_STOP_ID : chr &quot;82370&quot; &quot;20980&quot; &quot;45610&quot; &quot;82240&quot; ... 대전광역울시에서 운행 중인 버스 노선이 100개임을 확인할 수 있다. 컬럼의 갯수는 27개 : 이들에 대한 자세한 내용은 “OpenAPI활용가이드_대전광역시_버스정보시스템_v1.0.docx : p. 14~17 참고…” 1.2 3. 106번 버스의 노선 ID 확인 dj_Bus 데이터 세트의 ROUTE_NO 컬럼이 노선 번호를, 그리고 ROUTE_CD 컬럼이 노선 ID를 나타내고 있다. (“OpenAPI활용가이드_대전광역시_버스정보시스템_v1.0.docx : p. 15 참고..”) 따라서, dj_Bus 데이터 세트에서 ROUTE_N0 == 106인 ROUTE_CD를 찾으면 된다. bus_ID &lt;- dj_Bus[dj_Bus$ROUTE_NO == &quot;106&quot;, &quot;ROUTE_CD&quot;] bus_ID ## [1] &quot;30300041&quot; "],["dj-Bus-Route.html", "Chapter 2 대전광역시 버스 노선 정류소 정보 조회 1. 패키지 불러오기 2.1 2. 노선별 정류소 정보 확인", " Chapter 2 대전광역시 버스 노선 정류소 정보 조회 data.go.kr의 Open API 활용 방법을 학습하기 위해, 현재 대전광역시 운행중인 106번 버스의 버스 노선별 정류소 조회에 대한 정보 조회 방법을 예로 들어본다. 버스 노선별 정류소를 구글 지도에 시각화해 보기로 한다 1. 패키지 불러오기 library(XML) library(ggmap) library(tidyverse) 2.1 2. 노선별 정류소 정보 확인 먼저 Open API를 사용하기 위해 data.go.kr에서 발급받은 API Key를 인증받는다. 2.1.1 2-1. API Key 인증받기 API_key &lt;- &quot;XNamCEPA1y........w2oz2Hqld26g%3D%3D&quot; # data.go.kr에서 발급받은 API_key 입력 2.1.2 2-2. 노선별 정류소 목록 조회하기 2.1.2.1 1) 노선 ID 확인 노선번호 106번 버스의 노선 ID는 bus_ID에 저장되어 있으며, 그 값은 “30300041”이다. busRouteId &lt;- &quot;30300041&quot; 2.1.2.2 2) 노선별 경유 정류소 정보 조회 서비스 URL. 노선별 경유 정류소 조회 서비스를 이용하여, 노선ID에 해당하는 경유 정류소 목록을 조회한다 (Call Back) url = “http://openapitraffic.daejeon.go.kr/api/rest/busRouteInfo/getStaionByRoute?busRouteId=” busRouteId= : busRouteId serviceKey = : API_key url &lt;- &quot;http://openapitraffic.daejeon.go.kr/api/rest/busRouteInfo/getStaionByRoute?busRouteId=&quot; srch_url &lt;- paste0(url, busRouteId, &quot;&amp;serviceKey=&quot;, API_key) 2.1.2.3 3) 노선별 경유 정류소 정보 조회 xmlParse() 함수를 이용하여 노선별 정류소 정보를 다운로드하여, xmlfile에 대입한다. xmlfile &lt;- xmlParse(srch_url) # xmlRoot(xmefile) 2.1.2.4 4) 조회한 정보를 데이터 프레임 형태로 변환 xmlToDataFrmae() 함수를 이용하여, xmlfile을 데이터 프레임 형태로 변환하여 dj_station 변수에 대입한다. 이제 dj_station 변수는 bus_ID에 수록된 노선이 운행하는 정류소 정보를 담고 있다. dj_station &lt;- xmlToDataFrame(getNodeSet(xmlfile, &quot;//itemList&quot;)) str(dj_station) ## &#39;data.frame&#39;: 83 obs. of 12 variables: ## $ BUSSTOP_ENG_NM: chr &quot;Mokwon University Front Gate&quot; &quot;Heungdo Elementary School&quot; &quot;Humansia Apts. 10&quot; &quot;Treefullcity Apts.9&quot; ... ## $ BUSSTOP_NM : chr &quot;목원대학교&quot; &quot;흥도초등학교&quot; &quot;도안고등학교&quot; &quot;트리풀시티9단지&quot; ... ## $ BUSSTOP_SEQ : chr &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ BUSSTOP_TP : chr &quot;1&quot; &quot; &quot; &quot; &quot; &quot; &quot; ... ## $ BUS_NODE_ID : chr &quot;8001641&quot; &quot;8070030&quot; &quot;8005991&quot; &quot;8003100&quot; ... ## $ BUS_STOP_ID : chr &quot;33230&quot; &quot;41810&quot; &quot;45520&quot; &quot;45890&quot; ... ## $ GPS_LATI : chr &quot;36.329674&quot; &quot;36.333813&quot; &quot;36.33707&quot; &quot;36.341488&quot; ... ## $ GPS_LONG : chr &quot;127.33825&quot; &quot;127.338264&quot; &quot;127.33825&quot; &quot;127.33867&quot; ... ## $ ROAD_NM : chr &quot;도안동로&quot; &quot; &quot; &quot; &quot; &quot; &quot; ... ## $ ROAD_NM_ADDR : chr &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; ... ## $ ROUTE_CD : chr &quot;30300041&quot; &quot;30300041&quot; &quot;30300041&quot; &quot;30300041&quot; ... ## $ TOTAL_DIST : chr &quot;105&quot; &quot;509&quot; &quot;871&quot; &quot;1589&quot; ... bus_ID 노선의 정류소 정보가 83개임을 확인할 수 있다. 컬럼의 갯수는 12개 : 이들에 대한 자세한 내용은 “(OpenAPI활용가이드_대전광역시_버스정보시스템_v1.0.docx, pp. 5~8 참고).” 2.1.2.5 5) 분석용 데이터 세트의 생성 dj_station 데이터 세트의 BUSSTOP_NM(정류소 이름), GPS_LATI(위도), GPS_LONG(경도) 컬럼을 선택하여 다음과 같이 변환시켜 bus_station 데이터 세트를 생성한다. BUSSTOP_NM -&gt; stationNm 으로 이름 변경 GPS_LAT1 -&gt; 숫자형 변환 -&gt; gpsY로 이름 변경 GPS_LONG -&gt; 숫자형 변환 -&gt; gpsX로 이름 변경 gpsX &lt;- as.numeric(dj_station$GPS_LONG) gpsY &lt;- as.numeric(dj_station$GPS_LATI) bus_station &lt;- data.frame(stationNm = dj_station$BUSSTOP_NM, lon=gpsX, lat=gpsY) str(bus_station) ## &#39;data.frame&#39;: 83 obs. of 3 variables: ## $ stationNm: chr &quot;목원대학교&quot; &quot;흥도초등학교&quot; &quot;도안고등학교&quot; &quot;트리풀시티9단지&quot; ... ## $ lon : num 127 127 127 127 127 ... ## $ lat : num 36.3 36.3 36.3 36.3 36.3 ... 2.1.2.6 6) 데이터 세트 저장하기 write_rds(bus_station, &quot;data/bus_station.rds&quot;) "],["dj-Bus-Route-Visualization.html", "Chapter 3 대전광역시 버스 노선 정류소 시각화 1. 패키지 불러오기 3.1 2. 버스 정류소 위치를 Marker로 표시하기 3.2 3. 버스 정류소 위치에 정류소 이름 표시하기", " Chapter 3 대전광역시 버스 노선 정류소 시각화 data.go.kr의 Open API 활용 방법을 학습하기 위해, 현재 대전광역시 운행중인 버스 노선에 대한 정보 조회 방법을 예로 들어본다. 버스 노선별 정류소를 구글 지도에 시각화해 보기로 한다 1. 패키지 불러오기 library(XML) library(ggmap) library(tidyverse) 3.1 2. 버스 정류소 위치를 Marker로 표시하기 3.1.1 2-1. Google API 인증 register_google(key=&quot;API Key&quot;) # https://console.cloud.google.com 에서 확인 3.1.2 2-2. 버스 위치의 중심점 찾기 station 데이터 세트에서 위치정보 컬럼만 선택하여, gc 에 대입한다. 그리고 버스 정류소의 중심 위치를 확인하여 cen에 대입한다. station &lt;- read_rds(&quot;data/bus_station.rds&quot;) gc &lt;- station[, 2:3] # lon, lat 컬럼만 추출 cen &lt;- sapply(gc, mean) # 차량위치의 중심점 3.1.3 2-3. 구글 지도 정보 가져오기 get_googlemap() 함수를 이용하여 구글 지도 정보를 가져온다. 그 결과는 map에 대입한다. map &lt;- get_googlemap(center = cen, maptype = &quot;roadmap&quot;, zoom = 11, marker = gc) ## Source : https://maps.googleapis.com/maps/api/staticmap?center=36.350464,127.395379&amp;zoom=11&amp;size=640x640&amp;scale=2&amp;maptype=roadmap&amp;markers=36.329674,127.33825%7C36.333813,127.338264%7C36.33707,127.33825%7C36.341488,127.33867%7C36.34515,127.34043%7C36.35159,127.34072%7C36.354378,127.342026%7C36.358105,127.34342%7C36.361355,127.34468%7C36.359398,127.35449%7C36.358505,127.361%7C36.359715,127.36569%7C36.35968,127.371956%7C36.359173,127.37414%7C36.356583,127.37412%7C36.353825,127.37399%7C36.351604,127.37698%7C36.351147,127.38076%7C36.351116,127.384865%7C36.351143,127.38867%7C36.351124,127.39167%7C36.35111,127.39719%7C36.350384,127.40151%7C36.347336,127.401566%7C36.341076,127.41007%7C36.338676,127.41313%7C36.33962,127.42015%7C36.345608,127.422134%7C36.346455,127.42565%7C36.345467,127.4298%7C36.34904,127.43719%7C36.350216,127.440475%7C36.348995,127.443214%7C36.346027,127.44738%7C36.348312,127.45116%7C36.350624,127.45246%7C36.353428,127.4541%7C36.356636,127.45446%7C36.35839,127.45051%7C36.359646,127.44942%7C36.36065,127.450066%7C36.360332,127.44997%7C36.359825,127.44932%7C36.35832,127.45011%7C36.357056,127.453514%7C36.354073,127.45417%7C36.350567,127.45212%7C36.34835,127.45088%7C36.346153,127.44707%7C36.34641,127.44533%7C36.348618,127.44393%7C36.350426,127.43968%7C36.349014,127.43566%7C36.345703,127.42946%7C36.34656,127.42596%7C36.345478,127.42163%7C36.340084,127.42007%7C36.339115,127.41302%7C36.34149,127.41003%7C36.345898,127.402145%7C36.351364,127.39831%7C36.3514,127.393265%7C36.351402,127.38817%7C36.35139,127.3835%7C36.351402,127.3806%7C36.351944,127.37698%7C36.353165,127.374466%7C36.355083,127.37443%7C36.359123,127.37448%7C36.359947,127.370865%7C36.359947,127.366585%7C36.358727,127.362434%7C36.359795,127.35469%7C36.36134,127.3472%7C36.36156,127.34411%7C36.35776,127.3426%7C36.354877,127.34152%7C36.35236,127.34095%7C36.346264,127.34013%7C36.34161,127.33818%7C36.33774,127.338036%7C36.333828,127.338104%7C36.329712,127.338104&amp;key=xxx 3.1.4 2-4. 구글 지도 그리기 ggmap(map) 3.2 3. 버스 정류소 위치에 정류소 이름 표시하기 3.2.1 3-1. 구글 지도 정보 가져오기 map1 &lt;- get_googlemap(center = cen, maptype = &quot;roadmap&quot;, zoom = 11) ## Source : https://maps.googleapis.com/maps/api/staticmap?center=36.350464,127.395379&amp;zoom=11&amp;size=640x640&amp;scale=2&amp;maptype=roadmap&amp;key=xxx 3.2.2 3-2. 정류소 위치를 점으로 표시하기 geom_point() 함수를 이용하여 정류소의 위치에 점을 찍는다. ggmap(map1) + geom_point(data = station, # 데이터 세트 aes(x= lon, y = lat), # 위치 정보 size = 1, # 점의 크기 colour = &#39;blue&#39;) # 점의 색깔 3.2.3 3-3. 정류소 이름을 표시하기 geom_text() 함수를 이용하여 station 데이터 세트의 stationNm 컬럼을 label의 인수로 지정하여 지도를 그린다. ggmap(map1) + geom_point(data = station, # 데이터 세트 aes(x= lon, y = lat), # 위치 정보 size = 1, # 점의 크기 colour = &#39;blue&#39;) + # 점의 색깔 geom_text(data = station, # 데이터 세트 aes(x = lon, y = lat), # 위치 정보 size = 2, # 글자의 크기 label = station$stationNm, # 정류소 이름 color = &quot;red&quot;) "],["dj-Bus-Location.html", "Chapter 4 노선 버스의 실시간 위치 확인 패키지 불러오기 4.1 1. 특정 노선의 실시간 위치", " Chapter 4 노선 버스의 실시간 위치 확인 data.go.kr의 Open API 활용 방법을 학습하기 위해, 대전광역시에서 운행중인 버스의 실시간 위치 정보 조회 방법을 알아보기로 한다. (OpenAPI활용가이드_대전광역시_버스정보시스템_v1.0.docx 참고) 패키지 불러오기 library(XML) library(ggmap) library(tidyverse) 4.1 1. 특정 노선의 실시간 위치 먼저 Open API를 사용하기 위해 data.go.kr에서 발급받은 API Key를 인증받는다. 4.1.1 2-1. API Key 인증받기 API_key &lt;- &quot;XNamCEPA1y........w2oz2Hqld26g%3D%3D&quot; # data.go.kr에서 발급받은 API_key 입력 4.1.2 2-2. 실시간 버스 위치 정보 조회 (OpenAPI활용가이드_대전광역시_버스정보시스템_v1.0.docx P. 23 ~ 26. 참고) 4.1.2.1 1) 조회할 노선 ID 노선번호 106번인 버스의 노선 ID는 bus_ID에 저장되어 있으며 “30300041” 이다. busRtNm &lt;- &quot;30300041&quot; # 검색할 노선버스 번호를 빈문자로 정한다. 4.1.2.2 2) 운행 중인 버스의 실시간 위치 정보 조회 서비스 URL 노선정보조회 서비스 url을 입력한다. 기본 url : “http://openapitraffic.daejeon.go.kr/api/rest/busposinfo/getBusPosByRtid?serviceKey=” &amp;busRouteId= : busRtNm url &lt;- &quot;http://openapitraffic.daejeon.go.kr/api/rest/busposinfo/getBusPosByRtid?serviceKey=&quot; srch_url &lt;- paste0(url, API_key, &quot;&amp;busRouteId=&quot;, busRtNm) 4.1.2.3 3) 실시간 위치 정보 조회 xmlParse() 함수를 이용하여 실시간 위치 정보 데이터를 다운로드하여, xmlfile에 대입한다. xmlfile &lt;- xmlParse(srch_url) # 해당 url에 데이터를 요구(request)하고, # 그 결과(response)를 xmlfile 변수에 저장한다. # xmlRoot(xmlfile) # xmlfile 변수의 내용을 출력한다. 4.1.2.4 4) 조회한 정보를 데이터 프레임 형태로 변환 xmlToDataFrmae() 함수를 이용하여, xmlfile을 데이터 프레임 형태로 변환하여 dj_location 변수에 대입한다. 이제 dj_location 변수는 노선 번호가 106번인 운행 중인 버스들의 실시간 위치 정보를 담고 있다. dj_location &lt;- xmlToDataFrame(getNodeSet(xmlfile, &quot;//itemList&quot;)) str(dj_location) ## &#39;data.frame&#39;: 12 obs. of 12 variables: ## $ ARR_TIME : chr &quot;20201206203124&quot; &quot;20201206203106&quot; &quot;20201206203033&quot; &quot;20201206203020&quot; ... ## $ BUS_NODE_ID: chr &quot;8070030&quot; &quot;8001570&quot; &quot;8001801&quot; &quot;8002997&quot; ... ## $ BUS_STOP_ID: chr &quot;41810&quot; &quot;31930&quot; &quot;51580&quot; &quot;41360&quot; ... ## $ DIR : chr &quot;0&quot; &quot;0&quot; &quot;0&quot; &quot;0&quot; ... ## $ EVT_CD : chr &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; ... ## $ GPS_LATI : chr &quot;36.333409&quot; &quot;36.354264&quot; &quot;36.359368&quot; &quot;36.357786&quot; ... ## $ GPS_LONG : chr &quot;127.338262&quot; &quot;127.374276&quot; &quot;127.449021&quot; &quot;127.343119&quot; ... ## $ PLATE_NO : chr &quot;대전75자3309&quot; &quot;대전75자3311&quot; &quot;대전75자3305&quot; &quot;대전75자3313&quot; ... ## $ ROUTE_CD : chr &quot;30300041&quot; &quot;30300041&quot; &quot;30300041&quot; &quot;30300041&quot; ... ## $ STRE_DT : chr &quot;20201206203127&quot; &quot;20201206203108&quot; &quot;20201206203037&quot; &quot;20201206203025&quot; ... ## $ TOTAL_DIST : chr &quot;509&quot; &quot;7533&quot; &quot;19335&quot; &quot;3529&quot; ... ## $ ud_type : chr &quot;0&quot; &quot;0&quot; &quot;0&quot; &quot;0&quot; ... 30300041 노선 버스들의 실시간 위치 정보를 보여 준다. 현재 13대의 버스가 운행 중이다. 컬럼의 갯수는 12개 : 이들에 대한 자세한 내용은 “(OpenAPI활용가이드_대전광역시_버스정보시스템_v1.0.docx P. 23 ~ 26. 참고)” 4.1.2.5 5) 분석용 데이터 세트 생성 dj_location 데이터 세트의 PLATE_NO(버스차량 번호), GPS_LATI(위도), GPS_LONG(경도) 컬럼을 선택하여 다음과 같이 변환시켜 bus_location 데이터 세트를 생성한다. PLATE_NO : 운행 중인 자동차 번호판 -&gt; busNo GPS_LAT1 -&gt; 숫자형 변환 -&gt; gpsY로 이름 변경 GPS_LONG -&gt; 숫자형 변환 -&gt; gpsX로 이름 변경 gpsX &lt;- as.numeric(dj_location$GPS_LONG) gpsY &lt;- as.numeric(dj_location$GPS_LATI) bus_location &lt;- data.frame(busNo = dj_location$PLATE_NO, lon=gpsX, lat=gpsY) str(bus_location) ## &#39;data.frame&#39;: 12 obs. of 3 variables: ## $ busNo: chr &quot;대전75자3309&quot; &quot;대전75자3311&quot; &quot;대전75자3305&quot; &quot;대전75자3313&quot; ... ## $ lon : num 127 127 127 127 127 ... ## $ lat : num 36.3 36.4 36.4 36.4 36.3 ... 현재 12대의 버스가 운행 중임을 알 수 있다. 4.1.2.6 6) 데이터 세트 저장하기 write_rds(bus_location, &quot;data/bus_location.rds&quot;) "],["dj-Bus-Location-Visualization.html", "Chapter 5 실시간 버스 위치의 시각화 1. 패키지 불러오기 5.1 2. 실시간 위치를 Marker로 표시하기 5.2 2-4. 구글 지도 그리기 5.3 3. 차량의 현지 운행 지점을 점으로 찍기", " Chapter 5 실시간 버스 위치의 시각화 이제 다운받은 노선버스의 실시간 위치 정보를 이용하여 Google 지도에 시각화한다. 즉, 구글 맵에 버스 위치를 표시해 보기로 한다. 1. 패키지 불러오기 library(XML) library(ggmap) library(tidyverse) 5.1 2. 실시간 위치를 Marker로 표시하기 5.1.1 2-1. Google API 인증 register_google(key=&quot;API Key&quot;) # https://console.cloud.google.com 에서 확인 5.1.2 2-2. 버스 위치의 중심점 찾기 data &lt;- read_rds(&quot;data/bus_location.rds&quot;) gc &lt;- data[, 2:3] # lon, lat 컬럼만 추출 cen &lt;- sapply(gc, mean) # 차량위치의 중심점 5.1.3 2-3. 구글 지도 정보 가져오기 get_googlemap() 함수를 이용하여 구글 지도 정보를 가져온다. 그 결과는 map에 대입한다. map &lt;- get_googlemap(center = cen, maptype = &quot;roadmap&quot;, zoom = 11, marker = gc) ## Source : https://maps.googleapis.com/maps/api/staticmap?center=36.346535,127.388049&amp;zoom=11&amp;size=640x640&amp;scale=2&amp;maptype=roadmap&amp;markers=36.333409,127.338262%7C36.354264,127.374276%7C36.359368,127.449021%7C36.357786,127.343119%7C36.33937,127.419713%7C36.346616,127.424965%7C36.3403,127.420478%7C36.334197,127.338096%7C36.341893,127.338461%7C36.348201,127.444081%7C36.351719,127.377418%7C36.351301,127.388698&amp;key=xxx 5.2 2-4. 구글 지도 그리기 이제 버스의 위치를 구글 지도위에 marker로 표시한다. ggmap(map) # , extent=&quot;device&quot;) 5.3 3. 차량의 현지 운행 지점을 점으로 찍기 5.3.1 3-1. 지도 정보 가져오기 map1 &lt;- get_googlemap(center = cen, maptype = &quot;roadmap&quot;, zoom = 11) ## Source : https://maps.googleapis.com/maps/api/staticmap?center=36.346535,127.388049&amp;zoom=11&amp;size=640x640&amp;scale=2&amp;maptype=roadmap&amp;key=xxx 5.3.2 3-2. 차량 위치를 점으로 찍기 ggmap(map1, extent=&quot;device&quot;) + geom_point(data = data, # 분석용 데이터 세트 aes(x = lon, y = lat), # 경도, 위도 등의 위치 size = 2, # 점의 크기 colour=&#39;blue&#39;) # 점의 색깔 5.3.3 3-3. 지도위에 버스 번호 표시하기 geom_text() 함수를 이용하여 data$busNo``를label` 인수의 값으로 입력해 준다. ggmap(map1, extent=&quot;device&quot;) + geom_text(data = data, # 분석용 데이터 세트 aes(x = lon, y = lat), # 경도, 위도 등의 위치 size = 3, # 글자 크기 label = data$busNo) + geom_point(data = data, # 분석용 데이터 세트 aes(x = lon, y = lat), # 경도, 위도 등의 위치 size = 2, # 점의 크기 colour=&#39;blue&#39;) # 점의 색깔 5.3.4 3-4. 운행 중인 차량번호를 범례로 표시하기 geom_text() 함수의 aes() 내의 colour 인수와, label 인수를 다음과 같이 조정해 주면, 운행중인 차량 번호를 범례로 표시해 준다. 대신에 차량의 위치를 나타내는 점은 찍지 않는다. 이제 차량의 위치가 번호로 표시되고, 그 위치의 차량 번호가 범례로 표시된다. ggmap(map1, extent=&quot;device&quot;) + # geom_point(data=data, # 현재 위치 점찍기 # aes(x=lon, y=lat), # size = 2, # colour=&#39;blue&#39;) + geom_text(data=data, aes(x=lon,y=lat, colour=busNo), size=3, label=seq_along(data$busNo)) "]]
