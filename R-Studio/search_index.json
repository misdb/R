[["index.html", "R STudio 활용 RStudio 활용", " R STudio 활용 Dae Ho Kim 2021-02-07 RStudio 활용 이 자료는 RStudio IDE의 활용을 다루고 있다. 전체적인 자료의 구성은 다음과 같다. RStudio의 설치 (R 설치 포함) Hello World RStudio Views RStudio 프로젝트 반복가능 분석 필수 R 패키지 데이터 시각화 R 마크다운 Shiny R 대시보드 R 패키지 코드 도구 R 프로그래밍 이 자료는 기본적으로 Matthew Campbell의 “Learn RStudio IDE: Quick, Effective, and Productive Data Science,” (APress, 2019)를 참고하고 있다. Creative Commons License The online version of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["Installing-RStudio.html", "Chapter 1 RStudio 설치", " Chapter 1 RStudio 설치 RStudio는 R에 구문 강조 및 코드 리팩토링과 같은 최신 기능을 추가하는 IDE (통합 개발 환경)이다. RStudio의 강점은 필요한 모든 기능을 한 곳에 모을 수 있다는 것이다. RStudio를 설치하기 전에 운영 체제용 R의 최신 버전과 git이라는 다른 프로그램을 설치해야 한다. 이 두 소프트웨어 패키지는 모두 RStudio에 통합되어 있지만 RStudio IDE와 함께 제공되지는 않다. R은 통계 프로그래밍 언어이며 RStudio를 사용하려면이 언어가 필요하다. Git은 RStudio에 통합 될 인기있는 버전 제어 시스템이다. git과 같은 버전 제어 시스템은 작업중인 코드의 사본을 관리하는 데 사용된다. Git은 파일 버전 간의 차이점을 확인하여 코드의 한 버전이 다른 버전과 다르게 작동하는 이유를 파악할 수 있도록 도와준다. 프로그래머가 코드와 프로젝트를 공유하는 온라인 커뮤니티 인 Github를 사용하려면 Git이 필요하다. "],["r-설치.html", "1.1 R 설치", " 1.1 R 설치 R은 통계 프로그래밍 및 그래픽에 사용되는 무료 오픈 소스 소프트웨어이다. Comprehensive R Network인 CRAN에서 최신 버전의 R을 얻을 수 있다. 이것은 R 및 R 패키지의 복사본이 있는 미러링된 서버의 네트워크이다. R 패키지는 커뮤니티의 R 사용자가 제공한 핵심 R 프로그래밍 언어에 대한 확장이다. R을 설치하려면 CRAN Mirror에 접속한다. 그러면 그림 1.1에 나와 있는 것과 같은 목록이 표시된다. 그림 1.1: CRAN 미러 서버 목록을 아래로 스크롤하여 지리적으로 가장 가까운 서버를 찾은 다음 링크를 클릭한다. 절대적으로 가장 가까운 서버를 얻는 것에 대해 너무 걱정하지 않아도 된다. 해당 국가에서 아무거나 선택하는 것이 좋다. 끊어진 링크를 찾으면 다시 다른 서버를 시도하면 된다. 그림 1.2에서 볼 수 있듯이 Windows 및 Mac 용 R 버전을 나열하는 새 화면이 표시된다. 그림 1.2: CRAN에서 R 설치하기 운영 체제 링크를 클릭한다. 각 운영 체제마다 R을 설정하는 지침이 다르다. 1.1.1 Mac에서 R 설치하기 Mac에 R을 설치하는 경우 다양한 R 릴리스에 대한 많은 세부 정보가 표시된다. 대부분의 사람들은 그림 1.3에 표시된 것처럼 최신 릴리스라는 제목 아래의 페이지 중간 영역으로 이동 한 다음 .pkg 파일 확장자로 끝나는 파일을 클릭한다. 파일의 정확한 이름은 설치 프로그램의 최신 릴리스에 따라 다르다. 그림 1.3: Mac R 설치 프로그램 최신 버전의 R을 설치하려면 pkg 링크를 클릭한다. 이전 버전의 R이 특별히 필요한 경우 아래로 스크롤하여 이전 버전의 R 설치 옵션을 볼 수 있다. pkg 파일은 다운로드에 나타난다. 다운로드 폴더로 이동하여 pkg 파일을 클릭하여 R을 설치한다. 그러면 그림 1-4와 같은 화면이 나타난다. 그림 1-4 Mac에 R 설치 그림 1-4와 같은 일련의 화면이 표시된다. 각 화면에 대해 계속을 클릭한다. 어느 시점에서 소프트웨어 라이센스에 동의하라는 대화 상자가 나타난다. 계속하려면 동의를 클릭한다. 다음으로 그림 1-5와 같이 특정 디스크에 설치할 수 있는 옵션이 표시된다. 그림 1-5 R 위치 선택 대부분의 사람들은 단순히 모든 사용자를 위한 설치 옵션을 선택한다. 첫 번째 옵션을 선택하고 계속 버튼을 클릭한다. 다음 화면에서 설치 버튼을 클릭한다. R 설치 프로그램이 Mac을 변경하므로 Mac 암호를 입력하라는 메시지가 표시된다. 계속하려면 비밀번호를 입력한다. 이제 R이 설치되고 모든 작업이 완료되면 그림 1-6과 같은 화면이 표시된다. 그림 1-6 성공적인 R 설치 닫기 버튼을 클릭하면 R이 Mac에 설치된다. 응용 프로그램 폴더에서 R을 찾을 수 있다. 응용 프로그램 폴더에서 R.app 프로그램을 두 번 클릭하여 R이 설치되어 있고 작동하는지 확인한다. 기본 R 콘솔 화면이 나타난다. 이미 약간의 R을 알고있는 경우 여기에서 시스템을 가지고 작업을 하거나, 프로그램을 종료할 수 있다. RStudio가 설치되면 R을 사용할 수 있다. 1.1.2 Windows에 R 설치 R for Windows 링크를 클릭하면 지침 페이지가 표시된다. 그림 1.4과 같이 “처음으로 R 설치”를 클릭한다. 그림 1.4: Windows에 R 설치 다음 페이지에 R 설치 프로그램을 다운로드 할 수 있는 링크가 있다. Windows 설치 프로그램을 받으려면 클릭한다. “Windows 용 R 다운로드”라는 이름이 지정된다. R 설치 프로그램을 다운로드하려면 이를 클릭한다. 잠시 후 다운로드 폴더에서 R 설치 실행 파일을 찾을 수 있다. 설치 프로그램 파일을 두 번 클릭하고 프롬프트를 클릭한다. 기본값을 선택한 다음 설치 프로그램이 완료되도록 한다. 1.1.3 리눅스 R 설치 Linux의 각 버전에는 R을 설치하기 위해 따라야 하는 설정 지침이 다르다. 일반적으로 명령 줄에서 R을 설치하려면 패키지 관리자를 사용한다. 다음과 같이 할 수 있다. sudo apt-get update sudo apt-get install r-base r-base-dev 그러나 각 Linux 버전은 여기에서 약간 다를 수 있으므로 CRAN 웹 사이트를 다시 확인하여 Linux 버전에 대해 수행해야 할 작업에 대한 자세한 내용을 확인해야 한다. https://cran.r-project.org에서 “Download R for Linux”링크를 클릭한 다음 Linux 버전을 선택하여 추가 지침을 확인한다. 1.1.4 Git 설치 Git은 다양한 버전의 코드 파일을 관리하는 데 사용되는 인기있는 버전 제어 시스템이다. RStudio는 git을 워크 플로에 통합하고 작업을 시각화하는 데 도움을 준다. 1.1.4.1 Mac에 Git 설치 Mac에 git을 설치하려면 다음 URL로 이동한다 : https://git-scm.com/download/mac 다운로드가 즉시 시작되지 않으면 “여기를 클릭하여 수동으로 다운로드” 텍스트를 클릭하여 git 설치 프로그램을 다운로드한다. 다운로드 폴더에 나타나는 파일을 두 번 클릭하고, pkg 파일을 클릭하여 설치 프로세스를 시작한다. 그림 1-8에 표시된 대화 상자와 같은 보안 알림을 받을 수 있다. 그림 1-8 Mac의 보안 경고 Mac의 보안 및 개인 정보 설정의 일반 탭으로 이동 한 다음 다운로드 한 파일 옆에 있는 “무시하고 열기”를 선택하여 이 보안 기능을 무시할 수 있다. 예는 그림 1-9를 참조하기 바란다. 그림 1-9 Mac에 git 설치를 위한 보안 설정 재정의 이제 설치가 완료되었다는 알림을 받을 때까지 설치 화면을 클릭하기 만하면 된다. Mac의 터미널 앱을 사용하여 터미널 창에 git –version을 입력하여 git이 설치되었는지 확인할 수 있다. 1.1.4.2 Windows에 Git 설치 Windows에 git을 설치하려면 다음 URL로 이동한다 https : //git-scm.com/download/win . 다운로드가 즉시 시작되지 않으면 “여기를 클릭하여 수동으로 다운로드” 텍스트를 클릭하여 git 설치 프로그램을 다운로드한다. 다운로드 디렉토리에 나타나는 파일을 두 번 클릭한다. 나타나는 각 화면에 대해 다음을 클릭하고 기본 설정을 선택하기만 하면 된다. 설치가 완료되면 마침을 클릭한다. Windows 명령 프롬프트로 이동하여 “git –version”을 입력하여 git이 설치되었는지 확인한다. 최신 버전의 git을 보여주는 응답이 표시되어야한다. 1.1.4.3 Linux에 Git 설치 Linux를 사용하고 git이 아직 설치되지 않은 경우 패키지 관리자를 사용하여 명령 줄에서 git을 설치할 수 있다. sudo apt install git-all 여기서는 apt를 사용했지만 배포를 위해 패키지 관리자를 사용해야 한다. "],["rstudio-설치.html", "1.2 RStudio 설치", " 1.2 RStudio 설치 이제 git과 R이 설치되었으므로 RStudio 자체를 설치할 준비가 되었다. RStudio 다운로드 페이지로 이동한다 : http://www.rstudio.com/products/rstudio/download/. 사용 가능한 모든 RStudio 옵션을 보여주는 화면이 표시된다. RStudio의 데스크톱 및 서버 버전 별로 사용할 수 있는 오픈 소스 및 상용 라이선스가 있다. 우리는 RStudio의 오픈 소스 (무료) 데스크톱 버전에 관심이 있다. 다른 버전은 상용 라이센스와 높은 수준의 기술 지원이 필요한 기업을 대상으로합니다. 그림 1.5: RStudio 다운로드 페이지 그림 1.5과 같이, 다운로드라고 표시된 녹색 알약을 클릭하면 화면이 Windows 및 Mac 용 설치 프로그램 목록으로 스크롤 된다. 운영 체제에 맞는 설치 프로그램을 클릭하고 다운로드가 완료될 때까지 기다린다. 설치 프로그램은 다운로드 폴더에 저장된다. 파일 이름은 RStudio-1.1.463이고, 확장자는 Mac의 경우 dmg , Windows의 경우 exe 로 지정된다. 설치 프로그램을 두 번 클릭하고 지시를 따른다. Mac에서는 RStudio 아이콘과 애플리케이션 디렉토리 바로 가기가 있는 화면이 나타난다. RStudio 아이콘을 Applications 폴더 바로 가기로 드래그하기만 하면 된다. Windows에서는 프롬프트에 따라 기본 위치를 선택하기만하면 된다. 설치가 완료되면 마침 버튼을 클릭하여 설치를 종료한다. 1.2.1 RStudio 확인 계속 진행하기 전에 RStudio가 설치되어 작동하는지 확인한다. 시스템에서 RStudio 앱 아이콘을 검색하고 두 번 클릭하여 앱을 연다. 아이콘을 찾는 데 문제가 있는 경우 Mac 화면의 경우는 오른쪽 상단 영역을, Windows의 경우는 화면의 왼쪽 하단 영역에있는 검색 아이콘으로 이동한다. “RStudio”를 입력하면 RStudio 앱에 대한 바로 가기가 나타난다. 이 아이콘을 두 번 클릭한다. Mac을 사용하는 경우 그림 1-11과 같이 보안 팝업이 나타난다. 그림 1-11 RStudio 보안 팝업 열기를 클릭하여 RStudio로 이동한다. 이제 데스크톱에 RStudio 앱이 표시되어, 다음의 그림 1.6과 같이 보일 것이다. 그림 1.6: RStudio IDE 초기 화면 이제 RStudio IDE가 설치되어 사용할 준비가 되었다! "],["Hello-World.html", "Chapter 2 Hello World", " Chapter 2 Hello World 이제 모두 RStudio를 설정했으므로이 프로그램을 사용하여 더 나은 R 코더가 될 수 있도록 하자. 가장 먼저해야 할 일은 RStudio를 열고 콘솔에서 R로 직접 작업하는 것으로 시작해 본다. "],["대화형-r-콘솔.html", "2.1 대화형 R 콘솔", " 2.1 대화형 R 콘솔 RStudio를 처음 열면 화면 왼쪽 전체를 차지하는 창이 표시된다. 이것은 콘솔 화면이며 사용자 화면은 그림 2.1에 표시된 것과 유사해야 한다. 그림 2.1: 콘솔 화면 사용 중인 R 버전에 대한 정보가 표시되어야 한다. 맨 아래에는 커서 &gt;가 있다. 커서 오른쪽에 있는 공간은 R 명령을 콘솔에 직접 입력할 수있는 곳이다. 1 + 1을 입력 한 다음 Enter 키를 누른다. 아래 줄에 [1] 2가 표시되어야 한다. 2는 질문 1 + 1에 대한 답이고, 괄호 [1]의 1은 답 2에 해당하는 벡터의 위치(색인)이다. 2.1.1 벡터 R의 중심 개념은 벡터 데이터 구조라는 것이다. 벡터는 동일한 데이터 유형의 객체 목록이다. R의 많은 연산은 질문이 1 + 1과 같이 하나의 값만 반환하는 경우에도 답변을 벡터로 반환한다. [1] 2는 첫 번째 위치에 값이 2 인 하나의 숫자 데이터 유형으로 구성된 벡터이다. 2.1.2 Hello World 이제 전통적인 Hello World 예제를 통해 콘솔에서 다른 유형의 벡터를 살펴 보기로 한다. 콘솔 화면에 표시된대로 정확히 다음 문자들을 입력한다. “Hello World” 여기서, 인용 부호를 포함하는 것을 잊지 말아야 한다. 이제 Enter 키를 누르면, 또 다른 벡터가 나타나지만 이번에는 [1] \"Hello World\"로 표시됩니다. 이전과 마찬가지로 이 벡터는 첫 번째 위치에 하나의 항목이 있지만 이번에는 객체가 유명한 문장을 보여주는 문자열이다. 하나 이상의 항목 길이를 가진 벡터를 만드는 데 사용할 수 있는 함수를 사용하여, Hello World를 다른 방식으로 시도해 보자. 문자 c를 사용하고, 쉼표(,)로 구분 된 개체 목록을 포함하는 벡터를 만들 수 있다. 벡터의 모든 개체는 동일한 유형이어야 한다(숫자와 문자가 섞이지 않음). 개체가 다른 유형인 경우 R은 제공하는 데이터를 수용할 수 있는 가장 일반적인 유형으로 강제 변환(coercing)한다. 콘솔 창에 c( \"Hello\", \"World\")를 입력한 다음 Enter 키를 누른다. 이번에는 [1] \"Hello\" \"World\"가 콘솔에 출력되는 것을 볼 수 있다. 이것은 우리가 전에 본 것과 매우 유사하게 보이지만 약간 다른 점이 있다. 이 벡터에는 두 개의 항목이 있지만 콘솔은 행에 [1] 만 표시하고 있다. 그러나 각각 고유한 따옴표 집합이 있으므로 위에 두 개의 개체가 있음을 알 수 있다. R은 각 출력 행의 항목 번호 만 표시하여 출력 화면의 공간을 절약한다. 이것이 어떻게 작동하는지 보기 위해 더 큰 벡터를 살펴 보기로 한다. 콘솔에 1:100을 입력하고 Enter를 누른다. 그림 2.2에 표시된 이미지와 같은 것을 볼 수 있다. 1:100 그림 2.2: 100개 요소를 갖는 벡터의 출력 :는 범위를 정의하는 데 사용할 수있는 바로 기호이다. 1:100을 입력하면 1에서 100 사이의 모든 숫자가 제공된다. 결과는 벡터이며 각 행이 첫 번째 열에 있는 데이터 값의 항목 위치를 어떻게 보고하는지 명확하게 확인할 수 있다. RStudio IDE 둘러보기로 다시 돌아 가보자. 도구의 사용 방법을 더 깊게 배우면서 R 프로그래밍과 벡터에 대해 더 많이 알게 될 것이다. "],["터미널terminal.html", "2.2 터미널(Terminal)", " 2.2 터미널(Terminal) 방금 소개한 콘솔 화면은 R을 다운로드하고 코딩을 시작했다면 사용할 수있는 화면이다. 이것은 R과 대화식으로 작업하는 데 적합하지만 RStudio는 단순한 콘솔보다 더 많은 기능을 제공한다. RStudio를 통합 개발 환경으로 만드는 몇 가지 RStudio 기능을 살펴 보기로 한다. 콘솔 화면 상단의 콘솔 탭 바로 옆에는 “터미널(Terminal)”이라는 탭이 있다. 이를 클릭하면 콘솔과 비슷하지만 운영 체제에 대한 명령줄인 다른 화면이 나타납니다. 이것은 이런 방식으로 작업해야 할 때 발생할 상황에서는 편리하다. 이것은 명령 줄에 익숙한 사용자에게 환영받을 수 있는 기능이며 때때로 OS 명령어를 사용해야 할 경우에 적합한 기능이다. 터미널 탭을 클릭하고 사용할 수있는 명령을 입력한다. 예를 들어, 그림 2.3에서와 같이 명령 줄에 dir 또는 ls를 입력하여 파일 및 폴더 목록을 볼 수 있다. 그림 2.3: 터미널 명령 줄 사용할 수있는 실제 명령은 운영 체제에 따라 다르며, 그림 2.4의 터미널 탭 바로 아래에 있는 드롭 다운 메뉴를 사용하면 도우미 작업 목록에 액세스할 수도 있다. 그림 2.4: 명령 바로 가기 "],["환경environment.html", "2.3 환경(Environment)", " 2.3 환경(Environment) RStudio 환경 탭은 콘솔 화면 오른쪽에 있는 편리한 기능이다. 환경(Environment), 히스토리(History), 연결(Connections) 그리고 튜토리얼(Tutorials) 등의 네 가지 탭이 있다. 환경 탭은 그림 2.5에 나와 있다. 그림 2.5: 환경 탭 R에서 환경은 작업 공간이다. 환경에 개체와 데이터를 저장할 수 있다. 예제에서는 단순히 글로벌 환경을 사용하지만 R의 환경은 풍부한 주제가 될 수 있으며 고급 R 프로그래밍 기술에 사용된다는 점을 알고 있어야 한다. 예를 들어, 각 R 함수 (재사용 가능한 코드 단위)는 자체 환경을 갖게 되고 프로그래머는 다양한 목적을 위해 자체 환경을 할당할 수 있다. 그러나 대부분의 사람들은 이런 방식으로 환경의 미묘함에 대해 그렇게 걱정할 필요가 없다. 지금은 아직 개체를 만들지 않았거나 데이터를 로드하지 않았기 때문에 환경이 완전히 비어 있어야 한다. 변수를 만들어 변경해 보자. 콘솔을 클릭하고 “Hello World” 문자열을 greeting이라는 개체에 할당하여 개체를 만든다. greeting &lt;- \"Hello World\" 환경 창에서 무슨 일이 일어 났는지 보기 전에 이 새로운 구문에 대해 먼저 살펴 보기로 한다. 위의 구문을 바로 시작하여 분해해 보자. “Hello World”는 처음에 입력 한 것과 동일한 문자열이다. 문자열은 따옴표로 묶인 문자 집합이다. 숫자와 마찬가지로 문자열은 일종의 데이터이다. 문자열 왼쪽에 있는 &lt;- 기호 집합을 할당 연산자라고 한다. 할당 연산자의 임무는 개체에 데이터 값을 할당하는 것이다. 여기에 있는 개체는 할당 연산자의 왼쪽에 있으며 greeting이라는 이름이 지정되어 있다. 위의 코드를 입력하고 Enter 키를 눌러 greeting 개체에 “Hello World”값을 할당하면 이 개체에 관한 정보가 Global Environment에 들어 간다. 이제 그림 2.6과 같이 화면의 오른쪽 영역에서 글로벌 환경에서 이러한 내용을 확인할 수 있다. 그림 2.6: 환경 탭에서 개체 보기 데이터 분석을 수행할 때 작업의 현재 상태를 확인할 수 있게 해 주므로 매우 편리한 기능이라 할 수 있다.결과를 한 눈에 볼 수 있으며, 예상하는 변수가 올바른지 확인할 수도 있다. 이 기능만으로도 RStudio는 데이터 프로그래밍 키트에서는 필수 도구가 되는 것이다. 그러나 더 많은 것이 있다. 환경 위젯에는 작업을 저장하고 다른 환경을 여는 기능도 있다. 따라서 하루 종일 데이터 문제와 씨름하고, 모든 데이터와 변수를 저장하려면 플로피 디스크(저장) 아이콘을 사용하면 됩니다. 환경을 열려면 폴더 아이콘을 사용한 다음 저장한 환경 파일로 이동하면 된다. 2.3.1 데이터 불러오기 많은 사람들에게 도움이 될 또 다른 특징은 SAS 및 Excel과 같은 다른 데이터 분석 도구에서 데이터를 가져올 수 있는 능력이다. Import Dataset 버튼을 클릭하면 그림 2.7과 같이 다양한 옵션이 표시된다. 그림 2.7: 데이터 세트 가져 오기 이 옵션을 클릭하면 이러한 소스에서 RStudio로 데이터를 쉽게 가져 오는데 사용할 수 있는 가져 오기 마법사(import wizard)가 시작된다. 이는 다음과 같은 R 코드의 작업과 동일하다. library(readxl) dormitory &lt;- read_excel(&quot;data/dormitory.xls&quot;) View(dormitory) 마지막으로이 화면에는 환경에서 모든 것을 지울 수있는 친숙한 빗자루 아이콘이 있습니다. 2.3.2 데이터 세트 가져오기 기능을 설명하기 위해 data.go.kr의 대학재정알리미 사이트(http://uniarlimi.kasfo.or.kr/totalAnno/dormitory)에서 전국 대학의 기숙사 현황 데이터 세트를 다운로드했다.대학재정 알리미 웹 사이트는 그림 2.8에 나와 있다. 그림 2.8: 대학재정알리미 사이트의 기숙사 현황 데이터 다운로드 사이트 이 데이터는 Excel에 저장되며 데이터 세트 가져 오기 도구를 사용하여 데이터 세트를 R로 가져와서 검사할 수 있다. 이 예제를 따르려면 위의 URL을 방문하여 웹 페이지에서 xlsx 파일을 다운로드한다. data 폴더에서 dormitory.xlsx라는 파일을 찾는다. 이것은 우리가 살펴볼 Excel 형식의 데이터 세트이다. 이제 RStudio에서 “Import Dataset” 버튼을 클릭하고 “From Excel…”을 선택한다. “찾아보기” 버튼을 클릭한다. 이 화면의 예는 그림 2.9를 참조하기 바란다. 그림 2.9: Excel 데이터 가져 오기 다음으로 dormitory.xlsx라는 Excel 파일이 있는 위치로 이동한다. 화면은 데이터의 처음 몇 행과 그림 2.10과 같이 인터페이스를 사용하지 않고 나중에 이 데이터 세트를 다시 가져오는 데 사용할 수 있는 복사 할 수있는 코드로 채워진다. 그림 2.10: 데이터 가져 오기 미리보기 “Import”를 클릭하면 Import Dataset이 사라지고 메인 RStudio IDE 화면으로 돌아간다.. 그러나 그림 2.11에서 볼 수 있듯이 많은 것이 변경 될 것이다. 그림 2.11: R에서 열린 데이터 세트 데이터가 우리 화면에 나타난 것을 볼 수 있다. 이 새 화면의 컨트롤을 사용하여 데이터를 필터링하고 데이터 세트를 검색할 수 있다. 데이터 세트는 또한 우리의 Global Environment에도 나타났으며, 자동으로 dormitory로 이름이 지정되었다. 이것은 R 코드에서이 데이터 세트를 참조하는 데 사용할 이름이다. 예를 들어 콘솔에서 R의 head() 함수를 사용하여 데이터의 처음 6개의 행을 볼 수 있다. 그림 2.12에 표시된 출력은 이 데이터 세트에 대한 더 많은 정보를 제공한다. 데이터와 R에 대해 더 많이 배우면 데이터 세트 이름을 분석에 대한 입력으로 사용할 수 있다. 그림 2.12: head() 함수 "],["히스토리history.html", "2.4 히스토리(History)", " 2.4 히스토리(History) 지금까지이 R 세션에 입력한 모든 명령의 로그를 보려면 다음 탭을 클릭하면 된다. 결과를 찾았을 때 큰 도움이 되지만 특정 지점에 도달 한 방법을 잘 기억할 수 없을 때도있다. 로그를 보고 수행 한 단계 목록을 볼 수 있다. 그림 2.13에 표시된 히스토리 탭에는 히스토리에 나타나는 코드 줄을 R 콘솔에 다시 넣는 데 사용할 수있는 편리한 기능도 있다. 검색 아이콘이있는 텍스트 영역을 사용하여 특정 코드 줄을 검색할 수도 있다. 이것은 개체를 변경했음을 알고 있지만 잠재적으로 긴 명령 목록에서 변경이 수행 된 위치를 정확하게 찾는 데 문제가 있을 때 유용 할 수 있다. 그림 2.13: 히스토리 탭 "],["연결-탭connections.html", "2.5 연결 탭(Connections)", " 2.5 연결 탭(Connections) 마지막으로 연결 탭은 로컬 데이터베이스 또는 Spark 클러스터와 같은 데이터 소스에 연결하는 방법을 제공한다. 이러한 유형의 데이터 저장 솔루션은 데이터 세트가 너무 커서 컴퓨터에 로컬로 저장하기에는 너무 큰 경우에 사용된다. 연결 탭을 클릭하면 빈 목록이 표시되지만 ODBC (데이터베이스) 또는 Spark에 연결하는 옵션이 있다. 프로젝트에 필요한 데이터베이스에 대한 연결 정보가 있는 경우 이 인터페이스를 사용하여 연결할 수 있다. RStudio는 연결 프로세스를 안내하고 데이터 소스 작업에 필요한 모든 패키지를 설치한다. 이 창에는 R 코드로 직접 만든 데이터 소스 연결도 표시된다. "],["결론.html", "2.6 결론", " 2.6 결론 이 장에서는 필수 R 데이터 구조인 R 벡터를 소개했다. 또한 우리는 이미 RStudio IDE의 기본 기능을 많이 접하고 있다. 마지막으로 R의 데이터 세트에 대한 간략한 소개가 있었다. RStudio IDE 둘러보기를 진행하면서 이러한 개체를 다시 만나 더 자세히 살펴볼 것이므로 이것이 데이터 분석에 어떻게 도움이 되는지 알게 될 것이다. "],["RStudio-Views.html", "Chapter 3 RStudio Views", " Chapter 3 RStudio Views 계속해서 RStudio IDE 둘러보기로 한다. RStudio에는 4개의 창 레이아웃이 있으며 지난 장에서 이미 두 개의 창을 자세히 살펴 보았다. 대화 형 R 코드를 작성할 수있는 콘솔 화면과 R 환경의 상태를 볼 수 있는 환경 및 히스토리 화면을 보았다. 데이터 프레임도 세 번째 창에서 열렸지만 RStudio 인터페이스의 이 부분으로 더 많은 작업을 수행 할 수 있다. 이제 사용할 나머지 화면에 대해 살펴 보기로 한다. "],["파일-플롯-패키지-도움말-및-뷰어-창.html", "3.1 파일, 플롯, 패키지, 도움말 및 뷰어 창", " 3.1 파일, 플롯, 패키지, 도움말 및 뷰어 창 기본적으로 오른쪽 아래의 창에는 파일, 플롯, 패키지, 도움말 및 뷰어라는 이름이 달리 탭이 있다. 파일 탭은 현재 작업 폴더에 있는 파일을 보여준다. 작업 폴더는 R이 작업을 저장할 폴더이다. 이 창은 기본적으로 RStudio에 통합된 Windows 탐색기 또는 Mac Finder 앱과 연결된다. "],["파일.html", "3.2 파일", " 3.2 파일 파일 탭에는 RStudio를 종료하지 않고도 파일을 열고 일반적으로 작업하는 데 사용할 수 있는 편리한 기능이 포함되어 있다. 여기에는 파일 삭제 및 이름 바꾸기와 같은 작업이 포함된다. 그림 3.1에서 볼 수 있듯이 R 작업 폴더를 설정할 수도 있다. 그림 3.1: 파일 탭 "],["플롯.html", "3.3 플롯", " 3.3 플롯 Plots 탭을 사용하여 R 분석 중에 생성한 플롯을 볼 수 있다. 이 탭을 클릭하면 그림 3.2와 같은 몇 가지 기능 버튼이 있는 빈 화면이 표시된다. 그림 3.2: 파일 탭 플롯을 보고, 플롯을 파일로 내보내고, 생성한 플롯 세트를 탐색 할 수도 있다. 이 위젯은 데이터를 살펴보고 조사할 때 체계적으로 유지되도록 도와준다. 이 기능을 더 자세히 살펴보기 위해서는 콘솔 화면으로 이동하여 데이터 정리를 수행하고 플롯을 생성해야 한다. 3.3.1 데이터 결합 소개 이전 장에서 가져온 데이터를 사용할 수 있다. 해당 데이터의 이름은 dormitory 이다. 이 데이터를 사용하여 플롯을 만들기 전에 몇 가지 “데이터 정리”를 수행해야 한다. 데이터 병합(data munging)은 분석에 적합하도록 데이터를 재구성하는 프로세스이다. NOTE 위에서 “데이터 세트”와 “데이터 프레임”이라는 용어를 같은 의미로 사용한다. 그러나 R에서 작업하는 개체의 기술적 이름은 “데이터 프레임”(일반적으로는 표, 엑셀에서는 워크시트에 해당함)이다. “데이터 세트”라는 용어는 모든 분석 환경의 모든 데이터 세트에 적용되는 일반적인 용어이다. 이 그림의 경우 dormitory 데이터 프레임에서 학교명, 재학생수 그리고 수용인원 등의 세 열을 보고 싶다. 이 세 항목이 관계가 있는 것 같으므로 플롯을 사용하면 이 데이터가 우리에게 알려주는 내용을 이해하는 데 도움이 될 수 있는 단서 역할을 하는 패턴을 볼 수 있는지 확인하는 것이 좋다. 내가 하고 싶은 첫 번째 일은 내가 관심있는 열의 데이터 유형을 확인하는 것입니다. R의 class() 함수를 사용하여 이를 수행 할 수 있다. class(dormitory$학교명) ## [1] &quot;character&quot; 함수의 이름인 class가 괄호 안에 검사할 개체를 포함한다. 이미 데이터 프레임 이름 (dormitory)을 보았지만 이제 달러 기호 ’$’와 변수 학교명 이름도 있다. R의 달러 기호는 데이터 프레임에서 열을 참조하는 데 사용된다. 이러한 방식으로 dormitory 데이터 프레임의 각 열을 참조 할 수 있다. 위에서 우리는 학교명 열의 데이터 유형을 검사하기 위해 class() 함수를 사용했다. 그 결과로 “character”를 반환했다. 플롯의 경우 데이터가 숫자여야 한다. 이를 위해 두 번째 열인 재학생 수를 확인해 본다. 그런데 이 떄 열의 이름이 재학생 수로 공란이 포함되어 있다. 이때에는 \\`` 안에 컬럼 이름을 넣어 주면 된다. class(dormitory$`재학생 수`) 이번에는 그림 3.3과 같이 콘솔에 “numeric”를 반환하고 있다. 그림 3.3: 데이터 유형의 확인 3.3.2 플롯 이제 우리는 플롯을 만들 준비가 되었다. 콘솔 창에 다음 코드를 입력한다. plot(dormitory$`재학생 수`) 이제 플롯 탭에 그림 3.4와 같은 플롯이 나타난다. 그림 3.4: R의 플롯 그림 3-4는 Y 축에 각 대학별 재학생 수를 그리고 X축에는 데이터의 번호를 표시한다. 이것은 매우 기본적인 플롯이지만 이러한 데이터 요소 간의 관계를 암시하기에 충분하다. 어느 시점에서 기본 R을 확장하고 더 나은 시각화를 만드는 패키지에 대해 학습하게 되겠지만, 기본적으로 모두 Plots 탭에서 동일한 방식으로 작동한다. "],["패키지.html", "3.4 패키지", " 3.4 패키지 “패키지”라고 표시된 다음 탭에는 사용 가능한 R 패키지 목록이 표시된다. 패키지 목록의 모양을 보려면 그림 3.5를 참조하기 바란다. 그림 3.5: 패키지 뷰어 R 패키지는 1장에서 R을 설치할 때 기본적으로 설치되는 base 패키지를 확장한다. R 패키지는 커뮤니티 기여자가 작성했으며 누구나 사용할 수 있다. 패키지는 CRAN 네트워크에서도 관리되며 패키지 탭에서 이 모든 것을 관리 할 수 있다. 그림 3-5의 스크린 샷에서 볼 수 있는 것은 컴퓨터에 설치된 모든 패키지 목록이다. 확인 표시는 패키지가 R 환경에 불려와져 있으며, 사용할 준비가 되었음을 보여준다. 패키지를 확인하면 패키지를 불러오는 코드가 콘솔 화면에 나타난다. 예를 들어, broom 패키지를 사용하려면 확인란을 클릭하기 만하면 콘솔 화면에 다음과 같이 표시된다. library(&quot;broom&quot;) 정확한 위치는 R 버전과 사용중인 운영 체제에 따라 다르다. 이러한 방식으로 패키지가 로드되면 이전에 사용한 base R 함수와 동일한 방식으로 해당 패키지의 모든 데이터 세트와 함수를 사용할 수 있다. NOTE broom 패키지는 tidyverse 패키지 제품군의 일부이다. broom 패키지는 선형 회귀(linear regression)와 같은 분석 함수의 복잡한 출력을 다른 함수의 입력으로 쉽게 사용할 수있는 간단한 데이터 프레임으로 변환하는 데 사용된다. 뒷 부분에서 이와 같은 필수 패키지에 대해 자세히 살펴보기로 한다. 패키지 탭에서이 인터페이스를 사용하여 패키지를 설치할 수도 있다. 원하는 패키지 이름을 알고 있는 경우 “Install” 버튼을 클릭하면 그림 3.6과 같은 대화 상자가 나타난다. 그림 3.6: 패키지 탭 그런 다음 원하는 패키지 이름을 입력하고 “Install” 버튼을 클릭한다. CRAN 네트워크에서 사용할 수 있는 모든 패키지를 제공하므로 기본값을 그대로 둔다. 마지막으로 나타나는 각 패키지 이름은 패키지에 대한 문서로 이동하는 데 사용할 수있는 하이퍼 링크로 작동한다. 이 문서는 패키지를 설치할 때 같이 설치된다. 패키지 사용 방법을 알아 보려면 패키지 이름을 클릭하기만 하면 된다. 그러면 패키지 탭 오른쪽에 나타나는 도움말 위젯으로 자동으로 이동하게 된다. "],["도움말.html", "3.5 도움말", " 3.5 도움말 도움말 탭은 웹 브라우저처럼 설정되며 항목을 검색하는 데 도움이 되는 요소가 포함되어 있다. 그림 3.7에 표시된 것처럼 웹 페이지처럼 나타나는 콘텐츠를 탐색할 수 있다. 그림 3.7: 도움말 탭 그림 3-7의 화면에서 ggplot2라는 tidyverse 패키지에 대한 문서를 볼 수 있다. 이 패키지는 기본 플롯 기능을 사용하는 것보다 더 풍부한 데이터 시각화를 만드는 데 도움이 된다. 이와 같은 패키지에 대해 자세히 알아 보거나 검색 기능을 사용하여 특정 기능에 대한 도움말을 얻으려면 도움말 화면을 사용하면 된다. "],["뷰어.html", "3.6 뷰어", " 3.6 뷰어 오른쪽 아래 화면의 마지막 탭은 뷰어 탭이다. 이는 R 마크다운 문서와 같은 RStudio 보고의 고급 기능 중 일부에서 출력이 표시되는 영역이다. R 마크다운 문서는 결과를 공유하는 데 사용되는 재현 가능한 방식으로 코드와 결과를 함께 제공하는 데 사용된다. 뒤에 R 마크다운 문서에 대해 자세히 다룰 것이다. "],["결론-1.html", "3.7 결론", " 3.7 결론 이 시점에서 RStudio IDE 작업의 기본에 대하여 충분히 알게 되었다. RStudio의 기본 상태에서 사용할 수 있는 4 개의 패널에 있는 모든 기능을 사용하여 빠른 분석을 수행하는 데 필요한 모든 창과 인터페이스를 탐색하는 방법을 이해해야 한니다. 그 과정에서 base R을 사용하여 데이터 정리, 데이터 탐색 및 데이터 시각화를 수행하는 방법도 살펴 보았다. 다음으로, 우리는 RStudio가 어떻게 명확하고 통찰력 있고 재현 가능한 분석을 조직하고, 구축하는 데 어떻게 도움이 되는지 계속 탐구할 것이다. "],["RStudio-Projects.html", "Chapter 4 RStudio 프로젝트", " Chapter 4 RStudio 프로젝트 지금까지 배운 내용은 R 프로그래밍에 많은 통합을 추가한다. 그러나 우리는 이 모든 것을 재사용할 수있는 형식으로 모으는 방법을 놓치고 있다. 여기에서 RStudio 프로젝트가 시작된다. RStudio 프로젝트는 분석에 사용되는 모든 코드, 보고서 및 기타 자산을 구성하는 데 사용된다. 프로젝트를 만들 때 RStudio는 필요한 파일과 프로젝트 유형에 필요한 모든 것을 제공한다. "],["새-rstudio-프로젝트-만들기.html", "4.1 새 RStudio 프로젝트 만들기", " 4.1 새 RStudio 프로젝트 만들기 그림 4.1과 같이 RStudio 화면 상단에있는 메뉴 모음에서 “File”을 선택한 다음 “New Project…”를 선택하여 새 RStudio 프로젝트를 만든다. 그림 4.1: 새 프로젝트 만들기 이제 새 RStudio 프로젝트를 생성하는데 필요한 몇 가지 옵션을 제공하는 그림 4.2와 같은 대화 상자가 나타난다. 그림 4.2: RStudio 프로젝트 옵션 일반적으로 첫 번째 옵션 인 “New Directory”를 선택하면 지정된 이름을 갖는 새 폴더가 생성된다. 그리고 모든 구성 파일이 이 새 폴더에 나타난다. 그러나 시작하려는 코드 파일이 이미 있는 경우 두 번째 옵션인 “Existing Directory”를 선택할 수 있다. 마지막으로 이미 존재하는 프로젝트에 대해 git과 같은 버전 제어 시스템이 이미 설정되어 있는 경우 세 번째 옵션 인 “Version Control”을 선택할 수 있다. "],["프로젝트-유형.html", "4.2 프로젝트 유형", " 4.2 프로젝트 유형 이 예에서는 “New Directory(새 디렉토리)”를 클릭하여 새 프로젝트를 만들었다. 나타나는 화면은 그림 4.3과 같이 RStudio 프로젝트 유형 목록을 보여준다. 그림 4.3: 프로젝트 유형 처음 세 가지 프로젝트 유형은 가장 자주 사용하는 유형이다. 처음 세 개 이후의 프로젝트에는 모두 특수 사용 사례에 사용되는 특수 코드가 포함된다. 설명의 “Rcpp”에 있는 프로젝트는 모두 C ++ 코드 라이브러리와 통합하는 데 사용된다. “devtools”가 있는 프로젝트는 devtools 라이브러리로 R 패키지를 만드는 데 사용되며, sparklyr 프로젝트는 Spark와 함께 작동하는 패키지를 만든다. “Package(패키지)” 프로젝트는 재사용 가능한 R 개체 세트를 생성하도록 설정된다. 이것은 우리가 이 장에서하는 것보다 조금 더 발전된 것이며 나중에 다시 살펴 볼 것이다. 프로젝트 전체에서 사용할 수 있다고 생각되는 코드가 있는 경우 RStudio 프로젝트 패키지를 만들 수 있다. 이 예에서는 그림 4.4와 같이 “New Project(새 프로젝트)”를 선택하여 분석에 가장 적합한 프로젝트를 만들기로 한다. 그림 4.4: 기대 수명 프로젝트 기숙사의 평균 수용인원을 보여주는 data.go.kr 사이트에서 데이터 탐색을 수행할 예정이기 때문에 프로젝트 이름을 “life_expectancy”로 지정했다. 지금은 프로젝트를 저장할 디렉토리 (Mac에서는 폴더라고 함)를 선택한 다음 “Create Project(프로젝트 만들기)” 버튼을 클릭하여 이 RStudio 프로젝트를 만든다. "],["rstudio-프로젝트-둘러보기.html", "4.3 RStudio 프로젝트 둘러보기", " 4.3 RStudio 프로젝트 둘러보기 이제 프로젝트를 위한 새로운 공간이 생겼다. 이 새로운 RStudio 프로젝트는 그림 4.5에 표시된 대화 상자에 입력한 폴더에 저장된다. RStudio 프로젝트에는 자체 환경이 있으므로 프로젝트를 전환하는 경우 작업이 저장되고 구성된다. 이는 코드 파일 및 분석에 필요한 기타의 모든 경우에 해당된다. 우리를 위해 무엇이 설정되었는지 살펴 보기로 한다. 그림 4-5에서 RStudio 프로젝트가 이전 장에서 이미 본 것과 비슷하다는 것을 알 수 있다. 그림 4.5: 새 프로젝트 화면 그러나 그림 4.6에서는 일반 시작 화면에서 두 가지 변경 사항을 볼 수 있다. 프로젝트 이름과 “Rproj” 파일 확장자가 있는 새 파일이 오른쪽 하단 화면에 나타난다. 이 파일에는 프로젝트에 대한 모든 설정이 포함되어 있다. 파일 탐색기를 자세히 살펴보면 이 파일이 프로젝트와 이름이 같은 하위 디렉터리 아래에서 선택한 디렉터리에 있음을 알 수 있다. 화면의 오른쪽 상단 영역에서 프로젝트 이름을 클릭하면 그림 4-6과 같이 유용한 바로 가기 목록을 찾을 수 있다. 그림 4.6: 프로젝트 바로 가기 프로젝트를 열고 닫고, 최근에 열린 프로젝트로 빠르게 이동하고,이 프로젝트에 대해 특별히 RStudio 옵션을 설정할 수 있다. 프로젝트 옵션은 프로젝트 용으로 생성된 폴더에 “Rproj” 확장자가 있는 파일에 저장된다. 파일을 클릭하여 프로젝트 옵션을 열거나 그림 4-6에 표시된 바로 가기 목록에서 옵션을 선택할 수 있다. 이렇게 하면 이 프로젝트에 대해 설정할 수있는 옵션이 나열된 그림 4.7과 같은 화면이 표시된다. 그림 4.7: 프로젝트 옵션 이러한 프로젝트 옵션은 RStudio에 설정된 전역 옵션에서 상속되며, 대부분의 경우 이러한 옵션을 그대로 둘 수 있다. 처음 두 화면은 즉각적으로 가장 유용한 화면이다. “General” 탭은 분석 상태를 저장할 때 옵션을 제공한다. 기본값은 데이터 환경과 R 기록을 모두 저장하는 것이다. 프로젝트에서 대규모 데이터 세트를 로드해야하는 경우 프로젝트를 여는 데 시간이 더 오래 걸리므로 이러한 옵션을 낮추는 것이 좋다. 일반적으로 기본값을 유지하는 것이 가장 좋다. 다음 탭은 “Code Editing(코드 편집)”이며 그림 4.8에서 볼 수 있다. 이를 통해 코드 편집기 작동 방식을 제어 할 수 있다. 그림 4.8: 코드 편집 옵션 그림 4-8 코드 편집 옵션 일반적으로 이러한 기본 설정을 유지하는 것이 좋다. 첫 번째 옵션 인 “Index source files”가 선택되어 있는지 확인하기 바란다. 그러면 나중에 설명 할 일부 코드 도구가 올바르게 작동할 수 있다. 나머지 4 개의 옵션 탭에는이 책의 뒷부분에서 다시 살펴볼 기능에 대한 설정이 포함되어 있다. 이러한 옵션은 일반적으로 워크 플로에 통합할 준비가 되지 않은보고서 작성, 패키지 구축 그리고 기타 특수 기능에 사용된다. "],["결론-2.html", "4.4 결론", " 4.4 결론 이 장에서는 RStudio 프로젝트를 설정하는 방법을 배웠다. 이렇게 하면 여러 분석 작업을 시작할 때 체계적이고 효율적으로 유지하는 데 도움이 된다. 각 RStudio 프로젝트는 자체 폴더, 파일 세트, 데이터 세트 및 환경을 가져온다. 다음 장에서는 RStudio 프로젝트의 코드 구성이 효율적인 워크 플로를 설정하는 데 어떻게 도움이 되는지 확인할 수 있도록 예제를 살펴볼 것이다. "],["Repeatable-Analysis.html", "Chapter 5 반복 가능한 분석", " Chapter 5 반복 가능한 분석 RStudio 프로젝트를 사용하여 반복 가능한 분석을 만드는 방법을 살펴 보기로 한다. 이 예에서는 “life_expectancy”라는 이름이 붙은 이전 장에서 만든 프로젝트로 작업할 것이다. 데이터 세트는 National Center for Health Statistics에서 가져온 것이며 미국에서 1900년 이후의 기대 수명을 설명한다. 지금까지 따라서 했다면 이미 RStudio에이 프로젝트가 설정되어 있을 것이다. 그렇지 않은 경우 이전 장의 단계에 따라 “life_expectancy”라는 이름이 붙은 새 RStudio 프로젝트를 만든다. "],["데이터-세트-구성.html", "5.1 데이터 세트 구성", " 5.1 데이터 세트 구성 우리가 하고 싶은 한 가지는 데이터를 프로젝트로 읽어 오는 것이다. 프로젝트의 구조를 유지하기 위해, 데이터를 저장할 폴더를 만드는 것이 좋다. 파일 뷰어를 사용하여 그림 5.1과 같이 새 폴더를 만든다. 그림 5.1: 새 폴더 만들기 파일로 이동 한 다음 “데이터”라는 단어를 “새 폴더”로 입력 한 다음 “확인”을 클릭한다. 이제 이 프로젝트와 관련된 새 폴더가 생긴다. 5.1.1 기대 수명 데이터 다운로드 다음으로이 링크를 따라 데이터 세트가있는 페이지로 이동합니다. https://catalog.data.gov/dataset/nchs-death-rates-and-life-expectancy-at-birth-6db3e 이 페이지에는 데이터에 대한 자세한 설명이 포함되어 있다. 방금 만든 “data” 폴더에 csv 파일을 다운로드하려고 한다. 그림 5.2에 표시된 페이지 영역까지 아래로 스크롤한다. 그림 5.2: 기대 수명 csv 다운로드 링크 “Download” 버튼을 클릭한다. csv 파일이 다운로드 폴더에 나타난다. csv 파일을 “다운로드” 폴더에서 프로젝트에서 만든 “data” 폴더로 이동시킨다. 5.1.2 R 프로젝트에 데이터 세트 추가 data 폴더에 원시 csv 파일이 저장되어 있지만 분석에 사용하려면 데이터가 데이터 프레임 형식이어야 한다. 이 형식의 데이터를 읽는 가장 쉬운 방법은 그림 5.3과 같이 환경보기에있는 “Import Dataset” 기능을 사용하는 것이다. 그림 5.3: 데이터 세트 가져오기 “Environment” 보기로 이동하여 “Import Dataset”을 클릭한 다음 “From Text (readr)…”를 선택한다. 그러면 그림 5.4와 유사한 화면이 나타난다. 그림 5.4: 데이터 가져오기 위젯 “Browse” 버튼을 사용하여 csv 파일로 이동한다. 이것은 화면의 오른쪽 상단에 있는 그림 5-4에서 강조 표시된다. 데이터 프레임의 기본 이름은 파일과 동일하지만 매우 길게 나타날 것이므로 왼쪽 하단 영역의 “Name” 옆에 강조 표시된 영역에 표시된대로 이 위젯 화면에서 바로 변경할 수 있다. 우리는 단순히 데이터 프레임을 “expectancy”라고 명명했다. 이 프로세스를 완료하면 그림 5.5와 같이 R Studio 프로젝트에 데이터 프레임이 나타난다. 그림 5.5: 프로젝트의 데이터 프레임 그림 5.5에서 왼쪽 상단에 데이터 프레임의 샘플을 볼 수 있다. 데이터를 읽는 데 사용 된 코드는 콘솔의 왼쪽 하단에 표시되며 이 코드는 히스토리 보기에서도 유지된다. 마지막으로 오른쪽 상단의 “Environment” 창에 “expectancy”라는 이름의 개체가 표시된다. 어떤 시점에서 창을 닫으면 이 개체를 클릭하여 데이터를 다시 표시할 수 있다. 이것은 프로젝트 설정의 첫 번째 단계이다. RStudio를 닫은 경우 프로젝트 상태를 저장해야 한다. 그렇지 않으면 데이터 프레임 작업을 위해 지금까지의 과정을 다시 반복해야 한다. "],["r-코드-파일.html", "5.2 R 코드 파일", " 5.2 R 코드 파일 처음에는 제공된 위젯과 대화형 콘솔 화면을 사용하는 것이 쉬울 수 있지만 분석을 다시 실행하거나 동료에게 분석을 실행하도록 요청하려면 지금까지의 단계를 다시 추적하기가 어렵다. 분석을 실제로 재현할 수 없다. 작업을 재현할 수 있도록 프로젝트에 R 스크립트 파일을 추가할 수 있다. 이제 할 일은 R 스크립트 파일을 추가 한 다음 자동으로 생성된 코드를 이 파일에 추가하여 그림에서 재사용 할 수 있도록 하는 것입니다. RStudio 메뉴 모음으로 이동하여 “파일”  “새 파일”  “R 스크립트”를 선택한다. 그림 5.6에 표시된 새 탭이 “Untitled1”이라는 레이블이 붙은 데이터 프레임 옆에 나타난다. 그림 5.6: 스크립트 편집기 이 스크립트 편집기는 상단의 시각적 바로 가기 막대와 함께 매우 유용한 내부 기능을 제공한다. 먼저 플로피 디스크 아이콘을 클릭하여 기억에 남는 이름으로 이 파일을 프로젝트에 저장한다. 플로피 디스크 아이콘을 클릭하고 나타나는 대화 상자에서 파일의 이름을 “process_data.R”로 입력한다. 이제 파일이 파일 탐색기에 나타나고 이름을 클릭하여 언제든지 파일을 열 수 있다. 여기에서 코드 도구에 대해 이야기 할 때 다른 기능을 살펴 보겠지만 지금은 여기에 작업을 저장하고 위의 “실행”과 “소스” 버튼을 사용하여 코드를 실행할 수도 있다. 지금은 csv 파일에서 읽은 자동 생성된 코드를 검색한 다음 이 데이터 프레임에서 약간의 관리 작업을 수행하려고 한다. 오른쪽에 있는 “History” 탭을 열면 그림 5.7과 같이 csv 파일을 읽는 데 사용 된 코드 줄이 표시된다. 실행했던 명령어들을 클릭하여 코드의 처음 두 줄을 강조 표시 즉 선택한다. 그림 5.7: 히스토리 탭에서 코드 검색 “To Source” 버튼을 클릭하여 이 코드를 R 스크립트 파일로 이동시킨다. 그런 다음 플로피 디스크 아이콘을 클릭하여 그림 5.8과 같이 파일을 저장한다. 그림 5.8: 검색된 코드가 있는 R 스크립트 파일 이제 상단의 “Source” 버튼을 클릭하여 필요할 때마다 이 단계를 다시 실행할 수도 있다. 또한 이 프로젝트를 동료에게 보낼 수 있으며 그는 동일한 방식으로 작업을 재현할 수 있으므로 분석이 재현 가능한 상태로 유지된다. 계속 진행하기 전에 코드에 주석을 추가하고 나중에 작업하기 쉽도록 데이터 프레임을 정리해야 한다. 아래 코드는 이를 수행하는 방법의 한 예이다: # Import NCHS Dataset # File download from: # https://catalog.data.gov # Contains life expectancy data from 1900 in the US library(readr) expectancy &lt;- read_csv(&quot;data/NCHS_-_Age-adjusted_death_rates_and_life-expectancy_at_birth___All_Races__Both_Sexes___United_States__1900-2013.csv&quot;) ## ## -- Column specification -------------------------------------------------------- ## cols( ## Year = col_double(), ## Race = col_character(), ## Sex = col_character(), ## `Average Life Expectancy (Years)` = col_double(), ## `Age-adjusted Death Rate` = col_double() ## ) # Clean up dataframe # Use shorter column names names(expectancy)[1] &lt;- &quot;year&quot; names(expectancy)[2] &lt;- &quot;race&quot; names(expectancy)[3] &lt;- &quot;sex&quot; names(expectancy)[4] &lt;- &quot;life_expectancy&quot; names(expectancy)[5] &lt;- &quot;death_rate&quot; # 기호 다음은 주석 내용이고, R 코드의 마지막 5 줄은 열 이름을 작업하기 더 쉬운 짧은 이름으로 바꾸는 스크립트이다. 이 파일에 코드를 저장하려면 플로피 디스크 아이콘을 클릭하면 된다. "],["데이터-탐색.html", "5.3 데이터 탐색", " 5.3 데이터 탐색 새 프로젝트를 시작할 때 할 수 있는 작업 중 하나는 탐색적 데이터 분석(Exploratory Data Analysis)을 수행하는 것이다. 데이터 세트를 미리 시각적으로 검사 할 수 있지만 더 완전한 그림을 작성하는 것이 좋을 것이니다. 또한 더 중요한 데이터 포인트를 시각화하기를 원할 수도 있다. 5.3.1 데이터 프레임 요약 RStudio 메뉴 표시 줄로 이동하여 “파일”  “새 파일”  “R 스크립트”를 선택하여 새로운 R 스크립트 파일을 생성해 보자. 앞에서와 마찬가지로 새 파일이 나타난다. 플로피 디스크 아이콘을 클릭하여이 파일을 “data_exploration.R”의 파일 이름으로 저장한다. 이제 우리는 expectancy 데이터 프레임의 요약을 확인하고자 한다. 그래서 우리는 summary() 함수의 인수로 데이터 프레임을 사용할 수 있다. summary(expectancy) 이 함수를 R 스크립트 파일에 바로 입력한 다음 “실행” 버튼을 클릭하여이 코드를 실행한다. 그러면 그림 5.9와 같이 각 변수 (또는 데이터 프레임의 열)를 설명하는 출력이 표시된다. 그림 5.9: 코드 편집 옵션 그림 5-9의 정보는이 데이터 세트에 대한 많은 것을 보여주고 있다. 각 열에 어떤 유형의 데이터가 포함되어 있는지 알 수 있으며, 숫자 데이터에 대한 정보가 있다. 예를 들어, 우리는 데이터 세트가 1900년에서 부터 2015 년까지를 포함하고, 어떤 연도의 기대수명은 29.10 년이고 다른 연도의 기대수명은 81.4 년이라는 것을 알 수 있다. 또한 인종과 성별의 두 가지 문자열 유형이 있음을 알 수 있지만 이에 대한 정보는 거의 없다. 이는 카테고리형 변수들로서, 이 데이터 세트가 어떻게 구성되어 있는지 보여주고 있다. 인종 및 성별의 범주를 보기 위해 R의 unique() 함수를 사용하고 다음과 같은 인수로 데이터 열을 전달할 수 있다. unique(expectancy$race) ## [1] &quot;All Races&quot; &quot;Black&quot; &quot;White&quot; “실행” 버튼을 클릭하면, 그 결과는 다음과 같이 나타날 것이다: ## [1] &quot;All Races&quot; &quot;Black&quot; &quot;White&quot; 성별의 범주에 대해 동일한 작업을 수행하면 “Both Sexes,” “Female” 그리고 “Male”의 세 가지 범주도 사용할 수 있음을 알 수 있다. 이 모든 것을 통해 데이터가 year(연도), race(인종) 그리고 sex(성별)의 세 가지 범주로 구성된다는 것을 알 수 있다. 또한 매년 가능한 모든 인종 및 성별 조합에 대한 행이 있을 것이다. 데이터 프레임 보기를 사용하여 이를 확인할 수 있다. expectancy 데이터 프레임을 다시 보려면 프로젝트의 첫 번째 탭으로 이동한다. 데이터의 하위 집합을 보려면 필터(Filter) 버튼을 클릭한다. year(연도) 열의 슬라이더를 사용하여 그림 5.10에 표시된대로 1900 년으로 식별되는 행만 볼 수 있다. 그림 5.10: 필터링된 데이터 프레임 우리는 데이터 프레임이 어떻게 구성되어 있는지 알고 있으므로 이 데이터 프레임을 처리하는 방법에 주의해야 한다. 예를 들어, 중복되는 범주가 포함되어 있으므로 연도별로 데이터 포인트를 단순히 집계하지 않고, 조사 질문을 개발할 때 이러한 범주를 필터링하고자 한다. 또한 우리가 보고 있는 숫자 변수에 대한 통찰력을 얻기 위해 기초적인 시각화를 수행할 수도 있다. 예를 들어 1900 년 이후로 기대 수명이 늘어 났을 것이라고 추측할 수 있다. 이 가설을 테스트하기 위해 race(인종)와 sex(성별) 범주 값이 “All Races”와 “Both Sexes”인 데이터 프레임의 행만 볼 수 있다. trend &lt;- expectancy trend &lt;- trend[trend$race == &quot;All Races&quot;, ] trend &lt;- trend[trend$sex == &quot;Both Sexes&quot;, ] 먼저 trend라는 새 데이터 프레임에 expectancy 데이터 프레임을 할당한다. 그런 다음 데이터의 두 하위 집합을 가져온다. 두 번째 줄은 race(인종)이 “All Races”인 모든 행을 반환하고, 세 번째 줄은 sex(성별)이 “Both Sexes”인 모든 행을 반환한다. 다음으로, 특별히 살펴보게 될 변수에 대해 나머지 예상되는 값들은 모두 제거 할 수 있다. trend$race &lt;- NULL trend$sex &lt;- NULL trend$death_rate &lt;- NULL R에서 개체를 NULL로 설정하면 환경에서 개체가 제거된다. 이제 base R 플롯 함수를 사용하여 연도별 기대 수명을 플롯할 수 있다. plot(trend) 그러면 두 개의 변수가 자동으로 플롯되고 플롯 뷰어에는 그림 5.11과 같이 플롯이 표시된다. 그림 5.11: 연도 별 기대 수명 보다시피 이 플롯은 기대 수명이 수년에 걸쳐 증가할 것이라는 처음의 추측을 뒷받침하고 있다. 이 플롯은 또한 초기 관측치가 후기 관측치만큼 일관성이 없음을 보여준다. "],["결론-3.html", "5.4 결론", " 5.4 결론 이 장에서는 RStudio 프로젝트를 사용하여 작업을 구성하고 재현 가능하게 만드는 방법에 대한 예를 제공하였다. RStudio 프로젝트를 사용하면 분석을 구체화할 때 단계를 쉽게 추적하고 이전 작업을 기반으로 구축할 수 있다. 또한 RStudio 프로젝트를 사용하면 동료와의 공동 작업을 훨씬 쉽게 할 수 있게 해 준다. 이와 같은 프로젝트에서 작업 한 후 RStudio를 닫을 때 즉 IDE를 종료할 때 메시지가 나타나면 “Save” 버튼을 클릭해야 한다. 이렇게 하면 작업과 기록이 저장되고 프로젝트에서 중단한 부분을 쉽게 선택할 수 있게 해 준다. "],["Essential-R-Packages.html", "Chapter 6 필수적인 R 패키지 : tidyverse", " Chapter 6 필수적인 R 패키지 : tidyverse 이제 필수 RStudio 워크 플로가 준비되었으므로 데이터 분석을 실제로 강화할 몇 가지 도구를 사용할 준비가 되었다. 이러한 모든 도구가 RStudio 전용은 아니며 다른 R에서도 볼 수 있다. 하지만 RStudio IDE와 매우 잘 어울린다는 것이다. 여기서 첫 번째 순서는 R 툴킷의 초석을 제공할 필수 패키지를 소개하는 것이다. 이러한 패키지 중 상당수는 이미 R에 존재하는 기능을 단순화하는 것도 있고, 어떤 패키지는 base 시스템에 기능을 추가하는 것도 있다. 이러한 패키지와 함께 RStudio는 R을 데이터 실무자를 위한 전문 도구로 변환시켜 준다. "],["r-패키지.html", "6.1 R 패키지", " 6.1 R 패키지 R 패키지는 R에 내장 된 base 기능을 확장하기 위해 RStudio에 연결할 수 있는 것이다. R이 인기를 얻은 이유 중 하나는 R을 데이터 과학을 위한 포괄적인 플랫폼으로 만드는 풍부한 패키지 에코 시스템을 가지고 있기 때문이다. RStudio를 사용하여 패키지를 불러오기, 찾아보기, 설치하고 제거하거나 R 코드를 사용하여 R 패키지를 관리 할 수 있다. RStudio의 패키지 지원은 3 장에서 자세히 설명된 바 있다. "],["tidyverse.html", "6.2 tidyverse", " 6.2 tidyverse 우리가 논의할 패키지는 실제로 “tidyverse”라는 패키지 모음이다. tidyverse는 주로 RStudio를 이용하여 작업하는 Hadley Wickham이 개발했다. tidyverse 웹 사이트는이 패키지 세트를 가장 잘 설명한다. “tidyverse는 데이터 과학을 위해 설계된 독자적인 R 패키지 모음이다. 이 패키지가 담고 있는 모든 패키지들은 기본 디자인 철학, 문법 및 데이터 구조를 공유한다.” 저자는 tidyverse를 “독자적인” 것으로 설명한다. 이것은 tidyverse가 함수들의 집합 이상이라는 것을 의미한다. 또한 데이터 과학을 수행하는 규정된 방법이기도 하다. 일을 처리하는 tidyverse 방법이 있다. 이것이 그들이 tidyverse가 “독자적이다”는 말의 의미이다. tidyverse가 잘하는 것 중 하나는 base R의 거친 가장자리를 부드럽게하는 것입니다. tidyverse는 사용하기 쉽고 기억하기 쉬운 base R에 이미 존재하는 함수에 대해 일관된 함수들을 제공한다. 이러한 패키지는 또한 base R에 포함된 기능들에 더 많은 기능들을 추가한다. 예를 들어, ggplot2 (tidyverse 패키지 중의 하나)는 base R의 플롯 기능으로 수행 할 수있는 작업을 확장하지만 더 많은 플롯 유형을 추가하고 있다. 지금부터 핵심 tidyverse 패키지를 살펴 보기로 한다. 아래 예제를 따라 하려면 tidyverse를 설치한 다음, 라이브러리를 프로젝트로 가져와야 한다. 이를 위해 3 장의 패키지 지침을 사용하거나 이 코드를 R 콘솔에 입력할 수 있다. # install.packages(&quot;tidyverse&quot;) library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 -- ##  ggplot2 3.3.3  dplyr 1.0.2 ##  tibble 3.0.4  stringr 1.4.0 ##  tidyr 1.1.2  forcats 0.5.0 ##  purrr 0.3.4 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract magrittr 패키지는 파이프 연산자 (%&lt;%)를 도입하여 R 코딩의 흐름을 변경한다. %&lt;% 연산자는 왼쪽 값을 오른 쪽 표현식으로 파이프한다. 이를 통해 코드 블록이 수행하는 작업을 즉시 명확하게 볼 수 있게 해 주는 “파이프 라인”을 만들 수 있다. 함수에 너무 많이 의존하는 R과 같은 프로그래밍 언어에서는 다음과 같이 읽기 어려운 코드로 끝날 수 있다. round(mean(subset(expectancy, race == &quot;All Races&quot;)$death_rate), 1) ## [1] 1469.6 이 한 줄의 코드는 지난 장에서 작업했던 expectancy 데이터 프레임의 평균 사망률을 계산해서 반환해 준다. 그런데 데이터 세트 필터링, 평균 점수 계산, 결과의 반올림 등의 세 가지 작업을 수행하고 있다. 이와 같은 코드를 읽는 것은 매우 어려운데, 문제가 더 복잡해다면 이런 코드는 더 읽기 어려워 진다. magrittr 패키지의 파이프 연산자 (%&gt;%)는 중첩 함수 호출의 필요성을 제거하여 주고, 코드를 정리하는 데 도움을 준다. 다음은 이 코드를 작성하는 다른 방법을 보여주고 있다. expectancy %&gt;% subset(race == &quot;All Races&quot;) %&gt;% .$death_rate %&gt;% mean() %&gt;% round(1) ## [1] 1469.6 이 코드는 조금 더 길지만 훨씬 더 명확하다. 이 코드는 위에서 아래의 방향으로 작동하고, 각각의 %&gt;%는 그 위(또는 왼쪽)에 있는 개체를 가져 와서 다음 함수의 첫 번째 인수로 보낸다. 상단에서 %&gt;%를 사용하여 expectancy 데이터 프레임을 서브세팅하기 위해 오른쪽 함수의 인수로 보낸다. 이제 데이터 프레임에서 시작하여, 행의 일부를 가져오고 death_rate컬럼을 선택하고, 평균을 구하기 위해 mean을 사용한 다음, 값을 반올림(round)했다고 명확하게 말할 수 있다. Note : 점(.)을 주목하라. 위 코드의 세 번째 줄에서 사용되고 있는 점(.)은 magrittr에 의해 파이프되는 개체를 참조하는 데 사용되는데, 위의 서브세팅 함수가 출력하고 있는 데이터 프레임을 참조한다. 즉, expectancy 데이터 프레임에서 race == \"All Races\"인 행들로 구성된 데이터 프레임을 참조하고 있다. magrittr 패키지는 모든 tidyverse 패키지에 사용되는 핵심 패키지로, tidyverse에서 사용되는 독자적 분석 스타일을 알리는 데 도움이 된다. "],["tibble.html", "6.3 tibble", " 6.3 tibble tibble 패키지는 또 다른 tidyverse의 기본 패키지이다. tibble은 base R 데이터 프레임의 tidyverse 버전이다. 이 패키지를 반드시 직접 사용하는 것은 아니지만 tidyverse 함수는 데이터 프레임 대신 tibble들을 반환한다. 실제로 이것은 큰 영향을 미치지 않으며 tibble을 데이터 프레임으로 취급할 수 있다. 그러나 tibble은 다른 방식으로 작동한다. 예를 들어 R 콘솔에 iris라는 단어를 입력하면 iris 데이터 프레임에 있는 모든 데이터의 목록을 얻을 수 있다. 그러나 iris 데이터 프레임을 tibble로 변환하여 그 데이터를 출력해 보면 다음과 같이 출력된다: iris %&gt;% as_tibble() 그림 6.1에 표시된 것과 같이 데이터를 깔끔하게 출력할 수 있다. 그림 6.1: Tibble tidy 출력 데이터 화면이 하나만 표시되지만 더 유용한 정보가 표시된다. 데이터 자체의 샘플을 볼 수 있으며, 각 열의 데이터 유형과 데이터 세트의 차원을 얻을 수 있다. "],["dplyr.html", "6.4 dplyr", " 6.4 dplyr dplyr는 데이터 조작에 사용하는 깔끔한 패키지이다. 이 패키지를 사용하면 행을 필터링하고, 변수를 선택하고, 콘텐츠를 변경하는 것이 훨씬 쉬워진다. dplyr는 magrittr과 협력하여 데이터 조작을 위한 “문법”을 제공한다. dplyr과 tidyverse에서 일반적으로 문법이라는 단어는 R에서 작업하는 독자적인 방식을 나타낸다. tidyverse 문법에서는 함수를 동사라고한다. 동사는 매우 설명적인 방식으로 작성되어 깔끔한 문법을 사용할 때 작성 중인 코드가 매우 명확하게 분석 스토리를 전달한다. 예를 들어 다음과 같이 dplyr과 magrittr을 사용하여 평균 사망률을 구하는 마지막 예를 코딩할 수 있다. expectancy %&gt;% filter(race == &quot;All Races&quot;) %&gt;% summarize(avg = mean(death_rate)) %&gt;% mutate(avg = round(avg, 1)) ## # A tibble: 1 x 1 ## avg ## &lt;dbl&gt; ## 1 1470. 위의 코드에서 expectancy 데이터 프레임을 우리가 하는 일을 설명하는 동사 세트로 파이프한다. 우리는 필터링하고, 요약하고, 변형하고 있다. 이것은 우리가 하는 일을 설명하고 있다. 또한 파이프 라인의 어느 곳에서나 간단히 새 동사를 변경하거나 추가할 수 있으므로 이 파이프 라인을 쉽게 변경할 수도 있다. 위의 코드는 tibble로 반환되는 하나의 값을 출력한다. ## A tibble: 1 x 1 ## ## avg &lt;dbl&gt; ## 1 1489. 동일한 분석을하고 싶지만 성별에 따른 평균 사망률도 확인하려면 파이프 라인에 group_by 동사를 추가하면 된다. expectancy %&gt;% filter(race == &quot;All Races&quot;) %&gt;% group_by(sex) %&gt;% summarize(avg = mean(death_rate)) %&gt;% mutate(avg = round(avg, 1)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 3 x 2 ## sex avg ## &lt;chr&gt; &lt;dbl&gt; ## 1 Both Sexes 1459 ## 2 Female 1288. ## 3 Male 1662 이번에는 남녀 모두에 대한 값, 남성에 대한 값, 여성에 대한 값 등 세 가지 값을 얻는다. ## A tibble: 3 x 2 ## ## sex avg ## &lt;chr&gt; &lt;dbl&gt; ## 1 Both Sexes 1478. ## 2 Female 1305. ## 3 Male 1683. 6.4.1 SQL 유사 조인 inner_join, left_join 그리고 right_join 동사를 사용하여 두 개의 관련 데이터 세트를 함께 결합한다. 이러한 dplyr 동사는 비슷한 이름의 SQL 문인 INNER JOIN, LEFT JOIN 및 RIGHT JOIN과 대략 동일하다. dplyr 조인을 설명하기 위해 데이터 프레임(아니, tibble!)에 더 나은 레이블이 필요하고, 더 나은 레이블이 포함된 tibble도 있다고 가정해 보자. 이제 다음과 같이 레이블 티블을 만들 수 있다. labels &lt;- tribble( ~key, ~new_label, &quot;Both Sexes&quot;, &quot;All Genders&quot;, &quot;Female&quot;, &quot;Identifies Female&quot;, &quot;Male&quot;, &quot;Identifies Male&quot; ) 이 코드를 실행하면 “labels”라는 새 tibble이 환경 창의 “Data” 아래에 나타난다. 보기에서 개체 이름을 클릭하기 만하면 이전에 데이터 프레임을 본 것과 동일한 방식으로 볼 수 있다. 이제 dplyr의 inner_join 동사를 사용하여 이러한 레이블을 파이프 라인에 쉽게 추가할 수 있다. expectancy %&gt;% filter(race == &quot;All Races&quot;) %&gt;% group_by(sex) %&gt;% summarize(avg = mean(death_rate)) %&gt;% inner_join(labels, by = c(&quot;sex&quot; = &quot;key&quot;)) %&gt;% mutate(avg = round(avg, 1)) %&gt;% select(gender = new_label, avg_death_rate = avg) 위의 코드에서 dplyr의 select 동사를 사용하여 레이블을보 다 나은 방식으로 정렬하고 이름을 바꾼 것을 볼 수 있다. 결과는 그림 6.2에서 볼 수 있다. 그림 6.2: [tibble에 적용된 성별 라벨기 위의 코드를 실행하면 결과가 tibble로 반환되는 것을 알 수 있다. 콘솔에 결과를 표시하는 대신 할당 연산자 &lt;- 를 사용하여 나중에 사용할 수 있도록 결과를 저장할 수도 있다. avg_death_rates_by_gender &lt;- expectancy %&gt;% filter(race == &quot;All Races&quot;) %&gt;% group_by(sex) %&gt;% summarize(avg = mean(death_rate)) %&gt;% inner_join(labels, by = c(&quot;sex&quot; = &quot;key&quot;)) %&gt;% mutate(avg = round(avg, 1)) %&gt;% select(gender = new_label, avg_death_rate = avg) ## `summarise()` ungrouping output (override with `.groups` argument) "],["stringr.html", "6.5 stringr", " 6.5 stringr 자세히 살펴볼 마지막 tidyverse 패키지는 문자열 작업에 도움이 될 것이다. 이 데이터 유형은 단순한 숫자보다 더 복잡할 수 있기 때문에 문자열로 작업하는 것은 까다롭다. stringr에는 패턴 감지, 문자열 분할 그리고 문자열 결합을 돕는 함수들이 포함되어 있다. stringr 함수는 자체적으로 사용할 수 있지만, filter와 mutate 등의 dplyr 동사와 함께 사용할 수도 있다. 예를 들어 race 열에 “All”문자 패턴을 포함하는 레코드를 필터링하려면 다음과 같이 필터 동사에 str_detect를 사용한다. expectancy %&gt;% filter(str_detect(race, &quot;All&quot;)) ## # A tibble: 357 x 5 ## year race sex life_expectancy death_rate ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1900 All Races Both Sexes 47.3 2518 ## 2 1901 All Races Both Sexes 49.1 2473. ## 3 1902 All Races Both Sexes 51.5 2301. ## 4 1903 All Races Both Sexes 50.5 2379 ## 5 1904 All Races Both Sexes 47.6 2502. ## 6 1905 All Races Both Sexes 48.7 2424. ## 7 1906 All Races Both Sexes 48.7 2399 ## 8 1907 All Races Both Sexes 47.6 2494. ## 9 1908 All Races Both Sexes 51.1 2299. ## 10 1909 All Races Both Sexes 52.1 2249. ## # ... with 347 more rows str_replace를 사용하여 한 패턴의 문자를 다른 패턴으로 바꿀 수도 있다. race 열의 “All Races” 항목을 “Most Races”로 변경하려면 다음과 같이 하면 된다. expectancy &lt;- expectancy %&gt;% mutate(race = str_replace(race, &quot;All&quot;, &quot;Most&quot;)) 문자열 작업에 도움이 되는 많은 stringr 함수가 있다. 대부분은 base R 함수와 함께 작동하는 단순히 래퍼이다. stringr의 가치는 주로 일관된 인터페이스를 제공한다는 점이다. 각 함수는 첫 번째 인수로 입력 문자열을 가지므로 magrittr 파이프 연산자와 함께 작동할 수 있다. "],["결론-4.html", "6.6 결론", " 6.6 결론 tidyverse 컬렉션에는 더 많은 패키지가 있지만 위에서 다룬 패키지는 모든 tidyverse 패키지로 작업할 수있는 지식을 제공한다. 이것들은 우리가 매일 사용할 가능성이 가장 높은 패키지이며 우리가 더 자세히 처리가 할 가치가 있다고 생각할 만큼 충분히 base R을 확장하는 개념이 필요하다. 하지만 잠시 시간을 내서 우리가 사용할 수 있는 다른 패키지가 어떤 것들이 있는지 알아보기로 한다. ggplot2는 R에서 데이터 시각화의 표준을 설정하는 깔끔한 패키지이다.이 패키지는 ‘데이터 시각화’ 장에서 자세히 다룰 것이다. tidyr은 데이터를 분석 파이프 라인에 쉽게 추가할 수있는 깔끔한 데이터 세트로 변환하는 데 도움이 된다. 이 밖에도 readr, readxl 그리고 haven 등의 패키지들은 텍스트 데이터, Excel 데이터 및 SAS / Stata / SPSS 데이터를 가져 오는 데 도움이된다. 그리고 lubridate는 까다로운 날짜 및 날짜 시간 작업을 도와준다. "],["Data-Visualization.html", "Chapter 7 데이터 시각화", " Chapter 7 데이터 시각화 RStudio 사용자에게 가장 매력적인 요소 중 하나는 사용 가능한 풍부한 데이터 시각화 도구 라이브러리이다. 이 장에서는 대부분의 일상 작업에 도움이 될 주요 그래픽 도구를 강조한다. 물론 R 생태계에는 시각화에 사용할 수있는 수백 개의 추가 라이브러리와 특수 패키지가 있다. 지금은 ggplot2 (tidyverse 패키지)부터 즉시 가장 큰 영향을 미칠 도구에 초점을 맞출 것이다. 여기서부터는 사용하기 위해서는 더 많은 작업을 요구하는 시각화를 더 많이 제어 할 수있는 패키지에 대하여 살펴 보기로 한다. "],["ggplot2.html", "7.1 ggplot2", " 7.1 ggplot2 ggplot2는 필수적인 플로팅을 하게 해 주는 tidyverse 방법이다. 이는 이전 장에서 이미 보았던 데이터 플로팅의 base R 방법을 대체하고 향상시킨다. 지난 장에서 dplyr에 대한 논의에서 기대할 수 있듯이 ggplot2는 데이터 시각화를 수행하는 매우 독자적인 방법을 제공한다. 일일 데이터 탐색과 정적 그래픽이 허용되는 보고서에 포함하기 위해 ggplot2를 사용한다. ggplot2를 사용하는 방법을 살펴 보자. 첫째, 다른 tidyverse 패키지와 마찬가지로 library() 함수를 사용하여 tidyverse 패키지를 불러온다. library(tidyverse) source(&quot;process_data.R&quot;) ## ## -- Column specification -------------------------------------------------------- ## cols( ## Year = col_double(), ## Race = col_character(), ## Sex = col_character(), ## `Average Life Expectancy (Years)` = col_double(), ## `Age-adjusted Death Rate` = col_double() ## ) tidyverse를 불러온 한 후 코드의 두 번째 줄에서 source() 명령을 사용하여 “process_data.R” 파일에 저장한 모든 코드를 다시 실행했다. 이를 통해 expectation 데이터 세트의 구조를 사용할 수 있게 해 준다. ggplot2를 사용하기 위해 데이터 세트를 ggplot() 함수로 파이프할 수 있다. 이 함수를 사용하려면 플로팅 할 변수를 지정해야 한다. expectancy %&gt;% filter(race == &quot;All Races&quot;, sex == &quot;Both Sexes&quot;) %&gt;% ggplot(aes(year, life_expectancy)) 이 코드를 실행하면 그림 7.1과 같이 X축과 Y 축이 이미 정의된 빈 캔버스가 나타난다. 그림 7.1: 빈 ggplot 캔버스 그림 7.1은 X 축에 연도, Y 축에 사망률이 있는 캔버스를 보여주고 있다. 이제 플롯의 범위를 정의했으므로 데이터를 표시하는 시각적 요소를 추가 할 수 있습니다. ggplot 함수를 데이터 스토리를 설명하는 “동사”세트로 파이핑하여 이를 수행한다. expectancy %&gt;% filter(race == &quot;All Races&quot;, sex == &quot;Both Sexes&quot;) %&gt;% ggplot(aes(year, life_expectancy)) + geom_line() geom_line 동사를 사용하여 데이터를 표현하기 위해 선을 사용하고 싶다고 말했다. 예상 할 수있는 magrittr 파이프 연산자 (%&gt;%)를 사용하는 대신 ggplot2는 파이프에 더하기 기호 (+)를 사용한다. 이 선 플롯의 예는 그림 7.2를 참조하기 바란다. 그림 7.2: 연도 별 사망률 선 플롯 그림 7.2의 플롯은 흥미로운 추세와 나중에 설명할 이상 값(outliers)을 보여주고 있다. 파이프 연산자 +를 사용하여 시각화를 파이핑하여 계속해서 시각화할 수 있다. 선에 점을 추가하려면 geom_point 동사를 사용한다. expectancy %&gt;% filter(race == &quot;All Races&quot;, sex == &quot;Both Sexes&quot;) %&gt;% ggplot(aes(year, life_expectancy)) + geom_line() + geom_point() 그러면 그림 7.3과 같이 플롯이 생성된다. 그림 7.3: 라인 플롯에 포인트 마커 추가 이 추세를 성별로 분류하고 싶다면 어떨까? ggplot 라인 플롯에서 이와 같은 하위 그룹을 보려면 분류하려는 geom_line 동사에 새로운 미적(aes) 매개 변수를 추가하기 만하면 된다. expectancy %&gt;% filter(race == &quot;All Races&quot;) %&gt;% ggplot(aes(year, life_expectancy)) + geom_line(aes(color = sex)) 이 시각화의 첫 번째 부분에서는 세 그룹을 모두 살펴 보고자하기 때문에 더 이상 “Both Sexes”를 필터링하지 않는다. 이 코드는 그림 7.4의 플롯을 생성한다. 그림 7.4: ggplot에서 하위 그룹 플로팅 이 그림은 두 성별 간의 관계를 보여준다. geom_line에서 aes의 color 인수를 지정했기 때문에 선이 색상으로 나타난다. 이 장에서 다루고 있는 ggplot에는 훨씬 더 많은 여지가 있다. 레이블 및 제목 옵션과 함께 다양한 유형의 데이터를 표시할 수있는 많은 옵션이 있다. 이 패키지는 본질적으로 RStudio의 시각화 도구이기도 하다. 이 패키지의 사용 방법에 대한 자세한 정보는 공식 웹 사이트 ggplot2를 참조하기 바란다. "],["htmlwidgets.html", "7.2 htmlwidgets", " 7.2 htmlwidgets ggplot2는 플로팅하는데 필요한 대부분의 기능을 제공하지만, 분석과 상호 작용하거나 매우 전문화된 그래픽을 추가하고 싶을 때가 있다. htmlwidget은 다음과 같은 용도로 사용할 수있는 패키지 모음으로, R 분석에 다음 수준의 시각화를 추가하는데 사용될 수 있다. htmlwidgets는 원래 웹 사이트 용으로 개발된 오픈 소스 자바 스크립트 위젯을 통합할 수있는 기능을 제공한다. 사용 가능한 전체 위젯 목록을 보려면 웹 사이트를 참고하기 바란다. 이러한 위젯 중 상당수는 시각화하려는 문제 유형에 매우 구체적이다. 지도, 시계열, 네트워크 그래프 및 일부 D3 그래픽에 대한 위젯을 찾을 수 있다. 하나의 htmlwidget, plotly를 사용하여 마지막 섹션에서 만든 플롯을 웹 지원 대화형 위젯으로 바꿀 수 있다. plotly는 gglot2와 함께 작동하고 실제로 ggplo2를 다음 수준으로 가져 가기 때문에 흥미롭다. 다음은 plotly를 사용하여 ggplot2 플롯에 상호 작용을 추가하는데 필요한 것들이다. library(plotly) i_plot &lt;- expectancy %&gt;% filter(race == &quot;All Races&quot;) %&gt;% ggplot(aes(year, life_expectancy)) + geom_line(aes(color = sex)) ggplotly(i_plot) 이 코드는 ggplot2에서했던 것과 매우 유사하다. 그러나 이번에는 결과를 개체에 할당하고 해당 개체를 매개 변수로 ggplotly에 사용하여 그림 7.5에서 볼 수있는 대화형 플롯을 만든다. 그림 7.5: 팝업이 있는 Plotly HTML 위젯 이제 이 플롯에는 세부 정보 팝업과 상단에 탐색 그림이 있는 도구 모음이 포함된다. 이후 장에서 일관된 보고서와 대시 보드를 작성하는 방법을 학슬할 때 이와 같은 위젯을 포함하여 사용자를 위한 풍부한 대화형 환경을 만들 수 있다. 계속 진행하기 전에 DT 패키지의 Datatables 구성 요소를 살펴보자. Datatables는 데이터 세트에 대한 검색 가능한 HTML 프레젠테이션을 생성하는 매우 유용한 대화형 HTML 위젯이다. 예를 들어 데이터 세트의 검색 가능한 버전을 사용자에게 직접 제공하려면 다음과 같이 하면된다. library(DT) datatable(expectancy, options = list(pageLength = 10)) 그러면 데이터로 채워진 검색 가능한 대화형 테이블로 그림 7.6과 같은 위젯이 생성된다. 그림 7.6: 데이터 테이블 위젯 "],["r2d3.html", "7.3 r2d3", " 7.3 r2d3 이 장의 처음 두 섹션에서 설명하는 패키지는 모두 대부분의 데이터 유형을 시각화하는 풍부한 개체를 제공한다. 그러나 결국 우리의 그래픽은 다른 사람들이 디자인하고 모든 R 개발자가 사용할 수 있는 그래픽처럼 보일 것이다. 시각화의 모든 측면을 절대적으로 제어하려는 몇 가지 사용 사례가 있다. 우리에게 도움이 되는 위젯이 없거나 고도로 맞춤화된 무언가가 필요하다. 여기서 D3가 우리를 도울 수 있고 r2d3는 D3를 RStudio 프로젝트에 통합하는 데 사용할 수있는 패키지이다. htmlwidgets와 마찬가지로 D3는 웹 기반 Javascript 솔루션이다. 그러나 D3를 사용하는 것은 htmlwidget으로 하는 것보다 더 복잡하다. D3는 본질적으로 프로그래밍 언어이다. D3의 핵심 아이디어는 그래픽 프리미티브 (선 및 원과 같은 것)로 데이터 세트를 결합할 수 있다는 것이다. 이러한 그래픽은 데이터 세트의 값에 따라 늘어나거나 줄어 들게 된다. D3 그래픽은 모양을 제어할 수 있기 때문에 매우 복잡해질 수 있다. D3의 학습은 범위를 벗어나지만 시작하기 위한 간단한 방법은 살펴보기로 한다. NOTE 여기에서 설명하는 기능을 사용하려면 다운로드한 RStudio의 현재 버전에서 사용할 수있는 RStudio 1.2가 필요하다. 그러나 이 장에서 사용된 버전은 RStudio의 미리보기 버전이므로 스크린 샷이 다소 다르게 보일 수 있다. D3를 사용하려면 RStudio 메뉴로 이동 한 다음 “파일,” “새 파일,” “D3 스크립트”를 차례로 선택합니다. D3 코드가있는 파일이 나타납니다. // !preview r2d3 data=c(0.3, 0.6, 0.8, 0.95, 0.40) // // r2d3: https://rstudio.github.io/r2d3 var barHeight = Math.ceil(height / data.length); svg.selectAll(&#39;rect&#39;) .data(data) .enter().append(&#39;rect&#39;) .attr(&#39;width&#39;, function(d) { return d * width; }) .attr(&#39;height&#39;, barHeight) .attr(&#39;y&#39;, function(d, i) { return i * barHeight; }) .attr(&#39;fill&#39;, &#39;steelblue&#39;); 이 파일의 코드는 Javascript이며 이 코드를 수정하여 시각화를 조정할 수 있다. 이 파일을 저장하고 “미리보기” 버튼을 클릭하여 D3 시각화가 어떻게 보이는지 확인한다. 앞서 강조한 사전 패키징된 솔루션과 비교하면 별로 좋아 보이지 않지만, D3는 실제로 그릴 수있는 캔버스를 더 많이 제공하므로 괜찮다. 미리보기는 단순히 파일의 주석에 있는 코드를 사용하지만 R 스크립트 파일에서 자체 데이터를 제공하는 경우 r2d3 라이브러리를 사용하여 수행할 수 있다. library(r2d3) r2d3(data = c(.1,.2,.3,.4,.3,.2,.1), script = &quot;d3_plot.js&quot;) 이 코드는 그림 7.7의 플롯을 생성한다. 그림 7.7: 기본 D3 플롯 분명히 이것은 매우 기본적인 시각화이다. r2d3 웹 사이트에서 D3로 할 수있는 멋진 시각화 전체 세트를 확인할 수 있다. 이러한 예제에는 사용자 고유의 D3 사용자 지정 시각화를 위한 시작점으로 사용할 수 있도록 해주는 필요한 코드도 포함하고 있다. "],["결론-5.html", "7.4 결론", " 7.4 결론 base R 플롯 기능 외에도 R에서 데이터 시각화를 위한 많은 옵션이 있다. ggplot은 대부분의 분석가가 대부분의 시간에 필요한 작업을 수행하는 매우 강력하고 독자적인 방법을 제공한다. r2d3 및 htmlwidgets와 같은 패키지는 보다 전문화된 사용 사례를 지원한다. 훨씬 더 전문화 된 시각화 옵션을 사용할 수 있으며 이러한 모든 기능은 이후 장에서 설명할 대시 보드와 보고서 옵션에서 사용할 수 있다. "],["R-Markdown.html", "Chapter 8 R 마크다운", " Chapter 8 R 마크다운 R Markdown을 사용하여 이전 장에서 설명한 기능을 통합하는 보고서를 만들어 보자. R Markdown은 HTML, CSS 및 Markdown과 같은 무료로 사용 가능한 오픈 소스 기술을 활용하여 다양한 형식으로 풍부한 보고서를 생성한다. R Markdown은 사람이 읽을 수 있는 방식으로 문서를 정의하는 간단한 방법인 Markdown을 기반으로 하고 있다. 아이디어는 구조화된 방식으로 빠른 메모를 작성할 수 있다는 것이다. 이러한 노트는 자체적으로 읽을 수 있지만 웹 페이지, 프레젠테이션 및 PDF 파일과 같은 세련된 프레젠테이션 형식으로 변환할 수도 있다. RStudio는 R 언어의 코드와 그래픽을 Markdown 문서에 추가하여 Markdown을 확장해 준다. 이러한 유형의 Markdown을 “R Markdown”이라고 한다. R Markdown을 사용하여 공유 가능한 보고서를 작성하기 위해 기대 수명 분석을 사용하기로 한다. "],["r-markdown-문서.html", "8.1 R Markdown 문서", " 8.1 R Markdown 문서 R Markdown은 RStudio에서 완벽하게 지원된다. Markdown에서 메모를 작성할 수 있을 뿐 만 아니라 포함된 코드를 블록 단위로 실행하여 R Markdown 문서에 실시간으로 바로 표시할 수도 있다. 새 R Markdown 문서를 만들려면 RStudio 메뉴 모음으로 이동하여 그림 8.1과 같이 “File,” “New File” 그리고 “R Markdown”을 클릭한다. 그림 8.1: 새 R 마크다운 문서 추가 그림 8.2에 표시된 대화 상자에 생성되는 문서의 유형을 결정하는 옵션이 표시된다. 그림 8.2: R 마크다운 옵션 여기에서 HTML 또는 PDF 문서를 원하는지 지정한다. 실험할 수 있는 덜 사용되는 다른 형식 유형도 있지만 일반적으로 사람들은 PDF 또는 HTML 보고서를 사용한다. RStudio는 그림 8.3과 유사한 템플릿 텍스트로 R Markdown 문서를 자동으로 생성한다. 그림 8.3: R 마크다운 문서 위의 R Markdown 문서에는 4 개의 개별 섹션이 있다. 처음 여섯 줄은 일명 YAML(Yet Another Markup Language)이라고 한다. --- title: &quot;Life Expectancy&quot; author: &quot;Dae Ho Kim&quot; date: &quot;2021 1 3&quot; output: html_document --- 이 YAML markup은 출력 형식의 유형 및 작성자 이름, 기본적으로 대화 상자에 입력한 내용을 지정한다. 회색으로 강조 표시된 다음 세 줄은 R Markdown 출력을 렌더링하는 데 사용되는 패키지 인 knitr에 필요한 옵션을 설정하는 데 사용된다. ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` 세 개의 백틱(```)과 중괄호({})가 있는 첫 번째 줄은 주의를 기울여야 한다. 이것은 문서에 R 코드를 포함할 수 있도록 Markdown 코드를 이스케이프하는 데 사용하는 표기법이다. 형식은 대략 세 개의 백틱, 여는 중괄호, 문자 r 다음에 몇 가지 옵션 그리고 끝 중괄호이다. 위 코드에서 setup은 단순히 레이블이고 include = FALSE는 코드가 실행되지만 R Markdown 출력에 표시되지 않음을 의미한다. 다음 몇 줄의 코드는 기본적인 Markdown이다. ## R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. 여기에서 데이터 분석에 대한 결과, 절차 그리고 설명을 작성한다. 시작 부분에 있는 두 개의 숫자 기호는 “제목 2”를 의미하며 형식화는 출력 문서에 이를 반영한다. 모든 일반 Markdown 기능을 사용할 수도 있다. Markdown의 작성자는 https://daringfireball.net/projects/markdown에 사용할 수 있는 서식 지정 기능을 문서화하고 있다. 나머지 코드는 또 다른 R 청크(chunk)이다. 이번에는 코드가 플롯을 생성하고 R Markdown 출력에 포함된다. ```{r cars} summary(cars) ``` 내장된 cars 데이터 세트의 요약이 출력된다. 다음에 다룰 예제에서 이것이 어떻게 보이는지 예제를 통해 살펴 볼 것이다. "],["r-markdown-예.html", "8.2 R Markdown 예", " 8.2 R Markdown 예 지금까지 수행한 작업 중 일부를 보고서에 추가하여 R Markdown을 살펴보기로 한다. 그 과정에서 R 스크립트 파일을 소싱하고 보고서에 그래픽을 삽입할 것이다. “life_expectancy.Rmd”라는 이름으로 만든 새 R Markdown 문서를 저장하여 시작하자. 템플릿에 제공된 상용구 소개를 우리의 작업에 대해 설명하는 것으로 대체하는 것으로 시작한다. ## 서론 [Life expectancy data] data.gov의 [다운로드](https://catalog.data.gov/dataset/nchs-death-rates-and-life-expectancy-at-birth-6db3e)사이트에서 데이터가 다운로드 되었다. 이 데이터 세트에는 1900 년부터 2015 년까지의 사망률과 기대 수명 통계가 포함되어 있다.이 데이터 세트에 대해 탐색적 분석을 수행하였는데, 이제 R Markdown의 출력 파일에 출력되는지 살펴 보겠다. R Markdown 문서 상단에 있는 메뉴 모음을 선택한 다음 “Knit”드롭 다운을 클릭한 다음 그림 8.4에 표시된대로 “Knit for HTML”을 선택합니다. 그림 8.4: HTML 출력 파일 만들기 이렇게 하면 R 및 Markdown 코드를 사용하고 R 패키지 knitr를 사용하여 그림 8.5와 같이 HTML 보고서를 만든다. 그림 8.5: R Markdown HTML 출력 이제 멋진 형식의 보고서를 시작했다. 물론, 우리는 여전히 cars 데이터 세트의 필터를 보여주고 있지만, 다음 단계에서 살펴보기로 한다. "],["r-markdown-재현성.html", "8.3 R Markdown 재현성", " 8.3 R Markdown 재현성 우리의 분석이 재현 가능하다고 말할 때, 우리는 보고서를 다시 실행해도 과거와 똑같은 결과를 얻을 수 있어야 함을 의미한다. 우리의 분석은 명령 줄에 입력 한 임의의 명령에 의존해서는 안된다. 분석이 재현 가능한지 확인하기 위해 source() 명령을 실행하고 expectancy 데이터 세트를 가져 오는 데 사용한 파일을 불러온다. r 코드 블록을 이것으로 바꾸고 데이터 세트의 요약을 포함한다. 위의 코드 블록에서 몇 가지 작업을 수행했다. 레이블을 “get_data”로 변경하고 소스를 사용하여 “process_data.R”에 저장된 모든 코드를 실행하고 expectancy 데이터 세트의 요약을 표시한다. Markdown 파일을 knit 하면 cars 데이터 세트 대신 expectancy 데이터 세트의 요약이 나타난다. 더 중요한 것은 R Markdown 문서의 다른 코드가 이전에 했던 것과 같은 방식으로 expectancy 데이터 세트에서 참조할 수 있다는 것이다. 이전에 따랐던 모든 데이터 처리 규칙은 새 출력 문서를 만들 때마다 실행된다. 데이터 시각화 장에서 했던 것처럼 사용자에게 데이터 세트를 간략하게 보여줄 수 있다. 마지막 부분에서 코드를 복사하여 다음과 같이 코드 블록으로 감쌀 수 있다. ## `expectancy` 데이터 세트 샘플 `expectancy` 데이터 세트의 일부 내용을 확인하기 위한 위젯을 아래와 같이 확인할 수 있다. 여기에서의 분석에서 나중에 검토될 데이터 세트를 보여주고 있다. ```{r} library(DT) datatable(expectancy, options = list(pageLength = 5)) ``` 여기서 우리는 그림 8.6에서 볼 수 있는 디스플레이를 생성하기 위해 r 코드 블록과 함께 Markdown 주석을 혼합한다. 그림 8.6: R Markdown 문서의 HTML 데이터 테이블 위젯 마지막으로, 수년에 걸친 기대 수명 플롯을 추가해 보자. 이번에는 사용자로부터 r 코드 블록을 숨기고 싶을 수 있으므로 이러한 두 가지 지시문 echo = FALSE와 message = FALSE를 포함한다. ## 기대 수명 플롯 아래의 플롯은 모든 성별에 대한 연도별 기대 수명을 보여주고 있다. ```{r} library(plotly) i_plot &lt;- expectancy %&gt;% filter(race == &quot;All Races&quot;) %&gt;% ggplot(aes(year, life_expectancy)) + geom_line(aes(color = sex)) ggplotly(i_plot) ``` 보다시피, 1900년부터 2015년까지 모든 사람의 기대 수명이 증가하였다. 여성은 남성보다 기대 수명이 더 길고 두 그룹의 차이를 유지하면서 동일한 상승 추세를 보이고 있다. 첫 번째 지시문은 코드가 표시되지 않도록 하고 두 번째 지시문은 문서에서 라이브러리를 로드하기 때문에 나타날 수있는 모든 메시지를 방지한다. 결과는 그림 8.7에 나와 있다. 그림 8.7: R Markdown 문서의 Plotly 위젯 "],["결론-6.html", "8.4 결론", " 8.4 결론 R Markdown은 강력한 보고서 생성 시스템을 제공한다. 이 장에서는 보고서 작성자가 사용할 수있는 기능에 대해 간략히 설명했다. 이는 조직 전체에서 공유 할 수 있는 분석을 개발할 때 보고 작업을 수행하는 도구가 된다. "],["Shiny-R-Dashboard.html", "Chapter 9 Shiny R 대시보드", " Chapter 9 Shiny R 대시보드 R Markdown 및 htmlwidgets는 팝 오버를 통해 풍부하고 대화형 경험을 할 수 있는 기능을 제공한다. 그러나 일부 사용 사례에는 이러한 유형의 정적 도구가 제공할 수있는 것보다 더 많은 것이 필요하다. 예를 들어 사용자가 분석에 사용할 매개 변수를 제공하거나 백엔드 데이터베이스에 연결하거나 사용자가 분석을 탐색할 때 새 R 스크립트를 실행하도록 요청해야 할 수 있다. RStudio에서 Shiny를 사용하여 R 시스템과 완전히 통합된 풍부한 기능을 가진 이러한 유형의 데이터 대시보드를 만들 수 있다. Shiny는 R에서 대화형 웹 앱을 만드는 데 사용되는 패키지이다. 이러한 앱은 RStudio 프로젝트에서 사용하거나 R Markdown 보고서에 추가하거나 웹 앱으로 온라인에 게시할 수 있다. Shiny는 이러한 앱을 개발하는 데 사용하기 쉬운 프레임워크를 제공하며, 자체 CSS 및 JavaScript 코드로 Shiny를 더욱 확장할 수 있다. "],["새로운-shiny-앱.html", "9.1 새로운 Shiny 앱", " 9.1 새로운 Shiny 앱 RStudio 프로젝트에 Shiny 앱을 추가하는 것은 매우 쉽다. RStudio 메뉴 모음으로 이동 한 다음 “File,” “New File,” “Shiny Web App…” 순으로 선택하면 된다. 그러면 그림 9.1과 같은 대화 상자가 나타난다. 그림 9.1: 새 Shiny 앱 앱의 이름을 지정하고 하나 또는 두 개의 파일에 코드를 넣을 것인지 선택할 수 있다. 웹 앱을 빌드하려면 “만들기” 버튼을 클릭한다. RStudio는 대화 상자에서 제공 한 이름으로 프로젝트에 새 폴더를 만든다. “Single File”을 선택하면 “app.R”이라는 새 파일이 나타나고 그림 9.2와 같이 편집기 보기에서 자동으로 열린다. 그림 9.2: app.R 콘텐츠 표시되는 코드는 RStudio가 시작점으로 생성하는 템플릿이다. 이것은 예제로 내장된 R의 데이터세트를 사용하는 작동하는 Shiny 앱이다. 웹앱을 실행하려면 그림 9-2와 같은“Run App” 버튼을 클릭한다. 그림 9.3과 같이 R에서 관리하는 로컬 웹 서버에서 앱이 실행되기 시작한다. 그림 9.3: 로컬에서 실행되는 Shiny 앱 이 히스토그램은 매우 상호작용적이며, 왼쪽의 슬라이더 컨트롤을 조정하면 오른쪽의 히스토그램을 다시 생성하기 위해 R 코드가 실행된다. 이것은 단순히 정적 보고서에 미리 적용된 팝 오버(popover)를 포함하는 것 이상의 단계이다. 그림 9-3의 맨 위에 http 주소와 “Open in Browser(브라우저에서 열기)” 버튼이 표시된다. 이 앱은 웹 서버에서 실행되므로 ‘Open in Browser(브라우저에서 열기)’ 버튼을 클릭하거나 브라우저의 주소 표시 줄에 http 주소를 입력하여 일반 브라우저를 사용하여 앱을 볼 수 있다. 오른쪽에 “Publish(게시)” 버튼이 있음을 알 수 있다. Shiny 앱은 누구나 사용할 수 있도록 웹 사이트에 게시된다. 이러한 앱은 RStudio가 제공하는 서비스를 통해 공개되거나 비즈니스에서 개인 서버를 관리 할 수 있다. 앱을 게시할 무료 계정을 얻으려면 Shiny 웹 사이트로 접속하여 가입하면 된다. "],["shiny-이해.html", "9.2 Shiny 이해", " 9.2 Shiny 이해 Shiny는 R 스크립트를 사용하고 웹에서 매우 쉽게 액세스할 수있는 대시보드를 만드는 데 사용할 수 있다. 그러나 대부분의 R 패키지와 마찬가지로 시스템에 훨씬 더 깊이 들어가 진정한 맞춤형 경험을 구축할 수 있다. 여기서는 Shiny의 좋은 시작점을 제공하기 위해 기본 사항에 대해 논의할 것이다.하지만이 패키지를 실제로 마스터하려면 https://shiny.rstudio.com/에서 자습서와 Shiny로 가능한 것을 보여주는 문서 등을 참고하기 바란다. Shiny 코드는 사용자 인터페이스와 서버라는 두 가지 책임 영역으로 구분된다. 이를 “프런트 엔드”와 “백 엔드”라고도 한다. 아이디어는 슬라이더 및 버튼과 같은 시각적 사용자 인터페이스 요소는 앱의 프런트 엔드 부분에 위치시키고, 숫자 크런칭 및 데이터 분석은 앱의 백 엔드 부분에 위치시키는 것이다. 생성한 코드에는 사용자 인터페이스와 서버가 모두 포함된 파일이 하나뿐이다. 또한 선택한 옵션이나 앱을 처음 코딩한 사람에 따라 이 두 구성 요소가 별도의 파일로 분리되어 표시된다. 9.2.1 사용자 인터페이스 사용자 인터페이스는 생성된 “app.R”파일에 코딩된 ui 개체에 포함되어 있다. ui 개체를 만드는 코드는 app.R 파일의 위쪽에 있다. ui &lt;- fluidPage( # Application title titlePanel(&quot;Old Faithful Geyser Data&quot;), # Sidebar with a slider input for number of bins sidebarLayout(sidebarPanel( sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, min = 1, max = 50, value = 30) ), # Show a plot of the generated distribution mainPanel( plotOutput(&quot;distPlot&quot;) ) ) ) 이 전체 코드 블록은 쉼표로 구분된 두 개의 매개 변수 titlePanel과 sidebarLayout로 호출되는 하나의 함수 fluidPage 이다 . 이 함수의 결과는 ui 개체에 할당된다. 이 ui 개체는 이 파일의 끝 부분에서 Shiny 앱을 시작하는 함수에 대한 매개 변수로 사용된다. 잠시 속도를 늦추고 위의 코드를 실제로 살펴보자. 이것은 아마도 코드 작성하는 방법과는 다를 것이다. 함수 이름에 사용된 단어는 무슨 일이 일어나고 있는지를 나타낸다. 잠깐 생각해 보면, 더 복잡한 것이 뒤 따르는 제목을 포함하는 페이지를 보게 될 것이라고 기대할 수 있다(지금은 무시한다). 그림 9-3에서 처음 보았던 “Old Faithful Geyser Data”라는 제목이 어디에서 오는지 명확하게 볼 수 있다. Shiny 프런트 엔드를 구축하기 위한 필수 프로세스는 다음과 같다. 앱에 무언가를 추가하려면 쉼표로 구분된 목록에 새 함수 호출을 포함한다. 예를 들어, Old Faithful이 무엇인지 설명하기 위해 HTML 단락을 추가하려면 titlePanel 바로 뒤에있는 공간에 p 함수를 추가 할 수 있다. # Define UI for application that draws a histogram ui &lt;- fluidPage( # Application title titlePanel(&quot;Old Faithful Geyser Data&quot;), p(&quot;Old Faithful is a cone geyser located in Yellowstone National Park in Wyoming, United States. It was named in 1870 during the Washburn-Langford-Doane Expedition. Wikipedia 2019.&quot;), 결과는 그림 9.4에서 볼 수있는 웹 앱이 된다. 본질적으로 동일한 앱이지만 이제 일부 텍스트 컨텍스트가 포함된다. 그림 9.4: Shiny 앱에 단락 추가 앱을 구축할 때 페이지에 조각을 계속 추가한다. 일부 함수는 p 함수와 같은 간단한 HTML 구성 요소이고 일부는 Shiny에만 해당된다. 종종 앱의 레이아웃을 정의하기 위해 다른 개체 내에 중첩된 개체를 찾는다. 쉼표로 구분된 목록에 매개 변수로 나타나는 두 개의 다른 개체로 구성된 전체 fluidPage의 개체인 sidebarLayout에서 이를 확인할 수 있다. # Sidebar with a slider input for number of bins sidebarLayout( sidebarPanel( sliderInput(&quot;bins&quot; , &quot;Number of bins:&quot; , min = 1, max = 50, value = 30) ), # Show a plot of the generated distribution mainPanel( plotOutput(&quot;distPlot&quot;) ) ) 위의 두 구성 요소는 sidebarPanel과 mainPanel 이다. sidebarPanel에는 사용자가 시각화를 제어하는 데 사용할 슬라이더를 정의하는 또 다른 중첩 개체 sliderInput이 포함되어 있다. 첫 번째 매개 변수 값 bin을 inputID라고하며 웹 앱의 서버 백엔드에서 구성 요소를 식별하는 데 사용된다. mainPanel에는 그래픽을 표시하는 개체인 plotOutput이 포함된다. plotOutput에서 매개 변수는 inputID로 사용되므로 서버 구성 요소가이 개체를 식별할 수 있으므로 강조 표시된다. 결론적으로, ui 객체는 이제 제목을 표시하는 개체를 포함한다. 제목, 단락, 슬라이더 컨트롤, 플롯 그리고 레이아웃 등을 적용하기 위한 기타의 개체들 등을 표시하는 개체들을 포함한다. 개체들 중 슬라이더와 플롯 등의 두 개체는 서버가 슬라이더에서 값을 검색하고 그래픽을 표시할 위치를 알 수 있도록 inputID 매개 변수도 포함하고 있다. 9.2.2 서버 서버 구성 요소는 백 엔드의 무거운 작업을 처리한다. 이 예에서 서버는 분석을 수행하고 플롯을 생성하는 R 코드를 실행하기 위해 사용자 인터페이스에서 사용자가 정의한 매개 변수를 수집한다. inputID는 입력과 출력 구성 요소를 모두 식별하는 데 사용된다. 다음은 입력과 출력이 강조 표시된 서버 코드이다. # Define server logic required to draw a histogram server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ # generate bins based on input$bins from ui.R x &lt;- faithful[, 2] bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) # draw the histogram with the specified # number of bins hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) } 위의 코드에서 서버 객체에 익명 함수를 할당하고 있다. 이러한 기능은 위의 사용자 인터페이스에서 수행한 것과 약간 다르다. 사용자 인터페이스에서는 단순히 함수 호출의 결과를 ui 개체에 할당하고 여기서는 익명 함수 형태의 명령 집합을 서버 개체에 할당한다. 이러한 지침은 사용자 인터페이스의 활동에 응답하는 데 사용된다. 굵게 표시된 코드는 서버가 사용자 인터페이스에 연결하는 후크이다. 모든 것은 익명 함수의 입력과 출력 매개 변수에서 참조된다. 입력에는 사용자 인터페이스의 모든 입력 구성 요소에 대한 참조가 포함되고, 출력에는 사용자 인터페이스의 모든 출력 구성 요소에 대한 참조가 포함된다. 달러 기호($)가 따라오는 input 개체와 input 개체의 입력 요소인 $bins의 inputID를 사용하여 입력 구성 요소를 참조한다. “bins”는 슬라이더 개체에 지정된 식별자였다는 것은 기억하는가? input$bins는 사용자가 선택한 현재 값을 반환한다. 여기서 output 개체는 위의 renderPlot 함수에 의해 생성된 모든 코드를 가져온다. 함수의 매개 변수 output$distPlot을 사용하여 유사한 방식으로 이 출력 구성 요소를 참조하는 것을 볼 수 있다. 사용자 입력이 어떻게 수집되고, renderPlot 함수에 포함된 코드 줄에 플롯이 어떻게 푯되는지 알 수 있다. 9.2.3 앱 Shiny가 웹 앱을 만들기 전에 해야 할 일이 하나 더 있다. ui와 서버 구성 요소를 연결한 다음 이 코드로 shinyApp(ui = ui, server = server)를 실행해야 한다. 이것은 상용구 코드로 포함되어 있으며 사용자 인터페이스 및 서버 개체의 이름을 변경하지 않는 한 이 코드를 전혀 건드리지 않아도 된다. 하지만 이 코드의 위치와 이 코드가 앱 인스턴스를 시작한다는 사실을 아는 것은 중요하다. "],["shiny-앱-사용자-지정.html", "9.3 Shiny 앱 사용자 지정", " 9.3 Shiny 앱 사용자 지정 이 상용구 코드를 분석에 적합한 것으로 변경해 보자. 지금은 사용자 인터페이스를 약간 조정하고 데이터 세트를 구축하는 대신 데이터를 표시해 보기로 한다. 가장 먼저해야 할 일은 데이터 세트를 Shiny 폴더에 복사하여 향후 모든 자산과 함께 배포할 수 있도록 하는 것이다. R 명령 줄에서 다음 코드를 사용하여 데이터 세트를 Shiny 앱 폴더에 rdata 파일로 저장한다. save(expectancy, file = &quot;life_expectancy_web_app/expectancy.rdata&quot;) 이제 앱이 시작될 때 이것을 Shiny 세션에 로드할 수 있다. Shiny app.R파일 상단에 코드를 넣어 데이터 세트를 불러온다. load(&quot;expectancy.rdata&quot;) expectancy &lt;- expectancy %&gt;% filter(!is.na(life_expectancy)) 이렇게 하면 데이터 세트가 로드된 다음 히스토그램을 방해하는 결측치(missing values)가 제거된다. 이제 우리는 서버 구성 요소에서 한 줄의 코드를 변경하여 데이터 세트를 검토할 수 있다. server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ # generate bins based on # input$bins from ui.R x &lt;- expectancy$life_expectancy bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) # draw the histogram with the # specified number of bins hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) } 이를 테스트하기 전에 제목 설명을 변경하고 플롯에 자체 색상을 추가해 보겠다. 이러한 변경을 수행할 위치를 짐작할 수 있다. 아래 코드에서 모든 변경 사항은 굵게 강조 표시된다. library(shiny) library(tidyverse) load(&quot;expectancy.rdata&quot;) expectancy &lt;- expectancy %&gt;% filter(!is.na(life_expectancy)) # Define UI for application that draws a histogram ui &lt;- fluidPage( # Application title titlePanel(&quot;Life Expectancy Data&quot;), p(&quot;Life expectancy data was downloaded from data.gov. This dataset contains death rates and life-expectancy statistics from 1900 to 2015. Exploratory analysis was conducted on this dataset. In the visualization below, you can see all life expectancy rates in the dataset and adjust the number of bins used to present the frequency. &quot;), # Sidebar with a slider input for number of bins sidebarLayout( sidebarPanel( sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, min = 1, max = 50, value = 30) ), # Show a plot of the generated distribution mainPanel( plotOutput(&quot;distPlot&quot;) ) ) ) # Define server logic required to draw # a histogram server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ # generate bins based on # input$bins from ui.R life_expectancy &lt;- expectancy$life_expectancy bins &lt;- seq(min(life_expectancy), max(life_expectancy), length.out = input$bins + 1) # draw the histogram with the # specified number of bins hist(life_expectancy, breaks = bins, col = &#39;lightblue&#39;, border = &#39;white&#39;) }) } # Run the application shinyApp(ui = ui, server = server) 이제 이 코드를 실행하면 앱이 그림 9.5에 표시된 것과 비슷해진다. 그림 9.5: 기대 수명 Shiny 앱 이제 컨텍스트가 관련성이 있으며 히스토그램에서 막대의 색상도 조정했다. 다음 URL로 이동하면 작성자의 shiny.io 페이지에 게시된 버전을 볼 수 있다. "],["결론-7.html", "9.4 결론", " 9.4 결론 이 장에서 우리는 Shiny를 소개했고 이 도구로 우리가 달성할 수있는 것에 대하여 대략적으로 살펴 보았다. Shiny는 웹 개발에 대한 특정 배경 없이도 데이터가 풍부한 앱을 웹에 직접 배포할 수있는 경로를 만든다. 즉, Shiny는 매우 풍부한 패키지이며 JavaScript를 사용하지 않아도 데이터 웹 앱 작업에 많은 시간을 할애할 수 있다. 시간을 내어 기본 사항을 배우고 https://shiny.rstudio.com의 예제 코드로 이 장의 패턴을 따라 해 보기 바란다. 익숙한 데이터로 작업할 수있는 흥미로운 예를 찾고 코드를 조정하여 자신 만의 시각화를 만들어 보기 바란다. 이 작업을 수행하고 패턴을 배우면 이제 통계 프로그래밍과 데이터 분석을 위해 Shiny 앱을 배포하는 것이 두 번째 특징이 될 것이다. "],["Custom-R-Package.html", "Chapter 10 R 패키지 만들기", " Chapter 10 R 패키지 만들기 핵심 R 언어에 중요한 기능을 추가하는 광범위한 제3자 패키지 라이브러리로 인해 데이터 분야에서 인기를 얻었다. 우리는 tidyverse 패키지를 사용하여 R 사용 경험을 어떻게 변화시킬 수 있는지 이미 알아 보았다. 많은 데이터 문제가 이미 해결되었으며 R 프로그래머는 이러한 솔루션을 누구나 사용할 수 있도록 한다. 실제로 많은 데이터 프로젝트는 당면한 문제를 해결하는 이미 존재하는 R 패키지를 검색하는 것으로 시작된다. 이 장에서는 자체 팀을 위해 또는 광범위한 세계에 배포하기 위해 자체 R 패키지를 만드는 방법에 대해 설명한다. "],["사용자-지정-r-패키지-사용-사례.html", "10.1 사용자 지정 R 패키지 사용 사례", " 10.1 사용자 지정 R 패키지 사용 사례 왜 우리 자신의 패키지를 만들어야 하는가? 패키지를 만드는 분명한 이유는 우리의 작업을 세상과 공유하기 위해서이다. R에서 해결되고 일반적으로 유용한 방식으로 코딩할 수있는 문제는 패키지에 적합한 후보이니다. 자신의 팀이나 자신의 프로젝트에만 실제로 적용되는 패키지를 만들 수도 있다. 그 이유는 패키지 형식으로 코딩하면 코드 재사용과 프로세스 효율성이 향상되기 때문이다. 특히 유사한 상황이 발생하는 경우 패키지를 사용하여 동료를 위해 데이터와 코드를 함께 묶을 수 있다. 마지막으로 R 패키지는 작업에서 복잡한 자료를 전달하는 방법을 제공하는 내장 문서 도구와 함께 제공된다. 모든 코드가 패키지에 속하는 것은 아니므로 애드혹 분석을 패키지로 전환할 때 약간의 판단을 내려야 한다. 일반적으로 R 패키지 형식일 때는 코드를 반복하고 테스트하는 것이 더 어렵기 때문에 일반적으로 유지 관리 모드가 될 때까지 기다렸다가 함수 집합을 패키지로 패키지화하는 것이 가장 좋다. 이 장에서는 이전 몇 장에서 수행한 작업을 기반으로 패키지를 만들어 본다. 이 작업을 위해 RStudio를 사용하여 새로운 프로젝트를 만든 다음 패키지의 기능을 선택적으로 가져오기로 한다. "],["새-사용자-지정-r-패키지-만들기.html", "10.2 새 사용자 지정 R 패키지 만들기", " 10.2 새 사용자 지정 R 패키지 만들기 RStudio에는 패키지 생성에 대한 지원이 내장되어 있다. RStudio 메뉴 모음으로 이동한 다음 “File,” “New Project,” “New Directory,” “R Package”를 차례로 선택한다. 그러면 그림 10.1과 같은 대화 상자가 나타난다. 그림 10.1: R 패키지 생성 대화 상자 패키지 이름을 추가하고 패키지를 생성할 디렉토리를 지정할 수 있다. “Create Project(프로젝트 생성)” 버튼을 클릭하여 R 패키지 프로젝트를 생성한다. 가이드로 따를 수있는 템플릿 파일 세트가 폴더에 있다. 키 파일은 “R” 폴더의 “hello.R”이고, “man”폴더의 “DESCRIPTION”과 “hello.Rd”이다. 이하에서 각각에 대해 살펴 보기로 한다. 10.2.1 hello.R 게시하려는 모든 코드는 “hello.R”과 마찬가지로 “R” 폴더에 있어야 한/다. 이 파일은 R 패키지 프로젝트를 생성할 때 열리고 다음과 같은 내용을 볼 수 있다. # Hello, world! # # This is an example function named &#39;hello&#39; # which prints &#39;Hello, world!&#39;. # # You can learn more about package authoring with # RStudio at: # # http://r-pkgs.had.co.nz/ # # Some useful keyboard shortcuts for package # authoring: # # Install Package: &#39;Cmd + Shift + B&#39; # Check Package: &#39;Cmd + Shift + E&#39; # Test Package: &#39;Cmd + Shift + T&#39; hello &lt;- function() { print(&quot;Hello, world!&quot;) } 이것은 매우 간단하지만 R 패키지 구축 프로세스가 어떻게 작동하는지 보여주기에 충분하다. 게시할 기능을 여기에 배치하여 사용 가능하게 할 수 있다. “R” 폴더에 기능 당 하나의 파일을 포함하는 것이 좋다. 10.2.2 설명서 “DESCRIPTION” 파일은 패키지에 대한 메타 데이터를 제공한다. 여기에서 제목, 설명, 버전 그리고 연락처 정보를 문서화한다. 파일을 클릭하여 열고 필드를 R 패키지에 대한 정보로 바꾼다. Package: life Type: Package Title: Shows Life Expectancy Trends Since 1900 Version: 0.1.0 Author: Dae Ho Kim Maintainer: KIM &lt;mis@mokwon.ac.kr&gt; Description: Includes datasets and helper functions to help present information on life expectancy rates. License: None Encoding: UTF-8 LazyData: true RoxygenNote: 7.1.1 데모를 따라하기 위해 이를 변경할 필요는 없지만 게시할 준비가되면 이러한 필드에 관련 정보가 포함되어 있는지 확인해야 한다. 10.2.3 hello.Rd “hello.Rd”는 R 문서 파일이다. 이 파일은 함수에 포함된 문서를 기반으로 자동 생성된다. 아래에서 코드 문서화에 대해 자세히 설명하겠다. 여기에 있는 정보는 “도움말” 창에서 읽은 패키지 설명서에 나타난다. 제목은 또한 RStudio에서 코드 완성의 일부로 표시되므로 코드 줄을 입력 할 때 콘텐츠가 편집기 화면에 바로 표시된다. 이는 팀의 다른 분석가가 필요할 때 바로 컨텍스트를 제공하는 매우 편리한 방법이다. 이 모든 것이 어떻게 작동하는지 볼 수 있도록 R 패키지를 구축해 보기로 한다. "],["r-패키지-구축.html", "10.3 R 패키지 구축", " 10.3 R 패키지 구축 R 패키지 프로젝트로 작업할 때 오른쪽 상단 보기에 “Build”라는 추가 탭이 있다. 이 탭은 R 패키지 구축과 관련된 몇 가지 옵션을 제공한다. 이 탭으로 이동한 다음 그림 10.2와 같이 “More”를 클릭한 다음 “Clean and Rebuild”를 클릭한다. 그림 10.2: Build 보기 그러면 코드가 구축되고 패키징된다. 필요하지만 설치되지 않은 필수 라이브러리가 있는 경우 RStudio는 지금 설치하라는 메시지를 표시한다. 대화 상자 마법사를 따라 필요한 패키지를 설치해 준다. 이제 패키지를 구축하고 설치했으므로 다음과 같은 기능을 사용할 수 있다. library(life) hello() 이 간단한 코드는 콘솔에 “Hello, world!”를 출력한다. 이 함수의 동작을 변경하려면 “hello.R” 파일의 코드를 변경한 다음 패키지를 다시 구축하면된다. 계속해서 이 기능을 변경하고 결과를 확인하기 바란다. 다른 RStudio 프로젝트에서 동일한 방식으로 이러한 기능을 사용할 수도 있다. 이것이 R 패키지가 코드 재사용을 장려하는 방법이다. R 패키지를 좀 더 보여주기 위해 기대 수명 분석의 일부 기능을 추가해 보기로 한다. "],["r-패키지-문서화.html", "10.4 R 패키지 문서화", " 10.4 R 패키지 문서화 roxygen2 패키지를 사용하여 R 패키지에 주석을 포함할 수 있다. 먼저 다음 명령을 사용하여 패키지를 설치해야 한다. install.packages(\"roxygen2\"). 그러면 필요한 지원 패키지와 함께 roxygen2 라이브러리가 설치된다. 다음 단계는 구축 도구를 구성하는 것이다. 메뉴의 “Build”로 이동한 다음 “Configure Build Tools…”를 선택한다. 그러면 그림 10.3과 같은 대화 상자가 나타난다. 그림 10.3: 빌드 도구 구성 “Generate documentation with Roxygen(Roxygen으로 문서 생성)” 확인란을 클릭한다. 그런 다음 “Configure(구성)…” 버튼을 클릭하면 그림 10.4와 같은 대화 상자가 나타난다. 그림 10.4: Roxygen 빌드 옵션 “Install and Restart(설치 및 다시 시작)” 확인란을 확인하라. 이제 R 패키지를 구축할 때 제공하는 필드를 기반으로 문서가 자동으로 생성된다. 백틱 # ’을 포함하는 특수 주석이 있는 문서를 포함한다. 각 필드 이름은 @로 시작한다. 몇 가지 일반적인 필드 유형에는 @name, @title 그리고 @description이 있다. 예를 들어 다음은 hello 함수 문서에 포함할 수있는 내용이다. # Hello, world! # # This is an example function named &#39;hello&#39; # which prints Hey there!. # #&#39; @name hello #&#39; @aliases hello #&#39; @title Hello World #&#39; @usage hello() #&#39; @description Prints &#39;Hey there!&#39; #&#39; @examples hello() hello &lt;- function() { print(&quot;Hey there!&quot;) } 이제 R 패키지를 구축할 때 도움말 문서에 그림 10.5에 표시된 대로 위에 포함된 내용이 반영된다. 그림 10.5: 사용자 지정 도움말 문서 도움말 파일에서 hello world 메시지가 함수에서 변경되었음을 반영하도록 설명 필드를 변경했다. "],["r-패키지에-데이터-세트-추가.html", "10.5 R 패키지에 데이터 세트 추가", " 10.5 R 패키지에 데이터 세트 추가 패키지에 데이터 세트와 함수를 포함할 수 있다. R 패키지에 “data” 폴더를 추가한 다음 데이터 세트를 해당 폴더에 저장하기만 하면 된다. 이러한 데이터 세트는 R 데이터 프레임 또는 모든 유형의 원시 데이터 파일 일 수 있다. 기대 수명 프로젝트의 경우 data.gov 웹 사이트에서 다운로드 한 csv 파일이 포함된 데이터 폴더를 복사하였다. 그런 다음 이 코드를 사용하여 이 데이터 세트를 R 데이터 프레임으로 저장했다. library(readr) life_expectancy &lt;- read_csv(&quot;data/NCHS_-_Death_rates_and_life_expectancy_at_birth.csv&quot;) # Clean up dataframe # Use shorter column names names(life_expectancy)[1] &lt;- &quot;year&quot; names(life_expectancy)[2] &lt;- &quot;race&quot; names(life_expectancy)[3] &lt;- &quot;sex&quot; names(life_expectancy)[4] &lt;- &quot;life_expectancy&quot; names(life_expectancy)[5] &lt;- &quot;death_rate&quot; save(life_expectancy, file =&quot;data/life_expectancy.rdata&quot;) 다음으로, 빌드보기에서 “Clean and Rebuild”를 클릭하여 life 패키지를 다시 구축해 보자. 이 프로세스가 완료되면 모든 RStudio 프로젝트에서이 코드를 사용하여 데이터 세트에 액세스할 수 있다. library(life) head(life_expectancy) 이것은 이 데이터 세트의 시작을 보여줄 것이며 더 중요한 것은 기대 수명 분석을 다시 실행하지 않고도 모든 분석에서이 코드를 사용할 수 있다는 것이다. "],["코드-완성.html", "10.6 코드 완성", " 10.6 코드 완성 RStudio에 코드를 입력할 때 코드를 입력하는 순간마다 매 코드 제안이 팝업되는 것을 볼 수 있다. RStudio 패키지의 코드도이 패턴을 따른다. 또한 그림 10.6과 같이 패키지 이름과 세미콜론 두 개를 입력하면 어떤 데이터와 기능을 사용할 수 있는지 빠르게 확인할 수 있다. 그림 10.6: 패키지 코드 완성 위의 코드에서 우리는 life::를 입력했다. 이것은 life 패키지에 속한 모든 콘텐츠를 필터링하는 방법이다. R 패키지에 대해 이 작업을 수행하여 어떤 패키지에 어떤 함수가 포함되어 있는지 확인할 수 있다. 도움말 문서의 설명 필드는 도구 설명으로 입력할 때도 표시된다. 최종적인 life 패키지의 폴더 구조를 보면 다음의 그림 10.7과 같다. 그림 10.7: [life 패키지의 폴더 구조 "],["결론-8.html", "10.7 결론", " 10.7 결론 이 장에서는 사용자 지정 R 패키지를 만들어 우리 팀과 그 이상으로 작업을 공유하는 방법에 대해 설명했다. R 패키지는 코드 재사용을 장려하고 작업을 문서화하고 패키징하는 수단을 제공하여 코드 수명을 자체 프로젝트 이상으로 연장할 수있는 좋은 방법이다. "],["Code-Tools.html", "Chapter 11 코드 도구", " Chapter 11 코드 도구 RStudio에는 코드를 작성하고, 디버그하고, 추적하는 데 도움이 되는 도구가 포함되어 있다. 코드 완성, 구문 강조 그리고 도구 설명과 같이 RStudio 편집기에 바로 딸려 있는 코드 도구를 이미 살펴 보았다. 또한 코드 파일의 버전을 추적하는 데 도움이 되는 git 지원, 코드 편집에 도움이되는 리팩토링 지원, 단계별 코드 검사에 도움이되는 디버깅 도구를 포함 할 수도 있다. "],["소스-제어-통합.html", "11.1 소스 제어 통합", " 11.1 소스 제어 통합 소스 제어는 코드 파일의 변경 사항을 추적하는 데 사용할 수 있는 시스템이다. RStudio는 두 가지 소스 제어 공급자(subversion 및 git)와의 통합을 지원한다. 둘 다 코드 버전을 통해 변경한 내용을 추적하는 필수 기능을 제공한다. 이미 소스 제어를 사용하고 있다면 RStudio가 제공하는 통합에 감사할 것이다. 그러나 소스 제어가 워크 플로의 일부가 아니었다면 소스 제어의 가치가 즉시 명확하지 않을 수 있다. 소스 제어를 사용하는 것이 가장 좋은 방법이지만 모든 프로젝트의 필수 기능은 아니다. 그래도이를 워크플로에 추가하는 것이 좋다. "],["git-설정.html", "11.2 Git 설정", " 11.2 Git 설정 이 장에서는 우리가 사용하고 있는 git을 사용하고 있어서, 이미 컴퓨터에 이 시스템이 설치되어 있다고 가정 할 것이다. 그렇지 않은 경우 제1장을 참조하여 git을 설치하기 바란다. RStudio가 소스 제어를 사용하는 방법을 알고 있는지 확인하는 데 필요한 몇 가지 단계가 있다. RStudio의 기본 설정 영역에서 git을 사용하고 있음을 표시해야 한다. RStudio 메뉴 표시 줄로 이동하여 “Tools”의 “Global Options…”를 선택하여 그림 11.1에 나타나는 대화 상자를 가져온다. 그림 11.1: 설치 버전 관리 “Enable version control interface for RStudio projects(RStudio 프로젝트에 대한 버전 제어 인터페이스 사용)” 상자를 선택하고, git 설치 경로를 제공했는지 확인하라. 이 경로는 컴퓨터와 git 설치 위치에 따라 다를 수 있다. 표시된 경로는 Windows 용 폴더가 설치하는 기본값이다. "],["git-저장소에-프로젝트-추가.html", "11.3 Git 저장소에 프로젝트 추가", " 11.3 Git 저장소에 프로젝트 추가 프로젝트에 git을 추가하려면 RStudio에서 “Terminal” 탭을 클릭하여 터미널을 사용해야 한다. 그런 다음 git init 명령을 입력하고 Return을 누른다. 그러면 프로젝트가 있는 폴더에 새 git 저장소가 생성된다. 이와 같이 ’Terminal’에서 git을 사용하거나 통합된 RStudio 도구를 사용하면 된다. 여기에서는 이 폴더의 파일을 새 git 저장소에 추가한 다음 commit 해 보겠다. git add . git commit -m &quot;initial commit&quot; 이 두 명령은 모든 파일을 저장소에 추가한 다음 “initial commit” 메시지와 함께 commit 한다. "],["git-뷰어.html", "11.4 Git 뷰어", " 11.4 Git 뷰어 이제 그림 11.2와 같이 git 통합 뷰어가 나타나는 것을 볼 수 있도록 RStudio를 다시 시작해야 한다. 그림 11.2: git 통합 뷰어 코드 파일을 변경하면 파일이 이 창에 나타난다. 예를 들어, “process_data.R” 파일의 일부를 변경하기로 결정한 경우 그림 11.3과 같이 소스 제어 뷰어 업데이트가 이를 반영하는 것을 볼 수 있다. 그림 11.3: 저장소의 버전 관리 뷰어 이제 git 뷰어에 두 개의 파일이 나타나는 것을 볼 수 있다. “process_data.R”이 나타날 것으로 예상했지만 긴 파일 경로 이름을 가진 두 번째 파일은 나타나지 않았다. 이 두 파일 옆에 있는 파란색 “M” 아이콘은 해당 파일이 수정(modified)되었음을 의미한다. 첫 번째 파일의 변경 사항을 살펴 보면 그림 11.4과 같다. 그림 11.4: 저장소에 수정된 파일 "],["git-diff-뷰어.html", "11.5 Git Diff 뷰어", " 11.5 Git Diff 뷰어 각 파일 옆에 있는 확인 란을 클릭한 다음 뷰어의 왼쪽 상단 영역에 있는 “Diff” 버튼을 클릭한다. 그러면 그림 11.5에 표시된 것과 같은 새 화면이 나타난다. 그림 11.5: Diff 화면 이 화면에 파일의 차이점(변경사항)이 표시된다. 공백은 두 파일에 있는 내용을 표시한다. 빨간색 공간은 파일의 이전 버전 (삭제 예정)에 있는 내용을 나타내고, 녹색 내용은 파일에 새로 추가된 내용을 나타낸다. 변경된 두 파일 사이를 탐색하려면 왼쪽 상단 영역의 목록을 사용한다. 다른 파일을 살펴보면 변경 사항이 그다지 중요하지 않고 무시할 수 있는 코드 편집기의 상태와 관련이 있음을 알 수 있다(잠시 파일을 무시하는 방법을 살펴 보겠다). 그림 11.6과 같이 맨 위에 있는 “History” 버튼을 클릭하면 작업을 시작한 이후 이 파일에 대한 모든 변경 기록을 볼 수 있다. 워크 플로의 이 시점에서 이러한 변경 사항을 제거하거나 저장소에 변경 사항을 commit할 수 있다. 그림 11.6: History 화면 "],["변경-사항-커밋하기.html", "11.6 변경 사항 커밋하기", " 11.6 변경 사항 커밋하기 변경 사항을 커밋하려면 화면의 오른쪽 상단에 “commit message(커밋 메시지)”를 입력한 다음, 그림 11.7과 같이 “commit” 버튼을 클릭한다. 기존의 커밋 메시지를 이용하려면 “Amend previous commit”을 선택해 주고, “commit” 버튼을 클릭한다. 그림 11.7: 저장소에 변경 사항 커밋 그러면 커밋된 사항에 대한 정보를 보여주는 “Git Commit” 창이 그림 11.8과 같이 나타난다. 그림 11.8: 변경 사항 확인 이때, “Commit” 버튼 대신 “Revert” 버튼을 클릭하여 변경 사항을 취소할 수도 있다. "],["git-브랜치.html", "11.7 Git 브랜치", " 11.7 Git 브랜치 Git은 브랜치(branch)를 지원한다. 원래 코드에 영향을 주지 않고 새 기능을 테스트할 수 있도록 프로젝트 복사본을 변경하려는 경우 브랜치를 만들 수 있다. 브랜치에서 작업한 다음 나중에 새 기능을 유지하기로 결정한 경우 브랜치를 원래 프로젝트에 “병합(merge)”할 수 있다. 새 브랜치의 이름은 원하는대로 지정할 수 있으며 작업 중인 기능이나 버그의 이름을 사용할 수 있다. 원래 소스 브랜치의 이름은 “master(마스터)”이다. 일반적으로 따르는 git 워크 플로는 마스터 브랜치에서 새 브랜치를 만들고, 새 브랜치에서 작업하며 새 브랜치가 요구 사항을 충족하면 마스터 브랜치로 다시 병합하는 것이다. RStudio에는 새 브랜치 생성 및 브랜치 간 전환 지원이 포함되어 있다. 그림 11.9에서 강조 표시된 버튼을 사용하여 새 브랜치를 추가하고 브랜치를 바꿀 수 있다. 그림 11.9: git 브랜치 관리 : 브랜치 추가 첫 번째 버튼은 브랜치를 만드는 데 사용되고, 두 번째는 브랜치를 전환하는 데 사용된다. 브랜치를 전환하면 프로젝트의 모든 코드가 브랜치의 코드로 대체된다. “Diff” 버튼을 클릭한 다음 “History”버튼을 클릭하여, “History”버튼 옆의 공간에서 “(all branch)”를 선택하여 저장소의 모든 브랜치에 대한 그림을 얻을 수 있다. 그림 11.10에는 마스터 브랜치와 “new_features” 브랜치가 있는 프로젝트의 예가 나와 있다. 그림 11.10: Git 브랜치 이 도구를 사용하여 브랜치의 차이점을 탐색하고, 시각화하고, 프로젝트의 변경 내역을 볼 수 있다. RStudio는 모든 git 기능을 지원하지는 않는다. 브랜치를 삭제하거나 브랜치를 병합하려면 Terminal 탭을 사용하여 적절한 명령을 찾아서 실행해야 한다. "],["디버거.html", "11.8 디버거", " 11.8 디버거 디버깅은 코드의 결함을 식별하고 수정하는 프로세스이다. 디버깅하는 가장 간단한 방법은 단순히 “Console” 화면에 개체 값을 출력하는 것이다. 그러나 이는 각 코드 줄이 실행될 때 분석 상태가 변경되면서 실망할 수 있다. 이 문제를 해결하기 위해 RStudio에는 코드 실행을 중지하고 개체 값을 검사할 기회를 제공하는 중단 점(breakpoints)을 설정할 수있는 기본 제공 도구가 있다. 중단 점을 설정하고 디버거를 사용하여 디버깅을 한다. 코드 파일을 열고 R을 중지할 코드 줄의 왼쪽 영역을 클릭하면 된다. 이 영역을 거터(gutter)라고 하며 그림 11.11에서 볼 수 있다. 그림 11.11: 중단 점 설정 코드의 8 줄 옆에 있는 빨간색 점이 중단 점이다. 콘솔에서 debugSource(“debugger_deom.R”) 명령을 이용하여 이 코드를 실행하면 RStudio는 이 코드 줄에서 멈추고 그림 11.12에 표시된 것처럼 코드 디버거를 표시한다. 그림 11.12: 주요 디버거 기능 그림 11.12에서 모든 디버거 기능을 볼 수 있다. 왼쪽 중간 영역에는 코드 실행을 제어하는 데 사용할 수있는 일련의 컨트롤이 있다. 이제 중단 점에서 중지되었으므로 다음 줄로 진행하거나 다음 중단 점까지 모든 코드를 계속하거나 코드 실행을 중지 할 수 있다. 화면 하단에서 콘솔을 사용하여 프로젝트의 현재 상태를 검사하는 코드를 작성할 수 있다. 이것은 코드 결함에 대한 아이디어를 테스트할 때 유용한 기능이다. 또한 환경에 있는 모든 개체의 값을 볼 수 있는 환경 화면이 맨 위에 있다. RStudio “Debug(디버그)” 메뉴로 이동하여 디버깅을 위한 몇 가지 추가 옵션을 설정할 수 있다. 특히 처음 두 옵션인 Toggle Breakpoint와 Clear All Breakpoints...는 중단 점을 전환하고 지우는데 유용한다. "],["더-많은-코드-도구.html", "11.9 더 많은 코드 도구", " 11.9 더 많은 코드 도구 RStudio에는 코드 편집 및 리팩토링을 조금 더 쉽게 할 수 있는 몇 가지 도구가 더 있다. 코드 리팩토링은 작업 중인 프로젝트가 있지만 코드를 약간 정리하고 싶을 때 하는 것이다. 함수 이름을 변경하거나 코드를 들여 쓰거나 코드 영역을 다시 실행할 수 있는 함수로 추출할 수 있다. RStudio 헤더로 이동하여 “Code(코드)” 메뉴 항목을 선택하여 코드 리팩터링에 도움이되는 모든 옵션을 확인한다. 한 가지 핵심 항목은 “Rename in Scope(범위에서 이름 변경)” 기능으로, 개체를 강조 표시한 다음 메뉴를 선택하여 사용한다. 이 시점에서 개체에 대한 모든 편집 내용은 코드 파일에서 이 개체의 모든 모양에 반영된다. 줄을 다시 들여쓰고(Reindent Lines), 코드 형식을 다시 지정(Reformat Code)하는 옵션을 통해 코드를 체계적으로 보이게 할 수도 있다. 호출된 함수가 있지만 정의된 위치를 기억할 수 없을 때 Go To Function Definition(함수 정의로 이동)을 사용하면 코드 탐색이 훨씬 쉽다. "],["결론-9.html", "11.10 결론", " 11.10 결론 이 장에서는 코드를 구성하고 유지 관리하는 데 도움이 되는 RStudio와 함께 제공되는 몇 가지 기본 제공 도구를 소개하였다. Git은 코드 버전의 차이점을 구성하고 확인하는 데 사용된다. 디버거를 사용하여 코드를 단계별로 진행하면서 프로그램 상태를 관찰하여 버그를 수정할 수 있다. 마지막으로 코드 메뉴는 코드를 빠르게 다시 포맷하는 데 사용할 수있는 유틸리티 목록을 제공한다. "],["R-Programming.html", "Chapter 12 R 프로그래밍", " Chapter 12 R 프로그래밍 이 마지막 장에서는 R 프로그래밍을 수행하기 위해 알아야하는 기본 개념에 대해 살펴 보겠다. 이 튜토리얼은 포괄적이거나 프로그래밍을 처음 하는 것을 의미하지 않는다. 그러나 이전에 프로그래밍한 적이 있다면 R에서 시작하기에 충분한 정보를 제공할 것이다. 프로그래밍에 완전히 익숙하지 않은 독자는 아마도 Data Camp 또는 Coursera를 사용하여이 주제에 대한 집중 과정을 수강하는 것을 고려할 수 있다. "],["개체.html", "12.1 개체", " 12.1 개체 R의 모든 것은 개체이다. 개체는 숫자의 목록, 함수, 플롯 또는 분석 결과 일 수 있다. 리스트, 데이터 프레임 그리고 문자와 같은 다양한 유형의 개체가 있다. 할당 연산자 &lt;- 를 사용하여 개체를 만든다. 왼쪽에는 선택한 이름과 할당 연산자 &lt;-, 개체를 정의하는 코드가 이어진다. 다음과 같은 숫자 개체를 만들어 보자. a &lt;- 9 첫 번째 부분 a는 개체에 대해 선택한 이름이고 그 뒤에 할당 연산자 &lt;-, 그리고 값 9가 온다. 이제 코드에서 문자 a를 사용하여 이 개체를 참조한다. 예를 들어 a의 값을 두 배로 늘리는 방법을 알고 싶다면 다음과 같이 할 수 있다. a * 2 ## [1] 18 이것은 콘솔에 18을 인쇄한다. R에서 개체는 다른 유형이 될 수 있다. 위의 개체는 숫자이다. 이러한 유형을 R에서는 클래스(class)라고 한다. class() 함수를 사용하여 개체의 클래스가 무엇인지 알 수 있다. class(a) ## [1] &quot;numeric&quot; 그러면 콘솔에 숫자 값이 반환된다. 다음과 같이 할당 연산자를 사용하여 개체의 클래스를 변경할 수 있다. class(a) &lt;- &quot;custom_numeric&quot; 일반적으로 숫자나 문자처럼 이미 존재하는 개체의 클래스는 변경하지 않는다. 그러나 자신 만의 사용자 지정 클래스를 만들고 환경에 있는 다른 개체와 개체를 구분하려는 경우에는 가능하다. "],["필수-클래스-유형.html", "12.2 필수 클래스 유형", " 12.2 필수 클래스 유형 코드를 작성하는 동안 여러 유형의 개체를 정의하고 사용할 수 있지만 R 프로그래밍의 기초가 되는 몇 가지 유형이 있으므로 아래에서 구체적으로 설명한다. 12.2.1 문자 및 숫자 첫 번째 섹션에서 우리는 숫자 개체를 다루었고 문자 개체도 같은 방식으로 작동한다. 실제의 차이점은 문자 개체는 숫자가 아니라 문자를 저장한다는 것이다. 문자 개체는 다음과 같이 작은 따옴표('') 또는 큰 따옴표(\"\")로 묶어야 한다. b &lt;- &quot;nine&quot; 코드에서 b를 참조하면 “nine” 문자열이 반환된다. 이전에 살펴본 숫자 객체와 달리 b를 2로 곱할 수 없다.이를 시도하면 “non-numeric argument to binary operator(이항 연산자에 대한 숫자가 아닌 인수)”오류가 발생한다. 문자 개체에 대해 산술연산을 할 수는 없지만 stringr 라이브러리를 사용하여 이러한 개체를 조작할 수 있다. 예를 들어 두 개의 문자 개체를 함께 결합하려면 다음과 같이 stringr 라이브러리의 str_glue() 함수를 사용할 수 있다. library(stringr) str_glue(b, &quot; times 2&quot;) ## nine times 2 이렇게 하면 “9 x 2” 문자열이 반환된다. 라이브러리 키워드는 함수 라이브러리에 대한 액세스를 제공하는 데 사용된다. 위의 첫 번째 코드 줄은 stringr 라이브러리에 액세스해야 함을 의미한다. 12.2.2 벡터 벡터는 동일한 유형의 개체 목록이다. 문자, 숫자 또는 기타 유형의 개체 목록이 있을 수 있다. 1로 시작하는 숫자 값(색인, index)을 사용하여 목록의 개체를 추적한다. 벡터를 만들려면 쉼표로 구분된 값의 목록을 사용하여 목록을 만드는 c()라는 함수를 사용한다. 알파벳의 처음 5 개 문자를 구성하는 문자를 포함하는 벡터를 만드는 방법은 다음과 같다. alpha &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;) ## OR alpha1 &lt;- LETTERS[1:5] alpha라는 이름을 입력하여 전체 목록을 콘솔에 간단히 인쇄하거나, 관심있는 벡터의 요소에 해당하는 인덱스가 있는 개체 이름 뒤에 대괄호를 사용하여 개별 요소를 참조할 수 있다. 예를 들어, alpha[1]은 “A”를 인쇄하고, alpha[5]는 “E”를 인쇄한다. 벡터에 곱셈이나 함수와 같은 연산을 적용하면 연산이 벡터의 각 개체에 적용된다. 결과는 새로운 벡터가 된다. 예를 들어 숫자 20, 30, 40, 50, 60의 벡터가 있고 벡터에 4를 곱하면 새로운 벡터 80, 120, 160, 200, 240이 된다. n &lt;- c(20,30,40,50,60) n ## [1] 20 30 40 50 60 n * 4 ## [1] 80 120 160 200 240 12.2.3 행렬(Matrix) 행렬은 2 차원 (본질적으로 행과 열)을 가진 벡터이다. 벡터와 마찬가지로 행렬의 각 개체는 동일한 유형이어야 한다. 다음과 같이 벡터의 dim(차원) 속성을 설정하여 행렬을 만들 수 있다. m &lt;- c(1,2,3,4,5,6,7,8,9) dim(m) &lt;- c(3,3) m ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 m을 검사하면 행렬이 표시된다. [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 행렬의 개별 셀을 참조하려면 행과 열 인덱스를 제공한다. 예를 들어, 행 2와 열 1에 무엇이 있는지 확인하려면 m[2,1]에 이 작업을 수행하여 값 2를 얻는다. 12.2.4 리스트 앞에서 논의한 벡터는 동일한 요소를 모두 포함해야 하기 때문에 원자 벡터라고 한다. 혼합된 개체를 포함하는 벡터를 단순히 리스트(list)라고한다. 리스트는 관련 개체의 컬렉션을 관리하려는 경우 편리하다. 새 리스트를 만들려면 다음과 같은 목록 기능만 있으면 된다. l &lt;- list() l$name &lt;- &quot;Cards&quot; l$cards &lt;- c(&quot;10&quot;, &quot;Jack&quot;, &quot;Queen&quot;, &quot;King&quot;, &quot;Ace&quot;) l$bets &lt;- c(1,5,10) 첫 번째 줄은 빈 리스트를 만든 다음 $를 사용하여 개체를 할당할 이름을 만든다. 첫 번째는 리스트를 설명하는 문자 개체이고, 두 번째는 문자로 구성된 벡터이며, 마지막은 숫자 개체로 구성된 벡터이다. 나중에 이러한 값에 액세스하려면 목록 이름 다음에 달러 기호($)와 개체 이름을 사용해야 한다. 예를 들어, 입력 한 카드 리스트를 보려면 l$cards를 입력하고 목록에서 두 번째 카드를 얻으려면 l$cards[2]를 입력한다. 12.2.5 factor factor는 지정된 값만 포함 할 수 있는 벡터 유형이다. 예를 들어 성별을 나타내는 값 목록이 있을 수 있으며 각 값은 ‘남성,’ ‘여성’ 또는 ’알 수 없음’이어야 한다. 이 구조는 개체 범주에 대한 분석을 수행 할 때 유용하다. factor() 함수를 사용하고 값 목록을 제공하여 factor를 생성한다. sex &lt;- factor(c(&quot;male&quot;, &quot;female&quot;, &quot;unknown&quot;, &quot;male&quot;)) sex ## [1] male female unknown male ## Levels: female male unknown 위의 코드는 다음의 정보를 출력한다: ## [1] male female unknown male ## Levels: female male unknown 벡터에서와 같은 값 목록이 있지만 추가적으로 levels에 대한 정보도 있다. 12.2.6 데이터 프레임 데이터 프레임은 길이가 같은 구성 요소를 가져야 하는 특별한 종류의 리스트이다. 실제로 이것은 행과 열로 구성된 2차원 데이터 구조와 같은 일종의 스프레드 시트와 같은 구조를 갖는다. 데이터 프레임 구성 요소를 $ 연산자를 사용하는 리스트 또는 행과 열 인덱스를 사용하는 행렬처럼 처리할 수 있다. data.frame() 함수를 사용하여 데이터 프레임을 만들 수 있다. df &lt;- data.frame(numbers = c(1,2,3), letters = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) df$more &lt;- c(&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;) data.frame() 함수를 사용하여 데이터 프레임을 생성할 때 데이터 프레임에 동일한 길이의 벡터를 모두 제공할 수 있다. 데이터 프레임이 있으면 위에서 볼 수 있듯이 $ 연산자를 사용하여 추가 열을 만들 수 있다. 종종 함수의 출력으로 데이터 프레임이 생성된다. 데이터 프레임은 필수 R 개체이며 “tibble” 버전 유형의 데이터 프레임은 “필수 R 패키지”장에서 자세히 다룬 바 있다. "],["흐름-제어.html", "12.3 흐름 제어", " 12.3 흐름 제어 지금까지 우리는 본질적으로 개체를 생성하고 속성을 설정하고 결과를 검사했다. R 프로그래밍에는 루프를 사용하여 코드를 분기하고 코드를 반복하는 방법도 포함하고 있다. 12.3.1 If-then 문 if-then 문은 특정 개체의 상태에 따라 다른 작업을 수행하도록 프로그램에 지시한다. 다음은 if-then 문의 한 예이다. state &lt;- &quot;startup&quot; if(state == &quot;startup&quot;) { print(&quot;We are about to start the program&quot;) state = &quot;running program&quot; } else { print(&quot;Program running&quot;) } ## [1] &quot;We are about to start the program&quot; “startup”값을 가진 state라는 개체가 있다. 다음 코드 줄은 state 개체를 평가하고 개체의 값이 “startup”과 같으면 if 문 바로 뒤의 중괄호 안의 코드가 실행된다. state 메시지가 인쇄되고 state 개체의 값이 변경된다. state 객체가 “startup”이 아닌 경우 else 키워드 뒤의 코드가 실행된다. 여기서 프로그램은 단순히 “Program running”이라는 메시지를 출력한다. 위의 예에서 == 연산자를 사용하여 두 값이 같은지 테스트했다. 부등식을 사용하여 테스트 할 수도 있다 : !=, &gt;, &lt;, &gt;=, &lt;=. 한 줄의 코드에서 if-else를 사용할 수도 있으며 간결한 코드가 있으면 잘 작동한다. 예를 들어 state 개체를 테스트하여 `startup\" 모드에 있는지 확인하려면 다음과 같이하면 된다. ifelse(state == &quot;startup&quot;, TRUE, FALSE) ## [1] FALSE state가 “startup”이면 부울 값이 TRUE이다. 그렇지 않으면 부울 값 FALSE를 얻는다. 부울은 TRUE 또는 FALSE 일 수있는 특수한 유형의 객체이며 이와 같은 조건을 테스트하는 데 사용된다. 12.3.2 반복문 루프는 동일한 코드를 다시 반복하는 방법을 제공한다. R에서 사용할 수 있는 두 가지 유형의 루프가 있다. for 루프와 while 루프이다. 또한 루프와 유사한 동작을 제공하는 apply() 함수 군을 사용한다. 루프가 어떻게 작동하는지 살펴 보기로 한다. 12.3.2.1 For 루프 For 루프는 지정된 횟수만큼 실행된다. 예를 들어, 코드를 5 번 반복하려면 다음과 같이 할 수 있다. for (i in 1:5){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 이 코드는 1에서 5까지의 숫자를 출력한다.이 코드는 for 키워드로 구성되며 괄호 안에는 루프에서 우리가 어디에 있는지 추적하는 개체 i있다. 1:5는 1에서 5까지의 모든 숫자에 대한 R 의 단축어이다. 이 루프는 5 번 실행되며 중괄호 사이의 코드는 각 i의 값에 따라 다음의 출력을 생성한다. [1] 1 [1] 2 [1] 3 [1] 4 [1] 5 12.3.2.2 While 루프 While 루프는 코드를 반복적으로 실행한다. 그러나 고정된 횟수를 실행하는 대신 조건이 충족 될 때까지 이러한 루프가 실행된다. 다음은 while 루프를 사용하여 1에서 5까지 세는 방법을 보여준다. i &lt;- 0 while (i &lt;= 5) { print(i) i &lt;- i + 1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 while 루프는 i 개체의 상태를 확인하고 i &lt;= 5 조건이 거짓이 될 때까지 값을 콘솔에 출력한다. 루프가 반복 될 때마다 i 값이 1 씩 증가한다. "],["apply-함수.html", "12.4 apply() 함수", " 12.4 apply() 함수 apply 계열의 함수도 반복 패턴을 제공하지만 보다 간결한 형태로 제공된다. 이 유형의 함수는 다양한 R 패키지와 base R에서도 사용된다. 일반적인 패턴은 벡터, 데이터 프레임 또는 리스트와 같은 개체를 전달하여 apply() 함수를 사용하는 것이며 apply() 함수는 각각을 반복한다. 그 개체의 요소별로 apply() 함수에 각 요소에 대해 실행할 코드를 제공하면 그 함수가 적용되어 새 개체를 반환한다. 지금까지 반복했던 것을 출력하려면 다음과 같이 할 수 있다. sapply(1:5, function(x) {print(x)}) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 1 2 3 4 5 이것은 훨씬 더 깔끔하고, 우리는 벡터 1:5와 실행할 코드 만 가지고 있다. 코드는 “anonymous function(익명 함수)”이며 함수는 다음에 자세히 설명된다. 기본적으로 벡터의 현재 값에 대한 자리 표시자인 하나의 매개 변수 x가 있는 함수를 정의하고 중괄호 사이에는 벡터에 있는 각 요소에 대해 실행할 코드가 있다. 여기서는 sapply() 함수를 사용했으며 이 버전의 apply() 함수는 단순화된 객체 (이 경우 벡터)를 반환한다. 위의 경우 동일한 벡터를 다시 얻는다. 그러나 다음과 같은 작업을 수행할 수도 있다. sapply(1:5, function(x){ x * 2 }) ## [1] 2 4 6 8 10 코드를 좀 더 명확하게하기 위해 여기서 익명 함수를 사용하였다. 이 코드는 이를 콘솔에 인쇄할 새 벡터를 생성한다. ## [1] 2 4 6 8 10 이 apply 함수는 가장 단순한 개체를 반환하는 일반적인 래퍼 함수이다. 동일한 방식으로 작동하지만 리스트 객체를 반환하는 리스트 및 데이터 프레임에 사용되는 lapply도 있다. "],["함수.html", "12.5 함수", " 12.5 함수 함수는 함수에 제공하는 입력으로 실행할 수 있는 코드 블록을 포함하는 개체 유형이다. 이러한 개체는 코드를 한 번 작성하는 모범 사례를 따르는 좋은 방법이다. 일반적으로 프로젝트 전체에서 사용할 수 있다고 생각되는 코드 블록은 나중에 사용할 함수로 래핑할 수 있다. 함수 개체를 만드는 방법은 다음과 같다. my_fun &lt;- function(x, y) { r = x * 2 + y r } 중괄호 {와 } 사이의 코드가 함수를 구성한다. 이러한 중괄호 안에는 함수에서 매개 변수로 선언된 새 개체와 참조 개체를 만들 수 있다. 매개 변수는 function 키워드 뒤의 괄호 안에 표시되는 쉼표로 구분된 목록에 선언된다. 함수는 함수 자체보다 먼저 선언된 경우 함수 외부에서 선언 된 개체를 사용할 수도 있다. 매개 변수 목록과 코드 블록을 포함하는 함수가 my_fun 개체에 할당된다. 콘솔에 개체 이름을 입력하여 함수의 코드를 출력하여 함수를 검사 할 수 있다. 함수를 사용하려면 함수 이름 다음에 다음과 같이 쉼표로 구분된 매개 변수 목록을 입력해야 한다. my_fun(3, 189) ## [1] 195 이것은 숫자 개체 195를 반환할 것이다. 함수에서 일어나는 일은 코드의 각 줄이 실행되고 마지막 코드 줄이 호출자에게 반환된다는 것이다. my_fun의 마지막 코드 줄은 계산 결과이다. 개체 이름에 할당되지 않은 함수를 익명 함수라고하며 lapply 또는 sapply와 같은 함수에 대한 매개 변수로 자주 사용된다. 이러한 함수는 동일한 방식으로 작동하지만 반드시 표준 함수와 동일한 방식으로 재사용되는 것은 아니다. "],["json-데이터-가져오기.html", "12.6 JSON 데이터 가져오기", " 12.6 JSON 데이터 가져오기 JSON (JavaScript Object Notation)은 일부 프로그래머가 csv 또는 기타 2 차원 데이터 형식에 비해 익숙하지 않을 수있는 데이터 형식이다. JSON 데이터 형식은 구조화된 형식을 유지하면서 텍스트 형식으로 쉽게 전송할 수 있도록 설계되었다. 다음은 JSON 데이터의 예이다. life_json &lt;- &#39;[{&quot;year&quot;:2015, &quot;race&quot;:&quot;All Races&quot;, &quot;sex&quot;:&quot;Both Sexes&quot;, &quot;death&quot;:733.1}, {&quot;year&quot;:2014, &quot;race&quot;:&quot;All Races&quot;, &quot;sex&quot;:&quot;Both Sexes&quot;, &quot;life&quot;:78.9, &quot;death&quot;:724.6}, {&quot;year&quot;:2013, &quot;race&quot;:&quot;All Races&quot;, &quot;sex&quot;:&quot;Both Sexes&quot;, &quot;life&quot;:78.8, &quot;death&quot;:731.9}, {&quot;year&quot;:2012, &quot;race&quot;:&quot;All Races&quot;, &quot;sex&quot;:&quot;Both Sexes&quot;, &quot;life&quot;:78.8, &quot;death&quot;:732.8}, {&quot;year&quot;:2011, &quot;race&quot;:&quot;All Races&quot;, &quot;sex&quot;:&quot;Both Sexes&quot;, &quot;life&quot;:78.7, &quot;death&quot;:741.3}, {&quot;year&quot;:2010, &quot;race&quot;:&quot;All Races&quot;, &quot;sex&quot;:&quot;Both Sexes&quot;, &quot;life&quot;:78.7, &quot;death&quot;:747}]&#39; 이것은 우리가 이 과정 전체에서 작업한 기대 수명 데이터의 일부이다. 이 데이터에 대해 어느 정도 이해할 수는 있지만 친숙한 형식과는 거리가 멀다. 이와 같은 데이터로 작업하려면 jsonlite 패키지를 사용할 수 있다. 다음 코드로이 패키지를 설치한다. # install.packages(&quot;jsonlite&quot;) 이제 위의 JSON 데이터가 life_json이라는 개체에 저장되어 있다고 가정하면 데이터를 다음과 같은 간단한 코드 줄과 함께 사용할 수있는 깔끔한 형식으로 변환할 수 있다. library(tidyverse) library(jsonlite) ## ## Attaching package: &#39;jsonlite&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## flatten life &lt;- fromJSON(life_json) life 위의 라이브러리 참조를 포함했다. 이 데이터 프레임을 가져 오기 위해 명령 줄에 개체 이름 life를 입력하여 결과를 검사할 수 있다. ## year race sex death life ## 1 2015 All Races Both Sexes 733.1 NA ## 2 2014 All Races Both Sexes 724.6 78.9 ## 3 2013 All Races Both Sexes 731.9 78.8 ## 4 2012 All Races Both Sexes 732.8 78.8 ## 5 2011 All Races Both Sexes 741.3 78.7 ## 6 2010 All Races Both Sexes 747.0 78.7 jsonlite 패키지의 fromJSON 함수는 파일을 데이터 프레임으로 자동 변환한다. 이 함수는 자동으로 할 수있는 가장 높은 수준의 개체를 반환한다. 우리의 데이터는 우리가 받은 데이터 프레임에 깔끔하게 들어 맞는다. 그러나 기본 데이터 프레임이 이 구조에 맞지 않으면 JSON 파일의 구조를 반영하는 리스트 개체가 될 수 있다. 참고로, 우리가 사용하고 있는 expectancy 데이터 프레임을 json 파일로 변경할 수도 있다. 이를 위해 toJSON() 함수를 다음과 같이 이용하면 된다. expectancy 데이터 세트의 처음 5개 행만 json 파일로 변경해 본다. json_life &lt;- toJSON(expectancy[1:5, ]) json_life ## [{&quot;Year&quot;:1900,&quot;Race&quot;:&quot;All Races&quot;,&quot;Sex&quot;:&quot;Both Sexes&quot;,&quot;Average Life Expectancy (Years)&quot;:47.3,&quot;Age-adjusted Death Rate&quot;:2518},{&quot;Year&quot;:1901,&quot;Race&quot;:&quot;All Races&quot;,&quot;Sex&quot;:&quot;Both Sexes&quot;,&quot;Average Life Expectancy (Years)&quot;:49.1,&quot;Age-adjusted Death Rate&quot;:2473.1},{&quot;Year&quot;:1902,&quot;Race&quot;:&quot;All Races&quot;,&quot;Sex&quot;:&quot;Both Sexes&quot;,&quot;Average Life Expectancy (Years)&quot;:51.5,&quot;Age-adjusted Death Rate&quot;:2301.3},{&quot;Year&quot;:1903,&quot;Race&quot;:&quot;All Races&quot;,&quot;Sex&quot;:&quot;Both Sexes&quot;,&quot;Average Life Expectancy (Years)&quot;:50.5,&quot;Age-adjusted Death Rate&quot;:2379},{&quot;Year&quot;:1904,&quot;Race&quot;:&quot;All Races&quot;,&quot;Sex&quot;:&quot;Both Sexes&quot;,&quot;Average Life Expectancy (Years)&quot;:47.6,&quot;Age-adjusted Death Rate&quot;:2502.5}] "],["결론-10.html", "12.7 결론", " 12.7 결론 이 장에서는 R 프로그래밍에 대한 충분한 정보를 제공하여 시작하고 이 과정을 따라갈 수 있는지 확인했다. 이제 R의 개체, 제어 흐름 및 함수를 이해해야 한다. 또한 필수 R 패키지에 대한 장과 JSON에 대한 섹션은 과거에 데이터 분석을 생성한 경우 확실한 시작을 제공한다. 데이터 분석 과/또는 프로그래밍을 처음 접하는 독자의 경우 더 많은 도움이 필요할 수 있다. 프로그래밍은 처음에는 많은 연습과 약간의 이해가 필요하다. 다른 프로그래머의 데이터 분석 작업을 검토하면 도움이 될 수 있다. Github과 같은 웹 사이트에서 온라인으로 많은 예제를 볼 수 있다. 프로그래밍에 완전히 익숙하지 않은 독자는 필수 프로그래밍을 배우는 데 시간이 걸릴 수 있다. 이 책에서 루프, 함수 및 개체와 같은 아이디어를 처음 접한 경우라면 R 프로그래밍에 대한 로컬 또는 온라인 과정을 수강하는 것이 좋다. 모두에게 이 과정의 각 장의 자료가 어떤 도구를 사용할 수 있는지 이해하는 데 도움이 되어 찾고 있는 작업에 대한 통찰력을 실제로 제공할 수 있기를 바란다. 행운을 빈다. 데이터 과학 기술로의 여정을 즐기기 바란다! "]]
