[["index.html", "R을 이용한 네트워크 분석과 시각화 Chapter 1 R을 이용한 네트워크 분석과 시각화", " R을 이용한 네트워크 분석과 시각화 Translated by Dae Ho Kim, Mokwon University 2020-12-06 Chapter 1 R을 이용한 네트워크 분석과 시각화 To compile this example to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.name/tinytex/. "],["R-Basics.html", "Chapter 2 R 기초 복습 2.1 할당(Assignment) 2.2 값의 비교(Value comparisons) 2.3 특별한 상수(Special constants) 2.4 벡터(Vectors) 2.5 Factors 2.6 행렬과 배열(Matrces &amp; Arrays) 2.7 리스트(Lists) 2.8 데이터 프레임(Data Frames) 2.9 흐름 제어와 반복 구문(Flow Control and loops) 2.10 R 플롯과 색 지정 2.11 R 문제 해결", " Chapter 2 R 기초 복습 네트워크에 대해 학습하기 전에, R의 간단한 과제와 원리에 대한 간단한 소개와 복습을 하고자 한다. 2.1 할당(Assignment) assign() 함수, 치환 연산자( &lt;-, 또는 =) 등을 이용하여 개체(objects)에 값(value)를 할당할 수 있다. x &lt;- 3 # 변수 x에 3을 대입 x # 식을 계산하고 결과를 출력 ## [1] 3 y &lt;- 4 # 변수 y에 4를 대입 y + 5 # 계산, y의 값은 4로 변함이 없다. ## [1] 9 z &lt;- x + 17*y # 변수 z에 (x + 17 * y) 값을 대입 z # 계산한 결과를 출력 ## [1] 71 rm(z) # 변수 z를 삭제: 객체 z의 삭제 z # 에러! ## Error in eval(expr, envir, enclos): 객체 &#39;z&#39;를 찾을 수 없습니다 2.2 값의 비교(Value comparisons) &lt;, &gt;, &lt;=, &gt;=, ==(같음) and != (다름) 등의 기본 연산자를 사용할 수 있다. 비교 결과는 부울리안 값(TRUE 또는 FALSE, 간단히 T 또는 F)을 반환한다. 2 == 2 # 같은지 비교 ## [1] TRUE 2 != 2 # 다른지 비교 ## [1] FALSE x &lt;= y # 작거나 같은지 비교: &quot;&lt;&quot;, &quot;&gt;&quot;, 그리고 &quot;&gt;=&quot; 등의 비교도 가능 ## [1] TRUE 2.3 특별한 상수(Special constants) 다음과 같은 특별한 상수들이 있다: NA : 결측치 또는 정의되지 않은 데이터 (not available) NULL : 비어 있는 개체(e.g. null/empty lists) Inf 와 -Inf : 양의 무한대와 음의 무한대(infinity) NaN : 합리적으로 정의될 수 없는 결과 (not a number) # NA - 결측치 또는 정의되지 않은 데이터 5 + NA # 수식에서 사용되면, 결과는 일반적으로 NA ## [1] NA is.na(5 + NA) # is.na() 함수의 사용 : NA 인지 체크 ## [1] TRUE # NULL - 비어 있는 개체(e.g. null/empty lists) 10 + NULL # 비어 있는 개체 반환 (length zero) ## numeric(0) is.null(NULL) # is.null() 함수의 사용 : NULL 인지 체크 ## [1] TRUE Inf 와 -Inf는 양의 무한대와 음의 무한대(infinity)를 나타낸다. 수를 0으로 나누는 수 연산에 의해 반환될 수 있다: 5/0 ## [1] Inf is.finite(5/0) # is.finite() 함수의 사용 : 결과가 유한한지 무한인지 체크 ## [1] FALSE NaN (Not a Number) - 합리적으로 정의될 수 없는 연산의 결과로서, 0을 0으로 나눈 결과이다. 0/0 ## [1] NaN is.nan(0/0) # is.nan() 함수의 사용 ## [1] TRUE 2.4 벡터(Vectors) 벡터는 R의 중요한 함수인 c() 함수로 요소들을 결합하여 생성될 수 있다. v1 &lt;- c(1, 5, 11, 33) # 수치 벡터, 길이(요소의 갯수)가 4 v2 &lt;- c(&quot;hello&quot;,&quot;world&quot;) # 문자 벡터, 길이(요소의 갯수)가 2 (문자열 벡터) v3 &lt;- c(TRUE, TRUE, FALSE) # 논리 벡터, c(T, T, F)와 같음 하나의 벡터에 서로 다른 유형의 요소들을 결합하면 최소의 제한적인 유형으로 요소들을 강제 변환한다: v4 &lt;- c(v1, v2, v3, &quot;boo&quot;) # 모든 요소들이 문자형으로 변환됨 벡터 생성의 다른 방법들: # : 의 사용 v &lt;- 1:7 # (from:to), c(1,2,3,4,5,6,7)와 같음. # rep() 함수의 사용 v &lt;- rep(0, 77) # 복사 : 0을 77개 복사, 변수 v는 0이 77개 있는 벡터 v &lt;- rep(1:3, times=2) # 1:3을 두 번 복사 v &lt;- rep(1:10, each=2) # 1:10의 각 요소를 두 번 복사 # seq() 함수의 사용 v &lt;- seq(10,20,2) # 시퀀스 : 10과 20사이의 2 간격의 수 # 예 v1 &lt;- 1:5 # c(1,2,3,4,5)와 같음 v2 &lt;- rep(1,5) # c(1,1,1,1,1)과 같음 벡터의 길이 즉 벡터의 요소의 갯수는 length() 함수를 사용하여 확인한다. length(v1) ## [1] 5 length(v2) ## [1] 5 요소 단위의 연산 : v1 + v2 # 대응 요소별 더하기 ## [1] 2 3 4 5 6 v1 + 1 # 각 요소에 1 더하기 ## [1] 2 3 4 5 6 v1 * 2 # 각 요소를 2로 곱하기 ## [1] 2 4 6 8 10 v1 + c(1,7) # 자동 채우기 : v1 + c(1, 7, 1, 7, 1)과 같음. ## Warning in v1 + c(1, 7): 두 객체의 길이가 서로 배수관계에 있지 않습니다 ## [1] 2 9 4 11 6 # Warning 메시지 출력 산술 연산 : 다양한 함수를 이용하여 산술연산을 수행할 수 있다. sum(v1) # 변수 v1의 모든 요소들을 더한다 ## [1] 15 mean(v1) # 변수 v1 요소들의 평균 ## [1] 3 sd(v1) # 변수 v1 요소들의 표준편차 ## [1] 1.581139 cor(v1,v1*5) # 변수 v1과 v1*5 사이의 상관계수 ## [1] 1 논리 연산 : # 대소 비교 v1 &gt; 2 # 벡터 v1의 각 요소를 2와 비교, 논리 벡터 반환 ## [1] FALSE FALSE TRUE TRUE TRUE v1==v2 # 벡터 v1과 v2 각각의 요소가 같은지 비교, 논리 벡터 반환 ## [1] TRUE FALSE FALSE FALSE FALSE v1!=v2 # 벡터 v1과 v2 각각의 요소가 서로 다른지 비교, 논리 벡터 반환, ## [1] FALSE TRUE TRUE TRUE TRUE # !(v1==v2)와 같음. # 비교 연산의 결합 : OR(|), AND(&amp;) =&gt; 요소별 비교의 결합 (v1&gt;2) | (v2&gt;0) # | 는 부울리안 OR, 벡터를 반환 ## [1] TRUE TRUE TRUE TRUE TRUE (v1&gt;2) &amp; (v2&gt;0) # &amp; 는 부울리안 AND, 벡터를 반환 ## [1] FALSE FALSE TRUE TRUE TRUE # 비교 연산의 결합 : OR(||), AND(&amp;&amp;) =&gt; 벡터 전체 비교의 결합 (v1&gt;2) || (v2&gt;0) # || 는 부울리안 OR, 단일 값 반환 ## [1] TRUE (v1&gt;2) &amp;&amp; (v2&gt;0) # &amp;&amp; 는 부울리안 AND, 단일 값 반환 ## [1] FALSE 벡터 요소 : v1[3] # 벡터 v1의 세 번째 요소 ; 3은 요소의 색인(index) ## [1] 3 v1[2:4] # 벡터 v1의 2, 3, 4 번째 요소 ## [1] 2 3 4 v1[c(1,3)] # 1번째와 3번째 요소 - 색인도 벡터임을 주목 ## [1] 1 3 v1[c(T,T,F,F,F)] # 색인이 논리 벡터 : TRUE인 요소 만 - 1, 2번째 요소 ## [1] 1 2 v1[v1&gt;3] # v1&gt;3의 결과는 논리 벡터. 요소 중 값이 3보다 큰 요소 반환 ## [1] 4 5 R에서는 벡터의 요소 번호가 1부터 시작함에 주의해야 한다. C 언어와 같이 색인 번호가 0부터 시작하는 언어를 사용해 본 사람들은 혼동이 될 수 있다. 벡터에 요소를 추가하려면, 다음과 같이 추가할 수 있다. v1[6:10] &lt;- 6:10 v1 ## [1] 1 2 3 4 5 6 7 8 9 10 벡터에 요소의 갯수(길이)를 직접 할당할 수도 있다 : length(v1) &lt;- 15 # 11~15번째 요소는 결측치 NA로 추가된다 v1 ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA 2.5 Factors factor는 범주형 데이터를 저장하기 위해 사용된다. (factor는 기본적으로 문자형 벡터이다.) eye.col.vec &lt;- c(&quot;brown&quot;, &quot;green&quot;, &quot;brown&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;blue&quot;) # 문자 벡터 eye.col.vec ## [1] &quot;brown&quot; &quot;green&quot; &quot;brown&quot; &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; eye.col.fac &lt;- factor(c(&quot;brown&quot;, &quot;green&quot;, &quot;brown&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;blue&quot;)) # factor eye.col.fac ## [1] brown green brown blue blue blue ## Levels: blue brown green R은 factor의 서로 다른 level들을 식별한다 - 즉, 단일 값들. 데이터는 내부적으로 정수로 저장되며, 각 숫자는 factor의 level에 대응한다. (문자 벡터보다 데이터 저장 공간이 절약되는 효과가 있다.) # factor의 level 확인 : levels() 함수의 사용 levels(eye.col.fac) # factor(범주형 변수)의 levels들(단일 값) ## [1] &quot;blue&quot; &quot;brown&quot; &quot;green&quot; # factor의 숫자 벡터 변환 : as.numeric() 함수의 사용 as.numeric(eye.col.fac) # 수치 값 : 1은 &quot;blue&quot;, 2는 &quot;brown&quot;, 3은 &quot;green&quot; ## [1] 2 3 2 1 1 1 # 문자 벡터의 숫자 벡터 변환 as.numeric(eye.col.vec) # eye.col.vec 벡터는 숫자 벡터로 변환이 안됨. ## Warning: 강제형변환에 의해 생성된 NA 입니다 ## [1] NA NA NA NA NA NA # factor의 문자형 변환 : as.character() 함수의 사용 as.character(eye.col.fac) ## [1] &quot;brown&quot; &quot;green&quot; &quot;brown&quot; &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; # 문자 벡터의 문자형 변환 as.character(eye.col.vec) ## [1] &quot;brown&quot; &quot;green&quot; &quot;brown&quot; &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; 2.6 행렬과 배열(Matrces &amp; Arrays) 행렬(matrix)은 행과 열의 차원(dimension)을 갖는 벡터이다: m &lt;- rep(1, 20) # 1을 20번 복사. 변수 m은 모든 요소가 1인 벡터 dim(m) &lt;- c(5,4) # 차원을 5 &amp; 4로 설정 : 즉, m은 이제 5x4 행렬 행렬의 생성 : matrix(): 함수의 사용 m &lt;- matrix(data=1, nrow=5, ncol=4) # 위의 행렬과 동일. # 1의 요소 값(자동 반복)을 갖는 5x4 행렬 m &lt;- matrix(1,5,4) # 위의 행렬과 같음. (인수의 키워드 생략 가능) # 행렬의 차원 확인 : dim() 함수의 사용 dim(m) ## [1] 5 4 벡터 결합에 의한 행렬 생성 : cbind() 함수와 rbind() 함수의 사용 m &lt;- cbind(1:5, 5:1, 5:9) # 3개의 벡터들을 컬럼(column, 열) 단위로 결합. 5x3 행렬 m &lt;- rbind(1:5, 5:1, 5:9) # 3개의 벡터들을 로(row, 행) 단위로 결합. 3x5 행렬 행렬 요소의 선택 : # 행렬의 생성 m &lt;- matrix(1:10,10,10) ## 행렬 요소의 선택 : m[행번호, 열번호] # 단일 요소의 선택 m[2,3] # 행렬 m의 2행, 3열 요소 - 단일 요소(cell) ## [1] 2 # 행/열의 선택 m[2,] # 행렬 m의 2번째 행 전체 : 벡터 ## [1] 2 2 2 2 2 2 2 2 2 2 m[,2] # 행렬 m의 2번째 열 전체 : 벡터 ## [1] 1 2 3 4 5 6 7 8 9 10 # 복수 개 행/열의 선택 : 부분 행렬(submatrix) m[1:2,4:6] # 부분 행렬 : (1, 2)행과 (4, 5, 6) 열로 구성된 행렬 ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 2 2 2 # 행/열의 제외 : &#39;-&#39; m[-1,] # 1번째 행을 제외한 부분 행렬 ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 2 2 2 2 2 2 2 2 2 2 ## [2,] 3 3 3 3 3 3 3 3 3 3 ## [3,] 4 4 4 4 4 4 4 4 4 4 ## [4,] 5 5 5 5 5 5 5 5 5 5 ## [5,] 6 6 6 6 6 6 6 6 6 6 ## [6,] 7 7 7 7 7 7 7 7 7 7 ## [7,] 8 8 8 8 8 8 8 8 8 8 ## [8,] 9 9 9 9 9 9 9 9 9 9 ## [9,] 10 10 10 10 10 10 10 10 10 10 행렬의 연산 : # 1 행의 요소들이 1 열의 요소들과 같은가? m[1,]==m[,1] ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE # 논리 행렬 : m의 요소 값이 3보다 크면 TRUE, 아니면 FALSE : l &lt;- m &gt; 3 l ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [2,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [3,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [4,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [5,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [6,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [7,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [8,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [9,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [10,] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE # 논리 벡터 l의 요소가 TRUE인 m의 요소 선택 : 즉, 요소 값이 3보가 큰 요소 선택 m[l] ## [1] 4 5 6 7 8 9 10 4 5 6 7 8 9 10 4 5 6 7 8 9 10 4 5 6 7 ## [26] 8 9 10 4 5 6 7 8 9 10 4 5 6 7 8 9 10 4 5 6 7 8 9 10 4 ## [51] 5 6 7 8 9 10 4 5 6 7 8 9 10 4 5 6 7 8 9 10 # 전치 행렬(transpose matrix) : t() 함수의 사용 t(m) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 2 3 4 5 6 7 8 9 10 ## [2,] 1 2 3 4 5 6 7 8 9 10 ## [3,] 1 2 3 4 5 6 7 8 9 10 ## [4,] 1 2 3 4 5 6 7 8 9 10 ## [5,] 1 2 3 4 5 6 7 8 9 10 ## [6,] 1 2 3 4 5 6 7 8 9 10 ## [7,] 1 2 3 4 5 6 7 8 9 10 ## [8,] 1 2 3 4 5 6 7 8 9 10 ## [9,] 1 2 3 4 5 6 7 8 9 10 ## [10,] 1 2 3 4 5 6 7 8 9 10 mt &lt;- t(m) # mt는 m의 전치행렬 : 행과 열의 위치가 바뀐 행렬 # 행렬 곱 연산 : %*% 연산자 사용 m %*% mt # %*% 연산자는 행렬 곱 ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 10 20 30 40 50 60 70 80 90 100 ## [2,] 20 40 60 80 100 120 140 160 180 200 ## [3,] 30 60 90 120 150 180 210 240 270 300 ## [4,] 40 80 120 160 200 240 280 320 360 400 ## [5,] 50 100 150 200 250 300 350 400 450 500 ## [6,] 60 120 180 240 300 360 420 480 540 600 ## [7,] 70 140 210 280 350 420 490 560 630 700 ## [8,] 80 160 240 320 400 480 560 640 720 800 ## [9,] 90 180 270 360 450 540 630 720 810 900 ## [10,] 100 200 300 400 500 600 700 800 900 1000 m * m # * 는 행렬의 요소별 곱하기 ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 1 1 1 1 1 1 1 1 1 ## [2,] 4 4 4 4 4 4 4 4 4 4 ## [3,] 9 9 9 9 9 9 9 9 9 9 ## [4,] 16 16 16 16 16 16 16 16 16 16 ## [5,] 25 25 25 25 25 25 25 25 25 25 ## [6,] 36 36 36 36 36 36 36 36 36 36 ## [7,] 49 49 49 49 49 49 49 49 49 49 ## [8,] 64 64 64 64 64 64 64 64 64 64 ## [9,] 81 81 81 81 81 81 81 81 81 81 ## [10,] 100 100 100 100 100 100 100 100 100 100 배열(Arrays)은 2보다 큰 차원을 다룬다. 배열은 array() 함수로 생성할 수 있다: a &lt;- array(data=1:18, dim=c(3, 3, 2)) # 세 번째 차원을 갖는 배열 : 3x3x2 # 3x3 행렬이 두 개 있는 것 a &lt;- array(1:18, c(3, 3, 2)) # 동일한 배열 2.7 리스트(Lists) 리스트는 객체의 묶음이다. 단일 리스트는 모든 종류의 요소들(문자 벡터, 숫자 벡터, 행렬, 다른 리스트 등)을 포함할 수 있다. 리스트의 요소들은 보다 쉬은 접근을 위해 이름이 종종 부여된다. l1 &lt;- list(boo=v1, foo=v2, moo=v3, zoo=&quot;Animals!&quot;) # 요소별 이름을 갖는 리스트 l1 ## $boo ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA ## ## $foo ## [1] 1 1 1 1 1 ## ## $moo ## [1] TRUE TRUE FALSE ## ## $zoo ## [1] &quot;Animals!&quot; l2 &lt;- list(v1, v2, v3, &quot;Animals!&quot;) # 요소별 이름이 갖지 않는 리스트 l2 ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA ## ## [[2]] ## [1] 1 1 1 1 1 ## ## [[3]] ## [1] TRUE TRUE FALSE ## ## [[4]] ## [1] &quot;Animals!&quot; 빈(empty) 리스트 생성 : list() 함수 또는 NULL 사용 l3 &lt;- list() l4 &lt;- NULL 리스트 요소 접근 : l1[&quot;boo&quot;] # 한 개의 대괄호로 &quot;boo&quot; 요소에 접근: 그 결과는 리스트 ## $boo ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA l1[[&quot;boo&quot;]] # 이중 대괄호로 &quot;boo&quot; 요소에 접근 : 그 결과는 숫자 벡터 v1 ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA l1[[1]] # 리스트의 첫 요소를 반환, 위와 동일 : 결과는 숫자 벡터 v1 ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA l1$boo # 이중 대괄호와 마찬가지로, $ 연산자로 &quot;boo&quot; 요소에 접근 ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA 리스트에 요소 추가 : l3[[1]] &lt;- 11 # 빈 리스트 l3의 첫 번째 요소로 11을 추가 l3 ## [[1]] ## [1] 11 l4[[3]] &lt;- c(22, 23) # 빈 리스트 l4의 3번째 요소로 벡터 추가 l4 ## [[1]] ## NULL ## ## [[2]] ## NULL ## ## [[3]] ## [1] 22 23 리스트 l4에 3번 째 요소를 추가했기 때문에, 첫 번째와 두 번째 요소가 생성되지만 그 값은 비어 있는 NULL이다. l1[[5]] &lt;- &quot;More elements!&quot; # 네 개의 요소를 갖는 리스트 l1에, 5번째 요소를 추가 l1 ## $boo ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA ## ## $foo ## [1] 1 1 1 1 1 ## ## $moo ## [1] TRUE TRUE FALSE ## ## $zoo ## [1] &quot;Animals!&quot; ## ## [[5]] ## [1] &quot;More elements!&quot; l1[[8]] &lt;- 1:11 # 리스트 l1의 8번쨰 요소에 1:11 벡터 추가 l1 ## $boo ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA ## ## $foo ## [1] 1 1 1 1 1 ## ## $moo ## [1] TRUE TRUE FALSE ## ## $zoo ## [1] &quot;Animals!&quot; ## ## [[5]] ## [1] &quot;More elements!&quot; ## ## [[6]] ## NULL ## ## [[7]] ## NULL ## ## [[8]] ## [1] 1 2 3 4 5 6 7 8 9 10 11 리스트 l1에 8번째 요소를 추가했지만, 6번째와 7번째는 그러지 않았다. 따라서 6번째와 7번째 요소는 비어있다(NULL). l1$Something &lt;- &quot;A thing&quot; # &quot;Something&quot;이라는 이름의 요소로 &quot;A thing&quot; 값을 추가 l1 ## $boo ## [1] 1 2 3 4 5 6 7 8 9 10 NA NA NA NA NA ## ## $foo ## [1] 1 1 1 1 1 ## ## $moo ## [1] TRUE TRUE FALSE ## ## $zoo ## [1] &quot;Animals!&quot; ## ## [[5]] ## [1] &quot;More elements!&quot; ## ## [[6]] ## NULL ## ## [[7]] ## NULL ## ## [[8]] ## [1] 1 2 3 4 5 6 7 8 9 10 11 ## ## $Something ## [1] &quot;A thing&quot; 2.8 데이터 프레임(Data Frames) 데이터 프레임은 데이터 세트 테이블을 저장하는데 사용되는 특별한 종류의 리스트이다. 각 행은 데이터의 사례를 각 열은 변수로 생각하면 된다. 각 열은 벡터 또는 factor이다. 데이터 프레임의 생성 : dfr1 &lt;- data.frame( ID=1:4, FirstName=c(&quot;John&quot;,&quot;Jim&quot;,&quot;Jane&quot;,&quot;Jill&quot;), Female=c(F,F,T,T), Age=c(22,33,44,55) ) str(dfr1) ## &#39;data.frame&#39;: 4 obs. of 4 variables: ## $ ID : int 1 2 3 4 ## $ FirstName: chr &quot;John&quot; &quot;Jim&quot; &quot;Jane&quot; &quot;Jill&quot; ## $ Female : logi FALSE FALSE TRUE TRUE ## $ Age : num 22 33 44 55 dfr1$FirstName # dfr1의 두 번째 컬럼 접근 ## [1] &quot;John&quot; &quot;Jim&quot; &quot;Jane&quot; &quot;Jill&quot; 여기서, R(R 4.0 이전 버전)은 dfr1$FirstName 은 범주형 변수라고 생각하고, 문자 벡터가 아닌 factor 처럼 처리할 것이라는 점을 주목하라. as.vector() 함수를 이용하여 R에게 FirstName을 factor가 아닌 벡터로 처리하게 하자 : dfr1$FirstName &lt;- as.vector(dfr1$FirstName) # as.factor() : factor로 변환 다른 방법으로, stringsAsFactors=FALSE를 사용하여 처음부터 factor로 처리하지 않도록 할 수 있다. (R 4.0 이후에는 기본적으로 이렇게 설정되어 있다.) dfr2 &lt;- data.frame(FirstName=c(&quot;John&quot;,&quot;Jim&quot;,&quot;Jane&quot;,&quot;Jill&quot;), stringsAsFactors=F) dfr2$FirstName # Factor가 아님 : 성공 ## [1] &quot;John&quot; &quot;Jim&quot; &quot;Jane&quot; &quot;Jill&quot; 데이터 프레임의 요소 접근 : # 행/열 접근 dfr1[1,] # 첫 번째 행, 모든 열 ## ID FirstName Female Age ## 1 1 John FALSE 22 dfr1[,1] # 첫 번째 열, 모든 행 ## [1] 1 2 3 4 # Age 이름의 열 접근 dfr1$Age # Age 열, 모든 행 ## [1] 22 33 44 55 dfr1[1:2,3:4] # 1행, 2행 그리고 3열과 4열 - &quot;john&quot;과 &quot;jim&quot;의 &quot;gender&quot;와 &quot;age&quot; ## Female Age ## 1 FALSE 22 ## 2 FALSE 33 dfr1[c(1,3),] # 1행과 3행 그리고 모든 열 ## ID FirstName Female Age ## 1 1 John FALSE 22 ## 3 3 Jane TRUE 44 데이터에서 30세 이상인 사람들의 이름(FirstName) 확인 : dfr1[dfr1$Age&gt;30, 2] ## [1] &quot;Jim&quot; &quot;Jane&quot; &quot;Jill&quot; 데이터에서 모든 여성(Female == TRUE)의 평균 나이(mean(Age)) 확인 : females &lt;- dfr1$Female==TRUE ages_of_females &lt;- dfr1[females, 4] mean (ages_of_females) ## [1] 49.5 2.9 흐름 제어와 반복 구문(Flow Control and loops) R에서의 제어와 반복은 상당히 직접적이다(아래 참고). 코드 블럭이 실행될 지 여부와 반복 횟수를 결정한다. R에서의 코드 블럭은 중괄호({}) 안에 위치한다. ## 흐름 제어 : if() 구문 # if (조건식) expr1 else expr2 x &lt;- 5; y &lt;- 10 if (x==0) y &lt;- 0 else y &lt;- y/x # y ## [1] 2 ## 반복 구문 : for () 구문 # for (variable in sequence) expr ASum &lt;- 0; AProd &lt;- 1 for (i in 1:x) { ASum &lt;- ASum + i AProd &lt;- AProd * i } ASum # sum(1:x)과 같음 ## [1] 15 AProd # prod(1:x)과 같음 ## [1] 120 ## 반복 구문 : while () 구문 # while (condintion) expr while (x &gt; 0) {print(x); x &lt;- x-1;} ## [1] 5 ## [1] 4 ## [1] 3 ## [1] 2 ## [1] 1 ## 반복 구문 : repeat() 구문 # repeat expr, use break to exit the loop repeat { print(x); x &lt;- x+1; if (x&gt;10) break} ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 2.10 R 플롯과 색 지정 대부분의 R 함수에서 색 이름, 16진수, RGB 값 등을 이용할 수 있다. 단순한 base 패키지의 R 차트에서 x와 y는 점의 좌표를 pch는 점의 모양, cex는 점의 크기, 그리고 col은 색이다. R의 base 패키지에서의 차트 작성을 위한 파라미터를 확인하려면 console 창에 ?par를 입력한다. plot(x=1:10, y=rep(5,10), pch=19, cex=3, col=&quot;dark red&quot;) # 색 이름 지정 points(x=1:10, y=rep(6, 10), pch=19, cex=3, col=&quot;557799&quot;) # hex points(x=1:10, y=rep(4, 10), pch=19, cex=3, col=rgb(.25, .5, .3)) # RGB 값 지정 여기서 RGB 값은 0과 1 사이의 값이다. 이 값이 R의 기본값이지만, rgb(10, 100, 100, maxColorValue=255) 를 사용하면, 0-255 까지의 값으로 설정할 수 있다. alpha (0-1 범위 값) 파라미터를 이용하여 요소의 불투명도/투명도를 설정할 수 있다. plot(x=1:5, y=rep(5,5), pch=19, cex=12, col=rgb(.25, .5, .3, alpha=.5), xlim=c(0,6)) 16진수로 색깔을 표현한다면, grDevices 패키지의 adjustcolor를 사용하여 투명도 alpha를 설정할 수 있다. 그래픽 파라미터로 par() 함수를 사용하여 차트의 배경을 회색(gray)으로 설정할 수 있다. par(bg=&quot;gray40&quot;) col.tr &lt;- grDevices::adjustcolor(&quot;557799&quot;, alpha=0.7) plot(x=1:5, y=rep(5,5), pch=19, cex=12, col=col.tr, xlim=c(0,6)) R에 내장된 색 이름을 사용하고자 한다면, 사용할 수 있는 색의 모든 이름은 다음과 같은 방법으로 확인할 수 있다: colors() # 모든 색 이름을 보여준다 ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; ## [4] &quot;antiquewhite1&quot; &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; ## [7] &quot;antiquewhite4&quot; &quot;aquamarine&quot; &quot;aquamarine1&quot; ## [10] &quot;aquamarine2&quot; &quot;aquamarine3&quot; &quot;aquamarine4&quot; ## [13] &quot;azure&quot; &quot;azure1&quot; &quot;azure2&quot; ## [16] &quot;azure3&quot; &quot;azure4&quot; &quot;beige&quot; ## [19] &quot;bisque&quot; &quot;bisque1&quot; &quot;bisque2&quot; ## [22] &quot;bisque3&quot; &quot;bisque4&quot; &quot;black&quot; ## [25] &quot;blanchedalmond&quot; &quot;blue&quot; &quot;blue1&quot; ## [28] &quot;blue2&quot; &quot;blue3&quot; &quot;blue4&quot; ## [31] &quot;blueviolet&quot; &quot;brown&quot; &quot;brown1&quot; ## [34] &quot;brown2&quot; &quot;brown3&quot; &quot;brown4&quot; ## [37] &quot;burlywood&quot; &quot;burlywood1&quot; &quot;burlywood2&quot; ## [40] &quot;burlywood3&quot; &quot;burlywood4&quot; &quot;cadetblue&quot; ## [43] &quot;cadetblue1&quot; &quot;cadetblue2&quot; &quot;cadetblue3&quot; ## [46] &quot;cadetblue4&quot; &quot;chartreuse&quot; &quot;chartreuse1&quot; ## [49] &quot;chartreuse2&quot; &quot;chartreuse3&quot; &quot;chartreuse4&quot; ## [52] &quot;chocolate&quot; &quot;chocolate1&quot; &quot;chocolate2&quot; ## [55] &quot;chocolate3&quot; &quot;chocolate4&quot; &quot;coral&quot; ## [58] &quot;coral1&quot; &quot;coral2&quot; &quot;coral3&quot; ## [61] &quot;coral4&quot; &quot;cornflowerblue&quot; &quot;cornsilk&quot; ## [64] &quot;cornsilk1&quot; &quot;cornsilk2&quot; &quot;cornsilk3&quot; ## [67] &quot;cornsilk4&quot; &quot;cyan&quot; &quot;cyan1&quot; ## [70] &quot;cyan2&quot; &quot;cyan3&quot; &quot;cyan4&quot; ## [73] &quot;darkblue&quot; &quot;darkcyan&quot; &quot;darkgoldenrod&quot; ## [76] &quot;darkgoldenrod1&quot; &quot;darkgoldenrod2&quot; &quot;darkgoldenrod3&quot; ## [79] &quot;darkgoldenrod4&quot; &quot;darkgray&quot; &quot;darkgreen&quot; ## [82] &quot;darkgrey&quot; &quot;darkkhaki&quot; &quot;darkmagenta&quot; ## [85] &quot;darkolivegreen&quot; &quot;darkolivegreen1&quot; &quot;darkolivegreen2&quot; ## [88] &quot;darkolivegreen3&quot; &quot;darkolivegreen4&quot; &quot;darkorange&quot; ## [91] &quot;darkorange1&quot; &quot;darkorange2&quot; &quot;darkorange3&quot; ## [94] &quot;darkorange4&quot; &quot;darkorchid&quot; &quot;darkorchid1&quot; ## [97] &quot;darkorchid2&quot; &quot;darkorchid3&quot; &quot;darkorchid4&quot; ## [100] &quot;darkred&quot; &quot;darksalmon&quot; &quot;darkseagreen&quot; ## [103] &quot;darkseagreen1&quot; &quot;darkseagreen2&quot; &quot;darkseagreen3&quot; ## [106] &quot;darkseagreen4&quot; &quot;darkslateblue&quot; &quot;darkslategray&quot; ## [109] &quot;darkslategray1&quot; &quot;darkslategray2&quot; &quot;darkslategray3&quot; ## [112] &quot;darkslategray4&quot; &quot;darkslategrey&quot; &quot;darkturquoise&quot; ## [115] &quot;darkviolet&quot; &quot;deeppink&quot; &quot;deeppink1&quot; ## [118] &quot;deeppink2&quot; &quot;deeppink3&quot; &quot;deeppink4&quot; ## [121] &quot;deepskyblue&quot; &quot;deepskyblue1&quot; &quot;deepskyblue2&quot; ## [124] &quot;deepskyblue3&quot; &quot;deepskyblue4&quot; &quot;dimgray&quot; ## [127] &quot;dimgrey&quot; &quot;dodgerblue&quot; &quot;dodgerblue1&quot; ## [130] &quot;dodgerblue2&quot; &quot;dodgerblue3&quot; &quot;dodgerblue4&quot; ## [133] &quot;firebrick&quot; &quot;firebrick1&quot; &quot;firebrick2&quot; ## [136] &quot;firebrick3&quot; &quot;firebrick4&quot; &quot;floralwhite&quot; ## [139] &quot;forestgreen&quot; &quot;gainsboro&quot; &quot;ghostwhite&quot; ## [142] &quot;gold&quot; &quot;gold1&quot; &quot;gold2&quot; ## [145] &quot;gold3&quot; &quot;gold4&quot; &quot;goldenrod&quot; ## [148] &quot;goldenrod1&quot; &quot;goldenrod2&quot; &quot;goldenrod3&quot; ## [151] &quot;goldenrod4&quot; &quot;gray&quot; &quot;gray0&quot; ## [154] &quot;gray1&quot; &quot;gray2&quot; &quot;gray3&quot; ## [157] &quot;gray4&quot; &quot;gray5&quot; &quot;gray6&quot; ## [160] &quot;gray7&quot; &quot;gray8&quot; &quot;gray9&quot; ## [163] &quot;gray10&quot; &quot;gray11&quot; &quot;gray12&quot; ## [166] &quot;gray13&quot; &quot;gray14&quot; &quot;gray15&quot; ## [169] &quot;gray16&quot; &quot;gray17&quot; &quot;gray18&quot; ## [172] &quot;gray19&quot; &quot;gray20&quot; &quot;gray21&quot; ## [175] &quot;gray22&quot; &quot;gray23&quot; &quot;gray24&quot; ## [178] &quot;gray25&quot; &quot;gray26&quot; &quot;gray27&quot; ## [181] &quot;gray28&quot; &quot;gray29&quot; &quot;gray30&quot; ## [184] &quot;gray31&quot; &quot;gray32&quot; &quot;gray33&quot; ## [187] &quot;gray34&quot; &quot;gray35&quot; &quot;gray36&quot; ## [190] &quot;gray37&quot; &quot;gray38&quot; &quot;gray39&quot; ## [193] &quot;gray40&quot; &quot;gray41&quot; &quot;gray42&quot; ## [196] &quot;gray43&quot; &quot;gray44&quot; &quot;gray45&quot; ## [199] &quot;gray46&quot; &quot;gray47&quot; &quot;gray48&quot; ## [202] &quot;gray49&quot; &quot;gray50&quot; &quot;gray51&quot; ## [205] &quot;gray52&quot; &quot;gray53&quot; &quot;gray54&quot; ## [208] &quot;gray55&quot; &quot;gray56&quot; &quot;gray57&quot; ## [211] &quot;gray58&quot; &quot;gray59&quot; &quot;gray60&quot; ## [214] &quot;gray61&quot; &quot;gray62&quot; &quot;gray63&quot; ## [217] &quot;gray64&quot; &quot;gray65&quot; &quot;gray66&quot; ## [220] &quot;gray67&quot; &quot;gray68&quot; &quot;gray69&quot; ## [223] &quot;gray70&quot; &quot;gray71&quot; &quot;gray72&quot; ## [226] &quot;gray73&quot; &quot;gray74&quot; &quot;gray75&quot; ## [229] &quot;gray76&quot; &quot;gray77&quot; &quot;gray78&quot; ## [232] &quot;gray79&quot; &quot;gray80&quot; &quot;gray81&quot; ## [235] &quot;gray82&quot; &quot;gray83&quot; &quot;gray84&quot; ## [238] &quot;gray85&quot; &quot;gray86&quot; &quot;gray87&quot; ## [241] &quot;gray88&quot; &quot;gray89&quot; &quot;gray90&quot; ## [244] &quot;gray91&quot; &quot;gray92&quot; &quot;gray93&quot; ## [247] &quot;gray94&quot; &quot;gray95&quot; &quot;gray96&quot; ## [250] &quot;gray97&quot; &quot;gray98&quot; &quot;gray99&quot; ## [253] &quot;gray100&quot; &quot;green&quot; &quot;green1&quot; ## [256] &quot;green2&quot; &quot;green3&quot; &quot;green4&quot; ## [259] &quot;greenyellow&quot; &quot;grey&quot; &quot;grey0&quot; ## [262] &quot;grey1&quot; &quot;grey2&quot; &quot;grey3&quot; ## [265] &quot;grey4&quot; &quot;grey5&quot; &quot;grey6&quot; ## [268] &quot;grey7&quot; &quot;grey8&quot; &quot;grey9&quot; ## [271] &quot;grey10&quot; &quot;grey11&quot; &quot;grey12&quot; ## [274] &quot;grey13&quot; &quot;grey14&quot; &quot;grey15&quot; ## [277] &quot;grey16&quot; &quot;grey17&quot; &quot;grey18&quot; ## [280] &quot;grey19&quot; &quot;grey20&quot; &quot;grey21&quot; ## [283] &quot;grey22&quot; &quot;grey23&quot; &quot;grey24&quot; ## [286] &quot;grey25&quot; &quot;grey26&quot; &quot;grey27&quot; ## [289] &quot;grey28&quot; &quot;grey29&quot; &quot;grey30&quot; ## [292] &quot;grey31&quot; &quot;grey32&quot; &quot;grey33&quot; ## [295] &quot;grey34&quot; &quot;grey35&quot; &quot;grey36&quot; ## [298] &quot;grey37&quot; &quot;grey38&quot; &quot;grey39&quot; ## [301] &quot;grey40&quot; &quot;grey41&quot; &quot;grey42&quot; ## [304] &quot;grey43&quot; &quot;grey44&quot; &quot;grey45&quot; ## [307] &quot;grey46&quot; &quot;grey47&quot; &quot;grey48&quot; ## [310] &quot;grey49&quot; &quot;grey50&quot; &quot;grey51&quot; ## [313] &quot;grey52&quot; &quot;grey53&quot; &quot;grey54&quot; ## [316] &quot;grey55&quot; &quot;grey56&quot; &quot;grey57&quot; ## [319] &quot;grey58&quot; &quot;grey59&quot; &quot;grey60&quot; ## [322] &quot;grey61&quot; &quot;grey62&quot; &quot;grey63&quot; ## [325] &quot;grey64&quot; &quot;grey65&quot; &quot;grey66&quot; ## [328] &quot;grey67&quot; &quot;grey68&quot; &quot;grey69&quot; ## [331] &quot;grey70&quot; &quot;grey71&quot; &quot;grey72&quot; ## [334] &quot;grey73&quot; &quot;grey74&quot; &quot;grey75&quot; ## [337] &quot;grey76&quot; &quot;grey77&quot; &quot;grey78&quot; ## [340] &quot;grey79&quot; &quot;grey80&quot; &quot;grey81&quot; ## [343] &quot;grey82&quot; &quot;grey83&quot; &quot;grey84&quot; ## [346] &quot;grey85&quot; &quot;grey86&quot; &quot;grey87&quot; ## [349] &quot;grey88&quot; &quot;grey89&quot; &quot;grey90&quot; ## [352] &quot;grey91&quot; &quot;grey92&quot; &quot;grey93&quot; ## [355] &quot;grey94&quot; &quot;grey95&quot; &quot;grey96&quot; ## [358] &quot;grey97&quot; &quot;grey98&quot; &quot;grey99&quot; ## [361] &quot;grey100&quot; &quot;honeydew&quot; &quot;honeydew1&quot; ## [364] &quot;honeydew2&quot; &quot;honeydew3&quot; &quot;honeydew4&quot; ## [367] &quot;hotpink&quot; &quot;hotpink1&quot; &quot;hotpink2&quot; ## [370] &quot;hotpink3&quot; &quot;hotpink4&quot; &quot;indianred&quot; ## [373] &quot;indianred1&quot; &quot;indianred2&quot; &quot;indianred3&quot; ## [376] &quot;indianred4&quot; &quot;ivory&quot; &quot;ivory1&quot; ## [379] &quot;ivory2&quot; &quot;ivory3&quot; &quot;ivory4&quot; ## [382] &quot;khaki&quot; &quot;khaki1&quot; &quot;khaki2&quot; ## [385] &quot;khaki3&quot; &quot;khaki4&quot; &quot;lavender&quot; ## [388] &quot;lavenderblush&quot; &quot;lavenderblush1&quot; &quot;lavenderblush2&quot; ## [391] &quot;lavenderblush3&quot; &quot;lavenderblush4&quot; &quot;lawngreen&quot; ## [394] &quot;lemonchiffon&quot; &quot;lemonchiffon1&quot; &quot;lemonchiffon2&quot; ## [397] &quot;lemonchiffon3&quot; &quot;lemonchiffon4&quot; &quot;lightblue&quot; ## [400] &quot;lightblue1&quot; &quot;lightblue2&quot; &quot;lightblue3&quot; ## [403] &quot;lightblue4&quot; &quot;lightcoral&quot; &quot;lightcyan&quot; ## [406] &quot;lightcyan1&quot; &quot;lightcyan2&quot; &quot;lightcyan3&quot; ## [409] &quot;lightcyan4&quot; &quot;lightgoldenrod&quot; &quot;lightgoldenrod1&quot; ## [412] &quot;lightgoldenrod2&quot; &quot;lightgoldenrod3&quot; &quot;lightgoldenrod4&quot; ## [415] &quot;lightgoldenrodyellow&quot; &quot;lightgray&quot; &quot;lightgreen&quot; ## [418] &quot;lightgrey&quot; &quot;lightpink&quot; &quot;lightpink1&quot; ## [421] &quot;lightpink2&quot; &quot;lightpink3&quot; &quot;lightpink4&quot; ## [424] &quot;lightsalmon&quot; &quot;lightsalmon1&quot; &quot;lightsalmon2&quot; ## [427] &quot;lightsalmon3&quot; &quot;lightsalmon4&quot; &quot;lightseagreen&quot; ## [430] &quot;lightskyblue&quot; &quot;lightskyblue1&quot; &quot;lightskyblue2&quot; ## [433] &quot;lightskyblue3&quot; &quot;lightskyblue4&quot; &quot;lightslateblue&quot; ## [436] &quot;lightslategray&quot; &quot;lightslategrey&quot; &quot;lightsteelblue&quot; ## [439] &quot;lightsteelblue1&quot; &quot;lightsteelblue2&quot; &quot;lightsteelblue3&quot; ## [442] &quot;lightsteelblue4&quot; &quot;lightyellow&quot; &quot;lightyellow1&quot; ## [445] &quot;lightyellow2&quot; &quot;lightyellow3&quot; &quot;lightyellow4&quot; ## [448] &quot;limegreen&quot; &quot;linen&quot; &quot;magenta&quot; ## [451] &quot;magenta1&quot; &quot;magenta2&quot; &quot;magenta3&quot; ## [454] &quot;magenta4&quot; &quot;maroon&quot; &quot;maroon1&quot; ## [457] &quot;maroon2&quot; &quot;maroon3&quot; &quot;maroon4&quot; ## [460] &quot;mediumaquamarine&quot; &quot;mediumblue&quot; &quot;mediumorchid&quot; ## [463] &quot;mediumorchid1&quot; &quot;mediumorchid2&quot; &quot;mediumorchid3&quot; ## [466] &quot;mediumorchid4&quot; &quot;mediumpurple&quot; &quot;mediumpurple1&quot; ## [469] &quot;mediumpurple2&quot; &quot;mediumpurple3&quot; &quot;mediumpurple4&quot; ## [472] &quot;mediumseagreen&quot; &quot;mediumslateblue&quot; &quot;mediumspringgreen&quot; ## [475] &quot;mediumturquoise&quot; &quot;mediumvioletred&quot; &quot;midnightblue&quot; ## [478] &quot;mintcream&quot; &quot;mistyrose&quot; &quot;mistyrose1&quot; ## [481] &quot;mistyrose2&quot; &quot;mistyrose3&quot; &quot;mistyrose4&quot; ## [484] &quot;moccasin&quot; &quot;navajowhite&quot; &quot;navajowhite1&quot; ## [487] &quot;navajowhite2&quot; &quot;navajowhite3&quot; &quot;navajowhite4&quot; ## [490] &quot;navy&quot; &quot;navyblue&quot; &quot;oldlace&quot; ## [493] &quot;olivedrab&quot; &quot;olivedrab1&quot; &quot;olivedrab2&quot; ## [496] &quot;olivedrab3&quot; &quot;olivedrab4&quot; &quot;orange&quot; ## [499] &quot;orange1&quot; &quot;orange2&quot; &quot;orange3&quot; ## [502] &quot;orange4&quot; &quot;orangered&quot; &quot;orangered1&quot; ## [505] &quot;orangered2&quot; &quot;orangered3&quot; &quot;orangered4&quot; ## [508] &quot;orchid&quot; &quot;orchid1&quot; &quot;orchid2&quot; ## [511] &quot;orchid3&quot; &quot;orchid4&quot; &quot;palegoldenrod&quot; ## [514] &quot;palegreen&quot; &quot;palegreen1&quot; &quot;palegreen2&quot; ## [517] &quot;palegreen3&quot; &quot;palegreen4&quot; &quot;paleturquoise&quot; ## [520] &quot;paleturquoise1&quot; &quot;paleturquoise2&quot; &quot;paleturquoise3&quot; ## [523] &quot;paleturquoise4&quot; &quot;palevioletred&quot; &quot;palevioletred1&quot; ## [526] &quot;palevioletred2&quot; &quot;palevioletred3&quot; &quot;palevioletred4&quot; ## [529] &quot;papayawhip&quot; &quot;peachpuff&quot; &quot;peachpuff1&quot; ## [532] &quot;peachpuff2&quot; &quot;peachpuff3&quot; &quot;peachpuff4&quot; ## [535] &quot;peru&quot; &quot;pink&quot; &quot;pink1&quot; ## [538] &quot;pink2&quot; &quot;pink3&quot; &quot;pink4&quot; ## [541] &quot;plum&quot; &quot;plum1&quot; &quot;plum2&quot; ## [544] &quot;plum3&quot; &quot;plum4&quot; &quot;powderblue&quot; ## [547] &quot;purple&quot; &quot;purple1&quot; &quot;purple2&quot; ## [550] &quot;purple3&quot; &quot;purple4&quot; &quot;red&quot; ## [553] &quot;red1&quot; &quot;red2&quot; &quot;red3&quot; ## [556] &quot;red4&quot; &quot;rosybrown&quot; &quot;rosybrown1&quot; ## [559] &quot;rosybrown2&quot; &quot;rosybrown3&quot; &quot;rosybrown4&quot; ## [562] &quot;royalblue&quot; &quot;royalblue1&quot; &quot;royalblue2&quot; ## [565] &quot;royalblue3&quot; &quot;royalblue4&quot; &quot;saddlebrown&quot; ## [568] &quot;salmon&quot; &quot;salmon1&quot; &quot;salmon2&quot; ## [571] &quot;salmon3&quot; &quot;salmon4&quot; &quot;sandybrown&quot; ## [574] &quot;seagreen&quot; &quot;seagreen1&quot; &quot;seagreen2&quot; ## [577] &quot;seagreen3&quot; &quot;seagreen4&quot; &quot;seashell&quot; ## [580] &quot;seashell1&quot; &quot;seashell2&quot; &quot;seashell3&quot; ## [583] &quot;seashell4&quot; &quot;sienna&quot; &quot;sienna1&quot; ## [586] &quot;sienna2&quot; &quot;sienna3&quot; &quot;sienna4&quot; ## [589] &quot;skyblue&quot; &quot;skyblue1&quot; &quot;skyblue2&quot; ## [592] &quot;skyblue3&quot; &quot;skyblue4&quot; &quot;slateblue&quot; ## [595] &quot;slateblue1&quot; &quot;slateblue2&quot; &quot;slateblue3&quot; ## [598] &quot;slateblue4&quot; &quot;slategray&quot; &quot;slategray1&quot; ## [601] &quot;slategray2&quot; &quot;slategray3&quot; &quot;slategray4&quot; ## [604] &quot;slategrey&quot; &quot;snow&quot; &quot;snow1&quot; ## [607] &quot;snow2&quot; &quot;snow3&quot; &quot;snow4&quot; ## [610] &quot;springgreen&quot; &quot;springgreen1&quot; &quot;springgreen2&quot; ## [613] &quot;springgreen3&quot; &quot;springgreen4&quot; &quot;steelblue&quot; ## [616] &quot;steelblue1&quot; &quot;steelblue2&quot; &quot;steelblue3&quot; ## [619] &quot;steelblue4&quot; &quot;tan&quot; &quot;tan1&quot; ## [622] &quot;tan2&quot; &quot;tan3&quot; &quot;tan4&quot; ## [625] &quot;thistle&quot; &quot;thistle1&quot; &quot;thistle2&quot; ## [628] &quot;thistle3&quot; &quot;thistle4&quot; &quot;tomato&quot; ## [631] &quot;tomato1&quot; &quot;tomato2&quot; &quot;tomato3&quot; ## [634] &quot;tomato4&quot; &quot;turquoise&quot; &quot;turquoise1&quot; ## [637] &quot;turquoise2&quot; &quot;turquoise3&quot; &quot;turquoise4&quot; ## [640] &quot;violet&quot; &quot;violetred&quot; &quot;violetred1&quot; ## [643] &quot;violetred2&quot; &quot;violetred3&quot; &quot;violetred4&quot; ## [646] &quot;wheat&quot; &quot;wheat1&quot; &quot;wheat2&quot; ## [649] &quot;wheat3&quot; &quot;wheat4&quot; &quot;whitesmoke&quot; ## [652] &quot;yellow&quot; &quot;yellow1&quot; &quot;yellow2&quot; ## [655] &quot;yellow3&quot; &quot;yellow4&quot; &quot;yellowgreen&quot; grep(&quot;blue&quot;, colors(), value=T) # 색 이름에 &quot;blue&quot;가 포함된 색들 ## [1] &quot;aliceblue&quot; &quot;blue&quot; &quot;blue1&quot; &quot;blue2&quot; ## [5] &quot;blue3&quot; &quot;blue4&quot; &quot;blueviolet&quot; &quot;cadetblue&quot; ## [9] &quot;cadetblue1&quot; &quot;cadetblue2&quot; &quot;cadetblue3&quot; &quot;cadetblue4&quot; ## [13] &quot;cornflowerblue&quot; &quot;darkblue&quot; &quot;darkslateblue&quot; &quot;deepskyblue&quot; ## [17] &quot;deepskyblue1&quot; &quot;deepskyblue2&quot; &quot;deepskyblue3&quot; &quot;deepskyblue4&quot; ## [21] &quot;dodgerblue&quot; &quot;dodgerblue1&quot; &quot;dodgerblue2&quot; &quot;dodgerblue3&quot; ## [25] &quot;dodgerblue4&quot; &quot;lightblue&quot; &quot;lightblue1&quot; &quot;lightblue2&quot; ## [29] &quot;lightblue3&quot; &quot;lightblue4&quot; &quot;lightskyblue&quot; &quot;lightskyblue1&quot; ## [33] &quot;lightskyblue2&quot; &quot;lightskyblue3&quot; &quot;lightskyblue4&quot; &quot;lightslateblue&quot; ## [37] &quot;lightsteelblue&quot; &quot;lightsteelblue1&quot; &quot;lightsteelblue2&quot; &quot;lightsteelblue3&quot; ## [41] &quot;lightsteelblue4&quot; &quot;mediumblue&quot; &quot;mediumslateblue&quot; &quot;midnightblue&quot; ## [45] &quot;navyblue&quot; &quot;powderblue&quot; &quot;royalblue&quot; &quot;royalblue1&quot; ## [49] &quot;royalblue2&quot; &quot;royalblue3&quot; &quot;royalblue4&quot; &quot;skyblue&quot; ## [53] &quot;skyblue1&quot; &quot;skyblue2&quot; &quot;skyblue3&quot; &quot;skyblue4&quot; ## [57] &quot;slateblue&quot; &quot;slateblue1&quot; &quot;slateblue2&quot; &quot;slateblue3&quot; ## [61] &quot;slateblue4&quot; &quot;steelblue&quot; &quot;steelblue1&quot; &quot;steelblue2&quot; ## [65] &quot;steelblue3&quot; &quot;steelblue4&quot; 많은 경우, 많은 대비색 또는 복수 색상의 색들을 필요로 한다. R은 이를 위해 그것들을 생성할 수 있는 미리 지정된 팔레트(palette)로 처리한다. 예를 들면, pal1 &lt;- heat.colors(5, alpha=1) # &#39;heat&#39; palette에서 5가지 색, alpha=1 -&gt; 불투명 pal2 &lt;- rainbow(5, alpha=.5) # &#39;heat&#39; palette에서 5가지 색, alpha=0.5 -&gt; 투명 plot(x=1:10, y=1:10, pch=19, cex=5, col=pal1) plot(x=1:10, y=1:10, pch=19, cex=5, col=pal2) colorRampPalette를 사용하여 그래디언트(gradient)를 생성할 수도 있다. colorRampPalette는 우리가 필요로 하는 만큼의 색들을 그 palette에서 생성하는데 사용할 수 있는 함수를 반환한다. palf &lt;- colorRampPalette(c(&quot;gray80&quot;, &quot;dark red&quot;)) plot(x=10:1, y=1:10, pch=19, cex=5, col=palf(10)) colorRampPalette에 투명도를 추가하기 위해서는 alpha=TRUE 파라미터를 사용해야 한다. palf &lt;- colorRampPalette(c(rgb(1,1,1, .2),rgb(.8,0,0, .7)), alpha=TRUE) plot(x=10:1, y=1:10, pch=19, cex=5, col=palf(10)) 2.11 R 문제 해결 지금까지 R을 사용하면서 많은 (그리고 종종 매우 창의적으로) 에러를 만드는 동안, 종종 저지르는 세 가지의 간단한 것들이 있다. 이를 정리하면 다음과 같다: 대문자(Capitalization)의 사용. R은 대소문자를 구분한다. 예를 들어, 그래프의 노드 이름으로 “Jack”과 “jack”은 다르다. 함수 rowSums는 rowsums 또는 RowSums로 사용하면 작동하지 않을 것이다. 개체 클래스(Object class). 많은 함수들이 인수로 다양한 것들을 처리할 수 있지만, 숫자 벡터 대신에 문자 벡터나 factor를 요구하거나, 또는 데이터 프레임 대신에 행렬을 요구할 수 있다. 함수들은 때때로 기대치 않은 형식으로 결과를 반활하기도 할 것이다. 패키지(Package namespaces). 종종 같은 이름을 갖는 함수들을 여러 개의 패키지가 포함하고 있을 때 문제들이 발생한다. R은 이에 대해 경고한다. “The following object(s) are masked from ‘package:igraph’ as you load a package.” 이를 처리하기 위한 한 방법은 함수를 사용할 때 ::를 이용하여 패키지를 명시하는 것이다. 예를 들어, blash() 라는 함수가 패키지 A와 패키지 B에 존재한다면, A::blash()와 B::blash() 등과 같이 함수를 호출할 수 있다. 문제가 좀 더 복잡한 다른 경우에는 패키지를 특별한 순서로 불러오거나 아니면 패키지들을 함께 사용하지 않는 것이다. 예를 들어, igraph 패키지와 statnet 패키지는 동시에 불러왔을 때 여러 문제들을 야기한다. 이때, 하나의 패키지를 불러오기 전에 다른 패키지를 detach() 함수로 메모리에서 제거하는 것이 최상의 방법이다. library(igraph) # 패키지 불러오기 ## ## Attaching package: &#39;igraph&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## decompose, spectrum ## The following object is masked from &#39;package:base&#39;: ## ## union detach(package:igraph) # 패키지 메모리에서 제거하기 보다 더 많은 문제해결을 위해서는, try(), tryCatch(), 그리고 debug() 등을 이용할 수 있다. "],["Networks-in-igraph.html", "Chapter 3 igraph를 이용한 네트워크 3.1 네트워크 생성(Create networks) 3.2 에지(Edge), 정점(vertex), 그리고 네트워크 속성(network attributes) 3.3 특수 그래프(Specific graphs)와 그래프 모델(graph models)", " Chapter 3 igraph를 이용한 네트워크 rm(list = ls()) # 지금까지 생성한 모든 개체를 메모리에서 제거 library(igraph) # igraph 패키지 불러오기 ## ## Attaching package: &#39;igraph&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## decompose, spectrum ## The following object is masked from &#39;package:base&#39;: ## ## union 3.1 네트워크 생성(Create networks) 다음의 코드는 세 개의 에지(edge)를 갖는 무방향 그래프(undirected graph)를 생성한다. 정점(vertex, 노드) 안의 숫자들은 정점의 ID로 해석되며, 따라서 에지들은 1–&gt;2, 2–&gt;3, 3–&gt;1 이다. g1 &lt;- graph( edges=c(1,2, 2,3, 3, 1), n=3, directed=F ) plot(g1) # 단순한 네트워크 그림 class(g1) ## [1] &quot;igraph&quot; g1 ## IGRAPH 90110f8 U--- 3 3 -- ## + edges from 90110f8: ## [1] 1--2 2--3 1--3 # 10개의 노드와 기본 값으로 방향성 네트워크 g2 &lt;- graph( edges=c(1,2, 2,3, 3, 1), n=10 ) plot(g2) g2 ## IGRAPH 90127fd D--- 10 3 -- ## + edges from 90127fd: ## [1] 1-&gt;2 2-&gt;3 3-&gt;1 g3 &lt;- graph( c(&quot;John&quot;, &quot;Jim&quot;, &quot;Jim&quot;, &quot;Jill&quot;, &quot;Jill&quot;, &quot;John&quot;)) # named vertices plot(g3) g3 ## IGRAPH 901c1d6 DN-- 3 3 -- ## + attr: name (v/c) ## + edges from 901c1d6 (vertex names): ## [1] John-&gt;Jim Jim -&gt;Jill Jill-&gt;John g4 &lt;- graph( c(&quot;John&quot;, &quot;Jim&quot;, &quot;Jim&quot;, &quot;Jack&quot;, &quot;Jim&quot;, &quot;Jack&quot;, &quot;John&quot;, &quot;John&quot;), isolates=c(&quot;Jesse&quot;, &quot;Janis&quot;, &quot;Jennifer&quot;, &quot;Justin&quot;) ) # In named graphs we can specify isolates by providing a list of their names. plot(g4, edge.arrow.size=.5, vertex.color=&quot;gold&quot;, vertex.size=15, vertex.frame.color=&quot;gray&quot;, vertex.label.color=&quot;black&quot;, vertex.label.cex=0.8, vertex.label.dist=2, edge.curved=0.2) 소규모의 그래프는 무방향 연결을 나타내는-, 왼쪽과 오른쪽을 나타내는 방향성 표현을 위한 +- 또는 -+ , 대칭형 연결을 위한 ++ 그리고 정점의 집합을 위한 “:” 등의 설명으로 생성할 수 있다. plot(graph_from_literal(a---b, b---c)) # -의 갯수는 문제가 안됨 plot(graph_from_literal(a--+b, b+--c)) plot(graph_from_literal(a+-+b, b+-+c)) plot(graph_from_literal(a:b:c---c:d:e)) gl &lt;- graph_from_literal(a-b-c-d-e-f, a-g-h-b, h-e:f:i, j) plot(gl) 3.2 에지(Edge), 정점(vertex), 그리고 네트워크 속성(network attributes) 정점과 에지 접근 : E(g4) # 개체 g4의 에지들 ## + 4/4 edges from 9021dcb (vertex names): ## [1] John-&gt;Jim Jim -&gt;Jack Jim -&gt;Jack John-&gt;John V(g4) # 개체 g4의 정점들 ## + 7/7 vertices, named, from 9021dcb: ## [1] John Jim Jack Jesse Janis Jennifer Justin 또한 네트워크 행렬(network matrix)을 직접 검토할 수 있다 : g4[] ## 7 x 7 sparse Matrix of class &quot;dgCMatrix&quot; ## John Jim Jack Jesse Janis Jennifer Justin ## John 1 1 . . . . . ## Jim . . 2 . . . . ## Jack . . . . . . . ## Jesse . . . . . . . ## Janis . . . . . . . ## Jennifer . . . . . . . ## Justin . . . . . . . g4[1,] ## John Jim Jack Jesse Janis Jennifer Justin ## 1 1 0 0 0 0 0 네트워크 속성, 정점들 그리고 에지들 추가하기 : V(g4)$name # 네트워크 생성시 자동으로 생성됨. ## [1] &quot;John&quot; &quot;Jim&quot; &quot;Jack&quot; &quot;Jesse&quot; &quot;Janis&quot; &quot;Jennifer&quot; &quot;Justin&quot; V(g4)$gender &lt;- c(&quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;) E(g4)$type &lt;- &quot;email&quot; # 에지의 속성 모든 에지에 &quot;email&quot; 할당 E(g4)$weight &lt;- 10 # 에지의 가중치, 모든 기존 에지에 10으로 설정 속성의 확인 : edge_attr(g4) # 에지의 속성 확인 ## $type ## [1] &quot;email&quot; &quot;email&quot; &quot;email&quot; &quot;email&quot; ## ## $weight ## [1] 10 10 10 10 vertex_attr(g4) # 정점의 속성 확인 ## $name ## [1] &quot;John&quot; &quot;Jim&quot; &quot;Jack&quot; &quot;Jesse&quot; &quot;Janis&quot; &quot;Jennifer&quot; &quot;Justin&quot; ## ## $gender ## [1] &quot;male&quot; &quot;male&quot; &quot;male&quot; &quot;male&quot; &quot;female&quot; &quot;female&quot; &quot;male&quot; graph_attr(g4) # 네트워크 속성 확인 ## named list() 속성 설정 방법 (비슷하게 set_edge_attr(), set_vertex_attr(), 등을 사용) : g4 &lt;- set_graph_attr(g4, &quot;name&quot;, &quot;Email Network&quot;) g4 &lt;- set_graph_attr(g4, &quot;something&quot;, &quot;A thing&quot;) graph_attr_names(g4) ## [1] &quot;name&quot; &quot;something&quot; graph_attr(g4, &quot;name&quot;) ## [1] &quot;Email Network&quot; graph_attr(g4) ## $name ## [1] &quot;Email Network&quot; ## ## $something ## [1] &quot;A thing&quot; g4 &lt;- delete_graph_attr(g4, &quot;something&quot;) graph_attr(g4) ## $name ## [1] &quot;Email Network&quot; plot(g4, edge.arrow.size=.5, vertex.label.color=&quot;black&quot;, vertex.label.dist=1.5, vertex.color=c( &quot;pink&quot;, &quot;skyblue&quot;)[1+(V(g4)$gender==&quot;male&quot;)] ) 그래프 g4는 Jim에서 Jack으로 두 개의 에지를 가지고 있으며, John은 자신에게로 향하는 루프(loop)를 가지고 있다. 그래프에서 루프를 제거하고 같은 노드 사이의 복수개의 에지들을 제거하여 그래프를 단순화할 수 있다. 에지 속성들이 어떻게 결합되는지를 나타내기 위해 edge.attr.comb 을 사용한다. 가능한 옵션은 sum, mean, prod (product), min, max, first/last (첫/마지막 에지 속성 선택) 등을 포함한다. “type = ignore” 옵션은 속성이 무시되거나 제거되어야 함을 의미한다. g4s &lt;- simplify( g4, remove.multiple = T, remove.loops = F, edge.attr.comb=c(weight=&quot;sum&quot;, type=&quot;ignore&quot;) ) plot(g4s, vertex.label.dist=1.5) g4s ## IGRAPH 9130c66 DNW- 7 3 -- Email Network ## + attr: name (g/c), name (v/c), gender (v/c), weight (e/n) ## + edges from 9130c66 (vertex names): ## [1] John-&gt;John John-&gt;Jim Jim -&gt;Jack igraph 개체의 설명은 4 가지 글자로 시작한다. D 또는 U : 방향성 또는 무방향성 그래프 N : 명명된 그래프(노드가 name 속성을 가짐) W : 가중 그래프(에지들이 weight 속성을 가짐) B : 이분할 (bipartite; two-mode) 그래프(노드들이 type 속성을 가짐) 그래프에서 (7 5) 와 같은 두 숫자는 노드와 에지의 수를 의미한다. 설명은 또한 노드와 에지의 속성을 나열한다. 예를 들어, (g/c) - 그래프 수준의 문자 속성 (v/c) - 정점 수준의 문자 속성 (e/n) - 에지 수준의 숫자 속성 3.3 특수 그래프(Specific graphs)와 그래프 모델(graph models) 빈 그래프(Empty graph) eg &lt;- make_empty_graph(40) plot(eg, vertex.size=10, vertex.label=NA) 완전 그래프(Full graph) fg &lt;- make_full_graph(40) plot(fg, vertex.size=10, vertex.label=NA) 단순 성형 그래프(Simple star graph) st &lt;- make_star(40) plot(st, vertex.size=10, vertex.label=NA) 나무형 그래프(Tree graph) tr &lt;- make_tree(40, children = 3, mode = &quot;undirected&quot;) plot(tr, vertex.size=10, vertex.label=NA) 환형 그래프(Ring graph) rn &lt;- make_ring(40) plot(rn, vertex.size=10, vertex.label=NA) Erdos-Renyi random graph model (‘n’ : 노드의 갯수, ‘m’ : 에지의 갯수). [참고자료 : http://sanghyukchun.github.io/50/] er &lt;- sample_gnm(n=100, m=40) plot(er, vertex.size=6, vertex.label=NA) Watts-Strogatz small-world model (dim 차원과 size 차원의 노드의 수를 갖는) lattice를 생성하고, 확률 p로 무작위로 에지를 연결한다. 에지가 연결된 이웃들은 nei이다. loops 와 다중(multiple) 에지를 허용할 수 있다. [참고자료 : http://sanghyukchun.github.io/51/] sw &lt;- sample_smallworld(dim=2, size=10, nei=1, p=0.1) plot(sw, vertex.size=6, vertex.label=NA, layout=layout_in_circle) Barabasi-Albert preferential attachment model for scale-free graphs (n : 노드의 갯수, power 제곱승 (1은 선형); m 각 시간 단계에 추가되는 에지의 갯수) [참고자료 : http://sanghyukchun.github.io/52/] ba &lt;- sample_pa(n=100, power=1, m=1, directed=F) plot(ba, vertex.size=6, vertex.label=NA) igraph 는 몇가지 주목할 만한 역사적인 그래프를 제공할 수 있다. 예를 들어, zach &lt;- graph(&quot;Zachary&quot;) # the Zachary carate club plot(zach, vertex.size=10, vertex.label=NA) Rewiring a graph each_edge() 은 확률 prob으로 일양분포하는 에지의 끝단을 변경하는 재연결 방법이다. rn.rewired &lt;- rewire(rn, each_edge(prob=0.1)) plot(rn.rewired, vertex.size=10, vertex.label=NA) 특정 거리에서 정점들을 다른 정점들과 연결하기 위한 리와이어. rn.neigh = connect.neighborhood(rn, 5) plot(rn.neigh, vertex.size=8, vertex.label=NA) 그래프의 결합(분리된 정점 집합을 가정한 상호배제 합집합(disjoint union) ) : %du% plot(rn, vertex.size=10, vertex.label=NA) plot(tr, vertex.size=10, vertex.label=NA) plot(rn %du% tr, vertex.size=10, vertex.label=NA) "],["Reading-Network-Data-Files.html", "Chapter 4 파일로 부터 네트워크 데이터 읽어오기 4.1 데이터 세트 1: 에지 목록(edgelist) 4.2 데이터 세트 2: 인접 행렬(adjacent matrix)", " Chapter 4 파일로 부터 네트워크 데이터 읽어오기 다음의 절에서는 두 개의 소규모 예제 데이터 세트를 가지고 주로 작업할 것이다. 이 데이터 세트들은 미디어 조직에 대한 데이터를 포함하고 있다. 하나는 새로운 소스들 사이의 하이퍼링크와 언급의 네트워크를 포함하고 있다. 또 다른 하나는 미디어 발생지와 소비자들 사이의 링크 네트워크이다. 여기서 사용되는 예제 데이터는 비록 규모가 작기는 하지만, 우리가 생성하는 분석과 시각화의 많은 아이디어들이 중간규모와 대규모의 네트워크에 적용될 수 있다. 4.1 데이터 세트 1: 에지 목록(edgelist) 우리가 사용할 첫 번째 데이터 세트는 “Media-Example-NODES.csv”와 “Media-Example-EDGES.csv”두 개의 파일로 구성된다 (download here). nodes &lt;- read.csv(&quot;Dataset1-Media-Example-NODES.csv&quot;, header=T, as.is=T) links &lt;- read.csv(&quot;Dataset1-Media-Example-EDGES.csv&quot;, header=T, as.is=T) 데이터 내용을 살펴보자 : head(nodes) ## id media media.type type.label audience.size ## 1 s01 NY Times 1 Newspaper 20 ## 2 s02 Washington Post 1 Newspaper 25 ## 3 s03 Wall Street Journal 1 Newspaper 30 ## 4 s04 USA Today 1 Newspaper 32 ## 5 s05 LA Times 1 Newspaper 20 ## 6 s06 New York Post 1 Newspaper 50 head(links) ## from to weight type ## 1 s01 s02 10 hyperlink ## 2 s01 s02 12 hyperlink ## 3 s01 s03 22 hyperlink ## 4 s01 s04 21 hyperlink ## 5 s04 s11 22 mention ## 6 s05 s15 21 mention nrow(nodes); length(unique(nodes$id)) ## [1] 17 ## [1] 17 nrow(links); nrow(unique(links[,c(&quot;from&quot;, &quot;to&quot;)])) ## [1] 52 ## [1] 49 from-to 조합의 단일값 보다 더 많은 링크가 있음에 주목하라. 동일한 두 개의 노드 사이에 복수개의 링크가 있는 예가 있음을 의미한다. 동일한 노드 사이의 동일 유형의 모든 링크는 from, to, 그리고 type 별로 aggregate() 함수를 사용하여 그들의 가중치를 합해 줌으로써 없애 줄 것이다. 여기서 우리는 서로 다른 링크 유형을 없애지 않기 위해 simplify() 함수를 사용하지 않는다. links &lt;- aggregate(links[,3], links[,-3], sum) links &lt;- links[order(links$from, links$to),] colnames(links)[4] &lt;- &quot;weight&quot; rownames(links) &lt;- NULL 4.2 데이터 세트 2: 인접 행렬(adjacent matrix) 이분할 그래프(Two-mode or bipartite graphs)는 두 개의 서로 다른 유형의 actor와 상호간의 링크를 가지지만, 각 유형 내에서는 그렇지 않다. 두 번째 미디어 예제는 이런 종류의 네트워크로 뉴스 출처와 그들 소비자 간의 링크를 검토한다. nodes2 &lt;- read.csv(&quot;Dataset2-Media-User-Example-NODES.csv&quot;, header=T, as.is=T) links2 &lt;- read.csv(&quot;Dataset2-Media-User-Example-EDGES.csv&quot;, header=T, row.names=1) 데이터 검토: head(nodes2) ## id media media.type media.name audience.size ## 1 s01 NYT 1 Newspaper 20 ## 2 s02 WaPo 1 Newspaper 25 ## 3 s03 WSJ 1 Newspaper 30 ## 4 s04 USAT 1 Newspaper 32 ## 5 s05 LATimes 1 Newspaper 20 ## 6 s06 CNN 2 TV 56 head(links2) ## U01 U02 U03 U04 U05 U06 U07 U08 U09 U10 U11 U12 U13 U14 U15 U16 U17 U18 U19 ## s01 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## s02 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## s03 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 ## s04 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 ## s05 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 ## s06 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 ## U20 ## s01 0 ## s02 1 ## s03 0 ## s04 0 ## s05 0 ## s06 0 우리는 links2가 이분할 네트워크의 인접행렬(adjacent matrix)임을 알 수 있다. links2 &lt;- as.matrix(links2) dim(links2) ## [1] 10 20 dim(nodes2) ## [1] 30 5 "],["Turning-Networks-into-Igraph.html", "Chapter 5 네트워크를 igraph 개체로 변환하기 5.1 데이터 세트 1 5.2 데이터 세트 2", " Chapter 5 네트워크를 igraph 개체로 변환하기 원 데이터를 igraph 네트워크 개체로 변환하면서 시작한다. 여기서는 d와 vertices라는 두 개의 데이터 프레임을 취하는 graph.data.frame() 함수를 사용한다. 이 함수의 주요 인수는 다음과 같다. d는 네트워크의 에지들을 서술한다. 첫 두 개의 열은 각 에지의 소스와 대상 노드의 ID 들이다. 다음의 열들은 에지 속성(weight, type, label, 또는 그 밖의 속성)들이다. vertices 는 노드 ID들의 열로 시작한다. 이어지는 열들은 노드의 속성들로 해석된다. 5.1 데이터 세트 1 library(igraph) net &lt;- graph_from_data_frame(d=links, vertices=nodes, directed=T) class(net) ## [1] &quot;igraph&quot; net ## IGRAPH 9239b68 DNW- 17 49 -- ## + attr: name (v/c), media (v/c), media.type (v/n), type.label (v/c), ## | audience.size (v/n), type (e/c), weight (e/n) ## + edges from 9239b68 (vertex names): ## [1] s01-&gt;s02 s01-&gt;s03 s01-&gt;s04 s01-&gt;s15 s02-&gt;s01 s02-&gt;s03 s02-&gt;s09 s02-&gt;s10 ## [9] s03-&gt;s01 s03-&gt;s04 s03-&gt;s05 s03-&gt;s08 s03-&gt;s10 s03-&gt;s11 s03-&gt;s12 s04-&gt;s03 ## [17] s04-&gt;s06 s04-&gt;s11 s04-&gt;s12 s04-&gt;s17 s05-&gt;s01 s05-&gt;s02 s05-&gt;s09 s05-&gt;s15 ## [25] s06-&gt;s06 s06-&gt;s16 s06-&gt;s17 s07-&gt;s03 s07-&gt;s08 s07-&gt;s10 s07-&gt;s14 s08-&gt;s03 ## [33] s08-&gt;s07 s08-&gt;s09 s09-&gt;s10 s10-&gt;s03 s12-&gt;s06 s12-&gt;s13 s12-&gt;s14 s13-&gt;s12 ## [41] s13-&gt;s17 s14-&gt;s11 s14-&gt;s13 s15-&gt;s01 s15-&gt;s04 s15-&gt;s06 s16-&gt;s06 s16-&gt;s17 ## [49] s17-&gt;s04 우리는 다음과 같이 노드, 에지 그리고 속성들에 쉽게 접근할 수 있다. E(net) # &quot;net&quot; 개체의 에지들 ## + 49/49 edges from 9239b68 (vertex names): ## [1] s01-&gt;s02 s01-&gt;s03 s01-&gt;s04 s01-&gt;s15 s02-&gt;s01 s02-&gt;s03 s02-&gt;s09 s02-&gt;s10 ## [9] s03-&gt;s01 s03-&gt;s04 s03-&gt;s05 s03-&gt;s08 s03-&gt;s10 s03-&gt;s11 s03-&gt;s12 s04-&gt;s03 ## [17] s04-&gt;s06 s04-&gt;s11 s04-&gt;s12 s04-&gt;s17 s05-&gt;s01 s05-&gt;s02 s05-&gt;s09 s05-&gt;s15 ## [25] s06-&gt;s06 s06-&gt;s16 s06-&gt;s17 s07-&gt;s03 s07-&gt;s08 s07-&gt;s10 s07-&gt;s14 s08-&gt;s03 ## [33] s08-&gt;s07 s08-&gt;s09 s09-&gt;s10 s10-&gt;s03 s12-&gt;s06 s12-&gt;s13 s12-&gt;s14 s13-&gt;s12 ## [41] s13-&gt;s17 s14-&gt;s11 s14-&gt;s13 s15-&gt;s01 s15-&gt;s04 s15-&gt;s06 s16-&gt;s06 s16-&gt;s17 ## [49] s17-&gt;s04 V(net) # &quot;net&quot; 개체의 정점들 ## + 17/17 vertices, named, from 9239b68: ## [1] s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 s13 s14 s15 s16 s17 E(net)$type # 에지 속성 &quot;type&quot; ## [1] &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;mention&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; ## [7] &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; ## [13] &quot;mention&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;mention&quot; &quot;mention&quot; ## [19] &quot;hyperlink&quot; &quot;mention&quot; &quot;mention&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;mention&quot; ## [25] &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;mention&quot; &quot;mention&quot; &quot;mention&quot; &quot;hyperlink&quot; ## [31] &quot;mention&quot; &quot;hyperlink&quot; &quot;mention&quot; &quot;mention&quot; &quot;mention&quot; &quot;hyperlink&quot; ## [37] &quot;mention&quot; &quot;hyperlink&quot; &quot;mention&quot; &quot;hyperlink&quot; &quot;mention&quot; &quot;mention&quot; ## [43] &quot;mention&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;hyperlink&quot; &quot;mention&quot; ## [49] &quot;hyperlink&quot; V(net)$media # 정점 속성 &quot;media&quot; ## [1] &quot;NY Times&quot; &quot;Washington Post&quot; &quot;Wall Street Journal&quot; ## [4] &quot;USA Today&quot; &quot;LA Times&quot; &quot;New York Post&quot; ## [7] &quot;CNN&quot; &quot;MSNBC&quot; &quot;FOX News&quot; ## [10] &quot;ABC&quot; &quot;BBC&quot; &quot;Yahoo News&quot; ## [13] &quot;Google News&quot; &quot;Reuters.com&quot; &quot;NYTimes.com&quot; ## [16] &quot;WashingtonPost.com&quot; &quot;AOL.com&quot; 이제 igraph 네트워크 개체가 마련되었다. 이를 그림으로 시각해 보기로 한다. plot(net, edge.arrow.size=.4,vertex.label=NA) 그렇게 멋져 보이지는 않는다. 그래프 내의 loop를 제거해서 수정해 보기로 한다. net &lt;- simplify(net, remove.multiple = F, remove.loops = T) simplify() 함수를 이용하여 simplify(net, edge.attr.comb=list(weight=\"sum\",\"ignore\"))와 같은 명령을 이용하여 복수 개의 에지들의 가중치를 합함으로써 복수 개의 에지들을 결합할 수 있음을 알게 될 것이다. 문제는 이것이 복수의 에지 유형들(이 데이터에서는 “hyperlinks”와 “mentions”)도 결합하게 된다는 것이다. 이 유형들이 필요하다면, igraph 네트워크로 부터 에지 목록(edge list)이나 인접 행렬(adjacent matrix)을 추출할 수 있다. as_edgelist(net, names=T) ## [,1] [,2] ## [1,] &quot;s01&quot; &quot;s02&quot; ## [2,] &quot;s01&quot; &quot;s03&quot; ## [3,] &quot;s01&quot; &quot;s04&quot; ## [4,] &quot;s01&quot; &quot;s15&quot; ## [5,] &quot;s02&quot; &quot;s01&quot; ## [6,] &quot;s02&quot; &quot;s03&quot; ## [7,] &quot;s02&quot; &quot;s09&quot; ## [8,] &quot;s02&quot; &quot;s10&quot; ## [9,] &quot;s03&quot; &quot;s01&quot; ## [10,] &quot;s03&quot; &quot;s04&quot; ## [11,] &quot;s03&quot; &quot;s05&quot; ## [12,] &quot;s03&quot; &quot;s08&quot; ## [13,] &quot;s03&quot; &quot;s10&quot; ## [14,] &quot;s03&quot; &quot;s11&quot; ## [15,] &quot;s03&quot; &quot;s12&quot; ## [16,] &quot;s04&quot; &quot;s03&quot; ## [17,] &quot;s04&quot; &quot;s06&quot; ## [18,] &quot;s04&quot; &quot;s11&quot; ## [19,] &quot;s04&quot; &quot;s12&quot; ## [20,] &quot;s04&quot; &quot;s17&quot; ## [21,] &quot;s05&quot; &quot;s01&quot; ## [22,] &quot;s05&quot; &quot;s02&quot; ## [23,] &quot;s05&quot; &quot;s09&quot; ## [24,] &quot;s05&quot; &quot;s15&quot; ## [25,] &quot;s06&quot; &quot;s16&quot; ## [26,] &quot;s06&quot; &quot;s17&quot; ## [27,] &quot;s07&quot; &quot;s03&quot; ## [28,] &quot;s07&quot; &quot;s08&quot; ## [29,] &quot;s07&quot; &quot;s10&quot; ## [30,] &quot;s07&quot; &quot;s14&quot; ## [31,] &quot;s08&quot; &quot;s03&quot; ## [32,] &quot;s08&quot; &quot;s07&quot; ## [33,] &quot;s08&quot; &quot;s09&quot; ## [34,] &quot;s09&quot; &quot;s10&quot; ## [35,] &quot;s10&quot; &quot;s03&quot; ## [36,] &quot;s12&quot; &quot;s06&quot; ## [37,] &quot;s12&quot; &quot;s13&quot; ## [38,] &quot;s12&quot; &quot;s14&quot; ## [39,] &quot;s13&quot; &quot;s12&quot; ## [40,] &quot;s13&quot; &quot;s17&quot; ## [41,] &quot;s14&quot; &quot;s11&quot; ## [42,] &quot;s14&quot; &quot;s13&quot; ## [43,] &quot;s15&quot; &quot;s01&quot; ## [44,] &quot;s15&quot; &quot;s04&quot; ## [45,] &quot;s15&quot; &quot;s06&quot; ## [46,] &quot;s16&quot; &quot;s06&quot; ## [47,] &quot;s16&quot; &quot;s17&quot; ## [48,] &quot;s17&quot; &quot;s04&quot; as_adjacency_matrix(net, attr=&quot;weight&quot;) ## 17 x 17 sparse Matrix of class &quot;dgCMatrix&quot; ## [[ suppressing 17 column names &#39;s01&#39;, &#39;s02&#39;, &#39;s03&#39; ... ]] ## ## s01 . 22 22 21 . . . . . . . . . . 20 . . ## s02 23 . 21 . . . . . 1 5 . . . . . . . ## s03 21 . . 22 1 . . 4 . 2 1 1 . . . . . ## s04 . . 23 . . 1 . . . . 22 3 . . . . 2 ## s05 1 21 . . . . . . 2 . . . . . 21 . . ## s06 . . . . . . . . . . . . . . . 21 21 ## s07 . . 1 . . . . 22 . 21 . . . 4 . . . ## s08 . . 2 . . . 21 . 23 . . . . . . . . ## s09 . . . . . . . . . 21 . . . . . . . ## s10 . . 2 . . . . . . . . . . . . . . ## s11 . . . . . . . . . . . . . . . . . ## s12 . . . . . 2 . . . . . . 22 22 . . . ## s13 . . . . . . . . . . . 21 . . . . 1 ## s14 . . . . . . . . . . 1 . 21 . . . . ## s15 22 . . 1 . 4 . . . . . . . . . . . ## s16 . . . . . 23 . . . . . . . . . . 21 ## s17 . . . 4 . . . . . . . . . . . . . 또는 데이터 프레임으로 노드와 에지를 설명할 수 있다. as_data_frame(net, what=&quot;edges&quot;) ## from to type weight ## 1 s01 s02 hyperlink 22 ## 2 s01 s03 hyperlink 22 ## 3 s01 s04 hyperlink 21 ## 4 s01 s15 mention 20 ## 5 s02 s01 hyperlink 23 ## 6 s02 s03 hyperlink 21 ## 7 s02 s09 hyperlink 1 ## 8 s02 s10 hyperlink 5 ## 9 s03 s01 hyperlink 21 ## 10 s03 s04 hyperlink 22 ## 11 s03 s05 hyperlink 1 ## 12 s03 s08 hyperlink 4 ## 13 s03 s10 mention 2 ## 14 s03 s11 hyperlink 1 ## 15 s03 s12 hyperlink 1 ## 16 s04 s03 hyperlink 23 ## 17 s04 s06 mention 1 ## 18 s04 s11 mention 22 ## 19 s04 s12 hyperlink 3 ## 20 s04 s17 mention 2 ## 21 s05 s01 mention 1 ## 22 s05 s02 hyperlink 21 ## 23 s05 s09 hyperlink 2 ## 24 s05 s15 mention 21 ## 25 s06 s16 hyperlink 21 ## 26 s06 s17 mention 21 ## 27 s07 s03 mention 1 ## 28 s07 s08 mention 22 ## 29 s07 s10 hyperlink 21 ## 30 s07 s14 mention 4 ## 31 s08 s03 hyperlink 2 ## 32 s08 s07 mention 21 ## 33 s08 s09 mention 23 ## 34 s09 s10 mention 21 ## 35 s10 s03 hyperlink 2 ## 36 s12 s06 mention 2 ## 37 s12 s13 hyperlink 22 ## 38 s12 s14 mention 22 ## 39 s13 s12 hyperlink 21 ## 40 s13 s17 mention 1 ## 41 s14 s11 mention 1 ## 42 s14 s13 mention 21 ## 43 s15 s01 hyperlink 22 ## 44 s15 s04 hyperlink 1 ## 45 s15 s06 hyperlink 4 ## 46 s16 s06 hyperlink 23 ## 47 s16 s17 mention 21 ## 48 s17 s04 hyperlink 4 as_data_frame(net, what=&quot;vertices&quot;) ## name media media.type type.label audience.size ## s01 s01 NY Times 1 Newspaper 20 ## s02 s02 Washington Post 1 Newspaper 25 ## s03 s03 Wall Street Journal 1 Newspaper 30 ## s04 s04 USA Today 1 Newspaper 32 ## s05 s05 LA Times 1 Newspaper 20 ## s06 s06 New York Post 1 Newspaper 50 ## s07 s07 CNN 2 TV 56 ## s08 s08 MSNBC 2 TV 34 ## s09 s09 FOX News 2 TV 60 ## s10 s10 ABC 2 TV 23 ## s11 s11 BBC 2 TV 34 ## s12 s12 Yahoo News 3 Online 33 ## s13 s13 Google News 3 Online 23 ## s14 s14 Reuters.com 3 Online 12 ## s15 s15 NYTimes.com 3 Online 24 ## s16 s16 WashingtonPost.com 3 Online 28 ## s17 s17 AOL.com 3 Online 33 5.2 데이터 세트 2 앞에서 살펴본 바와 같이, 이번에는 네트워크의 에지들이 행렬 형태로 되어 있다. 이러한 데이터를 graph_from_incidence_matrix() 함수를 이용하여, 그래프 개체로 읽어 들일 수 있다. igraph에서 이분할 네트워크는 정점들에 대해 한 모드에서는 FALSE(또는 0) 값을 갖고 또 다른 모드에서는 TRUE(또는 1)값을 갖는 type이라 불리는 속성을 갖는다. head(nodes2) ## id media media.type media.name audience.size ## 1 s01 NYT 1 Newspaper 20 ## 2 s02 WaPo 1 Newspaper 25 ## 3 s03 WSJ 1 Newspaper 30 ## 4 s04 USAT 1 Newspaper 32 ## 5 s05 LATimes 1 Newspaper 20 ## 6 s06 CNN 2 TV 56 head(links2) ## U01 U02 U03 U04 U05 U06 U07 U08 U09 U10 U11 U12 U13 U14 U15 U16 U17 U18 U19 ## s01 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## s02 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## s03 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 ## s04 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 ## s05 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 ## s06 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 ## U20 ## s01 0 ## s02 1 ## s03 0 ## s04 0 ## s05 0 ## s06 0 net2 &lt;- graph_from_incidence_matrix(links2) table(V(net2)$type) ## ## FALSE TRUE ## 10 20 1 모드 네트워크를 igraph 개체로 변환하기 위해서는 대신에 graph_from_adjacency_matrix() 함수를 사용한다. [참고자료 : 1-mode 네트워크 : https://yjkim81.wordpress.com/network-data_1mode/] 또한 2 모드 네트워크에 대한 이분할 프로젝션을 쉽게 생성할 수 있다. (공동 멤버십은 네트워크 행렬과 그 전치 행렬을 곱함으로써 또는 igraph의 bipartite.projection() 함수를 사용함으로써 쉽게 계산할 수 있다.) [참고자료 : 2-mode 네트워크 : https://yjkim81.wordpress.com/network-data-2-mode/] net2.bp &lt;- bipartite.projection(net2) 또한 손으로도 프로젝션을 계산할 수 있다. as_incidence_matrix(net2) %*% t(as_incidence_matrix(net2)) ## s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 ## s01 3 0 0 0 0 0 0 0 0 1 ## s02 0 3 0 0 0 0 0 0 1 0 ## s03 0 0 4 1 0 0 0 0 1 0 ## s04 0 0 1 3 1 0 0 0 0 1 ## s05 0 0 0 1 3 1 0 0 0 1 ## s06 0 0 0 0 1 3 1 1 0 0 ## s07 0 0 0 0 0 1 3 1 0 0 ## s08 0 0 0 0 0 1 1 4 1 0 ## s09 0 1 1 0 0 0 0 1 3 0 ## s10 1 0 0 1 1 0 0 0 0 2 t(as_incidence_matrix(net2)) %*% as_incidence_matrix(net2) ## U01 U02 U03 U04 U05 U06 U07 U08 U09 U10 U11 U12 U13 U14 U15 U16 U17 U18 U19 ## U01 2 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 ## U02 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## U03 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## U04 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## U05 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## U06 0 0 0 0 0 2 1 1 1 0 0 0 0 0 0 0 0 0 1 ## U07 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 ## U08 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 ## U09 0 0 0 0 0 1 1 1 2 1 1 0 0 0 0 0 0 0 0 ## U10 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 ## U11 1 0 0 0 0 0 0 0 1 1 3 1 1 0 0 0 0 0 0 ## U12 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 ## U13 0 0 0 0 0 0 0 0 0 0 1 1 2 1 0 0 1 0 0 ## U14 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 1 1 0 0 ## U15 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 ## U16 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 1 1 1 ## U17 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 2 1 1 ## U18 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 ## U19 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 1 2 ## U20 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 ## U20 ## U01 0 ## U02 0 ## U03 0 ## U04 1 ## U05 1 ## U06 1 ## U07 0 ## U08 0 ## U09 0 ## U10 0 ## U11 0 ## U12 0 ## U13 0 ## U14 0 ## U15 0 ## U16 0 ## U17 0 ## U18 0 ## U19 1 ## U20 2 plot(net2.bp$proj1, vertex.label.color=&quot;black&quot;, vertex.label.dist=1, vertex.size=7, vertex.label=nodes2$media[!is.na(nodes2$media.type)]) plot(net2.bp$proj2, vertex.label.color=&quot;black&quot;, vertex.label.dist=1, vertex.size=7, vertex.label=nodes2$media[ is.na(nodes2$media.type)]) "],["Plotting-Networks-with-Igraph.html", "Chapter 6 igraph를 이용한 네트워크 시각화 Plotting parameters 6.1 Network layouts 6.2 네트워크 시각화 개선 6.3 tkplot 패키지를 이용한 상호대화식 시각화 6.4 다른 네트워크 시각화 방법 6.5 igraph로 2-모드 네트워크 시각화하기 참고자료", " Chapter 6 igraph를 이용한 네트워크 시각화 네트워크의 시각화는 설정할 수 있는 다양한 파라미터들을 가지고 있다. 여기에는 (vertex.으로 시작하는) 노드 옵션들과 (edge.으로 시작하는) 에지 옵션들을 포함한다. 일부의 옵션 목록은 다음과 같으며, 더 많은 정보는 ?igraph.plotting로 확인할 수 있다. ? igraph.plotting ## starting httpd help server ... done igraph의 플로팅 파라미터들은 다음과 같다. Plotting parameters NODES vertex.color Node color vertex.frame.color Node border color vertex.shape One of “none,” “circle,” “square,” “csquare,” “rectangle” “crectangle,” “vrectangle,” “pie,” “raster,” or “sphere” vertex.size Size of the node (default is 15) vertex.size2 The second size of the node (e.g. for a rectangle) vertex.label Character vector used to label the nodes vertex.label.family Font family of the label (e.g.“Times,” “Helvetica”) vertex.label.font Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol vertex.label.cex Font size (multiplication factor, device-dependent) vertex.label.dist Distance between the label and the vertex vertex.label.degree The position of the label in relation to the vertex, where 0 right, “pi” is left, “pi/2” is below, and “-pi/2” is above EDGES edge.color Edge color edge.width Edge width, defaults to 1 edge.arrow.size Arrow size, defaults to 1 edge.arrow.width Arrow width, defaults to 1 edge.lty Line type, could be 0 or “blank,” 1 or “solid,” 2 or “dashed,” 3 or “dotted,” 4 or “dotdash,” 5 or “longdash,” 6 or “twodash” edge.label Character vector used to label edges edge.label.family Font family of the label (e.g.“Times,” “Helvetica”) edge.label.font Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol edge.label.cex Font size for edge labels edge.curved Edge curvature, range 0-1 (FALSE sets it to 0, TRUE to 0.5) arrow.mode Vector specifying whether edges should have arrows, possible values: 0 no arrow, 1 back, 2 forward, 3 both OTHER margin Empty space margins around the plot, vector with length 4 frame if TRUE, the plot will be framed main If set, adds a title to the plot sub If set, adds a subtitle to the plot 노드와 에지 옵션을 두 가지 방법으로 설정할 수 있다 - 첫 번째는 plot() 함수 안에서 다음과 같이 옵션을 설정하는 것이다. # 곡선형 에지와 화살표 크기 조절하기 : plot(net, edge.arrow.size=.4, edge.curved=.1) # 에지 색을 회색으로 그리고 노드 색을 오렌지 색으로 설정하기 : # &quot;media&quot;에 저장된 노드 이름을 노드의 라벨로 대체 plot(net, edge.arrow.size=.2, edge.curved=0, vertex.color=&quot;orange&quot;, vertex.frame.color=&quot;#555555&quot;, vertex.label=V(net)$media, vertex.label.color=&quot;black&quot;, vertex.label.cex=.7) 두 번째 방법은 igraph 개체에 옵션을 추가하는 것이다. 네트워크의 노드를 media.type 에 따라 색을 지정하고, audience.size(대규모 audience는 노드를 크게)에 따라 노드의 크기를 설정해 보자. 또한 가중치에 따라 에지의 넓이를 바꿀 수도 있다. # media 종류에 따라 색 지정하기 : colrs &lt;- c(&quot;gray50&quot;, &quot;tomato&quot;, &quot;gold&quot;) V(net)$color &lt;- colrs[V(net)$media.type] # 고객의 규모에 따라 노드의 크기 지정하기 : V(net)$size &lt;- V(net)$audience.size*0.7 # 라벨들은 현 노드의 ID이다. # 라벨을 NA로 설정하면 라벨이 표시되지 않는다. V(net)$label.color &lt;- &quot;black&quot; V(net)$label &lt;- NA # 가중치에 따라 에지의 넓이를 지정하기 : E(net)$width &lt;- E(net)$weight/6 # 화살표 크기와 에지 색을 변경하기 : E(net)$arrow.size &lt;- .2 E(net)$edge.color &lt;- &quot;gray80&quot; E(net)$width &lt;- 1+E(net)$weight/12 또한 plot()에 명시적으로 속성을 지정할 수 있다. plot(net, edge.color=&quot;orange&quot;, vertex.color=&quot;gray50&quot;) 우리가 사용한 색의 의미를 설정하는 범례를 추가할 수 있다 : plot(net) legend(x=-1.5, y=-1.1, c(&quot;Newspaper&quot;,&quot;Television&quot;, &quot;Online News&quot;), pch=21, col=&quot;#777777&quot;, pt.bg=colrs, pt.cex=2, cex=.8, bty=&quot;n&quot;, ncol=1) 때때로 의미 네트워크의 경우 특히, 노드의 라벨만을 표시하고자 할 때가 있다.: plot(net, vertex.shape=&quot;none&quot;, vertex.label=V(net)$media, vertex.label.font=2, vertex.label.color=&quot;gray40&quot;, vertex.label.cex=.7, edge.color=&quot;gray85&quot;) 원천 노드의 색에 따라 그래프의 에지 색을 지정할 수 있다. igraph 패키지의 end() 함수로 각 에지의 시작 노드를 알 수 있다. edge.start &lt;- ends(net, es=E(net), names=F)[,1] edge.start ## [1] 1 1 1 1 2 2 2 2 3 3 3 3 3 3 3 4 4 4 4 4 5 5 5 5 6 ## [26] 6 7 7 7 7 8 8 8 9 10 12 12 12 13 13 14 14 15 15 15 16 16 17 edge.col &lt;- V(net)$color[edge.start] plot(net, edge.color=edge.col, edge.curved=.1) 6.1 Network layouts 네트워크 레이아웃(Network layouts)은 네트워크 내에 있는 각 노드에 대한 좌표를 반환하는 단순 알고리듬이다. 레이아웃을 이해하기 위해 약간 규모가 큰 80개 노드로 구성된 그래프를 생성하기로 한다. 사전에 설정된 선호도 수준에 따라 하나의 노드에서 시작해서 더 많은 노드와 에지를 추가하는 단순 그래프를 생성하는 sample_pa() 함수를 사용한다(Barabasi-Albert model). net.bg &lt;- sample_pa(80) V(net.bg)$size &lt;- 8 V(net.bg)$frame.color &lt;- &quot;white&quot; V(net.bg)$color &lt;- &quot;orange&quot; V(net.bg)$label &lt;- &quot;&quot; E(net.bg)$arrow.mode &lt;- 0 plot(net.bg) plot() 함수 안에 레이아웃을 설정할 수 있다: plot(net.bg, layout=layout_randomly) 또는 먼저 노드의 좌표를 계산할 수 있다 : l &lt;- layout_in_circle(net.bg) l ## [,1] [,2] ## [1,] 1.000000e+00 0.000000e+00 ## [2,] 9.969173e-01 7.845910e-02 ## [3,] 9.876883e-01 1.564345e-01 ## [4,] 9.723699e-01 2.334454e-01 ## [5,] 9.510565e-01 3.090170e-01 ## [6,] 9.238795e-01 3.826834e-01 ## [7,] 8.910065e-01 4.539905e-01 ## [8,] 8.526402e-01 5.224986e-01 ## [9,] 8.090170e-01 5.877853e-01 ## [10,] 7.604060e-01 6.494480e-01 ## [11,] 7.071068e-01 7.071068e-01 ## [12,] 6.494480e-01 7.604060e-01 ## [13,] 5.877853e-01 8.090170e-01 ## [14,] 5.224986e-01 8.526402e-01 ## [15,] 4.539905e-01 8.910065e-01 ## [16,] 3.826834e-01 9.238795e-01 ## [17,] 3.090170e-01 9.510565e-01 ## [18,] 2.334454e-01 9.723699e-01 ## [19,] 1.564345e-01 9.876883e-01 ## [20,] 7.845910e-02 9.969173e-01 ## [21,] 6.123032e-17 1.000000e+00 ## [22,] -7.845910e-02 9.969173e-01 ## [23,] -1.564345e-01 9.876883e-01 ## [24,] -2.334454e-01 9.723699e-01 ## [25,] -3.090170e-01 9.510565e-01 ## [26,] -3.826834e-01 9.238795e-01 ## [27,] -4.539905e-01 8.910065e-01 ## [28,] -5.224986e-01 8.526402e-01 ## [29,] -5.877853e-01 8.090170e-01 ## [30,] -6.494480e-01 7.604060e-01 ## [31,] -7.071068e-01 7.071068e-01 ## [32,] -7.604060e-01 6.494480e-01 ## [33,] -8.090170e-01 5.877853e-01 ## [34,] -8.526402e-01 5.224986e-01 ## [35,] -8.910065e-01 4.539905e-01 ## [36,] -9.238795e-01 3.826834e-01 ## [37,] -9.510565e-01 3.090170e-01 ## [38,] -9.723699e-01 2.334454e-01 ## [39,] -9.876883e-01 1.564345e-01 ## [40,] -9.969173e-01 7.845910e-02 ## [41,] -1.000000e+00 1.224606e-16 ## [42,] -9.969173e-01 -7.845910e-02 ## [43,] -9.876883e-01 -1.564345e-01 ## [44,] -9.723699e-01 -2.334454e-01 ## [45,] -9.510565e-01 -3.090170e-01 ## [46,] -9.238795e-01 -3.826834e-01 ## [47,] -8.910065e-01 -4.539905e-01 ## [48,] -8.526402e-01 -5.224986e-01 ## [49,] -8.090170e-01 -5.877853e-01 ## [50,] -7.604060e-01 -6.494480e-01 ## [51,] -7.071068e-01 -7.071068e-01 ## [52,] -6.494480e-01 -7.604060e-01 ## [53,] -5.877853e-01 -8.090170e-01 ## [54,] -5.224986e-01 -8.526402e-01 ## [55,] -4.539905e-01 -8.910065e-01 ## [56,] -3.826834e-01 -9.238795e-01 ## [57,] -3.090170e-01 -9.510565e-01 ## [58,] -2.334454e-01 -9.723699e-01 ## [59,] -1.564345e-01 -9.876883e-01 ## [60,] -7.845910e-02 -9.969173e-01 ## [61,] -1.836910e-16 -1.000000e+00 ## [62,] 7.845910e-02 -9.969173e-01 ## [63,] 1.564345e-01 -9.876883e-01 ## [64,] 2.334454e-01 -9.723699e-01 ## [65,] 3.090170e-01 -9.510565e-01 ## [66,] 3.826834e-01 -9.238795e-01 ## [67,] 4.539905e-01 -8.910065e-01 ## [68,] 5.224986e-01 -8.526402e-01 ## [69,] 5.877853e-01 -8.090170e-01 ## [70,] 6.494480e-01 -7.604060e-01 ## [71,] 7.071068e-01 -7.071068e-01 ## [72,] 7.604060e-01 -6.494480e-01 ## [73,] 8.090170e-01 -5.877853e-01 ## [74,] 8.526402e-01 -5.224986e-01 ## [75,] 8.910065e-01 -4.539905e-01 ## [76,] 9.238795e-01 -3.826834e-01 ## [77,] 9.510565e-01 -3.090170e-01 ## [78,] 9.723699e-01 -2.334454e-01 ## [79,] 9.876883e-01 -1.564345e-01 ## [80,] 9.969173e-01 -7.845910e-02 plot(net.bg, layout=l) l 은 그래프에 있는 N개 노드에 대하여 단순히 x, y 좌표로 구성되는 (N x 2) 행렬이다. 쉽게 생성할 수 있다 : l &lt;- cbind(1:vcount(net.bg), c(1, vcount(net.bg):2)) l ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 80 ## [3,] 3 79 ## [4,] 4 78 ## [5,] 5 77 ## [6,] 6 76 ## [7,] 7 75 ## [8,] 8 74 ## [9,] 9 73 ## [10,] 10 72 ## [11,] 11 71 ## [12,] 12 70 ## [13,] 13 69 ## [14,] 14 68 ## [15,] 15 67 ## [16,] 16 66 ## [17,] 17 65 ## [18,] 18 64 ## [19,] 19 63 ## [20,] 20 62 ## [21,] 21 61 ## [22,] 22 60 ## [23,] 23 59 ## [24,] 24 58 ## [25,] 25 57 ## [26,] 26 56 ## [27,] 27 55 ## [28,] 28 54 ## [29,] 29 53 ## [30,] 30 52 ## [31,] 31 51 ## [32,] 32 50 ## [33,] 33 49 ## [34,] 34 48 ## [35,] 35 47 ## [36,] 36 46 ## [37,] 37 45 ## [38,] 38 44 ## [39,] 39 43 ## [40,] 40 42 ## [41,] 41 41 ## [42,] 42 40 ## [43,] 43 39 ## [44,] 44 38 ## [45,] 45 37 ## [46,] 46 36 ## [47,] 47 35 ## [48,] 48 34 ## [49,] 49 33 ## [50,] 50 32 ## [51,] 51 31 ## [52,] 52 30 ## [53,] 53 29 ## [54,] 54 28 ## [55,] 55 27 ## [56,] 56 26 ## [57,] 57 25 ## [58,] 58 24 ## [59,] 59 23 ## [60,] 60 22 ## [61,] 61 21 ## [62,] 62 20 ## [63,] 63 19 ## [64,] 64 18 ## [65,] 65 17 ## [66,] 66 16 ## [67,] 67 15 ## [68,] 68 14 ## [69,] 69 13 ## [70,] 70 12 ## [71,] 71 11 ## [72,] 72 10 ## [73,] 73 9 ## [74,] 74 8 ## [75,] 75 7 ## [76,] 76 6 ## [77,] 77 5 ## [78,] 78 4 ## [79,] 79 3 ## [80,] 80 2 plot(net.bg, layout=l) 사전에 네트워크 레이아웃을 설정하고 이를 적용하는 것도 가능하다. 또한 igraph 패키지에 내장된 네트워크 레이아웃 함수는 다음과 같다. layout.random() : 임의 네트워크 배치 layout.circle() : 원형태 네트워크 배치 layout.sphere() : 구형태 네트워크 배치 이 레이아웃은 단지 예를 든 것이며 크게 도움이 되는 것은 아니다. 다행히도 igraph는 다음과 같은 다양한 내장된 레이아웃을 가지고 있다 : # 정점을 무작위로 배치하기 l &lt;- layout_randomly(net.bg) plot(net.bg, layout=l) # 원형 레이아웃 l &lt;- layout_in_circle(net.bg) plot(net.bg, layout=l) # 3D 구형 레이아웃 l &lt;- layout_on_sphere(net.bg) plot(net.bg, layout=l) 그 밖의 레이아웃 함수들 : layout_as_bipartite(), layout_as_star(), layout_as_tree(), layout_in_circle(), layout_nicely(), layout_on_grid(), layout_on_sphere(), layout_randomly(), layout_with_dh(), layout_with_fr(), layout_with_gem(), layout_with_graphopt(), layout_with_kk(), layout_with_lgl(), layout_with_mds(), layout_with_sugiyama() 심미적으로 보기 좋은 네트워크 그래프를 얻기 위해 많은 알고리즘이 제안되었고, Fruchterman-Reingold 알고리즘을 비롯한 다양한 알고리즘이 존재한다. 물리학에서 가져온 스프링, 힘 등의 개념을 노드와 엣지에 적용하여 컴퓨터의 도움을 얻어 데이터가 크지 않은 경우 빠른 시간내에 시각화가 가능하다. Fruchterman-Reingold 알고리즘인 layout_with_fr() 함수는 심미적으로 보기 좋은 네트워크 그래프를 위한 레이아웃 알고리즘 중의 하나이다. Force-directed 네트워크 배치 알고리즘은 에지 길이가 비슷하고, 엣지가 가능하면 서로 거의 겹치지 않는 그래프를 생성하고자 한다. 이는 물리시스템으로 그래프를 모의시험한다. 노드는 서로 가까워지면 서로 밀어내는 성질을 갖는 전기적 성격을 갖는 입자이며, 에지는 연결된 노들들을 서로 가깝게 끌어들이는 스피링처럼 동작한다. 결과적으로 노드는 시각화 평면에 골고루 분산되어 위치하게 되고, 더 많은 연결점을 갖는 노드는 서로 더 가까이 위치하게 된다는 점에서 직관적이다. 이런 유형의 알고리즘이 갖는 단점은 실행 시간에 오래 걸리며, 따라서 ~ 1,000 개보다 큰 노드를 갖는 그래프에는 잘 사용되지 않는다. 일부 모수를 조정해서 네트워크 그래프를 조정하는 것도 가능하다. area : 기본 설정값으로 노드 제곱 repulserad : 밀어내는 반경 weight : 노드 사이 끌림을 증대 예를 들어, weight 인수를 이용하여 강한 에지로 연결되는 노드 사이의 매력도를 증가시킬 수 있다. l &lt;- layout_with_fr(net.bg) plot(net.bg, layout=l) 이 레이아웃은 확정적이지 않다는 것을 알 수 있다. 시행할 때마다 결과는 약간씩 다를 것이다. 레이아웃을 변수 l에 저장하면 여러분 동일한 결과를 가질 수 있게 해 준다. 즉, 그래프의 시간에 따른 진화를 시각화하거나, 또는 서로 다른 관계성을 시각화하고자 할 때 도움이 될 수 있으며, 노드들이 여러 플롯에서 같은 장소에 위치하게 하고자 할 때도 도움이 된다. par(mfrow=c(2,2), mar=c(0,0,0,0)) # 2행 2열로 4개의 그림 그리기 plot(net.bg, layout=layout_with_fr) # plot(net.bg, layout=layout_with_fr) # 위의 레이아웃과 다름 plot(net.bg, layout=l) # plot(net.bg, layout=l) # 위의 레이아웃과 같음 dev.off() ## null device ## 1 기본 값으로, 플롯의 좌표들은 x와 y 모두 [-1, 1] 구간으로 재설정된다. 이 구간은 rescale = FALSE 파라미터로 변경할 수 있으며, 좌표에 상수 값을 곱해서도 수작업으로 재설정할 수 있다. 또한 norm_coords() 함수를 이용하여 우리가 원하는 경계로 플롯을 정규화할 수도 있다. l &lt;- layout_with_fr(net.bg) l &lt;- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1) par(mfrow=c(2,2), mar=c(0,0,0,0)) plot(net.bg, rescale=F, layout=l*0.4) plot(net.bg, rescale=F, layout=l*0.6) plot(net.bg, rescale=F, layout=l*0.8) plot(net.bg, rescale=F, layout=l*1.0) dev.off() ## null device ## 1 fruchterman.reingold.grid() 함수는 fruchterman.reingold()와 유사하지만 속도가 더 빠르다. 또 다른 알고리즘으로 Kamada Kawai 알고리즘인 layout_with_kk() 함수가 있다. Fruchterman Reingold 처럼 스프링 시스템에서의 에너지를 최소화하고자 한다. l &lt;- layout_with_kk(net.bg) plot(net.bg, layout=l) LGL 알고리즘인 layout_with_lgl() 함수는 대규모(large)의 연결된 그래프를 의미한다. 여기에서 레이아웃을 중심에 위치하는 root를 지정할 수 있다. plot(net.bg, layout=layout_with_lgl) igraph 패키지에서 이용가능한 모든 레이아웃들은 다음과 같이 살펴볼 수 있다 : ? igraph::layout_ layouts &lt;- grep(&quot;^layout_&quot;, ls(&quot;package:igraph&quot;), value=TRUE)[-1] # 우리의 그래프에 적용되지 않는 레이아웃 제거 layouts &lt;- layouts[!grepl(&quot;bipartite|merge|norm|sugiyama|tree&quot;, layouts)] par(mfrow=c(3,3), mar=c(1,1,1,1)) for (layout in layouts) { print(layout) l &lt;- do.call(layout, list(net)) plot(net, edge.arrow.mode=0, layout=l, main=layout) } ## [1] &quot;layout_as_star&quot; ## [1] &quot;layout_components&quot; ## [1] &quot;layout_in_circle&quot; ## [1] &quot;layout_nicely&quot; ## [1] &quot;layout_on_grid&quot; ## [1] &quot;layout_on_sphere&quot; ## [1] &quot;layout_randomly&quot; ## [1] &quot;layout_with_dh&quot; ## [1] &quot;layout_with_drl&quot; ## [1] &quot;layout_with_fr&quot; ## [1] &quot;layout_with_gem&quot; ## [1] &quot;layout_with_graphopt&quot; ## [1] &quot;layout_with_kk&quot; ## [1] &quot;layout_with_lgl&quot; ## [1] &quot;layout_with_mds&quot; 6.2 네트워크 시각화 개선 아직 네트워크의 시각화가 그렇게 도움이 되지 않음을 알 수 있다. 노드의 형태와 크기를 지정할 수 있지만, 우리가 검토하고 있는 연결들이 너무 조밀해서 그 구조를 그렇게 잘 파악하기가 쉽지 않다. 이를 위한 하나의 접근방법은 가장 중요한 연결에만 집중하고 나머지는 제거함으로써 네트워크를 간소화할 수 있는지를 알아보는 것이다. hist(links$weight) mean(links$weight) ## [1] 12.40816 sd(links$weight) ## [1] 9.905635 중요한 에지들을 추출하는 좀 더 복잡한 방법이 있지만 여기서는 네트워크의 평균 가중치 보다 더 큰 가중치를 갖는 노드들만 집중하기로 한다. igraph 패키지에서는 delete_edges(net, edges) 함수를 이용하여 에지들을 삭제할 수 있다 : cut.off &lt;- mean(links$weight) net.sp &lt;- delete_edges(net, E(net)[weight &lt; cut.off]) plot(net.sp) 이에 대한 또 다른 고려 방법은 두 개의 연결 유형(hyperlink와 mention)을 따로 시각화하는 것이다. E(net)$width &lt;- 1.5 plot(net, edge.color=c(&quot;dark red&quot;, &quot;slategrey&quot;)[(E(net)$type==&quot;hyperlink&quot;)+1], vertex.color=&quot;gray40&quot;, layout=layout.circle) 두 개의 link들을 따로 플롯하기 : net.m &lt;- net - E(net)[E(net)$type==&quot;hyperlink&quot;] # another way to delete edges net.h &lt;- net - E(net)[E(net)$type==&quot;mention&quot;] # 두 개의 link를 따로 시각화하기 par(mfrow=c(1,2)) plot(net.h, vertex.color=&quot;orange&quot;, main=&quot;Tie: Hyperlink&quot;) plot(net.m, vertex.color=&quot;lightsteelblue2&quot;, main=&quot;Tie: Mention&quot;) 두 개의 플롯에서 존재하는 노드들을 확인하기 : l &lt;- layout_with_fr(net) plot(net.h, vertex.color=&quot;orange&quot;, layout=l, main=&quot;Tie: Hyperlink&quot;) plot(net.m, vertex.color=&quot;lightsteelblue2&quot;, layout=l, main=&quot;Tie: Mention&quot;) dev.off() ## null device ## 1 6.3 tkplot 패키지를 이용한 상호대화식 시각화 R과 igraph는 상화대화식 네트워크 시각화를 지원한다. 이는 소규모 그래프의 레이아웃을 약간 변경하고 싶을 때 유용한 옵션이 될 수 있다. 레이아웃을 수작업으로 수정한 다음, 노드의 좌표를 확인하고 다른 좌표에서 이용할 수 있다. tkid &lt;- tkplot(net) # tkid는 tkplot의 ID l &lt;- tkplot.getcoords(tkid) # tkplot에서 좌표 확인하기 tk_close(tkid, window.close = T) plot(net, layout=l) 6.4 다른 네트워크 시각화 방법 이제 네트워크를 공모양의 플롯에 국한하지 않고 표시할 수 있는 많은 다양한 방법이 있음을 알아야 한다. 예를 들어, 네트워크 행렬의 히트맵이 있다 : netm &lt;- get.adjacency(net, attr=&quot;weight&quot;, sparse=F) colnames(netm) &lt;- V(net)$media rownames(netm) &lt;- V(net)$media palf &lt;- colorRampPalette(c(&quot;gold&quot;, &quot;dark orange&quot;)) heatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(100), scale=&quot;none&quot;, margins=c(10,10) ) 6.5 igraph로 2-모드 네트워크 시각화하기 1-모드 네트워크에서는 네트워크를 플롯팅할 때 기본 기본 값으로 사용될 수 있는 시각화 속성들을 포함하여 네트워크 개체를 수정할 수 있다. 이번에는 노드의 모양- media는 정사각형으로 그리고 그들의 사용자들은 원형으로-을 변경할 수 있음을 주목하라. V(net2)$color &lt;- c(&quot;steel blue&quot;, &quot;orange&quot;)[V(net2)$type+1] V(net2)$shape &lt;- c(&quot;square&quot;, &quot;circle&quot;)[V(net2)$type+1] V(net2)$label &lt;- &quot;&quot; V(net2)$label[V(net2)$type==F] &lt;- nodes2$media[V(net2)$type==F] V(net2)$label.cex=.4 V(net2)$label.font=2 plot(net2, vertex.label.color=&quot;white&quot;, vertex.size=(2-V(net2)$type)*8) igraph는 또한 이분할 네트워크를 위한 특별한 레이아웃을 가지고 있다(비록 항상 잘 작동되는 것은 아니지만, 자신만의 이분할 레이아웃을 생성하고자 할 때 더 잘 표현할 수 있다). plot(net2, vertex.label=NA, vertex.size=7, layout=layout_as_bipartite) 때때로 노드를 텍스트로 사용하는 것도 유용할 때가 있다 : plot(net2, vertex.shape=&quot;none&quot;, vertex.label=nodes2$media, vertex.label.color=V(net2)$color, vertex.label.font=2.5, vertex.label.cex=.6, edge.color=&quot;gray70&quot;, edge.width=2) 참고자료 https://statkclee.github.io/network/ml-network-static-viz.html https://statkclee.github.io/network/ml-network-etc.html "],["Network-and-Node-Description.html", "Chapter 7 네트워크과 노드 설명 7.1 밀도(Density) 7.2 호혜성(Reciprocity) 7.3 이행성(Transitivity) 7.4 지름(Diameter) 7.5 노드 연결 정도(Node degrees) 7.6 연결 정도 분포(Degree distribution) 7.7 중심성과 중심화(Centrality &amp; centralization) 7.8 허브와 오쏘러티(Hubs and authorities) 참고자료", " Chapter 7 네트워크과 노드 설명 7.1 밀도(Density) 네트워크에 있는 모든 가능한 에지들 대비 현존 에지들의 비율을 밀도라고 한다. 밀도(density)는 네트워크에서 노드 간의 전반적인 연결정도 수준을 나타낸다. 밀도는 네트워크 내에 존재하는 최대 가능한 라인의 개수 대비 실제 존재하는 라인의 개수의 비율로 측정한다. 밀도가 높은 네트워크에 대해 우리는 일반적으로 응집력(cohesion)이 높다고 이야기한다 edge_density(net, loops=F) ## [1] 0.1764706 ecount(net)/(vcount(net)*(vcount(net)-1)) # 방향성 네트워크의 경우 ## [1] 0.1764706 7.2 호혜성(Reciprocity) 호혜성 : (방향성 네트워크에서의) 호혜적인 연결의 비율 액터들 간 연결관계의 상호 호혜적 관계를 호혜성(reciprocity)이라 한다. A에서 B로 향하는 연결관계가 존재하고 동시에 B에서 A로 향하는 연결관계가 존재하는 경우 네트워크의 응집성 정도 네트워크 간 호혜성의 차이는 종종 네트워크 구조의 계층적 특성, 힘이나 부의 불균형, 문화적 차이 등에 의해 설명된다(Borgatti et al. 2013) 호혜성의 측정 : 양자관계(dyad)에 초점을 맞춰서 호혜성을 측정 전체 연결된 액터쌍 대비 호혜적 액터쌍의 비율을 측정 두 개의 연결된 액터쌍(AB, BC)이 존재하고 이 중 호혜적 액터 쌍(AB)의 개수는 한 개이다. 따라서 호혜성 비율은 0.5(= 1 2 )가 된다. 선택관계(arc)에 초점을 맞춰서 호혜성을 측정 방향성을 고려한 선택관계 대비 호혜적 관계구조를 형성하는 라인의 비율을 측정 방향성을 고려한 선택관계는 세 개(AB, BA, BC)가 존재하고 그 중 두 개(AB, BA)가 상호 호혜적 관계구조를 형성한다. reciprocity(net) ## [1] 0.4166667 dyad_census(net) # Mutual, asymmetric, and nyll node pairs ## $mut ## [1] 10 ## ## $asym ## [1] 28 ## ## $null ## [1] 98 2*dyad_census(net)$mut/ecount(net) # Calculating reciprocity ## [1] 0.4166667 7.3 이행성(Transitivity) 호혜성은 두 액터(정점, 노드) 간의 관계로부터 정의되는 반면, 이행성(transitivity)은 세 액터(정점, 노드) 간의 관계인 삼자관계(triad)를 기반으 로 한다. 삼자관계는 세 개의 액터와 그 액터들 간의 연결관계로 구성된다. (삼자관계에 대한 분석은 기본적으로 방향/이진 그 래프를 대상으로 한다.) A가 B에 연결되어 있고 B는 C에 연결되어 있을 때 A가 C에 대해 연결관계를 가지면 이 삼자관계는 이행성을 충족한다 고 얘기한다. 즉 A  B이고 B  C이면서 동시에 A  C인 삼자관계는 이행성을 충족한다. 네트워크 내에 이행성을 충족하는 삼자관계가 많을수록 그 네트워크는 군집화된 구조(clumpy structure)를 갖게 되는 경향이 있다. 따라서 이런 의미에서 이행성은 네트워크의 군집화 및 구조적 균형의 정도를 나타낸다. 이행성의 측정 : 전체(global) - 연결된 삼각관계(triples)에 대한 삼각형(triangle)(방향)의 비율 부분(local) - 각 정점이 부분인 연결된 삼각관계에 대한 삼각형의 비율 transitivity(net, type=&quot;global&quot;) # net는 무방향 네트워크로 처리됨 ## [1] 0.372549 transitivity(as.undirected(net, mode=&quot;collapse&quot;)) # 위와 같음 ## [1] 0.372549 transitivity(net, type=&quot;local&quot;) ## [1] 0.2142857 0.4000000 0.1153846 0.1944444 0.5000000 0.2666667 0.2000000 ## [8] 0.1000000 0.3333333 0.3000000 0.3333333 0.2000000 0.1666667 0.1666667 ## [15] 0.3000000 0.3333333 0.2000000 triad_census(net) # 방향성 네트워크에 대해 ## [1] 244 241 80 13 11 27 15 22 4 1 8 4 4 3 3 0 삼자관계 유형(Triad types) (per Davis &amp; Leinhardt): 삼자관계는 총 16가지 유형으로 분류해 볼 수 있으며 이렇게 분류된 삼자관계유형은 네트워크의 구조적 특징 및 이행성 정도를 측정하는 데 활용된다. 네트워크 내에 삼자관계 각 유형이 어느 정 도 출현하는지를 조사하여 네트워크의 구조 적 특성을 이해하는 것을 삼자관계 센서스 (triad census)라고 한다. 003 A, B, C, 빈 삼자관계. 012 A-&gt;B, C 102 A&lt;-&gt;B, C 021D A&lt;-B-&gt;C 021U A-&gt;B&lt;-C 021C A-&gt;B-&gt;C 111D A&lt;-&gt;B&lt;-C 111U A&lt;-&gt;B-&gt;C 030T A-&gt;B&lt;-C, A-&gt;C 030C A&lt;-B&lt;-C, A-&gt;C. 201 A&lt;-&gt;B&lt;-&gt;C. 120D A&lt;-B-&gt;C, A&lt;-&gt;C. 120U A-&gt;B&lt;-C, A&lt;-&gt;C. 120C A-&gt;B-&gt;C, A&lt;-&gt;C. 210 A-&gt;B&lt;-&gt;C, A&lt;-&gt;C. 300 A&lt;-&gt;B&lt;-&gt;C, A&lt;-&gt;C, 완전 연결 7.4 지름(Diameter) 네트워크 지름은 네트워크에서 (두 노드 사이의 최단 경로의 길이인) 가장 긴 측지선 거리이다. igraph에서, diameter() 함수가 거리를 반환한다. 반면에, get_diameter() 함수는 그 거리의 첫 번째 발견된 경로에 있는 노드들을 반환한다. 만일 NA로 설정되어 있지 않다면, 에지의 가중치가 기본 값으로 사용됨을 주목하기 바란다. diameter(net, directed=F, weights=NA) ## [1] 4 diameter(net, directed=F) ## [1] 28 diam &lt;- get_diameter(net, directed=T) diam ## + 7/17 vertices, named, from 924fee6: ## [1] s12 s06 s17 s04 s03 s08 s07 get_diameter() 함수는 정점 시퀀스(vertex sequence)를 반환함을 주목하라. 그러나 벡터와 같이 작동하도록 요청되었을 때, 정점 시퀀스는 그 안에 있는 노드들의 수치 색인을 생성하게 됨을 주목하라. 에지 시퀀스에도 동일하게 적용된다. class(diam) ## [1] &quot;igraph.vs&quot; as.vector(diam) ## [1] 12 6 17 4 3 8 7 지름 내의 노드들 색 지정하기 : vcol &lt;- rep(&quot;gray40&quot;, vcount(net)) vcol[diam] &lt;- &quot;gold&quot; ecol &lt;- rep(&quot;gray80&quot;, ecount(net)) ecol[E(net, path=diam)] &lt;- &quot;orange&quot; # E(net, path=diam) : &#39;diam&#39; 경로에 따른 에지들 plot(net, vertex.color=vcol, edge.color=ecol, edge.arrow.mode=0) 7.5 노드 연결 정도(Node degrees) degree() 함수의 mode 파라미터는 in for in-degree, out for out-degree, 그리고 all 또는 total for total degree 값을 갖는다. deg &lt;- degree(net, mode=&quot;all&quot;) plot(net, vertex.size=deg*3) 노드 연결 정도의 분포 : hist(deg, breaks=1:vcount(net)-1, main=&quot;Histogram of node degree&quot;) 7.6 연결 정도 분포(Degree distribution) deg.dist &lt;- degree_distribution(net, cumulative=T, mode=&quot;all&quot;) plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col=&quot;orange&quot;, xlab=&quot;Degree&quot;, ylab=&quot;Cumulative Frequency&quot;) 7.7 중심성과 중심화(Centrality &amp; centralization) (노드 수준에서의) 중심성 함수(Centrality functions)들과 (그래프 수준의) 중심화 함수(centralization functions). 중심화 함수들은 노드의 연결 중심성 값인 res, 중심화 값인 centralization, 그리고 이 사이즈 그래프에 대한 최대 중심화 점수인 theoretical_max 등을 반환한다. 중심화 함수는 (vids 파리미터로 설정된) 노드의 부분집합에서 실행된다. 이는 모든 중심성을 계산하는데 많은 자원이 요구되고 작업하는데 많은 시간이 걸리는 대규모 그래프에서 유용한다. 연결 정도(Degree) (연결의 수, number of ties) : degree() 함수와 centr_degree()함수 degree(net, mode=&quot;in&quot;) ## s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 s13 s14 s15 s16 s17 ## 4 2 6 4 1 4 1 2 3 4 3 3 2 2 2 1 4 centr_degree(net, mode=&quot;in&quot;, normalized=T) ## $res ## [1] 4 2 6 4 1 4 1 2 3 4 3 3 2 2 2 1 4 ## ## $centralization ## [1] 0.1985294 ## ## $theoretical_max ## [1] 272 근접 중심성(Closeness) (그래프에서 다른 노드들과의 거리에 기반한 중심성) : closeness() 함수와 centr_clo() 함수 노드에 있는 다른 노들들까지의 노드의 평균 측지 거리(average geodesic distance)의 역수. closeness(net, mode=&quot;all&quot;, weights=NA) ## s01 s02 s03 s04 s05 s06 s07 ## 0.03333333 0.03030303 0.04166667 0.03846154 0.03225806 0.03125000 0.03030303 ## s08 s09 s10 s11 s12 s13 s14 ## 0.02857143 0.02564103 0.02941176 0.03225806 0.03571429 0.02702703 0.02941176 ## s15 s16 s17 ## 0.03030303 0.02222222 0.02857143 centr_clo(net, mode=&quot;all&quot;, normalized=T) ## $res ## [1] 0.5333333 0.4848485 0.6666667 0.6153846 0.5161290 0.5000000 0.4848485 ## [8] 0.4571429 0.4102564 0.4705882 0.5161290 0.5714286 0.4324324 0.4705882 ## [15] 0.4848485 0.3555556 0.4571429 ## ## $centralization ## [1] 0.3753596 ## ## $theoretical_max ## [1] 7.741935 아이겐벡터 중심성(고유벡터, Eigenvector) (연결 중심성 합에 비례한 중심성) : eigen_centrality() 함수와 centr_eigen() 함수 그래프 행렬의 첫 번째 아이겐벡터 값들. eigen_centrality(net, directed=T, weights=NA) ## $vector ## s01 s02 s03 s04 s05 s06 s07 s08 ## 0.6638179 0.3314674 1.0000000 0.9133129 0.3326443 0.7468249 0.1244195 0.3740317 ## s09 s10 s11 s12 s13 s14 s15 s16 ## 0.3453324 0.5991652 0.7334202 0.7519086 0.3470857 0.2915055 0.3314674 0.2484270 ## s17 ## 0.7503292 ## ## $value ## [1] 3.006215 ## ## $options ## $options$bmat ## [1] &quot;I&quot; ## ## $options$n ## [1] 17 ## ## $options$which ## [1] &quot;LR&quot; ## ## $options$nev ## [1] 1 ## ## $options$tol ## [1] 0 ## ## $options$ncv ## [1] 0 ## ## $options$ldv ## [1] 0 ## ## $options$ishift ## [1] 1 ## ## $options$maxiter ## [1] 1000 ## ## $options$nb ## [1] 1 ## ## $options$mode ## [1] 1 ## ## $options$start ## [1] 1 ## ## $options$sigma ## [1] 0 ## ## $options$sigmai ## [1] 0 ## ## $options$info ## [1] 0 ## ## $options$iter ## [1] 7 ## ## $options$nconv ## [1] 1 ## ## $options$numop ## [1] 31 ## ## $options$numopb ## [1] 0 ## ## $options$numreo ## [1] 18 centr_eigen(net, directed=T, normalized=T) ## $vector ## [1] 0.6638179 0.3314674 1.0000000 0.9133129 0.3326443 0.7468249 0.1244195 ## [8] 0.3740317 0.3453324 0.5991652 0.7334202 0.7519086 0.3470857 0.2915055 ## [15] 0.3314674 0.2484270 0.7503292 ## ## $value ## [1] 3.006215 ## ## $options ## $options$bmat ## [1] &quot;I&quot; ## ## $options$n ## [1] 17 ## ## $options$which ## [1] &quot;LR&quot; ## ## $options$nev ## [1] 1 ## ## $options$tol ## [1] 0 ## ## $options$ncv ## [1] 0 ## ## $options$ldv ## [1] 0 ## ## $options$ishift ## [1] 1 ## ## $options$maxiter ## [1] 1000 ## ## $options$nb ## [1] 1 ## ## $options$mode ## [1] 1 ## ## $options$start ## [1] 1 ## ## $options$sigma ## [1] 0 ## ## $options$sigmai ## [1] 0 ## ## $options$info ## [1] 0 ## ## $options$iter ## [1] 7 ## ## $options$nconv ## [1] 1 ## ## $options$numop ## [1] 31 ## ## $options$numopb ## [1] 0 ## ## $options$numreo ## [1] 18 ## ## ## $centralization ## [1] 0.5071775 ## ## $theoretical_max ## [1] 16 중개 중심성(Betweenness) (다른 노드들을 연결하는 중개자 위치에 기반한 중심성) : betweenness() 함수, edge_betweenness() 함수 그리고 centr_betw() 함수 노드나 에지를 거쳐가는 측지 수(number of geodesics). betweenness(net, directed=T, weights=NA) ## s01 s02 s03 s04 s05 s06 ## 24.0000000 5.8333333 127.0000000 93.5000000 16.5000000 20.3333333 ## s07 s08 s09 s10 s11 s12 ## 1.8333333 19.5000000 0.8333333 15.0000000 0.0000000 33.5000000 ## s13 s14 s15 s16 s17 ## 20.0000000 4.0000000 5.6666667 0.0000000 58.5000000 edge_betweenness(net, directed=T, weights=NA) ## [1] 10.833333 11.333333 8.333333 9.500000 4.000000 12.500000 3.000000 ## [8] 2.333333 24.000000 16.000000 31.500000 32.500000 9.500000 6.500000 ## [15] 23.000000 65.333333 11.000000 6.500000 18.000000 8.666667 5.333333 ## [22] 10.000000 6.000000 11.166667 15.000000 21.333333 10.000000 2.000000 ## [29] 1.333333 4.500000 11.833333 16.833333 6.833333 16.833333 31.000000 ## [36] 17.000000 18.000000 14.500000 7.500000 28.500000 3.000000 17.000000 ## [43] 5.666667 9.666667 6.333333 1.000000 15.000000 74.500000 centr_betw(net, directed=T, normalized=T) ## $res ## [1] 24.0000000 5.8333333 127.0000000 93.5000000 16.5000000 20.3333333 ## [7] 1.8333333 19.5000000 0.8333333 15.0000000 0.0000000 33.5000000 ## [13] 20.0000000 4.0000000 5.6666667 0.0000000 58.5000000 ## ## $centralization ## [1] 0.4460938 ## ## $theoretical_max ## [1] 3840 7.8 허브와 오쏘러티(Hubs and authorities) Jon Kleinberg가 개발한 허브와 오쏘러티 알고리즘은 처음에 웹 페이지를 검토할 때 사용되었다. 허브(Hubs)는 대규모의 외부로 나가는 링크를 가지고 있는 목록들을 포함하고 있는 것으로 예상된다. 반면에 오쏘러티(Authorities)는 짐작하건대 고품질의 관련 정보를 담고있기 때문에 허브로 부터 들어오는 많은 링크를 가지고 있을 것으로 기대된다. hs &lt;- hub_score(net, weights=NA)$vector as &lt;- authority_score(net, weights=NA)$vector par(mfrow=c(1,2)) plot(net, vertex.size=hs*50, main=&quot;Hubs&quot;) plot(net, vertex.size=as*30, main=&quot;Authorities&quot;) dev.off() ## null device ## 1 참고자료 HITS 알고리듬과 소셜 네트웍 : https://webscience.creation.net/3 사회연결망 분석 : https://kuduz.tistory.com/1087 "],["Distances-and-Paths.html", "Chapter 8 거리와 경로(Distances and paths)", " Chapter 8 거리와 경로(Distances and paths) 평균 경로 길이 : (방향성 그래프에 대해서는 양 방향에서) 네트워크에 있는 노드들 사이의 최단 거리의 평균 - mean_distance() 함수 mean_distance(net, directed=F) ## [1] 2.058824 mean_distance(net, directed=T) ## [1] 2.742188 또한 그래프에서 모든 최단 경로들의 길이(the length of the shortest paths)를 찾을 수 있다 : distances() 함수 distances(net) # 에지 가중치 고려 ## s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 s13 s14 s15 s16 s17 ## s01 0 4 2 6 1 5 3 4 3 4 3 3 9 4 7 26 8 ## s02 4 0 4 8 3 7 5 6 1 5 5 5 11 6 9 28 10 ## s03 2 4 0 4 1 3 1 2 3 2 1 1 7 2 5 24 6 ## s04 6 8 4 0 5 1 5 6 7 6 5 3 3 6 1 22 2 ## s05 1 3 1 5 0 4 2 3 2 3 2 2 8 3 6 25 7 ## s06 5 7 3 1 4 0 4 5 6 5 4 2 4 5 2 21 3 ## s07 3 5 1 5 2 4 0 3 4 3 2 2 8 3 6 25 7 ## s08 4 6 2 6 3 5 3 0 5 4 3 3 9 4 7 26 8 ## s09 3 1 3 7 2 6 4 5 0 5 4 4 10 5 8 27 9 ## s10 4 5 2 6 3 5 3 4 5 0 3 3 9 4 7 26 8 ## s11 3 5 1 5 2 4 2 3 4 3 0 2 8 1 6 25 7 ## s12 3 5 1 3 2 2 2 3 4 3 2 0 6 3 4 23 5 ## s13 9 11 7 3 8 4 8 9 10 9 8 6 0 9 4 22 1 ## s14 4 6 2 6 3 5 3 4 5 4 1 3 9 0 7 26 8 ## s15 7 9 5 1 6 2 6 7 8 7 6 4 4 7 0 23 3 ## s16 26 28 24 22 25 21 25 26 27 26 25 23 22 26 23 0 21 ## s17 8 10 6 2 7 3 7 8 9 8 7 5 1 8 3 21 0 distances(net, weights=NA) # 에지 가중치 무시 ## s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 s13 s14 s15 s16 s17 ## s01 0 1 1 1 1 2 2 2 2 2 2 2 3 3 1 3 2 ## s02 1 0 1 2 1 3 2 2 1 1 2 2 3 3 2 4 3 ## s03 1 1 0 1 1 2 1 1 2 1 1 1 2 2 2 3 2 ## s04 1 2 1 0 2 1 2 2 3 2 1 1 2 2 1 2 1 ## s05 1 1 1 2 0 2 2 2 1 2 2 2 3 3 1 3 3 ## s06 2 3 2 1 2 0 3 3 3 3 2 1 2 2 1 1 1 ## s07 2 2 1 2 2 3 0 1 2 1 2 2 2 1 3 4 3 ## s08 2 2 1 2 2 3 1 0 1 2 2 2 3 2 3 4 3 ## s09 2 1 2 3 1 3 2 1 0 1 3 3 4 3 2 4 4 ## s10 2 1 1 2 2 3 1 2 1 0 2 2 3 2 3 4 3 ## s11 2 2 1 1 2 2 2 2 3 2 0 2 2 1 2 3 2 ## s12 2 2 1 1 2 1 2 2 3 2 2 0 1 1 2 2 2 ## s13 3 3 2 2 3 2 2 3 4 3 2 1 0 1 3 2 1 ## s14 3 3 2 2 3 2 1 2 3 2 1 1 1 0 3 3 2 ## s15 1 2 2 1 1 1 3 3 2 3 2 2 3 3 0 2 2 ## s16 3 4 3 2 3 1 4 4 4 4 3 2 2 3 2 0 1 ## s17 2 3 2 1 3 1 3 3 4 3 2 2 1 2 2 1 0 우리가 관심을 갖는 노드나 노드 집합에 대한 거리들을 추출할 수 있다. 예를 들어, New York Times 중심에서 모든 미디어의 거리를 계산해 보자. dist.from.NYT &lt;- distances(net, v=V(net)[media==&quot;NY Times&quot;], to=V(net), weights=NA) # 거리를 시각화하는 색 설정: oranges &lt;- colorRampPalette(c(&quot;dark red&quot;, &quot;gold&quot;)) col &lt;- oranges(max(dist.from.NYT)+1) col &lt;- col[dist.from.NYT+1] plot(net, vertex.color=col, vertex.label=dist.from.NYT, edge.arrow.size=.6, vertex.label.color=&quot;white&quot;) 또한 특정 노드 사이의 최단 경로(shortest paths)를 찾아낼 수도 있다. shortest_paths() 함수 여기서는 MSNBC와 New York Post 사이의 최단 경로를 찾아보자. news.path &lt;- shortest_paths(net, from = V(net)[media==&quot;MSNBC&quot;], to = V(net)[media==&quot;New York Post&quot;], output = &quot;both&quot;) # 노드와 에지 모두 # 경로를 시각화하기 위한 에지 색 변수 생성 ecol &lt;- rep(&quot;gray80&quot;, ecount(net)) ecol[unlist(news.path$epath)] &lt;- &quot;orange&quot; # 경로를 시각화하기 위한 에지 넓이(width) 변수 생성 ew &lt;- rep(2, ecount(net)) ew[unlist(news.path$epath)] &lt;- 4 # 경로를 시각화하기 위한 노드 색 변수 설정 vcol &lt;- rep(&quot;gray40&quot;, vcount(net)) vcol[unlist(news.path$vpath)] &lt;- &quot;gold&quot; plot(net, vertex.color=vcol, edge.color=ecol, edge.width=ew, edge.arrow.mode=0) 예를 들어, WSJ이라는 정점으로 들어가거나 정점에서 나오는 에지들을 확인해 보자. 단일 노드의 경우, incident() 함수를 사용하고, 복수 노드인 경우는 incident_edges() 함수를 사용한다. inc.edges &lt;- incident(net, V(net)[media==&quot;Wall Street Journal&quot;], mode=&quot;all&quot;) # 선택된 에지를 시각화하기 위해 색 설정 ecol &lt;- rep(&quot;gray80&quot;, ecount(net)) ecol[inc.edges] &lt;- &quot;orange&quot; vcol &lt;- rep(&quot;grey40&quot;, vcount(net)) vcol[V(net)$media==&quot;Wall Street Journal&quot;] &lt;- &quot;gold&quot; plot(net, vertex.color=vcol, edge.color=ecol) 또한 WSJ라는 정점과 인접한 이웃들(neighbors)을 쉽게 식별할 수도 있다. neighbors() 함수는 관심 노드에서 한 단계 인접한 모든 노드들을 찾아준다. 복수 노드들의 이웃을 찾기 위해서는 neighbors() 대신에 adjacent_vertices() 함수를 이용한다. 한 단계 이상의 이웃 노드들을 찾기 위해서는 관심 노드(들)로 부터 떨어진 단계의 수를 order 파라미터로 설정하는 ego() 함수를 이용한다. neigh.nodes &lt;- neighbors(net, V(net)[media==&quot;Wall Street Journal&quot;], mode=&quot;out&quot;) # 이웃들을 시각화하기 위해 색 설정 vcol[neigh.nodes] &lt;- &quot;#ff9d00&quot; plot(net, vertex.color=vcol) 에지 순서의 색인화를 위한 특별한 연산자들 : %–%, %-&gt;%, %&lt;-% * E(network)[X %–% Y] : 방향은 무시하고 정점 X와 Y 집합 사이의 에지들 선택 * E(network)[X %-&gt;% Y] : 정점집합 X에서 정점 집합 Y로 향하는 모든 에지들 선택 * E(network)[X %&lt;-% Y] : 정점집합 Y에서 정점 집합 X로 향하는 모든 에지들 선택 예를 들어, 정점의 type.label이 newpaper에서 online 출처로 향하는 모든 에지들을 선택해 보자. E(net)[ V(net)[type.label==&quot;Newspaper&quot;] %-&gt;% V(net)[type.label==&quot;Online&quot;] ] ## + 7/48 edges from 924fee6 (vertex names): ## [1] s01-&gt;s15 s03-&gt;s12 s04-&gt;s12 s04-&gt;s17 s05-&gt;s15 s06-&gt;s16 s06-&gt;s17 공동 인용(Co-citation)(노드들에 대해, 얼마나 많이 서로 이름들을 공유하고 있는지를 나타냄) : cocitations() 함수 사용 cocitation(net) ## s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 s13 s14 s15 s16 s17 ## s01 0 1 1 2 1 1 0 1 2 2 1 1 0 0 1 0 0 ## s02 1 0 1 1 0 0 0 0 1 0 0 0 0 0 2 0 0 ## s03 1 1 0 1 0 1 1 1 2 2 1 1 0 1 1 0 1 ## s04 2 1 1 0 1 1 0 1 0 1 1 1 0 0 1 0 0 ## s05 1 0 0 1 0 0 0 1 0 1 1 1 0 0 0 0 0 ## s06 1 0 1 1 0 0 0 0 0 0 1 1 1 1 0 0 2 ## s07 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 ## s08 1 0 1 1 1 0 0 0 0 2 1 1 0 1 0 0 0 ## s09 2 1 2 0 0 0 1 0 0 1 0 0 0 0 1 0 0 ## s10 2 0 2 1 1 0 0 2 1 0 1 1 0 1 0 0 0 ## s11 1 0 1 1 1 1 0 1 0 1 0 2 1 0 0 0 1 ## s12 1 0 1 1 1 1 0 1 0 1 2 0 0 0 0 0 2 ## s13 0 0 0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 ## s14 0 0 1 0 0 1 0 1 0 1 0 0 1 0 0 0 0 ## s15 1 2 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 ## s16 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 ## s17 0 0 1 0 0 2 0 0 0 0 1 2 0 0 0 1 0 "],["Subgroups-and-Communities.html", "Chapter 9 서브 그룹과 커뮤니티 9.1 클릭(Cliques) 9.2 커뮤니티 발견(Community detection) 참고자료", " Chapter 9 서브 그룹과 커뮤니티 네트워크 분석에서 하위집단, 커뮤니티 식별은 관심이 가는 흥미로운 주제중 하나다. 하위집단, 커뮤니티 탐지 분석작업을 위해서 먼저 방향성 없는 그래프로 변환해야 하는데 다음과 같은 3가지 방법을 사용할 수 있다. 연결된 노드들의 모든 쌍 사이의 무방향 링크를 생성할 수 있다 (mode = \"collapse\") 잠재적으로 멀티플렉스 그래프가 되는 네트워크에서 각각의 방향성있는 링크에 대해 무방향 링크를 생성한다(mode=\"each\") 그래프에서 각각의 대칭 링크에 대해 무방향 링크를 생성한다(mode=\"mutual\"). A -&gt; B 와B -&gt; A 의 연결이 있는 경우에는 각 에지의 속성들에 대해 앞에서 simplify() 함수에서 다룬것 처럼 edge.attr.comb 파라미터를 사용하여 어떻게 처리할 것인지를 설정하면 된다. 여기서는 링크들의 weight를 합하면 되고, 다른 모든 에지들의 속성은 무시하고 제거한다. net.sym &lt;- as.undirected(net, mode= &quot;collapse&quot;, edge.attr.comb=list(weight=&quot;sum&quot;, &quot;ignore&quot;)) 9.1 클릭(Cliques) 클릭(cliques)를 통해 방향성 없는 그래프 전체가 연결된 하위집단을 식별한다. (무방향 그래프의 완전한 서브 그룹인) 클릭을 찾아보자 : cliques() 함수 cliques(net.sym) # 클릭 목록 ## [[1]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s03 ## ## [[2]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s06 ## ## [[3]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s14 ## ## [[4]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s09 ## ## [[5]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s04 ## ## [[6]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s04 s06 ## ## [[7]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s03 s04 ## ## [[8]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s05 ## ## [[9]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s05 s09 ## ## [[10]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s03 s05 ## ## [[11]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s13 ## ## [[12]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s13 s14 ## ## [[13]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s10 ## ## [[14]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s09 s10 ## ## [[15]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s03 s10 ## ## [[16]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s16 ## ## [[17]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s06 s16 ## ## [[18]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s08 ## ## [[19]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s08 s09 ## ## [[20]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s03 s08 ## ## [[21]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s01 ## ## [[22]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s01 s05 ## ## [[23]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s01 s03 s05 ## ## [[24]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s01 s04 ## ## [[25]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s01 s03 s04 ## ## [[26]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s01 s03 ## ## [[27]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s17 ## ## [[28]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s16 s17 ## ## [[29]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s06 s16 s17 ## ## [[30]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s13 s17 ## ## [[31]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s04 s17 ## ## [[32]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s04 s06 s17 ## ## [[33]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s06 s17 ## ## [[34]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s12 ## ## [[35]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s12 s13 ## ## [[36]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s12 s13 s14 ## ## [[37]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s04 s12 ## ## [[38]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s04 s06 s12 ## ## [[39]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s03 s04 s12 ## ## [[40]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s12 s14 ## ## [[41]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s06 s12 ## ## [[42]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s03 s12 ## ## [[43]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s11 ## ## [[44]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s04 s11 ## ## [[45]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s03 s04 s11 ## ## [[46]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s11 s14 ## ## [[47]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s03 s11 ## ## [[48]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s07 ## ## [[49]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s07 s08 ## ## [[50]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s03 s07 s08 ## ## [[51]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s07 s10 ## ## [[52]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s03 s07 s10 ## ## [[53]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s07 s14 ## ## [[54]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s03 s07 ## ## [[55]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s15 ## ## [[56]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s01 s15 ## ## [[57]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s01 s05 s15 ## ## [[58]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s01 s04 s15 ## ## [[59]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s05 s15 ## ## [[60]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s04 s15 ## ## [[61]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s04 s06 s15 ## ## [[62]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s06 s15 ## ## [[63]] ## + 1/17 vertex, named, from 96fd32c: ## [1] s02 ## ## [[64]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s01 s02 ## ## [[65]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s01 s02 s05 ## ## [[66]] ## + 4/17 vertices, named, from 96fd32c: ## [1] s01 s02 s03 s05 ## ## [[67]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s01 s02 s03 ## ## [[68]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s02 s10 ## ## [[69]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s02 s09 s10 ## ## [[70]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s02 s03 s10 ## ## [[71]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s02 s05 ## ## [[72]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s02 s05 s09 ## ## [[73]] ## + 3/17 vertices, named, from 96fd32c: ## [1] s02 s03 s05 ## ## [[74]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s02 s09 ## ## [[75]] ## + 2/17 vertices, named, from 96fd32c: ## [1] s02 s03 sapply(cliques(net.sym), length) # 클릭 크기 ## [1] 1 1 1 1 1 2 2 1 2 2 1 2 1 2 2 1 2 1 2 2 1 2 3 2 3 2 1 2 3 2 2 3 2 1 2 3 2 3 ## [39] 3 2 2 2 1 2 3 2 2 1 2 3 2 3 2 2 1 2 3 3 2 2 3 2 1 2 3 4 3 2 3 3 2 3 3 2 2 largest_cliques(net.sym) # 최대 수의 노드를 갖는 클릭 ## [[1]] ## + 4/17 vertices, named, from 96fd32c: ## [1] s03 s01 s02 s05 vcol &lt;- rep(&quot;grey80&quot;, vcount(net.sym)) vcol[unlist(largest_cliques(net.sym))] &lt;- &quot;gold&quot; plot(as.undirected(net.sym), vertex.label=V(net.sym)$name, vertex.color=vcol) 9.2 커뮤니티 발견(Community detection) 다양한 알고리즘이 커뮤니티 탐지를 위해 개발되었다. 커뮤니티 사이는 링크연결이 최소화되고, 커뮤니티 내에는 연결이 조밀하게 많아야 된다. Newman-Girvan 라벨 전파(Propagating labels) Greedy optimization of modularity K-core 분해 에지 중개 중심성에 기반한 커뮤니티 발견(Newman-Girvan) 높은 중개 에지 중심성들이 (각 단계마다 다시 계산하여) 순차적으로 제거되고, 가장 좋은 네트워크의 분할이 선택된다 : cluster_edge_betweenness() 함수 ceb &lt;- cluster_edge_betweenness(net) ## Warning in cluster_edge_betweenness(net): At community.c:460 :Membership vector ## will be selected based on the lowest modularity score. ## Warning in cluster_edge_betweenness(net): At community.c:467 :Modularity ## calculation with weighted edge betweenness community detection might not make ## sense -- modularity treats edge weights as similarities while edge betwenness ## treats them as distances dendPlot(ceb, mode=&quot;hclust&quot;) plot(ceb, net) 커뮤니티 탐지 igraph 개체를 검토해 보자 : membership() 함수, modularity() 함수 그리고 crossing() 함수 class(ceb) ## [1] &quot;communities&quot; length(ceb) # 커뮤니티 수 ## [1] 5 membership(ceb) # 각 노드의 커뮤니티 소속 ## s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 s13 s14 s15 s16 s17 ## 1 2 3 4 1 4 3 3 5 5 4 4 4 4 1 4 4 modularity(ceb) # 그래프 분할의 모듈성 ## [1] 0.292476 crossing(ceb, net) # 부울리안 벡터 : 커뮤니티와 교차하는 에지들은 TRUE ## s01|s02 s01|s03 s01|s04 s01|s15 s02|s01 s02|s03 s02|s09 s02|s10 s03|s01 s03|s04 ## TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE ## s03|s05 s03|s08 s03|s10 s03|s11 s03|s12 s04|s03 s04|s06 s04|s11 s04|s12 s04|s17 ## TRUE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE ## s05|s01 s05|s02 s05|s09 s05|s15 s06|s16 s06|s17 s07|s03 s07|s08 s07|s10 s07|s14 ## FALSE TRUE TRUE FALSE FALSE FALSE FALSE FALSE TRUE TRUE ## s08|s03 s08|s07 s08|s09 s09|s10 s10|s03 s12|s06 s12|s13 s12|s14 s13|s12 s13|s17 ## FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## s14|s11 s14|s13 s15|s01 s15|s04 s15|s06 s16|s06 s16|s17 s17|s04 ## FALSE FALSE FALSE TRUE TRUE FALSE FALSE FALSE 분할의 높은 모듈성(High modularity)은 커뮤니티 내의 강한 연결성(dense connection)과 커뮤니티 간의 약한 연결성(sparse connection)을 반영한다. 전파 라벨(propagating lables)에 기반한 커뮤니티 탐지 노드에 라벨을 할당하고, 랜덤화한 다음, 이웃 사이에 가장 자주 나타나는 각 정점의 라벨로 대체한다 이 절차들은 각 정점이 이웃들과 가장 공통적인 라벨을 가질 때까지 반복 수행된다. clp &lt;- cluster_label_prop(net) plot(clp, net) 모듈성의 탐욕적 최적화(greedy optimization of modularity)에 기반한 커뮤니티 탐지 cfg &lt;- cluster_fast_greedy(as.undirected(net)) plot(cfg, as.undirected(net)) 내장된 plot() 함수에 의존하지 않고도 커뮤니티를 시각화할 수 있다. V(net)$community &lt;- cfg$membership colrs &lt;- adjustcolor( c(&quot;gray50&quot;, &quot;tomato&quot;, &quot;gold&quot;, &quot;yellowgreen&quot;), alpha=.6) plot(net, vertex.color=colrs[V(net)$community]) K-코어 분할(K-core decomposition) k-core는 모든 노드들이 최소한 k의 연결중심성을 갖는 최대의 서브그래프이다. 결과는 네트워크 내에 있는 각 정점들의 coreness이다. 만일 한 노드가 D-코어에 속하지만, (D+1) –코어에 속하지 않는다면, 그 노드의 coreness는 D가 된다. kc &lt;- coreness(net, mode=&quot;all&quot;) plot(net, vertex.size=kc*6, vertex.label=kc, vertex.color=colrs[kc]) 참고자료 커뮤니티 탐지란? : https://lsjsj92.tistory.com/587 네트워크 커뮤니티 탐지 : https://statkclee.github.io/network/ml-network-communities.html [withR]소셜네트워크분석 — subgroup(부그룹)](https://medium.com/excitinglab/withr-%EC%86%8C%EC%85%9C%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EB%B6%84%EC%84%9D-subgroup-%EB%B6%80%EA%B7%B8%EB%A3%B9-834bf221b017) network에서 clique를 뽑고, 사용하는 방법. Network Modularity (네트워크의 모듈성) : https://mons1220.tistory.com/93 "],["Assortativity-and-Homophily.html", "Chapter 10 동류성과 동질성 참고자료", " Chapter 10 동류성과 동질성 동질성(homophily) : 일부 변수에 있어서 유사한 다른 노드들과 연결하려는 노드의 성향. 다음과 같은 함수를 사용한다 : assortativity_nominal() : 범주형 변수(라벨)의 경우 assortativity() : 서열과 상위 변수의 경우 assortativity_degree() : 노드 연결 정도에서의 동류성 확인 assortativity_nominal(net, V(net)$media.type, directed=F) ## [1] 0.1715568 assortativity(net, V(net)$audience.size, directed=F) ## [1] -0.1102857 assortativity_degree(net, directed=F) ## [1] -0.009551146 참고자료 네트워크 동류성 : https://mons1220.tistory.com/120 소셜 네트워크의 성질 "]]
