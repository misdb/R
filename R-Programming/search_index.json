[["index.html", "R 프로그래밍 저작권", " R 프로그래밍 Dae Ho Kim, Mokwon University 2021-02-08 저작권 Creative Commons License The online version of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["r과-r-studio.html", "Chapter 1 R과 R Studio", " Chapter 1 R과 R Studio R을 배우는 이유는 무엇인가? R과 R Studio는 무엇인가? R과 R Studio의 설치 R은 통계 컴퓨팅, 데이터 분석 및 과학 연구에 일반적으로 사용되는 프로그래밍 언어 및 환경입니다. 통계 학자, 데이터 분석가, 연구자 그리고 마케팅 담당자 등이 데이터를 검색, 정리, 분석, 시각화 그리고 제공하는 데 가장 많이 사용하는 언어 중 하나입니다. 이해하기 쉬운 구문과 사용하기 쉬운 인터페이스로 인해 R은 최근 몇 년 동안 인기가 상승하고 있습니다. "],["r을-배우는-이유는-무엇입니까.html", "1.1 R을 배우는 이유는 무엇입니까?", " 1.1 R을 배우는 이유는 무엇입니까? 1.1.1 R은 지시와 클릭을 포함하지 않습니다. 그것은 좋은 것입니다. 학습 곡선이 다른 소프트웨어보다 더 가파를 수 있지만, R을 사용하면 분석 결과가 일련의 지시와 클릭(pointing and clicking)을 기억하는 데 의존하지 않고 대신 일련의 작성된 명령에 의존합니다. 이는 좋은 일입니다! 따라서 더 많은 데이터를 수집해서 분석을 다시 실행하려는 경우 결과를 얻기 위해 어떤 버튼을 클릭했는지 기억할 필요가 없습니다. 다만 스크립트를 다시 실행하기만 하면 됩니다. 스크립트로 작업하면 분석에 사용한 단계가 명확해지고, 작성한 코드는 다른 사람이 검토해서 그에 대한 피드백을 제공하고 에러를 찾아 낼 수 있습니다. 스크립트로 작업하면 수행 중인 작업에 대해 더 깊이 이해하고 사용하는 방법을 쉽게 배우고 이해할 수 있습니다. 1.1.2 R 코드는 재현성에 좋습니다 재현성(reproducibility)이란 다른 사람 (미래의 자신 포함)이 동일한 분석을 사용할 때 동일한 데이터 세트에서 동일한 결과를 얻을 수 있는 것을 말합니다. R은 다른 도구와 통합되어 코드에서 보고서를 생성할 수 있습니다. 더 많은 데이터를 수집하거나 데이터 세트에서 에러를 수정하면 보고서 내의 도표와 통계 테스트가 자동으로 업데이트됩니다. 점점 더 많은 저널 및 자금 지원 기관에서는 이러한 재현성이 높은 연구 분석을 기대함에 따라 R을 아는 것은 이러한 요구 사항을 충족시킬 수 있는 도구를 가지게 되는 것입니다. 1.1.3 R은 학제적이고 확장 가능합니다. 기능을 확장할 수 있는 17,000 개 이상(2021-01-16일 현재, 17,049개)의 패키지를 설치할 수 있기 때문에, R은 데이터 분석에 필요한 분석 프레임 워크에 가장 적합하도록 여러 과학 분야의 통계적 접근 방식을 결합할 수있는 프레임 워크를 제공합니다. 예를 들어 R에는 이미지 분석, 지리공간정보(GIS), 시계열, 집단 유전학 그리고 기타 등을 위한 패키지가 있습니다. 1.1.4 R은 모든 형태와 규모의 데이터에서 작동합니다. R로 배우는 기술은 데이터 세트의 크기에 따라 쉽게 확장됩니다. 데이터 세트에 수백 또는 수백만 줄이 있더라도 큰 차이는 없습니다. R은 데이터 분석을 위해 설계되었습니다. 누락된 데이터 및 통계 요인을 편리하게 처리할 수있는 특수 데이터 구조 및 데이터 유형이 함께 제공됩니다. R은 컴퓨터나 웹에서 스프레드 시트, 데이터베이스 그리고 기타 여러 데이터 형식에 연결할 수 있습니다. 1.1.5 R은 고품질 그래픽을 생성합니다. R의 플로팅 기능(시각화 기능)은 무한하며 그래프의 모든 측면을 조정하여 데이터의 메시지를 가장 효과적으로 전달할 수 있습니다. 1.1.6 R에는 커뮤니티가 있습니다. 수천 명의 사람들이 매일 R을 사용합니다. 그들 중 많은 사람들이 메일링 리스트와 Stack Overflow 와 같은 웹 사이트 또는 RStudio 커뮤니티를 통해 여러분을 기꺼이 도와 줄 것 입니다 . 짧고 재현 가능한 코드 조각 으로 백업된 질문은 지식이 풍부한 답변을 끌어낼 가능성이 더 높습니다. 1.1.7 R은 무료 일뿐만 아니라 오픈 소스 및 크로스 플랫폼입니다. 누구나 소스 코드를 검사하여 R이 어떻게 작동하는지 확인할 수 있습니다. 이러한 투명성으로 인해 실수할 가능성이 적고, 사용자 (또는 다른 사람)가 일부를 발견하면 그러한 버그를 보고하고 수정할 수 있습니다. R은 오픈 소스(open source_이고 대규모 개발자 및 사용자 커뮤니티에서 지원하기 때문에 R의 기본 기능을 확장하는 데 무료로 사용할 수 있는 매우 다양한 제3자 제공의 애드온 패키지가 있습니다. 1.1.8 R을 배우면 취업 가능성이 높아집니다. 2021 년 Edureka에서 전망한 2021에 학습해야 할 상위 10개의 프로그래밍 언어에 R이 포함되어 있으며, 연봉 수준은 12.1 만 달러로 제시하고 있습니다. 물론 R 프로그램을 작성하는 방법을 안다고해서 곧바로 일자리를 얻을 수는 없으므로 데이터 과학자는 작업을 수행하기 위해 많은 도구를 활용해야 합니다. 소프트웨어 개발자 직책에 지원하는 경우에도 R 프로그래밍 경험을 통해 많은 사람들에게 돋보일 수 있습니다. R을 사용하는 기업들 R은 단순함과 힘의 올바른 조합이며 전 세계 기업에서 이를 사용하여 계산된 결정을 내립니다. 다음은 업계의 충실한 사람들이 R을 사용하고 R 생태계에 기여하는 몇 가지 방법을 보여주고 있습니다. 기업 활용 / 기여 Twitter 사용자 경험 모니터 Ford 자동차 디자인 결정을 위해 소셜 미디어 분석 New York Times 인포그래픽스, 데이터 저널리즘 Microsoft 2015 년 Revolution Analytics 인수한 후 향상된 R 배포 및 Microsoft R 서버인 Microsoft R Open 출시 Human Rights Data Analysis Group 전쟁의 영향 측정 Google Google 내부 R 사용자 커뮤니티를 위한 R 스타일 가이드 작성 "],["r-프로그래밍은-배우기-쉬운-언어입니까.html", "1.2 R 프로그래밍은 배우기 쉬운 언어입니까?", " 1.2 R 프로그래밍은 배우기 쉬운 언어입니까? 대답하기 어려운 질문입니다. 많은 연구자들이 데이터 분석 요구를 해결하기 위해 R을 모국어로 배우고 있습니다. 이것이 바로 R 프로그래밍의 힘입니다. 진행하면서 배울 수있을만큼 간단합니다. 필요한 것은 데이터와 해당 데이터에 대한 분석을 기반으로 결론을 도출하려는 명확한 의도뿐입니다. 사실, R은 원래 프로그래밍 언어로 의도된 언어 S 프로그래밍 위에 구축되어 학생들이 데이터를 가지고 놀면서 프로그래밍을 배우는 데 도움이 된 언어입니다. 그러나 Python, PHP 또는 Java 배경에서 온 프로그래머는 처음에는 R이 기발하고 혼란스러울 수 있습니다. R이 사용하는 구문은 다른 일반적인 프로그래밍 언어와 약간 다릅니다. R은 프로그래밍 언어의 모든 기능을 가지고 있지만 R 언어로 코드를 작성하는 동안 if 조건이나 루프를 많이 작성하지는 않습니다. 벡터, 리스트, 프레임, 데이터 테이블, 행렬 등과 같은 다른 프로그래밍 구조가 있어 데이터를 대량으로 변환할 수 있습니다. "],["실무에서의-r-프로그램-응용.html", "1.3 실무에서의 R 프로그램 응용", " 1.3 실무에서의 R 프로그램 응용 1.3.1 데이터 과학 Harvard Business Review는 데이터 과학자를 “21 세기의 가장 섹시한 직업”으로 선정했습니다. Glassdoor는이를 2016 년 “올해의 최고의 직업”으로 선정했습니다. 더 나은 결정을 내리는 데 사용할 수있는 테라 바이트 및 테라 바이트의 데이터를 생성하는 IoT 장치의 출현으로 데이터 과학은 다른 방법이 없는 분야입니다. 간단히 설명하면 데이터 과학자는 컴퓨터 프로그래밍 기술이라는 추가 자산을 가진 통계 학자입니다. R과 같은 프로그래밍 언어는 데이터 과학자에게 실시간으로 데이터를 수집하고, 통계 및 예측 분석을 수행하고, 시각화를 생성하고, 실행 가능한 결과를 이해 관계자에게 전달할 수있는 강력한 능력을 제공합니다. 대부분의 데이터 과학 과정에는 데이터 과학자가 가장 좋아하는 도구인 R이 커리큘럼에 포함됩니다. 1.3.2 통계 컴퓨팅 R은 통계 학자들 사이에서 가장 인기있는 프로그래밍 언어입니다. 사실, 처음에는 통계학자를 위해 통계 학자에 의해 구축되었습니다. 상상할 수있는 모든 통계 기능을 갖춘 16,000개 이상의 패키지가 있는 풍부한 패키지 저장소가 있습니다. R의 표현 구문을 사용하면 컴퓨터 과학을 전공하지 않은 연구원도 다양한 데이터 소스에서 데이터를 빠르게 가져오고, 정리하고, 분석 할 수 있습니다. R에는 차트 기능도 있어 데이터를 플로팅하고 모든 데이터 세트에서 흥미로운 시각화를 만들 수 있습니다. 1.3.3 기계 학습 R은 예측 분석 및 기계 학습에서 많은 용도를 발견했습니다. 선형 및 비선형 회귀, 의사 결정 트리, 선형 및 비선형 분류 등과 같은 일반적인 기계학습 작업을위한 다양한 패키지가 있습니다. 기계 학습 애호가부터 연구원에 이르기까지 모든 사람이 R을 사용하여 관광, 서비스, 금융, 유전학 연구, 소매, 마케팅 및 건강 관리와 같은 분야에서 기계 학습 알고리즘을 구현합니다. RStudio는 R이 할 수있는 일을 확장하고 R 코드를 작성하고 R과 상호 작용하는 것을 더 쉽게 만듭니다. 위의 사진 크레딧 ; 아래 사진 크레딧 . "],["r은-무엇입니까-rstudio-란-무엇입니까.html", "1.4 R은 무엇입니까? RStudio 란 무엇입니까?", " 1.4 R은 무엇입니까? RStudio 란 무엇입니까? 1.4.1 R은 무엇입니까? R을 배우는 이유는 무엇입니까?절에서 R을 사용하여 분석 (특히 데이터 유형의 경우)을 시작해야하는 많은 이유에 대해 논의했습니다. R에 대해 배우기 위해 해당 장을 건너 뛴 경우 다음을 수행하는 것이 좋습니다. 뒤로 가서주의 깊게 읽으십시오. R로 작업하는 데 유창함을 키우기 시작할 때, 이 소개 장을 수시로 검토하는 것이 특히 중요합니다. 1.4.1.1 R 시작 R은 값 비싼 독점 옵션에 대한 오픈 소스 대안을 원했던 통계 학자 그룹에 의해 개발되었습니다. 통계 학자 (컴퓨터 과학자 대신)에 의해 만들어 졌기 때문에 R에 익숙해지는 데 시간이 걸리는 측면이 있습니다. 이를 돕기 위해 많은 패키지가 개발되었음을 알 수 있으며, 요즘에는 R을 사용하기 위해 고급 통계학 학위가 필요하지 않습니다. 1.4.1.2 R의 개발 R은 오클랜드 대학교의 뉴질랜드에있는 Ross Ihaka와 Robert Gentleman 이 만들었습니다 . S 프로그래밍 언어의 파생물이며 부분적으로 개발자의 이름을 따서 명명되었습니다 (위의 강조점에서 볼 수 있듯이). R을 만들기 위한 초기 아이디어는 1992년에 나왔고 R의 첫 번째 버전은 1994 년에 출시되었습니다. R의 배경, 기능 및 S 언어와의 연결에 대한 자세한 내용은 Wikipedia에서 찾을 수 있습니다. 1.4.1.3 R 패키지 R은 2010년에 들어와 많은 발전을 이루고 있습니다. 그러한 가장 큰 발전 중 하나는 R을 초보자가 쉽게 사용할 수 있도록 패키지(package)를 만든 것입니다. 패키지는 기본 R 설치의 기능을 높이기 위해 R 사용자가 만든 추가 기능입니다. 최근 Hadley Wickham과 다른 사람들이 만든 패키지는 R의 기능을 크게 확장하는 동시에 R로 시작하는 것을 더 간단하게 만들기 위해 노력하고 있습니다.1 2021 년 2 월 현재 17,000개 이상의 패키지 (2021-02-8일 현재, 17,049개)가 공통 R 리포지토리에서 사용가능합니다. 또 다른 훌륭한 개발은 RStudio라는 그래픽 사용자 인터페이스와 RStudio, Inc.에서 개발한 rmarkdown(R Markdown이라고도 함)으로, 우리 과정에서는 이러한 RStudio에 대해 중점적으로 설명합니다. 1.4.2 RStudio 란 무엇입니까? RStudio는 R을 위한 강력한 무료 오픈 소스 통합 개발 환경입니다. RStudio의 개발은 2010 년에 시작되었으며 첫 번째 베타는 2011 년 2 월에 출시되었습니다. RStudio Desktop과 RStudio Server의 두 가지 버전으로 제공됩니다. 이 책은 주로 RStudio Server에 초점을 맞추지 만 두 버전 모두 작업하기에 거의 동일합니다. Windows 및 Mac 컴퓨터에서 R 및 RStudio를 다운로드하고 설치하는 방법은 아래 링크되어 있습니다. RStudio Server를 사용하는 경우 교수 또는 조직의 IT 부서 구성원이이 단계를 수행했습니다. RStudio Server의 경우 웹 브라우저를 사용하여 클라우드의 계정에 로그온합니다. 피드백 및 오류 해결에 도움이되는 R 프로젝트 공유를 포함하여 초보 사용자를 위해 RStudio Server를 사용하면 많은 이점이 있습니다. 소프트웨어를 설치하면 자체 골칫거리가 될 수 있으며, 이는 RStudio Server를 사용하여 제거됩니다. 고급 사용자를 위한 참고 사항 : Digital Ocean에 매달 약 $ 5의 비용으로 자체 RStudio Server를 설치할 수도 있습니다. 이에 대한 지침은 Dean Attali 와 Digital Ocean 사이트에서 찾을 수 있습니다 . 예를 들어 패키지 설치 절에서 install.packages(\"dplyr\")를 통해 이러한 패키지를 다운로드 하고 library(dplyr) 를 통해 현재 R 작업 환경에 로드하는 방법을 볼 수 있습니다. ) "],["r과-r-studio의-설치-그리고-r-studio의-실행.html", "1.5 R과 R Studio의 설치 그리고 R Studio의 실행", " 1.5 R과 R Studio의 설치 그리고 R Studio의 실행 먼저 컴퓨터에 R과 RStudio (데스크톱 버전)를 모두 다운로드하여 설치해야합니다. 먼저 R을 설치 한 다음 RStudio를 설치하는 것이 중요합니다. 1.5.1 R 설치 https://cloud.r-project.org/ 로 이동하여 R을 다운로드하고 설치 해야합니다 . Windows 사용자인 경우 다음과 같은 절차를 거쳐 R을 설치합니다. R programming 공식 사이트에 접속합니다. 왼쪽 메뉴에 있는 CRAN 링크를 클립합니다. 화면에서 0-Cloud(또는 각국의 미러 링크)를 선택합니다. install R for the first time을 클릭합니다. Download R 4.0.3 for Windows를 클릭합니다. 그러면 여러분의 [다운로드] 폴더로 설치 파일이 다운로드 됩니다. 화면의 왼쪽 하단부를 보기 바랍니다. 다운로드가 완료되고 나면, 화면의 왼쪽 하단부에 있는 “R-4.0.3-win.exe”를 클릭하여 설치를 시작합니다. 32 비트 버전 아니면 64 비트 버전을 설치해야 합니까? 대부분의 사람들은 이에 대해 걱정할 필요가 없습니다. 64 비트 버전의 R은 32 비트 컴퓨터에서 작동하지 않지만 32 비트 및 64 비트 버전의 R은 64 비트 Windows에서 원활하게 실행됩니다. macOS 사용자인 경우, “(Mac) OS X 용 R 다운로드”를 클릭 한 다음 “최신 릴리스”에서 RX.XXpkg를 클릭합니다. 여기서 RX.XX는 버전 번호입니다. 예를 들어, 2019 년 11 월 25 일 현재 R의 최신 버전은 R-3.6.1입니다. Linux 사용자인 경우, “Linux 용 R 다운로드”를 클릭하고 배포를 선택하여 설정을 위한 R 설치에 대한 자세한 내용을 확인하십시오. 1.5.2 RStudio 설치 RStudio는 R 프로그램을 실행하는 데 가장 많이 사용되는 통합개발환경(IDE, Integrated Development Environment)이며 무료 라이선스가 있습니다. 설치 과정은 간단합니다. RStudio (Windows, Linux 및 Mac OS X)를 다운로드하고 파일을 실행한 다음 지침에 따라 설치하면 됩니다. 참고 : RStudio를 실행하려면 R이 시스템에 먼저 설치되어 있어야합니다. 1.5.3 RStudio 실행 이전의 자동차 비유를 상기하십시오. 엔진과 직접 상호 작용하는 것이 아니라 자동차 대시 보드의 요소와 상호 작용하여 자동차를 운전하는 것처럼 R을 직접 사용하지 않고 RStudio의 인터페이스를 사용합니다. 컴퓨터에 R과 RStudio를 설치하면 두 개의 새로운 프로그램 (응용 프로그램 이라고도 함 )을 열 수 있습니다. 우리는 특별한 경우가 아니면 항상 R 애플리케이션이 아닌 RStudio에서 작업할 것입니다. 그림 1.2 는 컴퓨터에서 어떤 아이콘을 클릭해야 하는지 보여줍니다. 컴퓨터의 R 대 RStudio 아이콘. 그림 1.2 : 컴퓨터의 R 대 RStudio 아이콘. 1.5.3.1 R Studio의 초기 화면 R이 설치되어 있으면 R Studio 인터페이스가 표시됩니다. 처음에는 R에서 한 줄 문을 작성하고 실행할 수있는 R 콘솔(Console)만 볼 수 있습니다. 그러나 사소한 작업의 경우에도 일련의 단계를 수행해야하며 R 스크립트를 만드는 것이 좋습니다. 아래 화면과 같이 File &gt; New File &gt; R Script로 이동하여 새 R 스크립트를 만듭니다. New file in RStudio 1.5.3.2 새 R Script 만들기 이제 여러 줄에 걸쳐있는 R 프로그램을 입력하고 저장할 수있는 R 스크립트 편집기를 볼 수 있습니다. RStudio는 단순한 텍스트 편집기가 아니라 R 스크립트를 쉽게 실행하고 디버깅하는 데 도움이되는 IDE입니다. 1.5.3.3 R Studio의 GUI R Studio GUI는 아래 스크린 샷과 같이 4 개의 주요 페인(pane)으로 나뉩니다. RStudio GUI 네 개의 주 창(Pane) : R Studio의 화면은 크게 편집(Editor) 창, 콘솔(Console) 창, 환경(Environment) 창, 그리고 파일 창 등의 네 개의 창으로 구성되어 있습니다. 이 장의 과정을 통해 이러한 각 창이 어떤 용도로 사용되는지 배우게 됩니다. "],["rstudio-둘러보기.html", "1.6 RStudio 둘러보기", " 1.6 RStudio 둘러보기 처음에는 RStudio에서 사용할 수있는 모든 다른 창과 탭에 약간 압도 당할 수 있지만 곧 이 레이아웃을 이해하는 방법을 배우게 됩니다. 왼쪽 상단 창에서 시작하여 시계 방향으로 진행합니다. 이러한 창의 레이아웃은 사용자 지정할 수 있지만 초보 사용자는 표준 레이아웃을 유지하는 것이 좋습니다. 1.6.1 코드 편집 창 대부분의 시간을 소비하게 될 창은 왼쪽 상단에있는 창입니다. 처음 로그인 할 때 이 창은 거기에 없지만 first_rmarkdown.Rmd를 만들 때 나타납니다 . 이 창은 R에서 파일 및 개체의 내용을 볼 수있는 장소 역할을 합니다. 아래 스크린에서 이 파일의 텍스트를 변경한 다음 파일을 저장할 수 있음을 알 수 있습니다. 파일을 편집할 때 파일 이름이 있는 탭이 검은 색에서 빨간색으로 변경되고 파일 이름 뒤에 별표가 표시되어 최신 변경 사항이 저장되지 않았음을 나타냅니다. 자주 파일을 저장하는 습관을 가져야합니다. 이 창에서 여러 탭을 열고 다른 파일을 볼 수 있습니다. 4 장에서는 이 View창에서 데이터 셋 을 만들 수 있음을 알 수 있습니다 . 이러한 추가 기능이 실제로 무엇을 하고 있는지 명확하지 않을 수 있습니다. 나중에 창 상단 근처에 있는 Knit HTML 버튼을 눌러 모든 텍스트, 코드 및 출력을 함께 생성할 수 있습니다. 1.6.2 환경과 기록 창 기본적으로 오른쪽 상단 창에는 환경 탭과 기록 탭이 있습니다. 이러한 탭이 제공하는 기능을 이해하려면 왼쪽 하단 창과 콘솔 탭 도 사용해야 합니다. Console을 사용하여 R에서 여러 개체를 만드는 방법을 보여 드리겠습니다. 처음에는 Environment(환경) 탭에 “환경이 비어 있습니다.”라는 메시지가 표시됩니다. 이는 아직 객체 (예 : 데이터)가 없음을 의미합니다. History(기록) 탭을 클릭하면 몇 개의 아이콘이 있는 빈 화면이 표시됩니다. 여기에서 이 모든 버튼을 살펴 보지는 않겠지 만, 마우스를 가져 가서 클릭하여 어떤 작업을 하는지 이해하는 것이 좋습니다. 콘솔에 코드를 입력 할 때, 환경 및 기록 탭이 어떻게 변경되는지 확인하기 바랍니다. 1.6.3 콘솔 창 작업을 확인하거나 R을 사용하여 문제를 해결하는 방법을 실험하는 방법으로 콘솔을 자주 사용합니다. 콘솔은 여러분이 컴퓨터를 가지고 놀 수 있는 장소로 생각할 수 있습니다 . R의 샌드 박스(모래 놀이터)입니다. 코드가 작동하는지 테스트한 다음 만족스러우면 해당 텍스트를 편집 창의 Rmd 파일에 복사할 수 있습니다. 다음 장에서 이에 대한 더 많은 예를 볼 것입니다. 콘솔 창에 다음의 내용을 입력해 보기 바랍니다. num1 &lt;- 7 num2 &lt;- 12 sum_1_2 &lt;- sum(num1, num2) sum_1_2 ## [1] 19 기본적으로 콘솔에 개체의 이름과 값을 입력하고, sum_1_2하면 결과가 표시됩니다. 또한 &lt;-로 표시되는 할당 연산자라고 하는 것을 보았습니다 . 이것은 오른쪽의 내용을 왼쪽에 나타나는 모든 이름의 개체에 넣는 것으로 읽을 수 있습니다. 예제 num1에서은 값 7을 저장하는 개체의 이름입니다. R 언어의 강력한 기능이 sum_1_2 &lt;- sum(num1, num2)라인에 도입되었습니다 . sum함수입니다. 함수는 이름과 괄호, 쉼표로 구분 된 하나 이상의 인수, 닫는 괄호 순으로 표시됩니다. 앞으로 이러한 것들의 많은 예를 보게 될 것입니다. 물론 여기에 표시된 기본 계산기 이상의 용도로 R을 사용할 것이지만 이것은 환경 및 기록 탭에 저장 되는 내용에 대한 아이디어를 제공하고자 하는 것입니다 . . 개체 이름 지정 규칙 변수가 실제로 나타내는 것에 해당하는 이름을 지정하는 습관을 갖는 것이 좋습니다. 개체의 이름을 지정하는 방법에 대해서는 제2부의 1장에서 자세히 살펴 보겠습니다 . 1.6.3.1 help 함수 ( ?) 물론, 여러분이 연습 할 때까지 내장 함수의 이름이 무엇인지 알 수는 없지만 생각해 볼 것이 있습니다. 함수가 내장되어 있는지 또는 포함된 패키지에 있는지 궁금한 경우 콘솔에서 ? 함수명을 사용하여 확인할 수 있습니다 . 아래에 스크린 캐스트로 몇 가지 예가 나와 있습니다. ? help ## starting httpd help server ... done ? sum ? diff ? sort 1.6.4 오른쪽 아래 창 : 파일, 플롯, 패키지, 도움말 RStudio의 오른쪽 아래 창에는 기본적으로 대부분의 탭이 포함되어 있으며 RStudio 프로젝트 및 해당 파일에 대한 다양한 기타 정보를 볼 수있는 유용한 위치입니다. 1.6.4.1 파일 여기서 가장 왼쪽 탭은 현재 작업 디렉토리에 대한 파일 및 폴더 구조를 보여줍니다. RStudio 프로젝트에서 이것은 프로젝트 파일이 저장된 폴더입니다. 파일이 저장된 위치, 파일 이름 및 프로젝트 폴더에 있을 수있는 모든 폴더를 보여줍니다. 이는 PC 에서 내 컴퓨터로 이동 하거나 Mac에서 Finder 를 여는 것과 유사하다고 생각할 수 있습니다 . 마찬가지로 이 탭에는 RStudio Server 용 클라우드 또는 RStudio Desktop 용 로컬 머신에있는 파일 및 디렉토리 구조가 나열됩니다. 1.6.4.2 플롯 / 뷰어 4 장에서 Plots 및 Viewer 탭이 제공하는 내용에 대한 보다 명확한 예를 볼 수 있습니다. 예상대로 Plots 는 R 코드가 생성한 결과로 그래프/그림을 보여줍니다. 뷰어 탭은 당신에게 R 마크다운을 Knit로 생성한 결과인 HTML 파일을 표시 할 수 있습니다. 1.6.4.3 패키지 패키지 탭은 컴퓨터 또는 클라우드 서버에 설치된 모든 패키지를 나열합니다. 패키지 이름 옆에 확인 표시가 있는지 확인하여 현재 작업 환경에 로드된(현재 사용가능한) 패키지를 확인할 수 있습니다. 패키지에 대한 설명과 버전 번호도 여기에 표시됩니다. 패키지는 자주 업데이트되고 개선되므로 패키지의 최신 버전이 있는지 확인하는 방법입니다. RStudio Server를 사용하는 경우 이 작업이 처리될 가능성이 높습니다. RStudio Desktop을 사용하는 경우 새 패키지를 다운로드하거나 현재 설치된 패키지를 업데이트하는 데 유용한 설치 및 업데이트 버튼을 찾을 수 있습니다. 1.6.4.4 도움 함수를 호출 할 때 도움말 탭을 사용하는 것도 좋습니다. 그러면 R 함수, 데이터 세트 및 패키지에 대한 도움말 문서가 표시됩니다. "],["작업-디렉토리-구성.html", "1.7 작업 디렉토리 구성", " 1.7 작업 디렉토리 구성 프로젝트 전체에서 일관된 폴더 구조를 사용하면 항목을 정리하고 향후 항목을 쉽게 찾고 보관할 수 있습니다. 이것은 여러 프로젝트가 있을 때 특히 유용 할 수 있습니다. 일반적으로 스크립트, 데이터 그리고 문서에 대한 디렉토리(폴더)를 만들 수 있습니다 . 다음은 권장 디렉토리의 몇 가지 예입니다. data/이 폴더를 사용하여 원시 데이터 및 중간 데이터 세트를 저장하십시오. data_output/ 원시 데이터를 수정해야하는 경우 데이터 세트의 수정된 버전을 다른 폴더에 저장하는 것이 유용할 수 있습니다. documents/ 개요, 초안 그리고 기타 텍스트에 사용됩니다. fig_output/ 이 폴더는 스크립트에 의해 생성된 그래픽을 저장할 수 있습니다. scripts/ 다양한 분석 또는 플로팅을 위해 R 스크립트를 보관할 수있는 장소입니다. 프로젝트 요구 사항에 따라 추가 디렉토리 또는 하위 디렉토리가 필요할 수 있지만 이는 작업 디렉토리의 백본을 형성해야합니다. 작업 디렉토리 구조의 예 1.7.1 작업 디렉토리 작업 디렉토리는 이해해야 할 중요한 개념입니다. R이 파일을 찾고 저장하는 곳입니다. 프로젝트용 코드를 작성할 때 스크립트는 작업 디렉토리의 루트와 관련된 파일과 이 구조 내의 파일만 참조해야 합니다. RStudio 프로젝트를 사용하면 이를 쉽게 수행할 수 있으며 작업 디렉토리가 올바르게 설정되었는지 확인이 필요한 경우 getwd()로 확인할 수 있습니다. . 어떤 이유로 작업 디렉토리가 올바른 것이 아닌 경우 파일 창에서 작업 디렉토리가 있어야 하는 위치로 이동하고 파란색 기어 아이콘 “More”를 클릭 한 다음 “Set”을 선택하여 RStudio 인터페이스에서 변경할 수 있습니다. 작업 디렉토리로 ”.” 또는 setwd(\"c:/R-2021/working_dir\")을 사용하여 작업 디렉토리를 재설정할 수 있습니다 . 1.7.2 데이터 다운로드 및 설정 이 강의에서는 작업 디렉토리에서 data/, data_output/및 fig_output/으로 설정하겠습니다. 일관성을 유지하기 위해 모두 소문자로 작성합시다. File 창 (오른쪽 아래)에서 “New Folder” 버튼을 클릭하여 RStudio 인터페이스를 사용하거나 폴더를 생성하거나, 아니면 다음과 같이 콘솔에 입력하여 R에서 직접 만들 수 있습니다. dir.create(&quot;data&quot;) dir.create(&quot;data_output&quot;) dir.create(&quot;fig_output&quot;) 작업 디렉토리를 생성하고 그 아래에 data 서브 디렉토리를 생성하였으며, 인터넷에서 데이터를 다운로드하여 이 data 서브디렉토리에 “SAFI_clean.csv” 라는 데이터 세트를 다운로드해 보기로 합시다. 직접 다운로드 링크는 https://ndownloader.figshare.com/files/11492171 입니다. 다음의 스크립트를 콘솔 창에 입력하면 인터넷에서 다운로드 한 파일이 방금 만든 data/디렉토리 안에 저장됩니다. 다음의 내용을 복사하여 콘솔 창의 터미널에 붙여 넣어 R에서 직접 수행할 수 있습니다. download.file(&quot;https://ndownloader.figshare.com/files/11492171&quot;, &quot;data/SAFI_clean.csv&quot;, mode = &quot;wb&quot;) "],["r과-상호-작용.html", "1.8 R과 상호 작용", " 1.8 R과 상호 작용 프로그래밍의 기본은 컴퓨터가 따라야 할 지침을 기록한 다음 컴퓨터가 이러한 지침을 따르도록 지시하는 것입니다. 우리는 컴퓨터와 우리 모두가 이해할 수있는 공통 언어인 R로 명령어를 작성하거나 코딩 합니다. 우리는 지침에 따라 명령을 호출하고, 우리는 컴퓨터에게 해당 명령을실행 하도록 지시를 하게 됩니다. R과 상호 작용하는 두 가지 주요 방법은 콘솔을 사용하거나 스크립트 파일 (코드가 포함된 일반 텍스트 파일)을 사용하는 것입니다. 콘솔 창 (RStudio의 왼쪽 하단 패널)은 R 언어로 작성된 명령을 컴퓨터에서 즉시 입력하고 실행할 수있는 곳입니다. 또한 실행 된 명령에 대한 결과가 표시됩니다. 콘솔에 직접 명령을 입력하고 키를 눌러 Enter해당 명령을 실행할 수 있지만 세션을 닫으면 무시됩니다. 코드와 워크 플로를 재현할 수 있기를 원하기 때문에 스크립트 편집기에서 원하는 명령을 입력하고 스크립트를 저장하는 것이 좋습니다. 이런 식으로 우리가 한 일에 대한 완전한 기록이 있으며 (미래 자신을 포함하여!) 누구나 쉽게 결과를 컴퓨터에 복제 할 수 있습니다. RStudio를 사용하면 스크립트 편집기에서 Ctrl+ Enter 키로 현재 커서가 위치한 스크립트를 직접 실행할 수 있습니다 (Mac에서는 Cmd+ Return가 작동 함). 스크립트의 현재 줄에있는 명령 (커서로 표시됨) 또는 선택한 텍스트의 모든 명령이 콘솔로 전송되고 Ctrl+ Enter 를 누르면 실행됩니다. 콘솔에 더 이상 필요하지 않은 정보가 있으면 Ctrl+L 을 사용하여 지울 수 있습니다. RStudio IDE에 대한 이 RStudio 치트 시트 에서 다른 키보드 단축키를 찾을 수 있습니다 . 분석의 어느 시점에서 스크립트에 반드시 기록을 유지하지 않고 변수의 내용이나 개체의 구조를 확인하고자 할 수 있습니다. 이러한 명령을 입력하고 콘솔에서 직접 실행할 수 있습니다. RStudio는 스크립트와 콘솔 창 사이를 이동할 수 있는 Ctrl+ 1및 Ctrl+ 2바로 가기를 제공 합니다. R이 명령을 수락할 준비가되면 R 콘솔에 &gt;프롬프트가 표시됩니다. R이 명령을 수신하면 (입력, 복사-붙여 넣기 또는 Ctrl+ Enter를 사용하여 스크립트 편집기에서 전송) R은 명령을 실행하려고 시도하고 준비가 되면 결과를 표시하고 &gt;새 명령을 기다리라는 새 프롬프트로 돌아옵니다. . R이 여전히 더 많은 텍스트를 입력하기를 기다리는 경우 콘솔에 +프롬프트 가 표시 됩니다. 완전한 명령 입력을 완료하지 않았음을 의미합니다. 이는 괄호나 인용문을 ‘닫지’ 않았기 때문일 수 있습니다. 즉, 오른쪽 괄호와 동일한 수의 왼쪽 괄호가 없거나 시작 및 닫는 따옴표의 수가 동일하지 않기 때문일 수 있습니다. 이런 일이 발생하고 명령 입력이 끝났다고 생각하면 콘솔 창 내부를 클릭하고 를 누르면 불완전한 명령이 취소되고 &gt;프롬프트로 돌아갑니다. 그런 다음 입력한 명령을 교정하고 오류를 수정할 수 있습니다. "],["r-코딩과-r-패키지.html", "Chapter 2 R 코딩과 R 패키지", " Chapter 2 R 코딩과 R 패키지 R에서의 코딩 R 패키지 "],["r에서-어떻게-코딩하나요.html", "2.1 R에서 어떻게 코딩하나요?", " 2.1 R에서 어떻게 코딩하나요? 이제 R 및 RStudio를 설정했으므로 “좋아요. 이제 R을 어떻게 사용합니까?” 가장 먼저 주목해야 할 점은 포인트 앤 클릭 인터페이스 를 제공하는 Excel, SPSS 또는 Minitab과 같은 다른 통계 소프트웨어 프로그램과 달리, R은 해석 언어라는 것입니다. 즉, R 코드로 작성된 명령을 입력해야합니다 . 즉, R로 코딩 / 프로그래밍해야 합니다.이 책에서는 “코딩”과 “프로그래밍”이라는 용어를 같은 의미로 사용합니다. R을 사용하기 위해 노련한 코더 / 컴퓨터 프로그래머일 필요는 없지만 새로운 R 사용자가 이해해야 하는 기본 프로그래밍 개념은 여전히 있습니다. 따라서 이 책은 프로그래밍에 관한 책은 아니지만 데이터를 효과적으로 탐색하고 분석하는 데 필요한 이러한 기본 프로그래밍 개념을 충분히 배울 수 있습니다. 2.1.1 기본 프로그래밍 개념 및 용어 이제 몇 가지 기본 프로그래밍 개념과 용어를 소개합니다. 지금 당장 이 모든 개념과 용어를 외워달라고 요청하는 대신 “행동을 통해 학습”할 수 있도록 안내해 드립니다. 학습을 돕기 위해 일반 텍스트와 컴퓨터 코드항상(가능하면) 다른 글꼴을 사용하겠습니다. 그리고 다음과 같은 주제를 마스터하는 가장 좋은 방법은 R과 많은 반복을 통해 의도적으로 연습하는 것입니다. 기초: 콘솔 창 : 명령을 입력하는 곳. 실행 코드 : R에게 콘솔에서 명령을 내어 행동을 수행하도록 지시하는 행위. 개체(Objects) : R에서 값이 저장되는 곳. 개체에 값을 할당 하는 방법과 객체의 내용을 표시하는 방법을 보여줍니다. 데이터 유형 : 정수, 이중(double) / 숫자, 논리 및 문자. 정수는 -1, 0, 2, 4092와 같은 값입니다. Double 또는 숫자는 정수뿐만 아니라 -24.932 및 0.8과 같은 소수 및 소수 값도 포함하는 더 큰 값 집합입니다. TRUE또는 FALSE문자는 논리값 중 하나입니다 “양배추,” “해밀턴,” “철사 가장 큰 TV 쇼 있나이다,” 그리고 “이라면이 맛있습니다.” 등의 문자는 종종 주위에 따옴표로 표시됩니다. 벡터(vector) : 일련의 값. 이들은 “결합”또는 “연결”을 의미 하는 c()함수를 사용하여 생성됩니다. 예를 들어 c(6, 11, 13, 31, 90, 92)는 양의 정수 값으로 구성된 6 개 요소의 시리즈를 만듭니다. factor(요인) : 범주형 데이터 는 일반적으로 R에서 요인으로 표시됩니다. 범주형 데이터는 문자열로도 나타낼 수 있습니다 . 우리는 앞으로 문자열과 요인의 차이를 알게될 것입니다. 데이터 프레임 : 직사각형 스프레드시트. 행이 관측치에 해당하고 열이 관측치를 설명하는 변수에 해당하는 R의 데이터 세트 표현입니다 . 데이터 프레임은 나중에 제2부의 7장에서 다룰 것 입니다. 조건부 사용 ‘같음’에 대한 테스트 ==(그리고 =일반적으로 할당을 위해 사용되는). 예를 들어, 2 + 1 == 3비교. R 코드 2 + 1 = 3는 에러를 반환한다. 부울 연산자 (비교 연산자) : TRUE/FALSE와 같은 수학 연산자 &lt;(미만) &lt;=(이하) 및 !=(같지 않음). 예를 들어 4 + 2 &gt;= 3는 TRUE를 반환하지만, 3 + 5 &lt;= 1은 FALSE를 반환합니다. 논리 연산자 : &amp;(and)와 |(or) 를 나타냅니다. 예를 들어 (2 + 1 == 3) &amp; (2 + 1 == 4) (첫 번째 절만 같으므로) FALSE를 반환합니다. 반면에, (2 + 1 == 3) | (2 + 1 == 4)는 TRUE를 반환합니다. ‘함수’ 라고도 하는 명령 : 함수는 R에서 작업을 수행하기 위해 인수를 입력받아 출력을 반환합니다. 이때, 함수는 인수를 수동으로 지정하거나 함수의 기본값을 사용할 수 있습니다 . 예를 들어, R 의 함수 seq() 는 일련의 숫자를 생성합니다. 그냥 실행 seq()하면 값 1이 반환됩니다. 그다지 유용하지 않은 것 같습니다! 기본 인수로 설정되어 있기 때문 seq(from = 1, to = 1)입니다. 당신이 다른 값을 전달하지 않는 경우 인수의 기본값은 1로 정해져 있기 때문입니다. 만일 seq(from = 2, to = 5)와 같이 인수 값을 지정하는 경우 그 결과로 2 3 4 5를 얻을 수 있습니다. 이 책 전체에서 함수에 대해 많이 작업 할 것이며 그 동작을 이해하는 데 많은 연습을 하게 될 것입니다. 책에서 함수가 언제 언급되는지 이해하는 데 더 도움이되도록 위에서 언급한 seq() 함수도 뒤에서 살펴 볼 것입니다. 2.1.2 오류, 경고 및 메시지 새로운 R 및 RStudio 사용자를 위협하는 한 가지는 오류 , 경고 및 메시지를 보고하는 방법 입니다. R은 눈부신 빨간색 글꼴로 오류, 경고 및 메시지를 보고하므로 꾸짖는 것처럼 보입니다. 그러나 콘솔에 빨간색 텍스트가 표시되는 것이 항상 나쁜 것은 아닙니다. R은 세 가지 다른 상황에서 콘솔 창에 빨간색 텍스트를 표시합니다. 오류 : 빨간색 텍스트가 합법적인 오류 인 경우 “Error in…”으로 시작하고 무엇이 잘못되었는지 설명하려고 합니다. 일반적으로 오류가 발생하면 코드가 실행되지 않습니다. 예를 들어, Error in ggplot(...) : could not find function \"ggplot\"를 볼 수 있다면 “ggplot 함수가 포함된 패키지가 로드되지 않았기 때문에 함수에 액세스 할 수 없음”을 의미합니다 . 따라서 ggplot2 패키지를 library(ggplot2)로 먼저 로드하지 않으면 함수를 사용할 수 없습니다. 경고 : 빨간색 텍스트가 경고인 경우 “Warning :”으로 시작되고 R은 경고가있는 이유를 설명하려고합니다. 일반적으로 코드는 여전히 작동하지만 몇 가지주의 사항이 있습니다. 예를 들어 데이터 행 중 두 개에 산점도에서 포인트를 생성하는 데 필요한 누락된 항목이있는 데이터 세트를 기반으로 산점도를 생성하는 경우 Warning: Removed 2 rows containing missing values (geom_point)의 경고가 표시됩니다.. R은 나머지 비결측값이 모두 포함된 산점도를 생성하지만 두 점이 존재하지 않는다는 경고를 표시하는 것입니다. 메시지 : 빨간색 텍스트가 ‘오류’ 또는 ’경고’로 시작하지 않으면 친근한 메시지 일뿐 입니다. R 패키지 를 로드하거나 read_csv() 함수를 사용하여 스프레드 시트 파일에 저장된 데이터를 읽을 때 이러한 메시지가 표시됩니다 . 이는 유용한 진단 메시지이며 코드 작동을 중단하지 않습니다. 또한 install.packages()를 이용하여 패키지를 설치할 때에도 이러한 메시지가 표시됩니다 . 콘솔에 빨간색 텍스트가 표시 될 때 당황하지 마십시오. 반드시 잘못된 것이 있다는 의미는 아닙니다. 텍스트가 “오류”로 시작하면 원인을 파악하십시오. 오류를 빨간색 신호등으로 생각하십시오. 뭔가 잘못되었습니다! 텍스트가 “경고”로 시작하는 경우 걱정할 사항이 있는지 확인하십시오. 예를 들어 산점도에서 누락된 값에 대한 경고를 받고 누락된 값이 있음을 알고 있다면 괜찮습니다. 그게 놀랍다면 데이터를 보고 무엇이 누락되었는지 확인하십시오. 경고를 노란색 신호등으로 생각하십시오. 모든 것이 잘 작동하지만 주의를 기울이십시오. 그렇지 않으면 텍스트는 메시지일 뿐입니다. 그것을 읽고, R에게 손을 흔들고, 당신과 이야기해주셔서 감사합니다. 메시지를 녹색 신호등으로 생각하십시오. 모든 것이 잘 작동하며 계속 진행됩니다! 2.1.3 코딩 학습 팁 코딩/프로그래밍을 배우는 것은 외국어를 배우는 것과 매우 유사합니다. 처음에는 힘들고 실망 스러울 수 있습니다. 이러한 좌절감은 흔하며 배우면서 낙담하는 것은 정상입니다. 그러나 외국어를 배우는 것과 마찬가지로 노력을 기울이고 실수를 두려워하지 않으면 누구나 배우고 향상 할 수 있습니다. 다음은 프로그래밍을 배울 때 기억해야 할 몇 가지 유용한 팁입니다. 컴퓨터가 실제로 그렇게 똑똑하지 않다는 것을 기억하십시오. 컴퓨터나 스마트 폰이 “스마트”하다고 생각할 수 있지만 실제로 사람들은 “스마트”하게 보이도록 설계하는 데 많은 시간과 에너지를 소비했습니다. 실제로는 컴퓨터가 해야 할 모든 것을 말해야합니다. 또한 컴퓨터에 제공하는 지침에는 오류가 있을 수 없으며 어떤 식으로든 모호함이 없이 명확해야 합니다. “복사, 붙여 넣기 및 수정”접근 방식을 사용하십시오 . 특히 첫 번째 프로그래밍 언어를 배우거나 특히 복잡한 코드를 이해해야 할 때 작동하는 기존 코드를 사용하여 목적에 맞게 수정하는 것이 훨씬 쉽습니다. 이것은 처음부터 코드를 입력하려는 것과 반대입니다. 이를 “복사, 붙여 넣기 및 수정”이라고합니다. 따라서 처음에는 메모리에서 코드를 작성하지 말고 우리가 제공한 기존 예제를 선택한 다음 목표에 맞게 복사, 붙여 넣기 및 수정을 하는 것이 좋습니다. 더 자신감을 느끼기 시작한 후에는 천천히이 접근 방식에서 벗어나 처음부터 코드를 작성할 수 있습니다. “복사, 붙여 넣기 및 수정” 접근 방식을 자전거 타기를 배우는 어린이를 위한 훈련용 바퀴로 생각하십시오. 편안 해지면 더 이상 필요하지 않습니다. 코딩을 배우는 가장 좋은 방법은 다음을 수행하는 것입니다. 코딩 자체를 배우는 것보다 목표를 염두에 두고 있거나 데이터 분석과 같은 특정 프로젝트에서 작업할 때 코딩을 배우는 것이 훨씬 더 원활 해집니다. 당신이 관심이 있고 그것은 당신에게 중요합니다. 연습이 중요합니다. 외국어 실력을 향상시키는 유일한 방법은 많은 연습과 말하기를 통하는 것처럼 코딩 실력을 향상시키는 유일한 방법은 많은 연습을 통해서입니다. 그러나 걱정하지 마십시오. 그렇게 할 수있는 많은 기회가 주어집니다! "],["r-패키지란-무엇입니까.html", "2.2 R 패키지란 무엇입니까?", " 2.2 R 패키지란 무엇입니까? 많은 새로운 R 사용자와 혼동되는 또 다른 점은 R 패키지의 아이디어입니다. R 패키지는 추가 기능, 데이터 및 문서를 제공하여 R의 기능을 확장합니다. R 사용자의 전 세계 커뮤니티에서 작성했으며 인터넷에서 무료로 다운로드 할 수 있습니다. 예를 들어, 데이터 시각화를위한 ggplot2패키지 (Wickham, Chang, et al. 2020 ) , 데이터 랭글링을 위한 패키지 (Wickham, François, et al. 2020), `dplyr 패키지, moderndive 패키지 등 16,000 개가 넘는 많은 패키지들이 있습니다. 2.2.1 R과 R 패키지 R 패키지에 대한 좋은 비유는 휴대폰에 다운로드 할 수있는 앱과 같다는 것입니다. R 패키지와 R 패키지의 비유. 그림 1.4 : R 대 R 패키지의 유추. 따라서 R은 새로운 휴대폰과 같습니다. 처음 사용할 때 특정 기능이 있지만 모든 기능이 있는 것은 아닙니다. R 패키지는 Apple의 App Store 또는 Android의 Google Play에서 휴대폰으로 다운로드 할 수있는 앱과 같습니다. 사진 편집 및 공유를 위해 Instagram 앱을 고려하여이 비유를 계속해 보겠습니다. 새 휴대폰을 구입했고 방금 찍은 사진을 Instagram에서 친구들과 공유하고 싶다고 가정 해 보겠습니다. 다음을 수행해야 합니다. 앱 설치 : 휴대 전화가 새 휴대 전화이고 Instagram 앱이 포함되어 있지 않으므로 앱 스토어 또는 Google Play에서 앱을 다운로드해야합니다. 이 작업을 한 번 수행하면 설정됩니다. 나중에 앱 업데이트가 있을 때 이 작업을 다시 수행해야 할 수 있습니다. 앱 열기 : 인스타그램을 설치 한 후 열어야합니다. 휴대폰에서 Instagram이 열리면 계속해서 친구 및 가족과 사진을 공유할 수 있습니다. 프로세스는 R 패키지를 사용하는 것과 매우 유사합니다. 다음을 수행해야 합니다. 패키지 설치 : 휴대 전화에 앱을 설치하는 것과 같습니다. 대부분의 패키지는 R 및 RStudio를 설치할 때 기본적으로 설치되지 않습니다. 따라서 처음으로 패키지를 사용하려면 먼저 패키지를 설치해야 합니다. 패키지를 설치한 후에는 최신 버전으로 업데이트하지 않는 한 다시 설치하지 않을 것입니다. 패키지 “로드”: 패키지 “로드”는 휴대 전화에서 앱을 여는 것과 같습니다. 컴퓨터에서 RStudio를 시작할 때 기본적으로 패키지는 “로드”되지 않습니다. RStudio를 시작할 때마다 사용하려는 각 패키지를 “로드”해야 합니다. 데이터 시각화를 위한 ggplot2패키지에 대해 이 두 단계를 수행해 보겠습니다 . 2.2.2 패키지 설치 R 패키지를 설치하는 방법에는 쉬운 방법과 고급 방법의 두 가지가 있습니다. ggplot2먼저 패키지를 쉽게 설치해 보겠습니다 . RStudio의 파일 창에서 : “Package” 탭을 클릭합니다. 하단에 있는 “Install”을 클릭합니다. “Packages (separe multiple with space or comma)” 아래에 패키지 이름으로 ggplot2를 입력합니다. “Install” 버튼을 클릭하십시오. 그림 1.5 : 쉬운 방법으로 R에서 패키지 설치. 패키지를 설치하는 대안이지만 약간 덜 편리한 방법 install.packages(\"ggplot2\")은 RStudio의 콘솔 창에 입력하고 키보드에서 Return / Enter를 누르는 것입니다. 패키지 이름 주위에 따옴표를 포함해야합니다. 휴대폰의 앱과 마찬가지로 패키지를 한 번만 설치하면 됩니다. 그러나 이전에 설치한 패키지를 최신 버전으로 업데이트하려면 앞의 2.번 단계에서 “Update” 를 선택하여 다음 단계를 진행하면 됩니다. 2.2.3 패키지 로딩 패키지를 설치 한 후에는 “Load(로드)”해야 합니다. 즉, “열어야” 합니다. library()명령 을 사용하여 이를 수행합니다. 예를 들어 ggplot2패키지를 로드하려면 콘솔 창에서 다음 코드를 실행합니다. “다음 코드 실행”이란 무엇을 의미합니까? 콘솔 창에 다음 코드를 입력하거나 복사하여 붙여 넣은 다음 Enter 키를 누릅니다. library(ggplot2) 이전 코드를 실행한 후 깜박이는 커서가 &gt;“프롬프트”기호 옆으로 돌아오면 성공했으며, 이제 ggplot2 패키지가 로드되어 사용할 준비가 되었음을 의미합니다. 그러나 다음과 같은 빨간색 “오류 메시지”가 표시되면 ... Error in library(ggplot2) : there is no package called ‘ggplot2’... ... 성공적으로 설치하지 못했음을 의미합니다. 이것은 “오류 메시지”의 예입니다 . 이 오류 메시지가 표시되면 R 패키지 설치를 다시하고, 계속하기 전에 ggplot2패키지를 설치했는지 확인하십시오 . 2.2.4 패키지 사용 새로운 R 사용자가 특정 패키지를 사용하려고 할 때 흔히 범하는 실수 중 하나는 방금 본 명령 library()를 사용하여 먼저 패키지를 “로드”하는 것을 잊는 것입니다. 기억하세요 : RStudio를 시작할 때마다 사용하려는 각 패키지를 로드해야합니다. 먼저 패키지를 “로드”하지 않고 해당 기능 중 하나를 사용하려고하면 다음과 유사한 오류 메시지가 표시됩니다. Error: could not find function 이것은 아직 설치되지 않은 패키지에서 방금 본 것과 다른 오류 메시지입니다. R은 아직 “로드”되지 않은 패키지의 함수를 사용하려고 한다는 것을 알려줍니다. R은 사용중인 함수를 어디서 찾을 수 있는지 모릅니다. 거의 모든 신규 사용자는 시작할 때 이 작업을 잊어 버리고 익숙해지면 약간 짜증이 납니다. 그러나, 당신은 연습을 통해 기억할 것이고 얼마 후 그것은 당신에게 제 2의 천성이 될 것입니다. 2.2.5 참고 문헌 Bray, Andrew, Chester Ismay, Evgeni Chasnovski, Ben Baumer 및 Mine Cetinkaya-Rundel. 2020. 추론 : 깔끔한 통계 추론. Kim, Albert Y., Chester Ismay. 2020. Moderndive : Tidyverse-Friendly Introductory Linear Regression . https://github.com/ModernDive/moderndive_package. Wickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani 및 Dewey Dunnington. 2020. Ggplot2 : 그래픽 문법을 사용하여 우아한 데이터 시각화 만들기 . https://CRAN.R-project.org/package=ggplot2. Wickham, Hadley, Romain François, Lionel Henry 및 Kirill Müller. 2020. Dplyr : 데이터 조작의 문법 . https://CRAN.R-project.org/package=dplyr. "],["r-마크다운.html", "Chapter 3 R 마크다운 ", " Chapter 3 R 마크다운 "],["r-마크다운의-작동-원리.html", "3.1 R 마크다운의 작동 원리", " 3.1 R 마크다운의 작동 원리 R Markdown은 풍부하고 완벽하게 문서화되고 재현 가능한 분석을 생성하는 쉬운 방법을 제공합니다. 사용자는 분석을 처음부터 끝까지 재현하는 데 필요한 모든 주석, R 코드 및 메타 데이터가 포함 된 단일 파일을 공유 할 수 있습니다. R Markdown을 사용하면 HTML 또는 LaTeX 코드를 알지 못하거나 Microsoft Word DOCX 파일에서 바로 서식을 가져 오는 데 소란스럽지 않고도 R 코드 청크를 Markdown 텍스트와 결합하고 멋진 형식의 HTML, PDF 또는 Word 파일을 생성 할 수 있습니다. 하나의 R Markdown 파일은 다양한 형식을 생성 할 수 있으며이 모든 작업은 몇 비트 형식의 단일 텍스트 파일을 사용하여 수행됩니다. 일단 익숙해지면 R Markdown 문서를 작성하는 것이 얼마나 쉬운 지 유쾌하게 놀랄 것입니다. 3.1.1 개요 R Markdown은 데이터 과학을위한 저작 프레임 워크를 제공합니다. 단일 R Markdown 파일을 두 가지 모두에 사용할 수 있습니다. 코드 저장 및 실행 청중과 공유 할 수있는 고품질 보고서 생성 R Markdown 문서는 완전히 재현 가능하며 수십 개의 정적 및 동적 출력 형식을 지원합니다. 이 1 분짜리 비디오는 R Markdown으로 무엇을 할 수 있는지에 대한 빠른 둘러보기를 제공합니다. 3.1.2 설치 나머지 R과 마찬가지로 R Markdown은 무료이며 오픈 소스입니다. 다음을 사용하여 CRAN에서 R Markdown 패키지를 설치할 수 있습니다. install.packages(&quot;rmarkdown&quot;) 3.1.3 시작하다 왼쪽 링크는 R Markdown에 대한 빠른 둘러보기를 제공합니다. 상단의 링크는 R Markdown 문서의 예와 다양한 R Markdown 주제에 대한 심층 토론을 제공합니다. 다음 리소스가 도움이 될 수도 있습니다. R Markdown 치트 시트 R Markdown 참조 가이드 3.1.4 작동 원리 확장명이 .txt 는 일반 텍스트 파일이며, R Markdown 파일의 확장자는 .Rmd입니다. img Rmd 파일에는 세 가지 유형의 콘텐츠가 포함되어 있습니다. --- ---로 둘러싸인 YAML 헤더 (선택 사항) ``` ```로 둘러싸인 R 코드 청크 간단한 텍스트 서식과 혼합된 텍스트 3.1.4.1 노트북 인터페이스 RStudio IDE에서 파일을 열면 R 용 노트북 인터페이스 가됩니다 . 아이콘 을 클릭하여 각 코드 청크를 실행할 수 있습니다 . RStudio는 코드를 실행하고 결과를 파일과 함께 인라인으로 표시합니다. img 3.1.4.2 렌더링 출력 파일에서 보고서를 생성하려면 다음 render명령을 실행하십시오 . library(rmarkdown) render(&quot;1-example.Rmd&quot;) 더 좋은 방법은 RStudio IDE의 “Knit”버튼을 사용하여 파일을 렌더링하고 한 번의 클릭 또는 키보드 단축키 (K)로 출력을 미리 볼 수 있습니다. img R Markdown은 선택한 텍스트, 코드 및 .Rmd 파일의 결과를 포함하는 새 파일을 생성합니다. 새 파일은 완성 된 웹 페이지 , PDF , MS Word 문서, 슬라이드 쇼 , 노트북 , 유인물 , 책 , 대시 보드 , 패키지 비 네트 또는 기타 형식 일 수 있습니다. 3.1.5 작동 원리 img Rmd 문서를 실행(render)하면 R Markdown 은 모든 코드 청크를 실행하고 코드와 해당 출력을 포함하는 새 마크 다운 (.md) 문서를 생성하는 knitr에 .Rmd 파일을 공급합니다 . knitr에 의해 생성된 마크 다운 파일은 완성된 형식을 생성하는 pandoc에 의해 처리됩니다 . 이것은 복잡하게 들릴 수 있지만 R Markdown은 위의 모든 처리를 단일 render함수 로 캡슐화하여 매우 간단하게 만듭니다 . 3.1.6 코드 청크 아래의 R Markdown 파일에는 세 개의 코드 청크가 있습니다. img 다음을 사용하여 이러한 청크를 파일에 빠르게 삽입 할 수 있습니다. 키보드 단축키 + - [I] (OS X : Cmd + Option + I** ) 에디터 툴바 의 Add Chunk 명령 또는 청크 구분 기호 ```{r}와 ``` .Rmd 파일을 렌더링할 때 R Markdown은 각 코드 청크를 실행하고 최종 보고서의 코드 청크 아래에 그 결과를 포함합니다. 3.1.6.1 청크 옵션 청크 출력은 knitr 옵션 , {}청크 헤더에 설정된 인수로 사용자 정의할 수 있습니다. 위에서 우리는 다섯 가지 인수를 사용합니다. include = FALSE완성된 파일에 코드와 결과가 나타나지 않도록합니다. R Markdown은 여전히 청크의 코드를 실행하며 결과는 다른 청크에서 사용할 수 있습니다. echo = FALSE코드를 차단하지만 완성된 파일에 결과가 표시되지는 않습니다. 이것은 그림을 포함하는 유용한 방법입니다. message = FALSE 코드에 의해 생성된 메시지가 완성된 파일에 나타나지 않도록 합니다. warning = FALSE 코드에 의해 생성 된 경고가 완료된 항목에 나타나지 않도록 합니다. error = TRUE 코드에 의해 생성된 에러 메시지를 출력합니다. 코드 청크에 에러가 있으면 knit 가 진행되지 않습니다. 이때, 이 코드 청크의 에러를 출력하고 knit 가 작업을 계속 진행하게 해 줍니다. fig.cap = \"...\" 그래픽 결과에 캡션을 추가합니다. knitr 청크 옵션의 전체 목록은 R Markdown 참조 가이드 를 참조하십시오 . 3.1.6.2 글로벌 옵션 파일의 모든 청크에 적용되는 전역 옵션을 설정하려면 knitr::opts_chunk$set코드 청크를 호출하십시오 . Knitr는 전달하는 각 옵션을 knitr::opts_chunk$set개별 청크 헤더에서 덮어 쓸 수있는 전역 기본값으로 취급합니다. 3.1.6.3 캐싱 긴 계산으로 인해 문서 렌더링에 시간이 많이 걸리는 경우 knitr 캐싱을 사용하여 성능을 향상시킬 수 있습니다. Knitr 청크 및 패키지 옵션 은 캐싱 작동 방식 을 설명하고 캐시 예제 는 추가 세부 정보를 제공합니다. 3.1.7 인라인 코드 r코드를 .Rmd 파일의 텍스트 영역에 삽입하여 그 결과를 텍스트와 함께 출력할 수 있게 해 줍니다. 아래 파일은 heat.colors를 반환하는 r의 colorFunc 변수를 텍스트 영역과 헤더 영역에 r colorFunc 형태로 두 번 사용합니다. img 이렇게 해서 텍스트 내에 다른 기능을 참조하도록 출력하여 보고서를 쉽게 업데이트 할 수 있습니다. img R Markdown은 항상 인라인 코드의 결과를 표시하지만 코드는 표시하지 않습니다. 결과에 관련 텍스트 서식을 적용할 수 있습니다. 결과적으로 인라인 출력은 주변 텍스트와 구별할 수 없습니다. 인라인 표현식은 knitr 옵션을 사용하지 않습니다. 3.1.8 코드 언어 이 .Rmd 파일이 bash 및 python에서 코드를 실행하는 방법에 유의하십시오. img knitr 는 R 외에 여러 언어로 코드를 실행할 수 있습니다. 사용 가능한 언어 엔진 중 일부는 다음과 같습니다. 파이썬 SQL 세게 때리다 Rcpp Stan 자바 스크립트 CSS 대체 언어 엔진을 사용하여 코드 청크를 처리하려면 r청크 선언의 시작 부분에있는를 언어 이름으로 바꿉니다. ```{bash} ``` 같은 청크 옵션을 참고 echo하고 results파이썬 같은 언어 엔진을 사용하는 경우 모두 유효합니다. knitr 언어 엔진 에서 R Markdown과 함께 다른 언어를 사용하는 방법에 대해 자세히 알아보십시오 . 3.1.9 매개 변수 R Markdown 문서에는 보고서를 렌더링할 때 값을 설정할 수있는 하나 이상의 매개 변수가 포함될 수 있습니다. 예를 들어, 아래 파일에서 data는 플로팅할 데이터 세트를 결정하는 매개 변수를 사용하고 있습니다. img 3.1.9.1 매개 변수 선언 매개 변수는 YAML 헤더 내에서 params필드를 사용하여 선언됩니다 . 예를 들어, 위의 파일은 매개 변수를 생성하고 data 기본값으로 \"hawaii\" 를 할당하고 있습니다 . 3.1.9.2 코드에서 매개 변수 사용 매개 변수는 knit 환경 내에서 params 라는 읽기 전용 목록으로 사용할 수 있습니다. 코드에서 매개 변수에 액세스하려면을 params$&lt;parameter name&gt; 형식으로 호출하면 됩니다 . 3.1.9.3 매개 변수 값 설정 새 매개 변수 값 세트를 사용하는 보고서를 작성하려면 render에 params인수를 추가하십시오 . 여기에서 aleutians데이터 세트를 사용하도록 보고서를 수정하기 위해서는 다음과 같이 합니다. render(&quot;5-parameters.Rmd&quot;, params = list(data = &quot;aleutians&quot;)) img 더 좋은 방법은 RStudio IDE knit 버튼 옆에있는 드롭 다운 메뉴에서 “Knit with Parameters”옵션을 클릭하여 매개 변수를 설정하고, 사용자 친화적인 단일 단계에서 보고서를 미리 볼 수 있습니다. img 매개 변수는 다양한 키 입력에 대해 고유한 값을 사용하여 동일한 보고서를 다시 렌더링하려는 경우에 유용합니다. 예를 들면 다음과 같습니다. 부서 또는 지역별 보고서 실행. 특정 기간을 다루는 보고서 실행. 별개의 핵심 가정 세트를 위해 여러 버전의 보고서를 실행합니다. 매개 변수화 된 보고서 에서 매개 변수에 대해 자세히 알아보십시오 . 3.1.10 테이블 기본적으로 R Markdown은 데이터 프레임과 행렬을 R 터미널에 있는 것처럼 (고정 폭 글꼴로) 표시합니다. 데이터를 추가 형식으로 표시하려면 knitr::kable아래 .Rmd 파일에서와 같이 함수를 사용할 수 있습니다. img results='asis'청크 옵션 사용에 유의하십시오 . 이것은 원시 테이블 출력이knitr에 의해 더 이상 처리되지 않도록하기 위해 필요합니다. "],["r-마크다운-문서-작성.html", "3.2 R 마크다운 문서 작성", " 3.2 R 마크다운 문서 작성 R Markdown은 풍부하고 완벽하게 문서화되고 재현 가능한 분석을 생성하는 쉬운 방법을 제공합니다. 사용자는 분석을 처음부터 끝까지 재현하는 데 필요한 모든 주석, R 코드 및 메타 데이터가 포함 된 단일 파일을 공유 할 수 있습니다. R Markdown을 사용하면 HTML 또는 LaTeX 코드를 알지 못하거나 Microsoft Word DOCX 파일에서 바로 서식을 가져 오는 데 소란스럽지 않고도 R 코드 청크를 Markdown 텍스트와 결합하고 멋진 형식의 HTML, PDF 또는 Word 파일을 생성 할 수 있습니다. 하나의 R Markdown 파일은 다양한 형식을 생성 할 수 있으며이 모든 작업은 몇 비트 형식의 단일 텍스트 파일을 사용하여 수행됩니다. 일단 익숙해지면 R Markdown 문서를 작성하는 것이 얼마나 쉬운 지 유쾌하게 놀랄 것입니다. 3.2.1 R Markdown 파일의 오류 수정 3 장에서 만든 R Markdown 파일 ( first_rmarkdown.Rmd )을 기억하십시오 . 우리는 변수 생성에 약간의 오류를 남겼다는 것을 알고 있으며 오류를 표시하는 것이 이상하게 보일 수 있지만 R을 처음 접하는 사람이 처음에 볼 수있는 다양한 오류를 보는 것은 좋은 노출입니다. 이러한 오류가있는 HTML 니트 버튼을 클릭하면 어떤 일이 발생하는지 살펴 보겠습니다 . 그런 다음 코드를 정리하고 Knit 에서 결과 파일이 어떻게 보이는지 확인합니다 . 이 R Markdown 파일을 처음 만들었을 때 R Markdown 파일에 포함 할 수있는 항목의 종류를 알 수 있도록 기본 템플릿이 일부 코드와 텍스트로 미리 채워졌습니다. 여기에서 해당 코드 중 일부를 수정했습니다. 예를 들어, cars이름이 저장된 객체 선언에서 오류가 발생하지 않았음에도 불구하고 명명 된 코드 청크의 모든 줄을 제거 했습니다. View in Pane 이 선택 되었기 때문에 뷰어 창 에 HTML 파일이 생성되는 것을 볼 수 있습니다 . Including Plots 텍스트 를 살펴보면 R Markdown 파일에 제공된 플롯이 없지만 HTML 파일에 온도 및 압력의 산점도가 포함되어 있다는 사실에 놀랄 수 있습니다. 이는 R Markdown이 R 청크에 저장된 코드를 평가 한 다음 해당 결과를 HTML (또는 PDF 또는 DOCX 등) 출력에 포함하기 때문입니다. R 코드 앞뒤에 텍스트가 주석으로 표시되는 것을 볼 수도 있습니다. “Including Plots”라는 텍스트가 다른 텍스트보다 훨씬 큰 이유를 조금 이해하게 될 것입니다. 중요 사항 : 실행하려는 모든 R 코드는 분석을 재현 할 수 있고 Knit를 사용할 때 오류가 발생하지 않도록 청크 (정확한 순서로)에 저장되어야합니다 . R 콘솔 에서 많은 작업을 수행 한 다음 해당 작업을 Rmd 파일 의 청크에 추가하는 것을 잊는 것은 쉽습니다 . 이것은 아마도 RStudio에서 처음 작업을 시작할 때 보게 될 가장 큰 오류 일 것입니다. 이 오류의 예는 다음과 같습니다. object not found오류가 가장 자주 발생하는 오류이며, R.이는 장에서 더 자세히 설명으로 잘못된 철자와 불완전 R 코드 세그먼트와 함께 문제의 대부분을 나타냅니다 (6) . 3.2.2 R Markdown 파일의 구성 요소 3.2.2.1 YAML 파일의 윗부분을 YAML 헤더라고합니다. YAML은 “YAML Ai n’t Markup Language”의 약자이며 공식 웹 사이트 http://yaml.org 에서 다음과 같이 정의 됩니다. YAML은 모든 프로그래밍 언어에 대한 인간 친화적 인 데이터 직렬화 표준입니다. 기본적으로 YAML 헤더는 문서에 필요한 메타 데이터를 저장합니다. first_rmarkdown.Rmd 파일 에서 YAML 헤더의 예를 볼 수 있습니다 . --- title: &quot;First RMarkdown&quot; author: &quot;Chester Ismay&quot; output: html_document --- YAML 헤더에서 사용자 정의 할 수있는 다른 많은 필드가 있습니다. 여기서 주목해야 할 중요한 것은 YAML 헤더를 시작하고 끝나는 세 개의 하이픈입니다. 들여 쓰기는 YAML에서도 의미가 있으므로 텍스트를 정렬 할 때주의하십시오. 3.2.2.2 헤더 위에서 볼 수 있듯이 헤더 #를 표시하려는 텍스트 앞에 하나 이상의 헤더를 추가하여 다양한 크기의 헤더를 만들 수 있습니다 . 3.2.2.3 강조 R Markdown 문서의 텍스트에 해시 태그가 표시 될 때마다 문서 섹션의 시작을 나타내는 굵게 표시된 더 큰 텍스트 2에 해당한다는 것을 알 수 있습니다. 이것은 R Markdown의 멋진 기능 중 하나입니다. 일반 텍스트를보고 니트 문서에서 생성되는 내용을 알 수 있습니다. 또한 단어, 구 또는 문장을 일치하는 기호로 둘러 싸서 다양한 스타일의 강조를 추가 할 수 있습니다. 다음은 몇 가지 예입니다. 출력을 사용자 정의하는 것이 얼마나 쉬운 지 알기 시작했습니다. 다음으로 URL에 링크를 추가하고, 정렬 된 목록과 정렬되지 않은 목록을 만들고, 자주 사용되는 다른 마크 다운 기능을 사용하는 방법에 대해 설명합니다. 3.2.2.4 링크 URL에 대한 링크를 추가하려면 결과 HTML 파일에 표시 할 텍스트를 내부 [ ]에 넣은 다음 그 ( )사이에 공백없이 바로 옆에 있는 링크 자체 를 묶으면됩니다 . 3.2.2.5 목록 아래 스크린 캐스트는 정렬 된 목록과 정렬되지 않은 목록을 모두 만드는 과정을 보여줍니다. “Warm up food”에 “1”로 번호를 매기면서 본 것처럼 숫자 만 필요합니다. 텍스트를 두 개의 공백으로 들여 쓰기하여 정렬되지 않은 목록과 정렬 된 목록을 결합 할 수도 있습니다. 다음의 많은 예에서 R Markdown 문서에 입력 한 실제 텍스트가 회색 배경으로 강조 표시되고 바로 아래에 해당 텍스트의 결과가 표시됩니다. 1. Wake up - Get out of bed 1. Warm up food - Open kitchen door - Get plate out of cupboard 2. Make coffee i. Warm up water ii. Grind beans 3. Make breakfast We can have a paragraph (or two) here describing how we could go about making breakfast. If we indent the paragraph a few spaces and create a newline, it will indent below the item. 일어나 침대에서 일어나 음식 예열 오픈 키친 도어 찬장에서 접시 꺼내기 커피를 만들다 물 데우기 콩 갈기 아침을 만들다 여기에 우리가 아침 식사를 만드는 방법을 설명하는 단락 (또는 두 개)이있을 수 있습니다. 단락을 몇 개의 공백으로 들여 쓰면 항목 아래에 들여 쓰기됩니다. 3.2.2.6 기타 마크 다운 줄 바꿈 / 흰색 간격 공백과 결합 된 줄 바꿈은 종종 새 단락의 시작을 나타 내기 때문에 Markdown에서 매우 중요합니다. Here is an example of text with only a line break. You may expect this line to appear in a new paragraph but it doesn&#39;t. 다음은 줄 바꿈 만있는 텍스트의 예입니다. 이 줄이 새 단락에 나타날 것으로 예상 할 수 있지만 그렇지 않습니다. 새 단락을 시작하려면 두 단락 사이에 공백을 추가해야합니다. Here is an example of text with a line break and white space. You may expect this line to appear in a new paragraph and it does. 다음은 줄 바꿈과 공백이있는 텍스트의 예입니다. 이 줄이 새 단락에 나타날 것으로 예상 할 수 있습니다. 수평 규칙 문서의 다른 부분을 나누는 또 다른 유용한 방법은 가로줄을 포함하는 것입니다. 가로줄은 세 개의 별표 (또는 세 개의 하이픈)를 나란히 배치하여 추가 할 수 있습니다. *** --- 인용구 누군가를 인용하거나 들여 쓰기 된 텍스트 블록을 생성 &gt;하려면 구절 앞에 를 추가하면됩니다 . &gt; Reproducible research is the idea that data analyses, and more generally, scientific claims, are published with their data and software code so that others may verify the findings and build upon them. - Roger Peng 재현 가능한 연구는 데이터 분석,보다 일반적으로 과학적 주장이 데이터 및 소프트웨어 코드와 함께 게시되어 다른 사람들이 결과를 확인하고이를 기반으로 구축 할 수 있다는 아이디어입니다. -로저 펭 주석 텍스트 R Markdown 문서 내에서 텍스트를 주석 처리하고 싶을 때가 있습니다. 결과 니트 문서에서 원하지 않는 내용을 작성했지만 완전히 삭제해야하는지 확실하지 않다고 가정 해 보겠습니다. 주석을 작성하려면 &lt;!-- --&gt;아래와 같이 텍스트 블록을 묶으십시오 . &lt;!-- I&#39;d like to save this text for later and don&#39;t want to delete it yet. --&gt; 이 책에서 주석 처리 된 결과를 볼 수 없습니다. 방정식 문서에 멋진 수학 공식이 필요한 경우 두 달러 기호 사이에 추가 할 수 있습니다. $y = mx + b$ 와이=미디엄엑스+비y=mx+b 3.2.2.7 R 청크 이제 기본 사항을 숙지 했으므로 R Markdown의 가장 좋은 부분 인 결과 출력에 컴파일 된 문서에 R 코드를 직접 포함 할 수있는 기능을 얻을 수 있습니다. 이미 R Markdown 파일에서 R 청크의 몇 가지 예를 보았습니다. 이러한 코드 블록은 모두 사용자가 알아야하는 몇 가지 공통 속성을 공유합니다. 코드 블록은 항상 세 개의 백틱으로 시작하고 끝납니다 `````. 처음 세 개의 백틱 후에 R 청크의 첫 번째 줄은로 시작하고 {r선택적으로 이름 및 / 또는 기타 청크 옵션을 포함하고 }. 시작과 닫는 세 개의 백틱 사이에있는 줄은 콘솔에서 실행할 수있는 유효한 R 코드입니다. 이러한 백틱 앞에 공백을 포함하면 오류가 발생합니다. 우리에 first_rmarkdown.Rmd 파일의이 인식하고 우리 자신의 R 덩어리를 만드는 예를 살펴 보자 : 이 예제에서는 값 벡터를 만드는 두 가지 방법을 소개합니다. 이에 대한 자세한 내용은 5 장에서 볼 수 있습니다. Knit HTML 버튼을 눌렀을 때 코드가 자동으로 실행 되고 그 출력이 니트 파일에 포함 된 것을 볼 수 있습니다. 중요 참고 사항 :이 이후의 다른 R 청크는 여기에서 생성 된 세 가지 변수 count20인 count100_by_5,, prod. mult_vectors명명 된 청크 이전의 청크 는 이러한 변수에 액세스 할 수 *없습니다* . 책처럼 문서를 읽을 수 있으므로 개체를 추가하고 적절한 순서로 작업하는 것이 중요합니다. 그렇지 않으면 R에서 오류를 받게됩니다. 3.2.2.8 인라인 R 코드 우리는 R 코드를 추가 할 수 있고 세 개의 백틱으로 묶인 R 코드 청크에서 실행할 수 있음을 확인했습니다. 그러나 간단한 계산 결과를 문서 텍스트에 직접 포함하려면 어떻게해야합니까? R Markdown도 그렇게 할 수 있습니다. 또 다른 교묘 한 접근 방식은 문서에서 생성 된 텍스트가 R 코드의 결과에 따라 자동으로 업데이트되도록하는 것입니다. 이에 대한 예를보기 위해 count20벡터 에서 무작위로 숫자를 선택합니다 . 숫자가 10보다 크거나 같으면 그렇게 말할 것입니다. 그렇지 않은 경우보고합니다. 세 번째 인수를 ifelse인용 부호에 포함하지 않았을 때 R에서 오류가 발생했음을 알 수 있습니다 . 그러나 코드를 수정하고 Knit HTML을 다시 누르면 오류가 사라졌습니다. 3.2.2.9 코드 강조 이전 예에서 보았 듯이 R 개체의 이름을 강조 표시하여 일반 텍스트와 구별하는 것이 좋습니다. 이것은 우리가했던 것과 같은 단일 백틱으로 단어를 묶어 수행 할 수 있습니다 one_value. 3.2.3 R 마크 다운 청크 옵션 청크 단위로 청크에 여러 옵션을 설정할 수 있습니다. 가장 일반적인 R 청크 옵션은 echo, eval하고 include. 기본적으로 이러한 세 가지 옵션은 모두로 설정됩니다 TRUE. echo 결과를 생성하는 코드가 해당 R 출력 전에 인쇄되어야하는지 여부를 나타냅니다. eval 코드를 평가할지 아니면 출력없이 표시할지 여부를 지정합니다. include코드와 그 출력이 결과 편직 문서에 포함되어야하는지 여부를 지정합니다. FALSE코드 로 설정되어 있으면 실행되지만 코드 또는 출력이 결과 문서에 포함되지 않습니다. 우리가 그것을 지정 eval=FALSE했고 그 청크가 one_value변수를 선언 한 곳 이었기 때문에 이제 오류가 발생합니다. 각 옵션을 쉼표로 구분하여 여러 청크 옵션을 포함 할 수 있습니다. 3.2.4 R Markdown 파일 작성을위한 일반 지침 공백은 당신의 친구입니다. R 청크와 Markdown 텍스트 사이에는 항상 빈 공백을 포함해야합니다. 문서를 훨씬 더 읽기 쉽게 만들고 잠재적 인 오류를 줄일 수 있습니다. 또한 헤더 텍스트와 단락 사이에 공백을 남겨 두십시오. 해설은 항상 좋습니다. 가능할 때마다 자신과 아이디어를 설명하십시오. 가장 빈번한 공동 작업자는 몇 달 후에는 본인 일 가능성이 높습니다. 미래에 친절하게 대하고 무엇을하고 있는지 설명하여 기억할 수 있도록하십시오! 콘솔 및 R 마크 다운 환경 (편직시)은 서로 상호 작용하지 않습니다. 이렇게하면 다른 사람과 공유하려는 결과를 정확히 생성하는 코드 만 R 청크에 포함해야합니다. 추가 출력으로 문서를 부 풀리지 마십시오. 무엇을하고 있는지 간결하고 명확하게 설명하십시오. 청크 옵션은 문서를 실제로 아름답게 꾸미고 문서 독자가보기를 원하는대로 정확하게 사용자 지정할 수 있습니다. 여기 에서 사용 가능한 모든 R 청크 옵션에 대한 자세한 정보를 찾을 수 있습니다 . 3.2.5 도움말-&gt; 치트 시트 RStudio는 RStudio 내에서 수행 할 많은 일반적인 작업에 대한 훌륭한 참조 역할을 할 수있는 정말 멋진 치트 시트를 제공합니다. 도움말-&gt; RStudio 내의 치트 시트 로 이동하여 파일의 멋진 PDF 버전을 얻을 수 있습니다 . RStudio 치트 시트 스크린 샷 그림 4.1 : RStudio Cheatsheets 스크린 샷 3.2.6 맞춤법 검사 R Markdown 편집기 창 상단에는 문서 작성에 유용한 도구 중 하나 인 맞춤법 검사 버튼이 있습니다. 위에 “ABC”가있는 녹색 확인 표시입니다. img img 문서를 제출하거나 다른 사람과 공유하기 전에 문서의 맞춤법을 검사해야합니다. 단어로 인식되지 않을 수 있기 때문에 사전에 R 명령을 추가하거나 무시해야 할 수도 있지만, 입력 할 때 단어의 철자를 틀리기 쉽고이 기능이 정말 도움이 될 수 있습니다. 네 번째, 다섯 번째 또는 여섯 번째 수준의 헤더를 원하지 않는 한 일반적이지 않습니다.  3.2.6.1 출력 형식 의 output_format인수를 설정하여 .Rmd 파일을 render하여 R Markdown의 지원되는 형식으로 렌더링합니다. 예를 들어 아래 코드는 1-example.Rmd를 Microsoft Word 문서로 렌더링합니다. library(rmarkdown) render(&quot;1-example.Rmd&quot;, output_format = &quot;word_document&quot;) img 형식을 선택하지 않으면 R Markdown은 파일을 output.Rmd 파일 헤더의 필드 에서 설정할 수있는 기본 형식으로 렌더링합니다 . 1-example.Rmd의 헤더는 기본적으로 HTML 파일로 렌더링됨을 보여줍니다. RStudio IDE Knit 버튼은 파일을 해당 output필드에 나열된 첫 번째 형식으로 렌더링합니다. 니트 버튼 옆에있는 드롭 다운 메뉴를 클릭하여 추가 형식으로 렌더링할 수 있습니다. img R Markdown과 함께 사용할 수있는 출력 형식은 다음과 같습니다. 문서 html_notebook- 대화 형 R 노트북 html_document- 부트 스트랩 CSS가있는 HTML 문서 pdf_document -PDF 문서 (LaTeX 템플릿 사용) word_document -Microsoft Word 문서 (docx) odt_document -OpenDocument 텍스트 문서 rtf_document- 서식있는 텍스트 문서 md_document- 마크 다운 문서 (다양한 특징) 프레젠테이션 (슬라이드) ioslides_presentation - ioslides가있는 HTML 프레젠테이션 revealjs :: revealjs_presentation - reveal.js를 사용한 HTML 프리젠 테이션 slidy_presentation -W3C Slidy를 사용한 HTML 프리젠 테이션 beamer_presentation -LaTeX Beamer를 사용한 PDF 프레젠테이션 powerpoint_presentation : PowerPoint 프레젠테이션 기타 flexdashboard :: flex_dashboard- 대화형 대시 보드 tufte :: tufte_handout -Edward Tufte 스타일의 PDF 유인물 tufte :: tufte_html -Edward Tufte 스타일의 HTML 유인물 tufte :: tufte_book -Edward Tufte 스타일의 PDF 책 html_vignette -R 패키지 비 네트 (HTML) github_document -GitHub Flavored Markdown 문서 R Markdown을 사용 하여 책 , 웹 사이트 및 대화 형 문서 를 만들 수도 있습니다 . 3.2.6.2 출력 옵션 각 출력 형식은 R의 함수로 구현됩니다. YAML 메타 데이터의 output. 필드 의 하위 값으로 함수에 인수를 전달하여 출력을 사용자 정의할 수 있습니다 . 예를 들어, 8-outputs.Rmd 는 부동 목차로 렌더링됩니다. img 형식이 어떤 인수를 사용하는지 알아 보려면 R 형식의 도움말 페이지 (예 : ?html_document. 참고 문헌 Grolemund, Garrett. 2014. R을 사용한 실습 프로그래밍 . 오라일리. "],["변수와-데이터-타입.html", "Chapter 4 변수와 데이터 타입", " Chapter 4 변수와 데이터 타입 관례적으로 “Hello, World!” 프로그램을 작성하여 R의 프로그래밍을 배우기 시작합니다. 필요에 따라 R 명령 프롬프트에서 프로그래밍하거나 R 스크립트 파일을 사용하여 프로그램을 작성할 수 있습니다. 둘 다 하나씩 확인합시다. "],["명령어-프롬프트.html", "4.1 명령어 프롬프트", " 4.1 명령어 프롬프트 R 환경 설정이 완료되면 R Studio를 실행하면 왼쪽 하단부에 Console 창에 다음과 같은 명령 프롬프트가 나타나 있습니다. 이 프롬프트는 R의 인터프리터가 작동되고 있음을 나타내며, 다음과 같이 프로그램 코드를 입력해 보기 바랍니다. (아니면 한 줄씩 블럭을 설정하여 +로 복사하여 프롬프트에 +로 붙여 넣기 합니다.) myString &lt;- &quot;Hello, World!&quot; myString ## [1] &quot;Hello, World!&quot; 여기서 첫 번째 문은 문자열 변수 myString을 정의하고 있는데, 이 변수에 문자열 \"Hello, World!\"을 할당 연산자 &lt;-를 이용하여 이 변수에 할당하고 있습니다. R Studio의 환경 창에 이 변수에 대한 정보가 게시되는 것을 확인하기 바랍니다. 다음 명령문은 단순히 변수명을 입력하고 있습니다. 이는 변수 myString에 저장된 값을 출력하는데 사용됩니다. "],["r-스크립트-파일.html", "4.2 R 스크립트 파일", " 4.2 R 스크립트 파일 일반적으로 스크립트 파일에 프로그램을 작성하여 프로그래밍을 하고, R script라는 R 인터프리터의 도움으로 명령 프롬프트에서 해당 스크립트를 실행하게 됩니다. 이제 test.R이라는 텍스트 파일에 다음 코드를 작성하는 것으로 시작하겠습니다. # R 프로그램의 첫 번째 프로그램 myString &lt;- &quot;Hello, World!&quot; myString ## [1] &quot;Hello, World!&quot; 위 코드를 편집 창에 입력한 다음 test.R 파일에 저장하고 첫 번째 줄에 커서를 위치시킨 다음 Run(실행) 버튼을 눌러서 실행합니다. 그러면 콘솔 창에 한줄 씩 스크립트가 표시되고 그 결과가 출력되는 것을 확인할 수 있습니다. "],["설명문.html", "4.3 설명문", " 4.3 설명문 설명문(주석, comments)은 R 프로그램의 도움말 텍스트와 같으며 실제 프로그램을 실행하는 동안 인터프리터는 이를 무시합니다. R 스크립트에서 설명문은 줄 단위로 입력할 수 있으며, # 기호를 이용하여 추가할 수 있습니다. (R Markdown의 # 기호와는 구분해야 합니다. 앞의 스크립트에서 첫 줄에 있는 # R 프로그래밍의 첫번째 프로그램은 스크립트를 설명하는 설명문(주석)입니다. "],["데이터-유형.html", "4.4 데이터 유형", " 4.4 데이터 유형 자료 : https://www.tutorialspoint.com/r/r_data_types.htm 일반적으로 모든 프로그래밍 언어로 프로그래밍하는 동안 다양한 정보를 저장하기 위해 다양한 변수를 사용해야 합니다. 그런데 변수는 값을 저장하기 위해 예약된 메모리 위치를 나타낼 뿐입니다. 이것은 변수를 만들 때 메모리에 약간의 공간을 예약한다는 것을 의미합니다. 문자, 와이드 문자, 정수, 부동 소수점, 이중 부동 소수점, 부울 등과 같은 다양한 데이터 유형의 정보를 저장하고 싶을 수 있습니다. 운영 체제는 변수의 데이터 유형에 따라 메모리를 할당하고 예약된 메모리에 무엇을 저장할 지를 결정합니다.. R의 C나 java와 같은 다른 프로그래밍 언어와 달리 변수는 일부 데이터 유형으로 선언되지 않습니다. 변수는 R-객체(objects)로 할당되고 R-객체의 데이터 유형은 변수의 데이터 유형이 됩니다. 많은 유형의 R-객체가 있습니다. 자주 사용되는 R-개체의 유형은 다음과 같습니다 : 벡터(Vectors) 리스트(Lists) 행렬(Matrices) 배열(Arrays) 요인(Factors) 데이터 프레임(Data Frames) 이러한 객체 중 가장 간단한 것은 벡터 객체이며 이러한 원자 벡터(atomic vector)에는 6 개의 데이터 유형이 있으며 6 개의 벡터 클래스라고도합니다. 그 밖의 다른 R-개체들은 원자 벡터를 기반으로 합니다. 데이터 유형 예 실 습 논리형 (logical) TRUE, FALSE v &lt;- TRUEclass(v) 숫자형 (numeric) 12.3, 5, 999 v &lt;- 23.5class(v) 정수형 (integer) 2L, 34L, 0L v &lt;- 2Lclass(v) 복소수 (complex) 3 + 2i v &lt;- 2+5iclass(v) 문자형 (character) 'a' , \"good\", \"TRUE\", '23.4' v &lt;- \"TRUE\"class(v) 원시형 (raw) “Hello” 라는 문자열은 실제로 48 65 6c 6c 6f의 형태로 저장이 됩니다. v &lt;- charToRaw(\"Hello\")class(v) R 프로그래밍에서 매우 기본적인 데이터 유형은 위에 표시된대로 서로 다른 클래스의 요소를 보유하는 벡터라는 R-객체입니다. R에서 클래스 수는 위의 6 가지 유형에만 국한되지 않습니다. 예를 들어, 많은 원자 벡터를 사용하여 클래스가 배열이 되는 배열(array)을 만들 수 있습니다. "],["예약어.html", "4.5 예약어", " 4.5 예약어 R 프로그래밍에서 예약어(reservec words)는 특별한 의미를 가지며 식별자(identifier)(변수 이름, 함수 이름 등)로 사용할 수없는 단어 집합입니다. 다음은 R의 파서에 있는 예약어 목록입니다. if else repeat while function foin next break TRUE FALSE NULL Inf NaN NA NA_integer_ NA_real_ NA_complex_ NA_character_ … 이 목록은 다음과 같이 R 명령 프롬프트에서 help (reserved) 또는? reserved를 입력하여 확인할 수 있습니다. ? reserved 이 중에서 if, else, repeat, while, function, for, in, next 및 break는 제3부에서 다루는 조건, 루프 및 사용자 정의 함수에 사용됩니다. 이것들은 R에서 프로그래밍의 기본 구성 요소를 형성합니다. TRUE와 FALSE는 R의 논리 상수입니다. NULL은 값이 없거나 정의되지 않은 값을 나타냅니다. Inf는 “무한대”를 의미합니다(예를 들어, 1/0), 반면에 NaN은 “숫자가 아님”을 의미합니다 (예 : 0/0). NA는 “Not Availabel(사용할 수 없음)”을 나타내며 결측값(missing value)을 나타내는 데 사용됩니다. R은 대소문자를 구분하는 언어입니다. 즉, TRUE와 True가 동일하지 않습니다. TRUE는 R에서 논리 상수를 나타내는 예약어이지만 Ture는 변수 이름으로 사용할 수 있습니다. TRUE &lt;- 1 # 에러 발생 ## Error in TRUE &lt;- 1: 대입에 유효하지 않은 (do_set) 좌변입니다 True &lt;- 1 # True가 식별자(변수명)로 사용됨 TRUE # 논리 상수 ## [1] TRUE True # 변수 ## [1] 1 "],["변수.html", "4.6 변수", " 4.6 변수 4.6.1 R의 변수 변수(variable)는 필요에 따라 값을 변경할 수 있는 데이터를 저장하는 데 사용됩니다. 변수(함수와 개체도)에게 주어진 고유 이름을 식별자(identifies)라고 합니다. 4.6.2 R에서 식별자 작성 규칙 식별자는 문자, 숫자, 마침표 (.) 그리고 밑줄 (_)의 조합으로 만들어 집니다. 식별자는 반드시 문자 또는 마침표로 시작해야합니다. 마침표로 시작하면 뒤에 숫자가 올 수 없습니다. R의 예약어는 식별자로 사용할 수 없습니다. 4.6.3 R의 유효한 식별자 예 total, Sum, .fine.with.dot, this_is_acceptable, Number5, var_name2., .var_name, var.name 변수명으로 한글을 사용할 수도 있지만 가능하면 영문으로 사용할 것을 권합니다. 4.6.4 R의 잘못된 식별자 tot@l : @기호는 식별자 내에 사용할 수 없습니다. @는 특별한 기능을 가지고 있습니다. 5um : 식별자는 숫자로 시작할 수 없습니다. _fine : 식별자는 밑줄(_)로 시작할 수 없습니다. TRUE : TRUE는 예약어로 식별자로 사용할 수 없습니다. .0ne : 식별자가 점(.)으로 시작하면 숫자(0)이 올 수 없습니다. first-class : -는 산술 연산자입니다. 식별자에 사용할 수 없습니다. 이는 “first - class”와 같은 산술식을 나타냅니다. 4.6.5 모범 사례 R의 이전 버전에서는 할당 연산자로 밑줄 (_)을 사용했습니다. 따라서 마침표 (.)는 여러 단어를 가진 변수 이름에 광범위하게 사용되었습니다. 현재 버전의 R은 밑줄(_)을 유효한 식별자로 지원하지만 마침표(.)를 단어 구분 기호로 사용하는 것이 좋습니다.2 예를 들어, 식별자로는 a.variable.name을 사용하는 것이 a_variable_name보다 낫다는 것입니다. 또는 aVariableName와 같이 중간 중간에 대문자를 사용하는 낙타 대문자(camel case)를 사용하는 것도 좋은 방법입니다. 4.6.6 변수 할당과 출력 변수는 할당 연산자로 &lt;-, -&gt; 또는 = 등을 이용하여 값을 할당할 수 있습니다. 또한 단순히 변수명을 입력하거나, print() 함수와 cat() 함수를 이용하여 변수에 저장된 값을 출력할 수 있습니다. cat() 함수는 여러 항목을 결합하여 출력합니다. ## 변수에 값을 할당하는 방법입니다. # 왼쪽 방향의 연산자를 이용한 할당입니다. 가장 널리 사용되는 방법입니다. var.2 &lt;- c(&quot;learn&quot;,&quot;R&quot;) # 등호 연산자를 이용한 할당입니다. var.1 = c(0,1,2,3) # 오른쪽 방향의 연산자를 이용한 할당입니다. 이 방법은 사용하지 말기를 권합니다. c(TRUE,1) -&gt; var.3 ## 변수에 저장된 값을 출력합니다. var.1 # 변수명 만으로 변수에 저장된 값을 확인할 수 있습니다. ## [1] 0 1 2 3 print(var.1) # var.1에 저장된 값을 출력합니다. ## [1] 0 1 2 3 cat (&quot;var.1 is &quot;, var.1 ,&quot;\\n&quot;) # 컴마로 구분된 3개의 요소를 연속적으로 결합하여 출력하고 있습니다. ## var.1 is 0 1 2 3 cat (&quot;var.2 is &quot;, var.2 ,&quot;\\n&quot;) ## var.2 is learn R cat (&quot;var.3 is &quot;, var.3 ,&quot;\\n&quot;) ## var.3 is 1 1 R 마크다운에서 _을 사용하면 작동하지 않는 경우가 있습니다 "],["상수.html", "4.7 상수", " 4.7 상수 이름에서 알 수 있듯이 상수(constants)는 값을 변경할 수없는 엔티티입니다. 상수의 기본 유형은 ‘숫자형 상수’와 ‘문자형 상수’입니다. 4.7.0.1 숫자형 상수 모든 숫자가 이 범주에 속합니다. 정수(integer), 이중(double, 실수) 또는 복합(complex, 수학의 복소수) 유형일 수 있습니다. typeof() 함수로 확인할 수 있습니다. 상수 값 맨 뒤에 L이 있는 숫자 상수는 정수로 간주되고, i가 있는 숫자 상수는 복소수로 간주됩니다. typeof(5) ## [1] &quot;double&quot; typeof(5L) ## [1] &quot;integer&quot; typeof(5i) ## [1] &quot;complex&quot; 0x 또는 0X가 앞에 오는 숫자 상수는 16 진수로 해석됩니다. 0xff ## [1] 255 0xF + 1 ## [1] 16 4.7.1 문자형 상수 문자 상수는 작은 따옴표 ( ') 또는 큰 따옴표 ( \")를 구분 기호로 사용하여 나타낼 수 있습니다. &#39;example&#39; ## [1] &quot;example&quot; typeof(&quot;5&quot;) # type(5)와 다르지요... ## [1] &quot;character&quot; 4.7.2 내장 상수 R에 정의된 일부 내장 상수(build-in constants)와 해당 값이 아래에 나와 있습니다. LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; pi ## [1] 3.141593 month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; month.abb ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot; &quot;Dec&quot; ### 특정 요소(3번째 요소)만 확인 LETTERS[3] ## [1] &quot;C&quot; letters[3] ## [1] &quot;c&quot; month.name[3] ## [1] &quot;March&quot; month.abb[3] ## [1] &quot;Mar&quot; 그러나 이것들은 값이 변경될 수 있는 변수로 구현될 수 있기 때문에 이것에 의존하는 것은 좋지 않습니다. pi # R에 내장되어 있는 상수 ## [1] 3.141593 pi &lt;- 56 # pi를 변수로 사용 pi # 변수 pi 값 확인 ## [1] 56 "],["연산자.html", "4.8 연산자", " 4.8 연산자 R에는 산술, 논리 및 비트 연산을 포함한 작업을 수행하는 여러 연산자(operator)가 있습니다. R의 연산자는 주로 다음 범주로 분류 할 수 있습니다. 산술 연산자(Arithmetic operators) 관계 연산자(Relational operators) 논리 연산자(Logical operators) 할당 연산자(Assignment operators) 4.8.1 산술 연산자 이 연산자는 덧셈 및 곱셈과 같은 산술적 연산을 수행하는 데 사용됩니다. 다음은 R에서 사용할 수 있는 산술 연산자 목록입니다. 연산자 설명 x + y 덧셈 x – y 뺄셈 x * y 곱셈 x / y 나눗셈 x ^ y 제곱 x %% y 나눗셈의 나머지 ( 7 %% 4 인 경우 3) x %/% y 나눗셈의 몫 ( 7 %/% 4 인 경우 1) 예 : # 데이터 x &lt;- 5 y &lt;- 16 # 데이터의 산술 연산 x + y ## [1] 21 x - y ## [1] -11 x * y ## [1] 80 y / x ## [1] 3.2 y %/% x ## [1] 3 y %% x ## [1] 1 y ^ x ## [1] 1048576 4.8.2 관계 연산자 관계 연산자는 값을 비교하는 데 사용됩니다. 다음은 R에서 사용할 수있는 관계 연산자 목록입니다. 연산자 설 명 x &lt; y x가 y보다 작은가 x &gt; y x가 y보다 큰가 x &lt;= y x가 y보다 작거나 같은가 x &gt;= y x가 y보다 크거나 같은가 x == y x가 y와 같은가 x != y x가 y와다른가 관계 연산자는 이와 같이 두 개 변수 간의 비교에 사용되는 연산자입니다. 예 : # 데이터 x &lt;- 5 y &lt;- 16 # 데이터의 비교 연산 x &lt; y ## [1] TRUE x &gt; y ## [1] FALSE x &lt;= 5 ## [1] TRUE y &gt;= 20 ## [1] FALSE y == 16 ## [1] TRUE x != 5 ## [1] FALSE 4.8.3 벡터 연산 위에서 언급한 연산자는 벡터에서도 작동합니다. 위에서 사용된 변수는 사실 단일 요소 벡터였습니다. 다음 장에서 설명하겠지만 R에서 벡터는 c() 함수(여기서 c는 concatenate 즉, 연결을 의미함)를 사용하여 만들 수 있습니다. 이러한 벡터의 연산은 벡터의 요소별로 1:1 방식으로 수행됩니다. 다음에 예가 있습니다. # 데이터 : 벡터 x &lt;- c(2,8,3) y &lt;- c(6,4,1) # 데이터의 연산 x + y # 산술연산 ## [1] 8 12 4 x &gt; y # 관계연산 ## [1] FALSE TRUE TRUE 연산에 사용되는 (피연산자) 두 개의 벡터 길이 (요소 수, length)가 일치하지 않으면 어떻게 될까요? 더 짧은 요소의 요소가 더 긴 요소의 길이와 일치하도록 순환 방식(cycling, 또는 자동채움)으로 재활용됩니다. R은 긴 벡터의 길이가 짧은 벡터 길이의 정수 배가 아닌 경우 경고메시지를 발생합니다. # 길이가 다른 두 개의 벡터 x &lt;- c(2, 1, 8, 3) # 4개의 요소로 구성된 x y &lt;- c(9, 4) # 2개의 요소로 구성된 y # 두 벡터의 연산 x + y # y의 요소들이 c(9, 4, 9, 4)와 같이 (9, 4)가 순환되어 자동채움됨. ## [1] 11 5 17 7 x - 1 # 상수 1은 c(1, 1, 1, 1)와 같이 자동 순환됨. ## [1] 1 0 7 2 x + c(1, 2, 3) # x는 요소 갯수가 4개인 반면, c(1, 2, 3)은 자동순환으로 c(1, 2, 3, 1)로 처리함 ## Warning in x + c(1, 2, 3): 두 객체의 길이가 서로 배수관계에 있지 않습니다 ## [1] 3 3 11 4 # 단, 경고메시지가 나타남 4.8.4 논리 연산자 논리 연산자는 AND, OR 등과 같은 부울 연산을 수행하는 데 사용됩니다. 연산자 설 명 !x 논리 NOT x &amp; y 요소단위의 논리곱 (AND) x &amp;&amp; y 논리곱(AND) x | y 요소단위의 논리합(OR) x || y 논리합(OR) 연산자 &amp;와 | 는 더 긴 피연산자의 길이를 갖는 결과를 생성하는 요소별 연산을 수행합니다. 하지만 &amp;&amp; 그리고|| 는 단일 길이 논리 벡터가 되는 피연산자의 첫 번째 요소만 검사합니다. 0은 FALSE로 간주되고 0이 아닌 숫자는 TRUE로 간주됩니다. 예제 실행. # 논리 데이터 x &lt;- c(TRUE,FALSE,0,6) y &lt;- c(FALSE,TRUE,FALSE,TRUE) # 논리 데이터의 논리 연산 ! x ## [1] FALSE TRUE TRUE FALSE x &amp; y ## [1] FALSE FALSE FALSE TRUE x &amp;&amp; y ## [1] FALSE x | y ## [1] TRUE TRUE FALSE TRUE x || y ## [1] TRUE x &amp; y와 x &amp;&amp; y의 결과를 꼭 비교확인해 보기 바랍니다. 마찬가지로. x | y와 x || y의 결과를 꼭 비교확인해 보기 바랍니다. 4.8.5 할당 연산자 이러한 연산자는 변수에 값을 할당하는 데 사용됩니다. 연산자 설 명 &lt;-, &lt;&lt;-, = 왼쪽 방향의 할당 -&gt;, -&gt;&gt; 오른쪽 방향의 할당 연산자 &lt;-와 =는 거의 같은 환경에서 변수에 할당하는 데 거의 같은 의미로 사용할 수 있습니다. &lt;&lt;- 연산자는 상위 환경의 변수에 할당하는 데 사용됩니다 (전역 할당과 비슷 함). 이에 대해서는 제3부의 제4장에서 설명할 기회가 있을 것입니다. 오른쪽 할당은 사용 가능하지만 거의 사용되지 않습니다. "],["연산자-우선-순위와-결합.html", "4.9 연산자 우선 순위와 결합", " 4.9 연산자 우선 순위와 결합 4.9.1 연산자 우선 순위 단일 표현식에서 여러 연산자를 사용하는 경우 발생할 작업 순서를 파악하려면 이러한 연산자의 우선 순위를 알아야 합니다. 우선 순위는 실행 순서, 즉 어떤 연산자가 더 높은 우선 순위를 갖는지 정의합니다. 4.9.1.1 예제 1 : R의 연산자 우선 순위 2 + 6 * 5 # 2 + ( 6 * 5 ) ## [1] 32 여기서 * 연산자는 + 보다 우선 순위가 높으므로2 + 6 * 5는 2 + (6 * 5)로 해석됩니다. 이 순서는 괄호 ()를 사용하여 변경할 수 있습니다. (2 + 6) * 5 ## [1] 40 4.9.2 연산자 결합 표현식에서 우선 순위가 동일한 여러 연산자를 사용할 수 있습니다. 이 경우 실행 순서는 연산자 결합(associativity)을 통해 결정됩니다. R에서 다른 연산자의 우선 순위와 결합은 다음의 표와 같습니다. 연산자 설 명 연관성 ^ 제곱 Right to Left - x, + x Unary minus, Unary plus ==&gt; %% Modulus ==&gt; *, \\ Multiplication, Division ==&gt; +, – Addition, Subtraction ==&gt; &lt;, &gt;, &lt;=, &gt;=, ==, != Comparisions ==&gt; ! Logical NOT ==&gt; &amp;, &amp;&amp; Logical AND ==&gt; |, || Logical OR ==&gt; -&gt;, -&gt;&gt; Rightward assignment ==&gt; &lt;-, &lt;&lt;- Leftward assignment &lt;== = Leftward assignment &lt;== 대부분이 왼쪽에서 오른쪽 방향으로의 결합되고 있음을 알 수 있습니다. 4.9.2.1 예제 2 : R의 연산자 결합 3 / 4 / 5 ## [1] 0.15 위의 예에서 3 / 4 / 5는 /연산자의 왼쪽에서 오른쪽 방향으로 결합됨으로 (3 / 4) / 5로 평가됩니다. 그러나이 순서도 괄호 ()를 사용하여 변경할 수 있습니다. 3 / (4 / 5) ## [1] 3.75 "],["개체와-클래스.html", "4.10 개체와 클래스", " 4.10 개체와 클래스 참고 : https://www.datamentor.io/r-programming/object-class-introduction/ R은 S3, S4, 그리고 참조(reference) 클래스 등의 3개의 클래스를 가지고 있습니다. 4.10.1 개체와 클래스 R에서도 개체 지향 프로그래밍(object oriented programming)을 할 수 있습니다. 사실 R의 모든 것은 개체(object, ‘객체’)입니다. 개체는 속성에 작용하는 몇 가지 속성과 메소드를 가진 데이터 구조입니다. 클래스(class)는 개체의 청사진입니다. 우리는 클래스를 집을 짓기 전의 스케치(프로토타입)처럼 생각할 수 있습니다. 여기에는 바닥, 문, 창문 등에 대한 모든 세부 정보가 포함되어 있습니다. 이러한 설명을 바탕으로 우리는 집을 짓습니다. 집이 개체입니다. 설명으로 많은 집을 만들 수 있으므로, 클래스를 이용해서 많은 개체를 만들 수 있습니다. 개체를 클래스의 인스턴스(“예”)라고도 하며, 이 개체를 만드는 프로세스를 인스턴스화(instantiation)라고합니다. 대부분의 프로그래밍 언어에는 단일 클래스 시스템이 있지만 R에는 세 개의 클래스 시스템이 있습니다. 즉, S3, S4 및 최근의 참조(reference) 클래스 시스템입니다. 이 클래스들은 각각의 고유 특징을 가지고 있으며, 어떤 클래스를 사용할 지 여부는 선호도에 달려 있습니다. 4.10.1.1 S3 클래스 S3 클래스는 본질적으로 다소 원시적입니다. 공식적인 정의가 없으며 클래스 속성(attribute)을 추가하는 것만으로 이 클래스의 개체를 만들 수 있습니다. 이러한 단순함은 R 프로그래밍 언어에서 이 클래스가 널리 사용된다는 사실을 설명합니다. 실제로 대부분의 R 내장 클래스는 S3 유형입니다. 다음은 list를 이용한 S3 클래스 생성을 보여주고 있습니다. # create a list with required components s &lt;- list(name = &quot;John&quot;, age = 21, GPA = 3.5) class(s) # 변수 s의 클래스를 확인합니다. : &quot;list&quot;로 반환합니다. ## [1] &quot;list&quot; # name the class appropriately class(s) &lt;- &quot;student&quot; # 변수 s를 새로운 클래스 student로 지정합니다. class(s) # &quot;student&quot;로 반환합니다. ## [1] &quot;student&quot; 자세한 내용은 R 프로그래밍 S3 클래스 섹션을 참조하십시오. 4.10.1.2 S4 클래스 S4 클래스는 S3 클래스를 개선한 것입니다. 그들은 같은 클래스의 개체를 다소 비슷하게 보이게 하는 데 도움이 되는 공식적으로 정의된 구조를 가지고 있습니다. 클래스 컴포넌트는 setClass() 함수를 사용하여 올바르게 정의되고, 개체는 new() 함수를 사용하여 생성합니다. setClass(&quot;student&quot;, slots=list(name=&quot;character&quot;, age=&quot;numeric&quot;, GPA=&quot;numeric&quot;)) 4.10.1.3 참조 클래스 참조(reference) 클래스는 다른 두 클래스에 비해 나중에 도입되었습니다. 다른 주요 프로그래밍 언어에서 보았던 개체 지향 프로그래밍과 더 유사합니다. 참조 클래스는 기본적으로 환경(environment)이 추가된 S4 클래스입니다. setRefClass(&quot;student&quot;) 4.10.1.4 클래스간 비교 S3 클래스 S4 클래스 참조 클래스 공식적 정의가 없음 setClass() 함수를 이용하여 클래스 정의 setRefClass() 함수를 이용하여 클래스 정의 클래스의 속성을 설정해서 개체 생성 개체는 new() 함수를 사용해서 생성함 개체는 생성 함수를 이용하여 생성됨 속성은 $로 접근함 속성은 @로 접근함 속성은 $로 접근함 메소드는 일반 함수에 속함 메소드는 일반 함수에 속함 메소드는 클래스에 속함 ‘copy-on-modify’ 시멘틱을 따름 ‘copy-on-modify’ 시멘틱을 따름 ‘copy-on-modify’ 시멘틱을 따르지 않음 자세한 사항은 제4부의 제5장을 참고하기 바랍니다. 4.10.2 클래스의 속성 모든 개체는 속성(attribute)를 가질 수 있습니다. 그런데 이러한 속성은 attr() 함수를 통해 속성을 지정하거나 조회할 수 있습니다. 이러한 개체의 속성이 중요한 이유는 속성을 통해 데이터 구조를 설정할 수도 있고, 함수의 기능 구현에 있어서 속성을 지정하여 제어할 수 있으며, 또 R 에서 개체를 구현할 수 있는 방법 중의 하나이기도 하기 때문입니다. 이러한 속성을 통해 새로운 해결 전략을 만들 수도 있고, 문제를 해결하는 시간을 단축할 수도 있습니다.3 4.10.2.1 개체 속성 정의 개체의 속성은 attr()함수를 이용해 생성할 수 있습니다. y1 &lt;- c(&quot;ID&quot;, &quot;Name&quot;, &quot;Grade&quot;, &quot;Gender&quot;) # y1는 문자형 벡터입니다. y1 # 벡터형으로 출력됩니다. ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Grade&quot; &quot;Gender&quot; attr(y1, &quot;new_class&quot;) &lt;- &quot;This is the list of class&quot; # y1의 속성지정합니다. (속성명과 속성값) y1 # y1에 데이터와 함께 속성 정보가 출력됩니다. ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Grade&quot; &quot;Gender&quot; ## attr(,&quot;new_class&quot;) ## [1] &quot;This is the list of class&quot; attr(y1, &quot;new_class&quot;) # y1의 속성 값을 조회합니다. ## [1] &quot;This is the list of class&quot; 한편 속성이 추가된 새로운 개체를 반환해 주는 structure() 함수가 있습니다. structure() 함수는 추가적인 속성이 설정된 주어진 객체를 반환합니다. structure() 함수의 형식은 다음과 같습니다. structure(.Data, ...) .Data : 다양한 속성이 첨부된 객체입니다. … : 데이터에 첨부 될 “tag = value” 형식으로 지정된 속성입니다. structure() 함수의 사용 예를 들어 보겠습니다. y2 &lt;- structure(c(&quot;ID&quot;, &quot;Name&quot;, &quot;Grade&quot;, &quot;Gender&quot;), new_class = &quot;A Class&quot;) y2 ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Grade&quot; &quot;Gender&quot; ## attr(,&quot;new_class&quot;) ## [1] &quot;A Class&quot; 4.10.2.2 속성의 조회 개체의 속성을 조회하기 위해서는 attributes() 함수를 이용합니다. 그 결과는 리스트 형태로 반환됩니다. attr(y1, &quot;new_class&quot;) # y1 개체의 new_class 속성의 값을 반환합니다. (벡터 형) ## [1] &quot;This is the list of class&quot; attributes(y1) # y1 개체의 속성 이름과 값을 반환합니다. (리스트 형) ## $new_class ## [1] &quot;This is the list of class&quot; attr(y2, &quot;new_class&quot;) # y2 개체의 new_class 속성의 값을 반환합니다. (벡터 형) ## [1] &quot;A Class&quot; attributes(y2) # y2 개체의 속성 이름과 값을 반환합니다. (리스트 형) ## $new_class ## [1] &quot;A Class&quot; 4.10.2.3 세 가지 중요한 속성 아래의 속성들은 R의 기본 함수에서 그 사용법이 약속되어 있습니다. Names : 각 요소에 지정될 수 있는 문자형 벡터입니다. Dimensions : 행렬과 배열에서 쓰입니다. Class : S3 개체 시스템서 쓰입니다. 데이터를 변형해도 이 속성들은 사라지지 않습니다. 그리고 다양한 함수에서 이 속성들을 통해 기능을 구현하고 있습니다. 4.10.3 names 속성 만들기 names 속성을 만드는 방법은 1) names() 함수를 이용하는 방법과 2) 변수를 생성할 때 지정하는 방법이 있습니다. names() 함수는 개체의 이름을 만들거나 조회하는 함수입니다. 4.10.3.1 names() 함수를 이용하는 방법 v &lt;- c(1, 2, 3) # v 백터 개체가 있습니다. v # 지정된 속성이 없습니다. ## [1] 1 2 3 names(v) &lt;- c(LETTERS[1:3]) # 이 개체의 names 속성을 (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)로 생성합니다. v # v 개체에 names 속성이 포함되어 있습ㄴ디ㅏ. ## A B C ## 1 2 3 names(v) # v 벡터 개체의 이름 속성이 반환됩니다. ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 4.10.3.2 변수를 생성할 때 names 속성 지정 y &lt;- c(&quot;A&quot; = 1, &quot;B&quot; = 2, &quot;C&quot; = 3) # 정수형 벡터를 생성할 때 각 요소의 이름을 지정합니다. names(y) # y 벡터 개체의 이름을 반환합니다. ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 4.10.3.3 names 속성의 조회 개체의 속성은 attr() 함수 또는 attributes() 함수를 통해서도 확인 가능합니다. attr(v, &quot;names&quot;) # v 개체의 names 의 속성 값을 벡터 형으로 반환합니다. ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; attributes(v) # v 개체의 속성을 리스트 형으로 반환합니다. ## $names ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; attr(y, &quot;names&quot;) # y 개체의 names 의 속성 값을 벡터 형으로 반환합니다. ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; attributes(y) # y 개체의 속성을 리스트 형으로 반환합니다. ## $names ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 참고자료 R Introduction R : 변수(variable) 개념 및 예제 Object and Class 클래스의 속성 이하의 내용은 https://3months.tistory.com/393를 참고하여 정리하였습니다 "],["벡터vector.html", "Chapter 5 벡터(vector)", " Chapter 5 벡터(vector) R에서 벡터는 가장 기본적인 데이터 구조이다. 즉, 다른 데이터 구조(배열, 행렬, 데이터 프레임, 리스트 등)를 구성하는 기본적인 데이터 구조이다. 벡터에는 원자 벡터와 리스트 등 두 가지 유형이 있습니다4. 원자 벡터(atomic vector)에는 논리, 정수, 이중, 문자, 복소수 및 원시(raw)의 6 가지 유형이 있습니다. 정수형 벡터와 이중 벡터는 집합적으로 숫자형 벡터라고합니다. 리스트(list)는 다른 목록을 포함할 수 있기 때문에 때때로 반복적 벡터(recursive vector)라고도합니다! (리스트는 제2부의 제4장에서 자세히 살펴보겠습니다.) 원자벡터와 리스트의 주요 차이점은 원자 벡터는 요소들이 동일한(homogeneous) 데이터 유형의 갖는 반면에, 리스트는 이질적(heterogeneous)일 수 있다는 것입니다. 다른 관련 개체는 NULL입니다. NULL은 종종 벡터의 부재를 나타내는 데 사용됩니다. 벡터에 값이 없음을 나타내는 데 사용되는 NA와 반대입니다. NULL은 일반적으로 길이가 0 인 벡터처럼 동작합니다. 모든 벡터들은 벡터의 유형과 길이라는 두 가지 주요한 특성을 갖습니다. 이러한 벡터의 유형은 벡터의 요소들이 갖는 데이터 유형을 나타내는 것으로 typeof() 함수로 확인할 수 있습니다. 벡터의 또 다른 중요한 속성은 길이입니다. 이것은 벡터의 요소 수를 말하는 것으로 length() 함수로 확인할 수 있습니다. http://rstudio-pubs-static.s3.amazonaws.com/275539_01625c9e47af41e7bc8f9fc4d229abcf.html "],["벡터-만들기.html", "5.1 벡터 만들기", " 5.1 벡터 만들기 벡터는 동일한 데이터 유형의 단일 값들이 일차원적으로 구성된 데이터 구조입니다. 5.1.1 벡터의 생성 이러한 벡터를 생성하는 데에는 c() ==&gt; c : concatenate 함수를 이용합니다. 벡터는 동일한 데이터 유형을 갖는 요소들을 각각 컴마로 구분하여 입력합니다. c(e1, e2, e3, e4 …) 벡터에는 동일한 유형의 요소가 있어야 하므로 이 함수는 요소가 다른 데이터 유형으로 구성되어 있는 경우 동일한 유형으로 강제 변환(coercion)합니다. (벡터의 데이터 유형 변환은 벡터 유형의 강제 변환(Coercion) 부분에서 자세히 다루겠습니다.) 강압은 낮은 유형에서 높은 유형으로 변환이 이루어 집니다. 논리형 -&gt; 정수형 -&gt; 이중형 -&gt; 문자형 순으로 변경됩니다. 예 : (80, 85, 70)의 값들을 하나의 벡터형의 데이터 세트로 하는 변수 x를 정의한다. x &lt;- c(80, 85, 70) # 처리할 데이터의 변수 x의 정의 x # 변수 내용의 확인 ## [1] 80 85 70 변수 x에 데이터 세트를 지정할 때는 앞의 예에서 처럼 오른쪽에서 왼쪽 방향으로 한다. c(80, 85, 70) -&gt; x # 이렇게 해도 되지만, 바람직하지 않음. x ## [1] 80 85 70 5.1.2 벡터 원소가 하나일 때 요소가 하나인 벡터의 생성은 c()를 사용하지 않아도 됨. x &lt;- c(80); x ## [1] 80 x &lt;- 80; x ## [1] 80 "],["벡터의-유형.html", "5.2 벡터의 유형", " 5.2 벡터의 유형 벡터는 그 벡터를 구성하는 요소의 데이터 유형에 따라 벡터의 유형이 정해지게 됩니다. 숫자형 : 숫자형에는 1L, 2L, 3L 등을 요소로 하는 벡터로 정수형(integer)이 있으며, 1.5, 2.5, 3.0 등을 요소로 하는 벡터로 실수형(double)이 있습니다. 그런데 이들은 집합적으로는 숫자형(numeric) 벡터라고 합니다. 문자형 : \"대한민국\", \"홍길동\", \"5\", \"2020-01-01\" 등과 같이 따옴표 안의 문자들을 요소로 하는 벡터를 문자형(character)이라고 합니다. 특히, \"5\"의 경우는 보기에는 숫자 5와 같지만, “5” 안에 있으면 단순한 기호로서의 5가 되어 문자로 처리가 됩니다. 또한 \"2020-01-01\" 의 경우에도 날짜로 보이지만 이는 날짜가 아니고 단순한 문자열입니다. 이를 날짜로 처리하기 위해서는 as.Date() 함수를 이용하여 벡터의 유형을 날짜형으로 강제 변환을 해야 합니다. 논리형 : TRUE, FALSE 등의 논리값을 요소로 하는 벡터는 논리형(logical)입니다. 날짜형 : \"2020-01-01\" , \"Jan-03-2021\" 등을 요소로 하는 벡터를 날짜형(Date) 벡터라고 합니다. 이들 날짜형 벡터는 먼저 문자열 벡터로 생성한 다음, as.Date()함수로 변경을 해야 날짜형 벡터로 사용할 수 있습니다. 여기서 특히, integer, double, numeric, character, logical, 그리고 Date 등은 여러분이 꼭 기억해 두기 바랍니다. 이는 벡터의 유형을 확인하고 싶을 때, typeof() 함수를 사용하면 벡터의 유형을 확인하고 출력하는 결과입니다. is.*() 함수를 이용하는 경우에는 *에 해당하는 벡터 유형인지 확인하는 것입니다. 또한, 벡터 유형의 강제변환에 있어서도 as.*() 함수의 *에 사용하여 원하는 벡터형으로 강제변환하게 됩니다. 5.2.1 벡터 유형의 종류 5.2.1.1 숫자형 벡터 숫자형(numeric)의 요소들로 구성된 벡터의 경우 x1 &lt;- c(1, 2, 3) # 숫자 벡터 x1 ## [1] 1 2 3 x2 &lt;- c(1L, 2L, 3L) # 정수형 x2 ## [1] 1 2 3 x3 &lt;- c(2+1i, 3+2i, 4+3i) # 복소수형 : (참고만 하세요) x3 ## [1] 2+1i 3+2i 4+3i 5.2.1.2 문자형 벡터 문자형(character)의 요소들로 구성된 벡터의 경우, 문자형 요소들을 모두 \"\" 또는 ‘’로 묶어 줍니다. y &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;c&quot;) # 문자 요소는 `&quot;&quot;`로 묶는다. y ## [1] &quot;A&quot; &quot;B&quot; &quot;c&quot; 5.2.1.3 논리형 벡터 논리형(logical)의 요소들로 구성된 벡터의 경우, 논리형의 요소 값은 TRUE, FALSE 또는 T, F로 한다. 논리형 벡터는 0, 1이라는 정수값으로 저장이 됩니다. z &lt;- c(TRUE, FALSE, T, F) z ## [1] TRUE FALSE TRUE FALSE 5.2.1.4 날짜형 벡터 날짜형(Date)은 별도의 함수를 사용해야 합니다. today &lt;- Sys.Date() # Sys.Date() 함수는 오늘 날짜를 반환하는 함수입니다. today # today는 날짜형 벡터가 됩니다. ## [1] &quot;2021-02-08&quot; date &lt;- c(&quot;2020-01-01&quot;, &quot;2021-01-01&quot;); date # date는 문자형 벡터입니다. ## [1] &quot;2020-01-01&quot; &quot;2021-01-01&quot; date1 &lt;- as.Date(date); date1 # as.Date() 함수를 이용하여 날짜형 벡터로 강제변환해 줘야 합니다. ## [1] &quot;2020-01-01&quot; &quot;2021-01-01&quot; 날짜형 벡터 date1의 경우는 보기에는 date와 마찬가지로 문자형 벡터로 보이지만, 다음에서 배울 class() 함수를 이용하여 벡터의 클래스를 확인해 보면 서로 다름을 알 수 있습니다. class(date) # &quot;character&quot;로 출력됩니다. ## [1] &quot;character&quot; class(date1) # &quot;Date&quot;로 출력됩니다. ## [1] &quot;Date&quot; "],["벡터의-유형-확인.html", "5.3 벡터의 유형 확인", " 5.3 벡터의 유형 확인 벡터 유형에 따라 다른 작업을 수행하고 싶을 때도 있습니다. 벡터의 유형을 확인하는 한 가지 방법은 typeof()함수를 사용하는 것입니다(도움말은 ? typeof()을 참고하세요). 또 다른 방법은 TRUE 또는 FALSE를 반환하는 is.*() 형태의 테스트 함수를 사용하는 것입니다. Base R은 is.vector()와 is.atomic()과 같은 많은 함수를 제공하고 있습니다. is.numeric(3) # 숫자형인지 테스트합니다. : TRUE 반환 ## [1] TRUE is.integer(3L) # 정수형인지 테스트합니다. : TRUE 반환 ## [1] TRUE is.logical(TRUE) # 논리형인지 테스트합니다. : TRUE 반환 ## [1] TRUE is.logical(2) # 논리형인지 테스트합니다. : 2는 논리형이 아니기 때문에 FALSE를 반환합니다. ## [1] FALSE is.character(&quot;abc&quot;) # 문자형인지 테스트합니다. : TRUE 반환 ## [1] TRUE is.character(4) # 문자형인지 테스트합니다. : FALSE 반환 ## [1] FALSE 5.3.0.1 tester 패키지 참고로 R 개체의 특성을 테스트할 수 있게 해 주는 tester 패키지의 is_* 함수를 사용하는 것이 더 안전합니다. # install.packages(&quot;tester&quot;) library(tester) is_logical_vector(T) ## [1] TRUE tester 패키지에서 제공하는 몇몇 함수들을 소개하면 다음과 같습니다. 함수 설 명 is_vector() 개체가 벡터인지 테스트합니다. is_numeric_vector() 개체가 숫자형 벡터인지 테스트합니다. is_string_vector() 개체가 문자형 벡터인지 테스트 합니다. is_logical_vector() 개체가 논리형 벡터인지 테스트합니다. is_not_vector() 개체가 벡터형이 아닌지 테스트합니다. is_integer() 숫자가 정수형인지 테스트합니다. is_not_integer() 숫자가 정수형이 아닌지 테스트합니다. is_negative() 숫자가 음수인지 테스트 합니다. is_string() 개체가 문자열인지 테스트합니다. is_not_string() 개체가 문자열이 아닌지 테스트합니다. 5.3.0.2 변수의 클래스와 유형 확인 생성된 변수가 어떠한 클래스에 속하는지를 아는 것은 매우 중요하다. 변수의 클래스를 확인하는 방법으로 class() 함수를 사용하면 됩니다. 그리고 변수의 데이터 유형은 typeof() 함수를 이용하여 확인할 수 있다. 클래스 안에서 개체가 만들어 집니다. 예를 들어, 우리가 집을 짓고자 할 때, 짓고자 하는 집의 청사진(blue print)을 클래스로 생각할 수 있습니다. 그리고 이러한 청사진을 이용하여 지은 집을 개체(object)라 할 수 있습니다. 즉 하나의 클래스를 이용하여 여러 개체를 생성할 수 있는 것입니다5. class(x); class(y); class(z); class(today) ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; ## [1] &quot;logical&quot; ## [1] &quot;Date&quot; 한편 typeof() 함수를 요소들의 원시적인 데이터 타입을 확인시켜 줍니다. x1 &lt;- c(1, 2, 3) # double 형 벡터입니다. 숫자형 클래스입니다 x2 &lt;- c(1L, 2L, 3L) # integer 형 벡터입니다. 이 또한 숫자형 클래스입니다. class(x1) # x1의 클래스는 numeric 입니다. ## [1] &quot;numeric&quot; class(x2) # x2의 클래스도 integer 입니다. ## [1] &quot;integer&quot; typeof(x1) # x1의 데이터 유형은 double 입니다. ## [1] &quot;double&quot; typeof(x2) # x2의 데이터 유형은 integer 입니다. ## [1] &quot;integer&quot; date &lt;- c(&quot;2020-01-01&quot;, &quot;2021-01-01&quot;); date # date는 문자형 벡터입니다. ## [1] &quot;2020-01-01&quot; &quot;2021-01-01&quot; date1 &lt;- as.Date(date); date1 # as.Date() 함수를 이용하여 날짜형 벡터로 강제변환했습니다. ## [1] &quot;2020-01-01&quot; &quot;2021-01-01&quot; class(date) # date의 클래스는 character입니다. ## [1] &quot;character&quot; class(date1) # date1의 클래스는 Date입니다. ## [1] &quot;Date&quot; typeof(date) # date의 데이터 유형은 character입니다. ## [1] &quot;character&quot; typeof(date1) # date1의 데이터 유혀은 double입니다. (실수형) ## [1] &quot;double&quot; class() 함수와 typeof() 함수 (그리고 mode() 함수)의 차이에 대하여는 이 자료를 참고하시기 바랍니다6. 5.3.0.3 세션에서 사용 중인 모든 변수의 유형 확인하기 참고로 지금 사용중에 있는 모든 객체의 데이터 유형을 확인하기 위해서는 다음가 같은 명령을 사용하면 됩니다. sapply(ls(), typeof) ## date date1 myString num1 num2 pi ## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; ## s sum_1_2 today True v var.1 ## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; ## var.2 var.3 x x1 x2 x3 ## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; ## y y1 y2 z ## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; eapply(.GlobalEnv,typeof) ## $s ## [1] &quot;list&quot; ## ## $y1 ## [1] &quot;character&quot; ## ## $y2 ## [1] &quot;character&quot; ## ## $num1 ## [1] &quot;double&quot; ## ## $num2 ## [1] &quot;double&quot; ## ## $v ## [1] &quot;double&quot; ## ## $x ## [1] &quot;double&quot; ## ## $var.1 ## [1] &quot;double&quot; ## ## $y ## [1] &quot;character&quot; ## ## $z ## [1] &quot;logical&quot; ## ## $var.2 ## [1] &quot;character&quot; ## ## $sum_1_2 ## [1] &quot;double&quot; ## ## $var.3 ## [1] &quot;double&quot; ## ## $myString ## [1] &quot;character&quot; ## ## $today ## [1] &quot;double&quot; ## ## $pi ## [1] &quot;double&quot; ## ## $x1 ## [1] &quot;double&quot; ## ## $True ## [1] &quot;double&quot; ## ## $x2 ## [1] &quot;integer&quot; ## ## $date1 ## [1] &quot;double&quot; ## ## $date ## [1] &quot;character&quot; ## ## $x3 ## [1] &quot;complex&quot; 5.3.1 벡터 요소의 갯수 확인 length(x); length(y); length(z); length(today) ## [1] 1 ## [1] 3 ## [1] 4 ## [1] 1 R에서의 클래스와 개체에 대해서는 제3부의 제5장을 참고하시기 바랍니다 https://buillee.tistory.com/83 "],["변수-값의-확인.html", "5.4 변수 값의 확인", " 5.4 변수 값의 확인 벡터 변수를 포함한 앞으로 배울 변수들이 가지고 있는 데이터 값을 확인하는 방법은 다음과 같습니다. # 변수명 기입 : 변수를 생성하고 다음 줄에 변수 명을 기입하는 방법입니다. x &lt;- c(1,2,3,4) x ## [1] 1 2 3 4 # 세미콜론(`;`) 다음에 변수명 기입 : 변수를 생성하고 같은 줄에 세미콜론(`;`) 다음에 변수 명을 기입하는 방법입니다. x &lt;- c(1,2,3,4) ; x ## [1] 1 2 3 4 y &lt;- c(2,3,4,5) ; y ## [1] 2 3 4 5 # 변수 생성 구문 또는 수식을 괄호(`()`)로 묶어 주는 방법입니다. (x &lt;- c(1, 2)) ## [1] 1 2 (y &lt;- c(3, 4)) ## [1] 3 4 (x + y) ## [1] 4 6 "],["반복값을-갖는-벡터-만들기-rep-함수.html", "5.5 반복값을 갖는 벡터 만들기 : rep() 함수", " 5.5 반복값을 갖는 벡터 만들기 : rep() 함수 데이터가 일정한 간격으로 증가/감소하거나(seq() 함수 이용), 같은 값이 반복되는 경우의 벡터를 생성할 수 있게 해주는 편리한 함수들이 있습니다. 먼저 반복적인 값을 가지는 벡터를 생성하는 rep() 함수에 대하여 살펴보겠습니다. 여기서 rep는 replicate(‘복제하다’ 라는 뜻)을 의미합니다. 이 rep() 함수의 형식은 다음과 같습니다. 형식 : rep(벡터, times|each = ) times ; 벡터의 복제 횟수 지정 each : 벡터요소 각각의 복제 횟수 지정 x &lt;- c(1, 2, 3) # 벡터 전체의 반복 횟수의 지정 : `times = x1 &lt;- rep(x, times=2); x1 # 벡터 x를 2번 복제합니다. ## [1] 1 2 3 1 2 3 x2 &lt;- rep(1:4, 2) ; x2 # times = 를 생략해도 됩니다. ## [1] 1 2 3 4 1 2 3 4 # 요소별로 복제 횟수의 지정 : each = x3 &lt;- rep(x, each=2); x3 # 벡터 x의 각 요소별로 각각 2번씩 복제합니다. ## [1] 1 1 2 2 3 3 x4 &lt;- rep(1:4, each = 2) ; x4 # &#39;each =&#39;는 생략할 수 없습니다. ## [1] 1 1 2 2 3 3 4 4 # 요소별 상이한 복제 횟수의 지정 x5 &lt;- c(3, 5, 2, 4, 6, 8) x6 &lt;- rep(x5, c(2, 3, 1, 1, 3, 4)) ; x6 ## [1] 3 3 5 5 5 2 4 6 6 6 8 8 8 8 x7 &lt;- rep(x5, rep(c(2, 1), 3)) ; x7 ## [1] 3 3 5 2 2 4 6 6 8 위의 예에서는 rep() 함수의 첫번째 인수를 모두 숫자형 벡터로 하였으나, 문자형 벡터, 논리형 벡터 등을 적용할 수도 있습니다. "],["연속-값들의-벡터-만들기-seq-함수와-세미콜론.html", "5.6 연속 값들의 벡터 만들기 : seq() 함수와 세미콜론(;)", " 5.6 연속 값들의 벡터 만들기 : seq() 함수와 세미콜론(;) rep() 함수는 동일한 요소 값을 복제하는 반면에, seq() 함수는 등차수열을 만들어 주는 함수입니다. 즉, 일정한 간격으로 요소들이 증가하거나 감소하는 벡터를 생성하고자 할 때 유용합니다. seq() 함수의 형식은 다음과 같습니다. 형식 : seq(from, to, by = | length.out = | along.with = ) from : 시작 값 to : 마지막 값 by : 간격 값 (기본 값은 1) length.out : 생성된 요소의 갯수 지정 along.with : 한편, 간단한 증가/감소 수열의 생성은 콜론(:)을 이용할 수도 있습니다. :은 기본 증가/감소 값을 1로 하는 seq() 함수 대신에 사용할 수 있습니다. 즉, seq() 함수의 from 인수와 to 인수만을 지정한 경우, 증가/감소값을 나타내는 by 인수의 기본값은 1이 됩니다. 5.6.1 : 를 이용한 벡터 생성 1씩 증가/감소하는 연속된 숫자로 구성된 벡터는 : 연산자로 쉽게 생성할 수 있습니다. # : 를 이용한 연속된 숫자로 구성된 벡터 생성 x &lt;- 1:7; x # x : 1, 2, 3, 4, 5, 6, 7 ## [1] 1 2 3 4 5 6 7 y &lt;- 2:-2; y # y : 2, 1, 0, -1, -2 ## [1] 2 1 0 -1 -2 5.6.2 seq() 함수를 이용한 벡터 생성 다양한 형태의 증가 및 감소하는 수열을 생성할 때에는 seq() 함수가 유용하게 사용됩니다. # 증가하는 수열의 생성 x &lt;- seq(1, 10); x # 1부터 10까지 기본값으로 1씩 증가하는 요소로 구성됩니다. ## [1] 1 2 3 4 5 6 7 8 9 10 x &lt;- 1:10; x ## [1] 1 2 3 4 5 6 7 8 9 10 # 감소하는 수열의 생성 x &lt;- seq(10, 1); x ## [1] 10 9 8 7 6 5 4 3 2 1 y &lt;- 10:1; y ## [1] 10 9 8 7 6 5 4 3 2 1 # 일정 간격으로 증가하는 수열의 생성 : by = x &lt;- seq(1, 10, by = 3); x # 1부터 시작해서 3씩 증가하는 10까지의 요소를 생성합니다. ## [1] 1 4 7 10 # 생성하는 벡터 요소의 갯수 지정 : length.out = y &lt;- seq(1, 10, length.out=5); y # 1부터 10사이에 `일정 간격`으로 `5`개의 요소를 생성합니다. ## [1] 1.00 3.25 5.50 7.75 10.00 # 다른 벡터의 길이와 같은 길이를 갖는 수열 생성 : along.with = x &lt;- 1:10 # x는 10개의 요소를 갖는 벡터입니다. y &lt;- seq(5, 20, along.with = x) # y는 5부터 20까지의 숫자를 동일한 간격으로 벡터 x의 길이인 10개 만큼 생성합니다. "],["벡터-유형의-강제-변환coercion.html", "5.7 벡터 유형의 강제 변환(Coercion)", " 5.7 벡터 유형의 강제 변환(Coercion) 한 유형의 벡터를 다른 유형으로 변환하거나 강제 변환하는 방법에는 두 가지가 있습니다. 5.7.1 암묵적 강제 변환 암묵적 강제 변환은 특정 유형의 벡터가 예상되는 특정 상황에서 벡터를 사용할 때 발생합니다. 예를 들어 숫자 요약 함수에 논리형 벡터를 사용하거나, 정수형 벡터가 예상되는데 이중 벡터를 사용하는 경우입니다. 이미 가장 중요한 유형의 암시적 강제 변환 (숫자를 사용하는 상황에서 논리 벡터를 사용)을 살펴본 바 있습니다. 예를 들어 논리형 벡터에서의 TRUE값은 정수형에서는 1로 변환되고 FALSE는 0으로 변환됩니다. 즉, 논리 벡터의 합은 TRUE의 갯수이고, 논리 벡터의 평균은 TRUE의 비율입니다. 즉, 논리형 벡터가 정수형 벡터로 암묵적으로 강제 변환이 되어 처리가 되는 것입니다. x &lt;- sample(20, 100, replace = TRUE) # 1~20 사이의 수에서 무작위로 100개를 중복 추출 y &lt;- x &gt; 10 # 100개 요소 각각에 대해 10보다 큰가를 비교 : TRUE or FALSE sum(y) # 10보다 큰 요소의 갯수 ## [1] 47 mean(y) # 100개 요소 중 10보다 큰 값을 갖는 요소의 비율 ## [1] 0.47 반대로 정수형에서 논리형이 되게하는 반대 방향으로 암묵적 강제 변환에 의존하는 일부 코드 (일반적으로 이전)를 볼 수 있습니다. if (length(x)) { # do something } length(x)의 경우 그 값이 0이면 FALSE로 변환되고 그렇지 않으면 모두 TRUE로 변환됩니다. 이로 인해 코드를 이해하기가 더 어려워질 수 있기 때문에 이러한 코드는 length(x) &gt; 0와 같이 명시적으로 해 주는 것이 좋습니다. c()를 사용하여 여러 유형을 포함하는 벡터를 만들 때 어떤 일이 발생하는지 이해하는 것도 중요합니다. 가장 복잡한 유형이 항상 이깁니다. 벡터의 요소들의 값들이 혼합된 경우 벡터는 논리형 &lt; 정수형 &lt; 실수형 &lt; 문자형 등으로 암묵적으로 강제 변환이 이루어집니다. typeof(c(TRUE, 1L)) # TURE는 &#39;논리형&#39;이고, 1L은 &#39;정수형&#39;입니다. -&gt; 정수형 ## [1] &quot;integer&quot; typeof(c(1L, 1.5)) # 1L은 &#39;정수형&#39;이지만, 1.5는 &#39;실수형(double)&#39;입니다. -&gt; 실수형 ## [1] &quot;double&quot; typeof(c(1.5, &quot;a&quot;)) # 1.5는 &#39;실수형&#39;이지만, &quot;a&quot;눈 &#39;문자형&#39;입니다 -&gt; 문자형 ## [1] &quot;character&quot; typeof(c(TRUE, &quot;a&quot;)) # TRUE는 &#39;논리형&#39;이고, &quot;a&quot;는 &quot;문자형&quot; -&gt; 문자형 ## [1] &quot;character&quot; typeof(c(TRUE, 1.5)) # TRUE는 &#39;논리형&#39;이고, &quot;a&quot;는 &quot;실수형&quot; -&gt; 실수형 ## [1] &quot;double&quot; typeof(c(1L, &quot;a&quot;)) # 1L은 &#39;정수형&#39;이고, &quot;a&quot;는 &quot;문자형&quot; -&gt; 문자형 ## [1] &quot;character&quot; 5.7.2 명시적 강제 변환 5.7.2.1 base 패키지의 강제 변환 함수들 as.logical(), as.integer(), as.double()또는 as.character()와 같은 함수를 이용하면 명시적으로 강제 변환이 이루어집니다. 명시적 강제 변환을 사용하는 자신을 발견 할 때마다 항상 업스트림 수정이 가능한지 확인하여 벡터가 처음에 잘못된 유형을 가지지 않도록 해야 합니다. 예를 들어, readr패키지의 col_types 사양을 조정해야 할 수도 있습니다. 함수 설 명 as.character(x) x를 문자형으로 강제 변환 as.numeric(x) 또는 as.double(x) x를 숫자형 또는 실수형으로 강제 변환 as.integer(x) x를 정수형으로 강제 변환 as.logical(x) x를 논리형으로 강제 변환 as.Date(x) x를 날짜형으로 강제 변환 as.complex(x) x를 복소수형으로 강제 변화 # 데이터 data1 &lt;- 2010:2020 # 강제 변환의 예 conv1 &lt;- as.character(data1); typeof(conv1) # 정수형을 문자형으로 강제변환 ## [1] &quot;character&quot; conv2 &lt;- as.integer(conv1); typeof(conv1) # 문자형을 정수형으로 강제변환 ## [1] &quot;character&quot; conv3 &lt;- as.numeric(conv2); typeof(conv3) ## [1] &quot;double&quot; data2 &lt;- c(0, 2, 0, 1, 1, 0) conv4 &lt;- as.logical(data2); typeof(conv4) # 정수형을 논리형으로 강제변환 ## [1] &quot;logical&quot; data3 &lt;- c(&quot;2018-01-01&quot;, &quot;2019-01-01&quot;, &quot;2020-01-01&quot;, &quot;2021-01-10&quot;) conv5 &lt;- as.Date(data3); typeof(conv5) # 문자형을 날짜형으로 강제변환 ## [1] &quot;double&quot; 5.7.2.2 readr 패키지의 강제 변환 함수들 tidyverse 패키지 안에 포함되어 있는 readr 패키지에는 다음과 같은 벡터의 데이터 유형을 강제 변환시키는 parse_*() 함수들이 있습니다. 특히, parse_*() 함수들은 벡터의 요소 값을 결측치로 처리할 수 있게 해주는 na = 인수를 제공하고 있습니다. library(tidyverse) parse_logical(x, na = c(&quot;&quot;, &quot;NA&quot;), locale = default_locale(), trim_ws = TRUE) parse_integer(x, na = c(&quot;&quot;, &quot;NA&quot;), locale = default_locale(), trim_ws = TRUE) parse_double(x, na = c(&quot;&quot;, &quot;NA&quot;), locale = default_locale(), trim_ws = TRUE) parse_character(x, na = c(&quot;&quot;, &quot;NA&quot;), locale = default_locale(), trim_ws = TRUE) 예 : # 패키지 설치와 불러오기 # install.packages(&quot;readr&quot;) library(readr) # 함수의 이용 예 parse_integer(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)) # 문자형 벡터를 정수형 벡터로 강제변환 ## [1] 1 2 3 parse_double(c(&quot;1.56&quot;, &quot;2.34&quot;, &quot;3.56&quot;)) # 문자형 벡터를 실수형 벡터로 강제변환 ## [1] 1.56 2.34 3.56 parse_logical(c(&quot;true&quot;, &quot;false&quot;)) # 문자형 벡터를 논리형 벡터로 강제변환 ## [1] TRUE FALSE parse_number(c(&quot;0%&quot;, &quot;10%&quot;, &quot;150%&quot;)) # 문자형 벡터를 숫자형 벡터로 강제변환 : 숫자만 선택한다 ## [1] 0 10 150 parse_number(c(&quot;$1,234.5&quot;, &quot;$12.45&quot;)) ## [1] 1234.50 12.45 parse_datetime(&quot;2010-10-01 21:45&quot;) # 문자형 벡터를 날짜-시간형 벡터로 강제변환 ## [1] &quot;2010-10-01 21:45:00 UTC&quot; parse_date(&quot;2010-10-01&quot;) # 문자형 벡터를 날짜형 벡터로 강제변환 ## [1] &quot;2010-10-01&quot; parse_time(&quot;1:00pm&quot;) # 문자형 벡터를 시간형 벡터로 강제변환 ## 13:00:00 "],["스칼라-및-자동반복-규칙.html", "5.8 스칼라 및 자동반복 규칙", " 5.8 스칼라 및 자동반복 규칙 5.8.1 스칼라(scalar) 벡터 간의 상호 호환되도록 벡터의 유형을 암시적으로 강제변환하는 것에 대해 앞에서 살펴 보았습니니다. 그런데 R은 벡터의 길이도 암시적으로 강제변환을 합니다. 5.8.2 자동 반복(recycling) 더 짧은 벡터가 더 긴 벡터와 동일한 길이로 반복(repeat)되거나 자동반복(recycling)되기 때문에이를 벡터 자동반복(recyling)이라고 합니다. 이것은 일반적으로 벡터와 “스칼라”를 혼합할 때 가장 유용합니다. R에는 실제로 스칼라가 없기 때문에 스칼라를 따옴표로 묶었습니다. 대신 단일 숫자는 길이가 1인 벡터입니다. 스칼라가 없기 때문에 대부분의 내장 함수는 벡터화되어 숫자 벡터에서 작동합니다. 이것이 바로 이 코드가 작동하는 이유입니다. data1 &lt;- sample(10) + 100 data2 &lt;- runif(10) &gt; 0.5 R에서 기본적인 수학 연산은 벡터로 작동합니다. 즉, 간단한 수학적 계산을 수행할 때 명시적 반복을 수행할 필요가 없습니다. 5.8.3 길이가 다른 두 벡터 연산 길이가 같은 벡터 두 개 또는 벡터와 “스칼라”를 더하면 어떤 일이 발생해야 하는지 직관적입니다. 하지만 길이가 다른 두 벡터를 더하면 어떻게 될까요? 1:10 + 1:2 # 1:10는 요소가 10개, 반면에 1:2는 요소가 2개. 즉 10이 2이 5배가 된다. -&gt; 자동 채우기로 연산 ## [1] 2 4 4 6 6 8 8 10 10 12 1:10 + 1:3 # 1:10는 요소가 10개, 그런데 1:3은 요소가 3개. 즉 10은 3의 정수 배수가 안된다. -&gt; 경고메시지 ## Warning in 1:10 + 1:3: 두 객체의 길이가 서로 배수관계에 있지 않습니다 ## [1] 2 4 6 5 7 9 8 10 12 11 여기서 R은 가장 짧은 벡터를 가장 긴 벡터와 같은 길이로 확장합니다. 긴 벡터의 요소 갯수가 짧은 벡터의 요소 갯수에 정수 배수가 되면 R은 알아서 짧은 벡터를 자동반복시켜 처리합니다. 그러나 정수 배수가 되지 않으면 R은 경고 메시지를 보여 줍니다. 벡터의 자동반복은 매우 간결하고 영리한 코드를 만드는 데 사용할 수 있지만 문제를 조용히 숨길 수도 있습니다. 이러한 이유로 tidyverse 패키지의 벡터화된 함수는 스칼라가 아닌 다른 것을 자동반복할 때 오류를 발생시킵니다. tidyverse 패키지의 벡터 함수들은 rep() 함수를 사용하여 직접 자동 반복을 수행해야 합니다. library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 -- ##  ggplot2 3.3.3  dplyr 1.0.2 ##  tibble 3.0.4  stringr 1.4.0 ##  tidyr 1.1.2  forcats 0.5.0 ##  purrr 0.3.4 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x tibble::has_rownames() masks tester::has_rownames() ## x purrr::is_integer() masks tester::is_integer() ## x purrr::is_vector() masks tester::is_vector() ## x dplyr::lag() masks stats::lag() tibble(x = 1:4, y = 1:3) # x컬럼의 요소 갯수는 4개인 반면, y 컬럼의 요소 갯수는 3개. -&gt; Error ## Error: Tibble columns must have compatible sizes. ## * Size 4: Existing data. ## * Size 3: Column `y`. ## i Only values of size one are recycled. tibble(x = 1:4, y = rep(1:2, 2)) # y 컬럼의 값으로 (1, 2)를 2번 반복함(`rep()` 함수 사용) ## # A tibble: 4 x 2 ## x y ## &lt;int&gt; &lt;int&gt; ## 1 1 1 ## 2 2 2 ## 3 3 1 ## 4 4 2 "],["벡터요소들에-이름-붙이기.html", "5.9 벡터(요소들)에 이름 붙이기", " 5.9 벡터(요소들)에 이름 붙이기 모든 유형의 벡터(요소)에 이름을 지정할 수 있습니다. c()를 사용하여 생성하는 동안 이름을 지정할 수 있습니다. c(x = 1, y = 2, z = 4) ## x y z ## 1 2 4 base 패키지의 names() 함수나 purrr 패키지의 set_names() 함수를 이용하여 이름을 붙일 수도 있습니다. x &lt;- 1:3 names(x) &lt;- letters[1:3] # 각 요소의 이름을 a, b, c로 붙인다. x ## a b c ## 1 2 3 names(x) &lt;- NULL; x # 이름을 없앤다. ## [1] 1 2 3 # install.packages(&quot;purrr&quot;) library(purrr) set_names(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## a b c ## 1 2 3 "],["벡터-요소에-접근하기.html", "5.10 벡터 요소에 접근하기", " 5.10 벡터 요소에 접근하기 벡터 인덱싱(indexing)을 사용하여 벡터의 요소에 접근하여 그 요소 값을 확인할 수 있습니다. 인덱싱에 사용되는 벡터는 논리형, 정수형 또는 문자형 벡터 등이 사용됩니다. 5.10.1 정수형 벡터를 인덱스로 사용하기 벡터의 색인번호는 곧 인덱스는 요소가 벡터 내에 위치하는 번호입니다. R에서는 이 인덱스가 0이 아닌 1부터 시작합니다. 그리고 이러한 색인 번호를 정수형 벡터로 생성한 다음, 벡터 요소의 접근을 위한 인덱스로 사용할 수 있습니다. 이때 인덱스를 사용하기 위해서는 벡터변수명[인덱스 벡터]와 같이 변수명 다음의 대괄호([])안에 인덱스 벡터를 기입합니다. x &lt;- c(1, 2, 3, 4, 5) # 데이터 x[2] # 벡터 x의 2번째 요소 값을 출력합니다. ## [1] 2 x[c(1, 3, 5)] # 벡터 x의 1, 3, 5번째 요소 값을 출력합니다. ## [1] 1 3 5 x[-1] # 1번째 요소를 제외한 요소 값을 확인합니다. ## [1] 2 3 4 5 # 음수의 사용 x[c(-1, -3)] # 1번째, 3번째 요소를 제외한 요소 값을 확인합니다. ## [1] 2 4 5 # 음수와 양수의 사용 : Error x[c(-1, 3)] # 음수와 양수를 동시에 사용하면 Error가 발생합니다. ## Error in x[c(-1, 3)]: only 0&#39;s may be mixed with negative subscripts 5.10.1.1 which() 함수의 이용 which() 함수를 이용하면 벡터에서 원하는 조건을 만족하는 요소의 색인번호를 찾을 수 있습니다. 원하는 조건을 which() 함수의 인수로 입력하면, which() 함수는 이 조건을 만족하는 벡터의 색인 번호를 반환해 줍니다. 다음의 벡터 x의 원소 중에서 2보다 큰 값을 가지는 요소의 색인번호를 반환합니다. x &lt;- c(6, 2, -3, 1, 5) # 데이터 z &lt;- which(x &gt; 2) # 벡터 x에서 2보다 큰 요소의 색인번호를 반환합니다. # 결과로 z는 (1, 5)가 됩니다. 즉 조건을 만족하는 요소가 1, 5번째 요소입니다. x[z] # 조건을 만족하는 요소의 값을 확인해 줍니다. 즉, 6, 5 입니다. ## [1] 6 5 5.10.2 논리형 벡터를 인덱스로 사용하기 인덱싱에 논리 벡터를 사용하면 논리 벡터가 TRUE 인 위치의 요소만 반환됩니다. 이 유용한 기능은 아래와 같이 벡터 필터링에 매우 유용하게 사용됩니다. 다음과 같이 x 벡터가 있을 때, 그 값이 2보다 큰 요소만 확인하고자 한다면 다음과 같이 할 수 있습니다. 즉, 인덱스로 값을 비교하는 조건식을 이용할 수 있습니다. x &lt;- c(6, 2, -3, 1, 5) x[x &gt; 2] ## [1] 6 5 이는 다음과 같이 값을 비교하는 비교식에 의해 논리형 벡터가 생성되고 이 논리형 벡터가 인덱싱에 사용되는 것입니다. x &lt;- c(6, 2, -3, 1, 5) # 데이터 z &lt;- x &gt; 2 # 데이터 요소들 각각이 2보다 큰지 비교 -&gt; z 벡터는 논리형 벡터입니다. # z &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE)가 됩니다. x[z] # 논리형 벡터 z가 인덱스로 사용되고 있으며, TRUE 인 요소만 반환이 됩니다. ## [1] 6 5 다음과 같이 x 벡터가 있을 때, 그 값이 2와 4의 사이에 있는 요소만 확인하고자 할 때는 제2부 제1장에서 배운 논리연산자 &amp;를 사용하면 됩니다. x &lt;- c(6, 2, -3, 1, 5) # 데이터 x[x &gt;=2 &amp; x &lt;=4] ## [1] 2 이는 다음과 같은 단계를 거쳐 그 결과가 출력되는 것입니다. x &lt;- c(6, 2, -3, 1, 5) # 데이터 z &lt;- ( x &gt;= 2 &amp; x &lt;= 4 ) # x의 요소 각각이 2와 4사이의 값이면 TRUE, 아니면 FALSE 값을 갖는 z z # z &lt;- c(FALSE, TRUE, TRUE, TRUE, FASLE)가 됩니다. ## [1] FALSE TRUE FALSE FALSE FALSE x[z] # z의 TRUE 요소에 해당하는 x 요소 값을 반환합니다. ## [1] 2 이 비교에 의한 확인은 다음의 원소 값의 수정에서도 유용하게 활용할 수 있습니다.** 5.10.3 문자형 벡터를 색인으로 사용하기 앞에서 우리는 벡터의 이름을 붙이는 방법에 대하여 살펴보았습니다. 이렇게 이름이 붙여진 벡터를 처리할 때 유용한 데, 벡터의 각 요소에 붙여진 이름을 이용하여 인덱싱할 수 있기 때문입니다. x &lt;- c(1, 3, 5, 7, 9) # 데이터 names(x) &lt;- LETTERS[1:5] # 요소 이름 붙이기 : A, B, C, D, E x ## A B C D E ## 1 3 5 7 9 x[&quot;A&quot;] # &quot;A&quot; 이름을 갖는 요소값 출력 ## A ## 1 x[c(&quot;A&quot;, &quot;C&quot;, &quot;D&quot;)] # 문자형 벡터의 인덱스 : c(&quot;A&quot;, &quot;C&quot;, &quot;D&quot;) ## A C D ## 1 5 7 x[-c(&quot;A&quot;, &quot;C&quot;, &quot;D&quot;)] # - 기호는 사용할 수 없습니다. ; Error ## Error in -c(&quot;A&quot;, &quot;C&quot;, &quot;D&quot;): 단항연산자에 유효한 인자가 아닙니다 "],["벡터의-결합-벡터-요소의-삽입.html", "5.11 벡터의 결합, 벡터 요소의 삽입", " 5.11 벡터의 결합, 벡터 요소의 삽입 벡터 x와 벡터 y를 다음과 같이 결합할 수 있습니다. x &lt;- c(1, 2, 3); y &lt;- c(4, 5, 6) # 벡터 x, y z &lt;- c(x, y) # c() 함수를 이용히여 벡터를 결합할 수 있습니다. 다음과 같은 벡터 x의 4번째에 8이라는 요소를 삽입하려면 다음과 같이 하면 됩니다. x &lt;- c(1,3, 5, 7, 9, 11); x # 수정 전 x ## [1] 1 3 5 7 9 11 x1 &lt;- x[1:3] x2 &lt;- x[4:6] x &lt;- c(x1, 8, x2); x # 수정 후 x ## [1] 1 3 5 8 7 9 11 5.11.1 문자열의 결합 함수 : paste() 함수와 paste0() 함수 문자열 벡터의 결합은 paste(x, sep= ) 함수나 paste0(x) 함수를 이용합니다. 이 두 함수의 차이는 paste() 함수는 문자열을 결합할 때 구분자를 sep = 인수로 지정할 수 있습니다. 반면에 paste0() 함수는 요소들을 결합할 때 모든 요소를 하나의 문자열로 결합해 줍니다. x &lt;- c(&quot;이&quot;,&quot;박&quot;,&quot;김&quot;,&quot;최&quot;,&quot;차&quot;); x ## [1] &quot;이&quot; &quot;박&quot; &quot;김&quot; &quot;최&quot; &quot;차&quot; y &lt;- c(&quot;순신&quot;, &quot;원순&quot;, &quot;재경&quot;, &quot;창원&quot;, &quot;태균&quot;); y ## [1] &quot;순신&quot; &quot;원순&quot; &quot;재경&quot; &quot;창원&quot; &quot;태균&quot; # paste(x, sep = ) 함수의 이용 s1 &lt;- paste(x,y); s1 # x와 y의 각 요소들을 공란(&quot; &quot;)으로 결합하여 문자열 벡터를 생성합니다. ## [1] &quot;이 순신&quot; &quot;박 원순&quot; &quot;김 재경&quot; &quot;최 창원&quot; &quot;차 태균&quot; s2 &lt;- paste(x, y, sep=&quot;,&quot;); s2 # x와 y의 각 요소들을 컴마(,)로 결합하여 문자열 벡터를 생성합니다. ## [1] &quot;이,순신&quot; &quot;박,원순&quot; &quot;김,재경&quot; &quot;최,창원&quot; &quot;차,태균&quot; s3 &lt;- paste(x, y, sep=&quot;&quot;); s3 # x와 y의 각 요소들을 공란없이 결합하여 문자열 벡터를 생성합니다. ## [1] &quot;이순신&quot; &quot;박원순&quot; &quot;김재경&quot; &quot;최창원&quot; &quot;차태균&quot; s4 &lt;- paste(1:4); s4 # 1부터 4까지의 숫자들을 공란을 추가하여 결합한 문자열 벡터를 생성합니다. ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; # paste0() 함수의 이용 s5 &lt;- paste0(x, y); s5 # x와 y의 각 요소들을 공란없이 결합하여 문자열 벡터를 생성합니다. ## [1] &quot;이순신&quot; &quot;박원순&quot; &quot;김재경&quot; &quot;최창원&quot; &quot;차태균&quot; s6 &lt;- paste0(1:4); s6 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; "],["벡터의-연산.html", "5.12 벡터의 연산7", " 5.12 벡터의 연산7 5.12.1 산술연산 5.12.1.1 단순 산술 연산 단순 스칼라의 경우에는 더하기, 빼기, 곱하기, 나누기, 나머지, 몫 등의 연산을 수행할 수 있습니다. x &lt;- 5 + 2; x ## [1] 7 x &lt;- 5 - 3; x ## [1] 2 x &lt;- 5 * 2; x ## [1] 10 x &lt;- 5 / 2; x ## [1] 2.5 x &lt;- 5 %% 2; x ## [1] 1 x &lt;- 5 %/% 2; x ## [1] 2 x &lt;- 5 ^ 2; x ## [1] 25 5.12.1.2 벡터의 산술연산 연산자 좌우의 두 벡터에 대응되는 각각의 요소별로 연산을 합니다. # 벡터 데이터 x &lt;- c(1, 2, 3, 4) # 4개 원소 y &lt;- c(2, 3, 4, 5) # 4개 원소 z &lt;- c(1, 2) # 2개 원소 # 더하기 연산 w1 &lt;- x + y; w1 ## [1] 3 5 7 9 w2 &lt;- x + 5; w2 ## [1] 6 7 8 9 # 빼기 연산 w3 &lt;- y - 2; w3 ## [1] 0 1 2 3 w4 &lt;- x - z; w4 ## [1] 0 0 2 2 # 곱하기 연산 w5 &lt;- y * 2; w5 ## [1] 4 6 8 10 w6 &lt;- x - z; w6 ## [1] 0 0 2 2 # 나누기 연산 w7 &lt;- y / 2; w7 ## [1] 1.0 1.5 2.0 2.5 w8 &lt;- x / z; w8 ## [1] 1 1 3 2 # 몫 연산 w9 &lt;- y %/% x; w9 ## [1] 2 1 1 1 # 나머지 연산 w10 &lt;- y %% x; w10 ## [1] 0 1 1 1 5.12.1.3 서로 다른 유형의 벡터 연산 # 문자와 숫자의 혼합 -&gt; 모두 문자로 처리합니다. y &lt;- c(&quot;A&quot;, 1, 2); y ## [1] &quot;A&quot; &quot;1&quot; &quot;2&quot; class(y) ## [1] &quot;character&quot; # 문자형 데이터의 산술 연산은 에러 발생 z &lt;- y + 1 # Error가 발생합니다. ## Error in y + 1: 이항연산자에 수치가 아닌 인수입니다 # 문자형과 논리형의 혼합 -&gt; 모두 문자로 처리합니다. y &lt;- c(&quot;A&quot;, T, F); y # T, F 모두를 &quot;TRUE&quot;와 &quot;FALSE&quot; 문자형으로 변환합니다. ## [1] &quot;A&quot; &quot;TRUE&quot; &quot;FALSE&quot; class(y) ## [1] &quot;character&quot; # 논리형과 숫자형의 연산 x &lt;- c(T, F, TRUE, FALSE); x ## [1] TRUE FALSE TRUE FALSE y &lt;- c(1, 3); y ## [1] 1 3 # y는 자동반복으로 c(1, 3, 1, 3)이됩니다. # x는 y와의 산술연산을 위해 (1, 0, 1, 0)으로 변환이 됩니다. x + y # 2, 3, 2, 3 으로 출력이 됩니다. ## [1] 2 3 2 3 5.12.2 비교 연산 비교 연산자는 연산자 좌우의 값들을 비교하고 그 결과를 논리형(TRUE 또는 FALSE)으로 반환합니다. - (&gt;=, &gt;, ==, &lt;, &lt;= ) =&gt; 결과는 ‘TRUE’ 또는 ‘FALSE’ x &lt;- 5 &lt; 3; x # 5 &lt; 3의 비교결과인 FALSE가 변수 x에 저장됩니다. ## [1] FALSE y &lt;- c(10, 20, 30) z &lt;- y &lt;= 10 # y 벡터의 3개 요소 각각을 10보다 작거나 같은지 비교합니다. z # z는 논리형 벡터로 (TRUE, FALSE, FALSE)가 됩니다. ## [1] TRUE FALSE FALSE 5.12.3 논리 연산 : |, &amp;, !, ||, &amp;&amp; 논리 연산자는 논리형 벡터의 논리 연산(AND, OR, NOT 등)에 사용됩니다. 숫자형 벡터의 경우 값이 0인 경우는 FALSE, 그 이외에는 TRUE가 됩니다. x &lt;- c(TRUE, TRUE, FALSE, FALSE); x ## [1] TRUE TRUE FALSE FALSE y &lt;- c(TRUE, FALSE, TRUE, FALSE); y ## [1] TRUE FALSE TRUE FALSE # 논리합 연산 : | # 양쪽의 값이 모두 `FALSE`인 경우에만 `FALSE`. 그 이외에는 `TRUE`입니다. x | y ## [1] TRUE TRUE TRUE FALSE # 논리곱 연산 : &amp; x &amp; y ## [1] TRUE FALSE FALSE FALSE # 논리부정 연산 : ! !x ## [1] FALSE FALSE TRUE TRUE !y ## [1] FALSE TRUE FALSE TRUE # 논리합 연산 : || x || y ## [1] TRUE # 논리곱 연산 : &amp;&amp; x &amp;&amp; y ## [1] TRUE # 논리연산 함수의 예 isTRUE(y) ## [1] FALSE # 요소의 갯수가 일치하지 않는 경우 z &lt;- c(TRUE, FALSE, FALSE) z | y # z 변수의 네 번쨰 요소가 TRUE로 자동채움되어 연산이 되며, 경고메시지를 출력합니다. ## Warning in z | y: 두 객체의 길이가 서로 배수관계에 있지 않습니다 ## [1] TRUE FALSE TRUE TRUE 제2부 제1장 연산자 부분도 참고하기 바랍니다. "],["원소-값의-수정.html", "5.13 원소 값의 수정", " 5.13 원소 값의 수정 할당 연산자(&lt;-)를 사용하여 벡터를 수정할 수 있습니다. 앞에서 설명한 벡터 요소에 접근하는 방법을 이용하여 벡터의 특정 요소에 접근하여 수정할 수 있습니다. 요소를 자르려면 재할당을 사용할 수 있습니다. x &lt;- seq(-2, 8, 2); x # 수정 전의 벡터 x ## [1] -2 0 2 4 6 8 names(x) &lt;- LETTERS[1:6] # 벡터에 이름을 붙입니다. &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot; # 정수형 벡터 색인을 이용한 수정 x[2] &lt;- 20; x # x[2] 즉 벡터 x의 2번째 요소를 20으로 수정합니다. ## A B C D E F ## -2 20 2 4 6 8 x[c(3, 4)] &lt;- 15; x # x의 3, 4번째 요소를 동시에 15로 수정합니다 ## A B C D E F ## -2 20 15 15 6 8 # 논리형 벡터 색인을 이용한 수정 x[x &lt;= 10] &lt;- 10; x # x의 요소를 3과 비교하여 작거나 같은 요소들만 10으로 변경합니다. ## A B C D E F ## 10 20 15 15 10 10 # 벡터 이름을 이용한 수정 x[c(&quot;A&quot;, &quot;D&quot;)] &lt;- 3; x # &quot;A&quot;, &quot;D&quot; 즉 첫번쨰와 네번쨰 요소의 값을 3으로 수정합니다. ## A B C D E F ## 3 20 15 3 10 10 "],["벡터의-서브세팅.html", "5.14 벡터의 서브세팅", " 5.14 벡터의 서브세팅 벡터를 하위 집합으로 만들 수 있는 방법에는 다음과 같은 네 가지 유형이 있습니다. 정수만 포함하는 숫자형 벡터입니다. 정수는 모두 양수, 모두 음수 또는 0이어야 합니다. 양의 정수로 부분 집합화하면 요소가 해당 위치에 유지됩니다. x1 &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;) # 정수형 벡터를 이용한 서브세팅 y1 &lt;- x1[c(3, 2, 5)]; y1 # y1벡터는 x1의 3, 2, 5 번쨰의 순으로 요소들을 서브세팅합니다. ## [1] &quot;three&quot; &quot;two&quot; &quot;five&quot; y2 &lt;- x1[c(1, 1, 5, 5, 5, 2)]; y2 # y2벡터는 x1의 1번째 요소를 2번, 5번째 요소를 3번, 그리고 2번쨰 요소를 1번 서브세팅합니다. ## [1] &quot;one&quot; &quot;one&quot; &quot;five&quot; &quot;five&quot; &quot;five&quot; &quot;two&quot; y3 &lt;- x1[c(-1, -3, -5)]; y3 # 음수의 사용은 그 요소를 제거합니다. 즉, y3는 x1의 1번쨰, 3번째, 5번째 요소를 제외한 서브세팅입니다. ## [1] &quot;two&quot; &quot;four&quot; y4 &lt;- x1[c(1, -1)]; y4 # 그러나 음수와 양수를 동시에 사용하면 Error가 발생합니다. ## Error in x1[c(1, -1)]: only 0&#39;s may be mixed with negative subscripts ## Error in eval(expr, envir, enclos): 객체 &#39;y4&#39;를 찾을 수 없습니다 # 결측치를 제거하는 서브세팅 x2 &lt;- c(10, 3, NA, 5, 8, 1, NA) # NA는 결측치입니다. y5 &lt;- x2[!is.na(x2)]; y5 # y5는 x2의 요소 중 NA가 아닌 것(!is.na(x2))만 서브세팅합니다. ## [1] 10 3 5 8 1 # 논리형 벡터를 이용한 서브세팅 y6 &lt;- x2[x2 %% 2 == 0]; y6 # y6는 x2의 요소 중 2로 나눈 나머지가 0인 즉 짝수인 요소만 서브세팅합니다. ## [1] 10 NA 8 NA # 그런데 NA도 출력됨을 주목하기 바랍니다. # 벡터의 이름을 이용한 서브세팅 x3 &lt;- c(abc = 1, def = 2, xyz = 5) # x3는 이름이 붙여진 벡터입니다. y7 &lt;- x3[c(&quot;xyz&quot;, &quot;def&quot;)]; y7 # y7는 x3의 &quot;xyz&quot;, &quot;def&quot;요소를 서브세팅합니다. ## xyz def ## 5 2 "],["벡터의-연산-함수의-예.html", "5.15 벡터의 연산 함수의 예", " 5.15 벡터의 연산 함수의 예 숫자형 벡터의 연산과 관련하여 주요 함수들을 알아두면 편리합니다. 다음에서 몇 가지 예를 살펴 보겠습니다. # 벡터와 관련된 알아두면 좋은 함수 # 데이터 x &lt;- c(1, 4, -4, 8, -2) y &lt;- c(3, 2, -2, 4, -1) # 요소 각각에 적용되는 함수 sqrt(x) # 각 요소의 제곱근을 반환합니다. ## Warning in sqrt(x): NaN이 생성되었습니다 ## [1] 1.000000 2.000000 NaN 2.828427 NaN abs(x) # 각 요소의 절대값을 반환합니다. ## [1] 1 4 4 8 2 # 요소의 전체의 합계, 곱하기 sum(x) # 모든 요소의 합을 반환합니다. ## [1] 7 prod(x) # 모든 요소의 곱을 반환합니다. ## [1] 256 diff(x) # 이전 요소와의 차를 반환합니다. ## [1] 3 -8 12 -10 cumsum(x) # 원소의 누적 합을 반환합니다. ## [1] 1 5 1 9 7 cumprod(x) # 원소의 누적 곱을 반환합니다. ## [1] 1 4 -16 -128 256 # 기본 통계량 min(x) # 최소값을 반환합니다. ## [1] -4 max(x) # 최대값을 반환합니다. ## [1] 8 summary(x) # 통계적 요약 정보를 반환합니다. ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -4.0 -2.0 1.0 1.4 4.0 8.0 mean(x) # 평균을 반환합니다. ## [1] 1.4 median(x) # 중앙값을 반환합니다. ## [1] 1 var(x) # 분산을 반환합니다. ## [1] 22.8 sd(x) # 표준편차를 반환합니다. ## [1] 4.774935 # 공분산과 상관관계 cov(x, y) # x와 y의 공분산을 반환합니다. ## [1] 11.15 cor(x, y) # x와 y의 상관관계를 반환합니다. ## [1] 0.9021319 # 벡터의 범위와 분위수 range(x) # x의 범위를 반환합니다. ## [1] -4 8 quantile(x) # x의 최대, 최소, 사분위수 값을 반환합니다. ## 0% 25% 50% 75% 100% ## -4 -2 1 4 8 # 요소의 갯수 length(x) # 벡터의 길이를 반환합니다. ## [1] 5 # 정렬 함수 sort(x) # 오름차순으로 정렬된 결과를 반환합니다. ## [1] -4 -2 1 4 8 sort(x, decreasing = TRUE) # 내림차순으로 정렬된 결과를 반환합니다. ## [1] 8 4 1 -2 -4 order(x) # 오름차순으로 정렬된 벡터 요소의 번호를 반환합니다. ## [1] 3 5 1 2 4 # 집합 함수 union(x, y) # 두 벡터의 합집합, 중복 제외. ## [1] 1 4 -4 8 -2 3 2 -1 intersect(x, y) # 두 벡터의 교집합 ## [1] 4 -2 setdiff(x, y) # 두 벡터의 차집합 ## [1] 1 -4 8 # 중복값을 제외한 벡터 생성 d &lt;- c(1, 2, 3, 1, 1, 3, 2, 4) uniq_d &lt;- unique(d) # uniq_d 는 (1, 2, 3, 4)가 됩니다. uniq_d ## [1] 1 2 3 4 # sample() 함수를 이용한 벡터 생성 samp.data &lt;- sample(1:5, 20, rep=TRUE) # 1:5까지의 숫자를 복원추출(rep=TRUE)하여 20개 생성합니다. samp.data ## [1] 3 2 2 2 4 4 1 1 5 1 4 4 4 1 3 5 3 1 3 4 "],["특수-상수.html", "5.16 특수 상수", " 5.16 특수 상수 5.16.1 결측치 : NULL, NA 데이터 처리 시 결측치(missing value)는 NULL 또는 NA로 처리합니다. NULL : 보통 변수의 초기화에 사용됩니다. NA : 보통 무응답의 경우에 사용됩니다. # NULL, NA(not available) x &lt;- NULL # x를 초기화합니다. is.null(x) # x가 NULL인지 테스트합니다. TRUE를 반환합니다. ## [1] TRUE # 결측치 값의 입력 y &lt;- c(1, 2, 3, NA, 5); y # y의 네번째 요소가 NA 즉, 결측치입니다. ## [1] 1 2 3 NA 5 y &lt;- NULL # y를 초기화 합니다. # is.na() 함수의 이용 y &lt;- c(1, 2, 3, NA, 5) z &lt;- is.na(y); z # z는 y의 요소 각각에 대한 is.na()의 반환값으로 구성됩니다. (논리형 벡터) ## [1] FALSE FALSE FALSE TRUE FALSE which(z) ## y벡터 중 NA값을 갖는 요소의 번호를 반환합니다. ## [1] 4 y[!z] ## y의 요소 중 NA가 아닌 요소만을 반환합니다. ## [1] 1 2 3 5 y[-which(z)] ## y의 요소 중 NA가 아닌 요소만을 반환합니다. ## [1] 1 2 3 5 5.16.2 Inf, -Inf, NaN # Inf, -Inf, is.infinite() 함수 z1 &lt;- 10/0; z1 # Inf : infinite : &#39;무한대&#39;를 의미합니다. ## [1] Inf is.infinite(z1) # Inf 인지 테스트합니다. ## [1] TRUE z2 &lt;- -10/0; z2 # -Inf ## [1] -Inf is.infinite(z2) ## [1] TRUE # NaN, is.nan() 함수 w &lt;- 0/0; w # NaN : not a number 를 의미합니다. (수학적으로는 부정) ## [1] NaN is.nan(w) # NaN 인지 테스트합니다. ## [1] TRUE "],["요인factor.html", "Chapter 6 요인(factor)", " Chapter 6 요인(factor) 이 장에서는 R 프로그래밍의 요인(factor)를 다루는 방법을 학습하겠습니다. 요인은 미리 정의된 유한한 수의 값에 사용되는 데이터 구조입니다. 또한 요인의 수준(levels)에 대해서도 학습하겠습니다. R에는 플롯을 만들거나 통계 분석을 수행할 때 발생할 수있는 범주형 데이터(categorical data)를 처리하기 위한 요인(factor)이라는 특수 데이터 클래스가 있습니다. 요인은 매우 유용하며 실제로 R을 이용한 데이터 작업을 특히 적합하게 만드는 데 기여합니다. 요인은 범주형 데이터를 나타냅니다. 요인은 기본적으로 문자형 벡터의 형태를 가집니다. 그러나, 데이터를 저장할 때는각각의 요소에 대한 레이블이 정수 값으로 저장되며, 정렬이 된 순서로 지정되거나 정렬이 되지 않은 순서로 저장될 수도 있습니다. 요인은 요일 또는 설문 조사 질문에 대한 응답과 같은 범주형 변수의 여러 수준(값) 간에 구조화된 관계를 만듭니다. 이렇게 하면 한 요소가 다른 요소와 어떻게 관련되는지 쉽게 확인할 수 있습니다. 요인는 문자형 벡터처럼 보이며 종종 그렇게 동작하지만 실제로는 R에서는 정수형 벡터로 처리됩니다. 따라서 그것들을 문자열로 취급할 때 매우 조심해야합니다. 요인 개체에 있어서 중요한 두 개의 속성이 있습니다. 그것은 class와 levels입니다. class는 요인이 factor 임을 알려 주고, 정수형 벡터와 다르게 사용되도록 합니다. levels 속성은 ‘미리 정의된 값’을 정의합니다. 일단 생성된 요인은 수준(levels) 이라고하는 미리 정의된 값의 집합 만을 포함할 수 있습니다. 기본적으로 R은 항상 사전(가나다 순, 알파벳 순) 순으로 수준을 정렬합니다. "],["요인-변수의-생성.html", "6.1 요인 변수의 생성", " 6.1 요인 변수의 생성 먼저 요인은 문자열 벡터를 기본으로 하여 생성을 할 수 있습니다. 예를 들어, 다음과 같은 st_data 라는 문자형 벡터가 있을 때 이를 범주형 변수 즉 요인으로 활용하고자 한다면 factor() 함수를 이용하여 st_data 를 요인으로 변경을 해야 합니다. 6.1.1 factor() 함수를 이용한 요인 생성 st_data &lt;- c(&quot;earth&quot;, &quot;cement&quot;, &quot;cement&quot;, &quot;earth&quot;) # st_data는 4개의 문자열 요소를 갖는 문자형 벡터입니다. st_data ## [1] &quot;earth&quot; &quot;cement&quot; &quot;cement&quot; &quot;earth&quot; floor_type &lt;- factor(st_data) # floor_type은 st_data가 갖는 데이터의 종류를 수준으로 하는 요인이 됩니다. floor_type ## [1] earth cement cement earth ## Levels: cement earth # 요인 개체의 클래스, 데이터 유형 확인 class(floor_type) # &quot;factor&quot; 클래스임을 알 수 있습니다 ## [1] &quot;factor&quot; typeof(floor_type) # &quot;integer&quot; 유형임을 알 수 있습니다. ## [1] &quot;integer&quot; is.factor(floor_type) # floor_type 개체가 요인형인지 확인합니다. ## [1] TRUE # TRUE를 반환합니다. attributes(floor_type) # floor_type 개체의 속성을 반환합니다. (levels와 class) ## $levels ## [1] &quot;cement&quot; &quot;earth&quot; ## ## $class ## [1] &quot;factor&quot; R Studio의 환경 창을 보면, 으로 나타나 있는 것을 알 수 있습니다. 즉, floor_type 이라는 개체는 Factor 클래스입니다. 그리고 데이터 유형은 “정수형”입니다. 2개의 수준(levels)으로 “cement”와 “earth”를 가지고 있다는 것입니다. 여기서 수준은 데이터 값의 종류라고 생각하면 됩니다. 이어서 저장된 형태가 2 1 1 2로 되어 있는 것은 원래의 문자열 데이터 (\"earth\", \"cement\", \"cement\", \"earth\")가 수준의 순서를 나타내는 2 1 1 2의 정수형으로 저장됨을 의미합니다. floor_type 개체의 속성(attributes)은 levels 속성과 class 속성으로 구성됩니다. "],["요인의-요소에-접근하기.html", "6.2 요인의 요소에 접근하기", " 6.2 요인의 요소에 접근하기 요인의 구성 요소에 접근하는 것은 벡터의 구성 요소에 접근하는 것과 매우 유사합니다. floor_type ## [1] earth cement cement earth ## Levels: cement earth # 정수형 벡터를 색인으로 이용하는 방법입니다. floor_type[2] # 2번째 요소를 반환합니다. ## [1] cement ## Levels: cement earth floor_type[c(2, 4)] # 2번째와 4번째 요소를 반환합니다. ## [1] cement earth ## Levels: cement earth floor_type[-1] # 1번 요소를 제외하고 반환합니다. ## [1] cement cement earth ## Levels: cement earth # 논리형 벡터를 색인으로 이용하는 방법입니다. floor_type[c(TRUE, FALSE, FALSE, TRUE)] # 1번째와 4번째 요소를 반환합니다. ## [1] earth earth ## Levels: cement earth # which() 함수의 이용 which(floor_type == &quot;earth&quot;) # 요소의 값이 earth인 색인 번호를 반환합니다. ## [1] 1 4 6.2.1 요인형 변수에 데이터 추가하기 floor_type 변수는 요인 변수로서 두 개의 수준인 “earth”와 “cement” 만을 요소 값으로 하고 있습니다. 만약에 이 변수에 “stone” 이라는 값을 추가하면 어떻게 될까요? stone이라는 값은 floor_type의 수준에 없기 때문에 Error가 발생하고 NA값이 입력됩니다. stone을 새로운 수준으로 설정하지 않은 이상stone은floor_type에 입력되지 않습니다. floor_type[5] &lt;- &quot;stone&quot; # 5번째 요소로 stone을 할당합니다. ## Warning in `[&lt;-.factor`(`*tmp*`, 5, value = &quot;stone&quot;): invalid factor level, NA ## generated # 경고 메시시가 출력되고, NA값이 입력됩니다. levels(floor_type) &lt;- c(levels(floor_type), &quot;stone&quot;) # stone를 수준에 추가해 줍니다. levels(floor_type) # 수준에 stone이 추가되었습니다. ## [1] &quot;cement&quot; &quot;earth&quot; &quot;stone&quot; floor_type[5] &lt;- &quot;stone&quot; # stone이 floor_type에 새로 추가되었습니다. "],["요인-데이터의-저장-방식.html", "6.3 요인 데이터의 저장 방식", " 6.3 요인 데이터의 저장 방식 여기서 수준의 순서는 “cement”, “earth”순이며 알파벳 순서로 자동으로 1, 2가 배정된 것입니다. 즉, R은 이 벡터의 첫 번째 요소가 earth 이지만 cement가 알파벳 순서 상 앞에 오기 때문에 cement가 1 수준이 되며, 이 1수준인 \"cement\"에 정수값 1을 할당하고, 2 수준인 \"earth\"에는 정수값 2를 배정하게 되는 것입니다. 이렇듯 요인의 데이터는 문자열로 보이지만, 실제로 저장되는 것은 정수형 숫자로 저장이 되는 것입니다. R의 메모리에서 이러한 요인는 정수 (1, 2)로 표시되지만, 요인의 수준값 또한 정수보다 더 많은 정보를 제공하기 때문에 중요합니다. \"cement\"와 \"earth\"가 1과 2 보다 더 많은 것을 설명하기 때문입니다. 어느 것이 “earth”인가 궁금할 때 정수 데이터만으로는 알 수가 없습니다. 따라서 요인에는이 정보도 내장되어 있습니다. "],["요인의-수준.html", "6.4 요인의 수준", " 6.4 요인의 수준 6.4.1 요인 수준의 확인 levels() 함수를 사용하여 요인의 수준을 확인할 수 있으며, nlevels() 함수를 이용하면 수준의 수를 확인할 수 있습니다. levels(floor_type) # floor_type 변수에 있는 수준을 반환합니다. 결과도 문자형 벡터입니다. ## [1] &quot;cement&quot; &quot;earth&quot; &quot;stone&quot; nlevels(floor_type) # floor_type 변수의 수준의 갯수를 반환합니다. ## [1] 3 때로는 요인의 순서가 중요하지 않습니다. 6.4.2 수준의 순서 지정 때로는 요인의 순서가 알파벳이나 가나다 순이 아닌 의미에 따른 순서가 중요할 수 있습니다. 이런 경우 요인들의 수준에 순서를 지정할 수 있습니다. 예를 들어, “낮음,” “중간,” “높음” 등이 수준인 경우 이러한 수준을 지정하지 않으면 R은 자동으로 가나다 순인 “낮음,” “높음,” “중간” 등의 순서로 수준의 순서를 정하게 됩니다. 그러나 이는 분석의 관점에서 보면 옳지 않는 순서입니다. 이러한 수준의 순서는 데이터의 시각화를 향상시키거나 특정 유형의 분석에 필요할 수 있습니다. 여기에서 floor_type 요인에서 수준을 우리가 원하는 순서로 정렬하는 방법은 다음과 같습니다. factor() 함수에 levels = 인수에 우리가 원하는 순서로 문자형 벡터로 지정해 주면 됩니다. floor_type # 현재 수준의 순서가 출력됩니다. ## [1] earth cement cement earth stone ## Levels: cement earth stone # levels = 인수에 문자형 벡터로 순서를 지정해 줍니다. floor_type &lt;- factor(floor_type, levels = c(&quot;earth&quot;, &quot;cement&quot;)) floor_type # 수준의 순서가 바뀌어 반환됩니다. ## [1] earth cement cement earth &lt;NA&gt; ## Levels: earth cement 6.4.3 수준 이름의 변경 수준의 이름을 쉽게 바꿀 수도 있습니다. 예를 들어, 실수를해서 “cement”가 아닌 “brick”으로 다시 코딩해야 한다고 가정해 보겠습니다. 그러면 levels() 함수에서 확인했던 수준의 이름을 이 levels() 함수를 이용하여 수정해 주면 되는 겁니다. 다음의 예에서 확인해 보겠습니다. levels(floor_type) # floor_type 변수의 수준이름이 반환됩니다. ## [1] &quot;earth&quot; &quot;cement&quot; levels(floor_type)[2] &lt;- &quot;brick&quot; # 수준이름의 2번째 값을 &quot;brick&quot;으로 수정합니다. levels(floor_type) # 수정된 수준이름이 반환됩니다. ## [1] &quot;earth&quot; &quot;brick&quot; floor_type # floor_type을 출력해 보면 cement가 모두 brick으로 변경됩니다. ## [1] earth brick brick earth &lt;NA&gt; ## Levels: earth brick 6.4.4 수준의 서열화 지금까지 살펴본 요인은 명목 변수처럼 순서가 지정되지 않았습니다. R은 명목 변수(nominal variable)와 서열 변수(ordinal variable)의 차이를 알지 못합니다. factor() 함수 내에 ordered=TRUE라는 옵션을 사용하여 요인에 서열을 지정할 수 있습니다. 그러면 서열화된 요인을 만들 수 있습니다. 그리고 이 서열화된 요인은 서열 변수가 되는 것입니다. 서열화된 수준은 &lt; 기호에 의해 낮은 순위부터 높은 순위로그 순위를 표시합니다. 그리고 요인이 서열화된 요인인지의 확인은 is.ordered()로 확인할 수 있습니다. floor_type_ordered &lt;- factor(floor_type, ordered=TRUE) floor_type_ordered # 서열이 설정된 요인 ## [1] earth brick brick earth &lt;NA&gt; ## Levels: earth &lt; brick is.ordered(floor_type_ordered) # 서열화된 요인인지 확인합니다. ## [1] TRUE 6.4.5 ordered() 함수를 이용한 서열형 요인 변수의 생성 한편 ordered() 함수로 서열화된 요인을 생성할 수 있습니다. 그리고 요인이 서열화되어 있는지는 is.ordered() 함수로 확인할 수 있습니다. ordered_floor &lt;- ordered(c(&quot;earth&quot;, &quot;cement&quot;, &quot;cement&quot;, &quot;earth&quot;), c(&quot;earth&quot;, &quot;cement&quot;)) ordered_floor ## [1] earth cement cement earth ## Levels: earth &lt; cement is.ordered(ordered_floor) # ordered_floor 변수가 서열화된 요인변수인지 확인합니다 ## [1] TRUE "],["데이터-유형-강제-변환.html", "6.5 데이터 유형 강제 변환", " 6.5 데이터 유형 강제 변환 6.5.1 요인형으로의 변환하기 벡터 변수를 요인형으로 변환하고자 할 경우 as.factor() 함수를 이용하면 됩니다. st_data &lt;- c(&quot;earth&quot;, &quot;cement&quot;, &quot;cement&quot;, &quot;earth&quot;) # st_data는 4개의 문자열 요소를 갖는 문자형 벡터입니다. st_data ## [1] &quot;earth&quot; &quot;cement&quot; &quot;cement&quot; &quot;earth&quot; floor &lt;- as.factor(st_data) # factor() 함수의 사용과 차이가 없습니다. is.factor(floor) # floor가 요인 변수인지 확인합니다 ## [1] TRUE as.factor() 함수는 factor() 함수처럼 levels=나 ordered =인수를 사용할 수 없습니다. 수준의 설정을 위해서는levels() 함수를 이용하고, 서열을 설정하기 위해서는 ordered() 함수를 이용해야 합니다. 6.5.2 요인을 다른 유형으로 강제 변환하기 요인을 문자형 벡터로 변환하려면 as.character(x) 함수를 사용하면 됩니다. as.character(floor_type) ## [1] &quot;earth&quot; &quot;brick&quot; &quot;brick&quot; &quot;earth&quot; NA 수준이 숫자로 표시되는 요인 (예 : 농도 수준 또는 연도)을 숫자 벡터로 변환하는 것은 약간 까다 롭습니다. 이 as.numeric() 함수는 수준이 아닌 요인의 인덱스 값을 반환하므로 완전히 새로운 (이 경우 원하지 않는) 숫자 집합이 생성됩니다. 이를 방지하는 한 가지 방법은 인수를 문자로 변환 한 다음 숫자로 변환하는 것입니다. 또 다른 방법은 levels()기능 을 사용하는 것입니다. 비교: year_fct &lt;- factor(c(1990, 1983, 1977, 1998, 1990)) as.numeric(year_fct) # 요인형 데이터를 바로 숫자형으로 강제변환하면 ## [1] 3 2 1 4 3 # 1990 ~ 1990이 아닌 1 ~ 5 등의 정수값으로 변환이 됩니다. as.numeric(as.character(year_fct)) # 먼저 요인형을 &#39;문자형&#39;으로 변환한 다음에 &#39;숫자형&#39;으로 변환해야 합니다. ## [1] 1990 1983 1977 1998 1990 as.numeric(levels(year_fct))[year_fct] # 가장 추천하는 방법입니다. ## [1] 1990 1983 1977 1998 1990 위에서 as.numeric(as.character(year_fct))과 as.numeric(levels(year_fct))[year_fct]이 같은 결과를 가져옴을 알 수 있습니다. 그렇지만 가능한 한 levels() 함수를 활용하는 후자의 방식을 사용할 것을 권장합니다. 참고로 권장되는 levels()접근 방식에서는 세 가지 중요한 단계가 발생합니다. 모든 요인 수준을 확인합니다 : levels(year_fct) 이 수준을 사용하여 숫자 값으로 변환합니다 : as.numeric(levels(year_fct)) 그런 다음 year_fct대괄호 안에 사용하여 숫자 값을 확인합니다. as.numeric(levels(year_fct))[year_fct] "],["gl-함수를-이용한-요인의-생성.html", "6.6 gl() 함수를 이용한 요인의 생성", " 6.6 gl() 함수를 이용한 요인의 생성 R 언어의 gl() 함수는 수준의 패턴을 지정하여 원하는 요인을 생성하는 데 사용됩니다. gl(x, k, length, labels, ordered) 인수 x : 레벨 수 k : 복제 수 length : 생성된 결과의 길이(요소 갯수) labels : 벡터에 대한 레이블 (선택 사항) ordered : 수준의 서열화 여부 gl() 함수를 이용하여 요인을 생성하는 예를 살펴 보겠습니다. # gl() 함수를 이용한 요인 생성 : x와 k만 지정한 경우 x1 &lt;- gl(2, 5) # 1부터 2까지의 정수를 수준으로 하여 각 요소를 5번씩 복제하여 요인을 생성합니다. x1 ## [1] 1 1 1 1 1 2 2 2 2 2 ## Levels: 1 2 # gl() 함수를 이용한 요인 생성 : 길이를 지정한 경우 x2 &lt;- gl(3, 4, 12) # 1부터 3까지의 정수를 수준으로 하여 각 요소를 4번씩 복제하여 요인을 생성합니다. x2 ## [1] 1 1 1 1 2 2 2 2 3 3 3 3 ## Levels: 1 2 3 # gl() 함수를 이용한 요인 생성 : 길이와 라벨을 지정한 경우 x3 &lt;- gl(3, 4, 12, label = letters[1:12]) # letters[1:3]까지의 값을 각각 4번씩 복제하여 x3 # 12개의 요소로 구성된 요인을 생성합니다. ## [1] a a a a b b b b c c c c ## Levels: a b c d e f g h i j k l levels(x3) # 이때 수준은 letters[1:12]가 됩니다. ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; # gl() 함수를 이용한 요인 생성 : 길이와 라벨과 서열화 여부를 지정한 경우 x4 &lt;- gl(3, 4, 12, label = letters[1:12], ordered = T) # 앞의 x3의 특성에 levels가 서열화되도록 설정합니다. x4 # Levels: a &lt; b &lt; .... &lt; l 로 확인할 수 있습니다. ## [1] a a a a b b b b c c c c ## Levels: a &lt; b &lt; c &lt; d &lt; e &lt; f &lt; g &lt; h &lt; i &lt; j &lt; k &lt; l is.ordered(x4) ## [1] TRUE "],["요인의-서브-세팅.html", "6.7 요인의 서브 세팅", " 6.7 요인의 서브 세팅 자료 : https://www.stat.auckland.ac.nz/~paul/ItDT/HTML/node65.html#SECTION001352000000000000000 요인의 서브세팅은 벡터의 서브세팅가 유사합니다. 그러나 요인을 서브세팅할 때 요인의 수준들은 바뀌지 않습니다. 예를 들어, 예를 들어candy_patterns 변수를 생각해 보겠습니다. candy_patterns &lt;- factor(c(&quot;pattern&quot;, &quot;pattern&quot;, &quot;pattern&quot;, &quot;plain&quot;, &quot;plain&quot;, &quot;plain&quot;, &quot;pattern&quot;, &quot;pattern&quot;, &quot;pattern&quot;, &quot;plain&quot;, &quot;plain&quot;, &quot;plain&quot;)) # 수준을 확인합니다. levels(candy_patterns) # 수준은 &quot;pattern&quot;과 &quot;plain&quot; 두 개입니다. ## [1] &quot;pattern&quot; &quot;plain&quot; # 첫 3개의 값만 서브세팅해 보겠습니다. : 벡터의 서브세팅과 유사합니다. sub_candy &lt;- candy_patterns[1:3] # 첫 3개의 요소를 선택합니다. levels(sub_candy) # sub_candy도 2개의 수준을 가지고 있습니다. ## [1] &quot;pattern&quot; &quot;plain&quot; is.factor(sub_candy) # sub_candy도 요인 클래스입니다. ## [1] TRUE # 서브세팅할 때 사용하지 않는 수준을 제거합니다. (drop = TRUE 옵션 사용) sub_candy &lt;- candy_patterns[1:3, drop = TRUE] # 서브세팅 이후에 사용되지 않는 수준은 제거해 줍니다. levels(sub_candy) # sub_candy의 수준이 &quot;pattern&quot; 한 개입니다. ## [1] &quot;pattern&quot; # 서브세팅한 요인에 &quot;plain&quot; 값을 삽입해 보겠습니다. sub_candy[4] &lt;- &quot;plain&quot; # sub_candy의 네 번째 요소로 plain을 삽입합니다. ## Warning in `[&lt;-.factor`(`*tmp*`, 4, value = &quot;plain&quot;): invalid factor level, NA ## generated # 앞에서 설명했듯이 경고메시지를 반환하고, NA값이 입력됩니다. sub_candy[4] # NA가 입력되어 있습니다. ## [1] &lt;NA&gt; ## Levels: pattern "],["요인의-발생빈도-계산.html", "6.8 요인의 발생빈도 계산", " 6.8 요인의 발생빈도 계산 요인 개체는 범주형 변수로서 요인 개체의 연산은 주로 요인의 수준별 발생 빈도와 관련한 연산을 하게 됩니다. 이와 관련된 함수가 table()함수와 proportions() 함수입니다. table() 함수는 교차 분류 요인(cross-classifying factor)을 사용하여 요인 수준의 각 조합8에 대한 발생 빈도표 즉 도수분포표(frequency table)를 반환합니다. proportions() 함수(또는 prop.tables() 함수)는table()함수를 데이터 인수로 하여 상대도수분포표를 반환합니다. candy_patterns &lt;- factor(c(&quot;pattern&quot;, &quot;pattern&quot;, &quot;pattern&quot;, &quot;plain&quot;, &quot;plain&quot;, &quot;plain&quot;, &quot;pattern&quot;, &quot;pattern&quot;, &quot;pattern&quot;, &quot;plain&quot;, &quot;plain&quot;, &quot;plain&quot;)) # 요인의 수준별 도수분포표와 상대도수분포표를 구합니다. table(candy_patterns) # candy_patterns 개체의 수준별 빈도수를 계산하여 ## candy_patterns ## pattern plain ## 6 6 # 각 수준별 발생 빈도를 보여주는 &quot;도수분포표&quot;를 반환합니다. proportions(table(candy_patterns)) # &#39;도수 분포표&#39;의 &quot;상대 도수분포표&quot;를 반환합니다. ## candy_patterns ## pattern plain ## 0.5 0.5 참고로table() 함수는 벡터에도 적용할 수 있습니다. 제2주 제7장의 데이터 프레임에서 좀 더 상세히 학습하겠습니다. "],["요인-변수의-할용-예.html", "6.9 요인 변수의 할용 예", " 6.9 요인 변수의 할용 예 데이터가 요인으로 저장되면 plot()함수를 사용하여 각 요인 수준으로 표시되는 관측치 수를 한 눈에 볼 수 있습니다. memb_assoc데이터 프레임에서 열을 추출하여 요인으로 변환 한 다음 관개 협회의 회원이거나 아니었던 인터뷰 응답자의 수를 살펴 보겠습니다. # 패키지 불러오기 # install.packages(&quot;tidyverse&quot;) library(tidyverse) # 데이터 불러오기 interviews &lt;- read_csv(&quot;data/SAFI_clean.csv&quot;, na = &quot;NULL&quot;) ## ## -- Column specification -------------------------------------------------------- ## cols( ## key_ID = col_double(), ## village = col_character(), ## interview_date = col_datetime(format = &quot;&quot;), ## no_membrs = col_double(), ## years_liv = col_double(), ## respondent_wall_type = col_character(), ## rooms = col_double(), ## memb_assoc = col_character(), ## affect_conflicts = col_character(), ## liv_count = col_double(), ## items_owned = col_character(), ## no_meals = col_double(), ## months_lack_food = col_character(), ## instanceID = col_character() ## ) ## interview 데이터 프레임의 memb_assoc 컬럼을 벡터로 만들기 memb_assoc &lt;- interviews$memb_assoc ## 벡터를 요인으로 강제 변환합니다 : as.factor() 함수 이용 memb_assoc &lt;- as.factor(memb_assoc) ## 요인 확인하기 memb_assoc ## [1] &lt;NA&gt; yes &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; no yes no no &lt;NA&gt; yes no &lt;NA&gt; yes ## [16] &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; no &lt;NA&gt; &lt;NA&gt; no no no &lt;NA&gt; no yes &lt;NA&gt; ## [31] &lt;NA&gt; yes no yes yes yes &lt;NA&gt; yes &lt;NA&gt; yes &lt;NA&gt; no no &lt;NA&gt; no ## [46] no yes &lt;NA&gt; &lt;NA&gt; yes &lt;NA&gt; no yes no &lt;NA&gt; yes no no &lt;NA&gt; no ## [61] yes &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; no yes no no no no yes &lt;NA&gt; no yes &lt;NA&gt; ## [76] &lt;NA&gt; yes no no yes no no yes no yes no no &lt;NA&gt; yes yes ## [91] yes yes yes no no no no yes no no yes yes no &lt;NA&gt; no ## [106] no &lt;NA&gt; no no &lt;NA&gt; no &lt;NA&gt; &lt;NA&gt; no no no no yes no no ## [121] no no no no no no no no no yes &lt;NA&gt; ## Levels: no yes ## 협회 회원 여부에 따른 응답자 수 막대 그래프 plot(memb_assoc) 벡터의 출력과 비교 한 플롯을 보면 “No”및 “Yes”외에도 협회의 회원인지 여부에 대한 정보가 없는 NA값을 갖는 일부 응답자가 있음을 알 수 있습니다. 이는 누락된 데이터 즉 결측치입니다. 이러한 결측치는 플롯에 나타나지 않습니다. 플롯에서 이러한 결측치를 처리하여 시각화에 반영할 수 있도록 다르게 코딩해 보겠습니다. ## interview 데이터 프레임의 memb_assoc 컬럼을 벡터로 만들기 memb_assoc &lt;- interviews$memb_assoc ## 결측치를 &quot;undetermined&quot;로 대체합니다. memb_assoc[is.na(memb_assoc)] &lt;- &quot;undetermined&quot; # is.na() 함수를 사용합니다. ## 벡터를 요인으로 변환시킵니다. : as.factor() 함수 이용. 수준도 순서를 정해줍니다. memb_assoc &lt;- as.factor(memb_assoc) ## 다시 요인의 값들을 확인합니다. memb_assoc # NA가 모두 undertermined로 변경되었습니다. ## [1] undetermined yes undetermined undetermined undetermined ## [6] undetermined no yes no no ## [11] undetermined yes no undetermined yes ## [16] undetermined undetermined undetermined undetermined undetermined ## [21] no undetermined undetermined no no ## [26] no undetermined no yes undetermined ## [31] undetermined yes no yes yes ## [36] yes undetermined yes undetermined yes ## [41] undetermined no no undetermined no ## [46] no yes undetermined undetermined yes ## [51] undetermined no yes no undetermined ## [56] yes no no undetermined no ## [61] yes undetermined undetermined undetermined no ## [66] yes no no no no ## [71] yes undetermined no yes undetermined ## [76] undetermined yes no no yes ## [81] no no yes no yes ## [86] no no undetermined yes yes ## [91] yes yes yes no no ## [96] no no yes no no ## [101] yes yes no undetermined no ## [106] no undetermined no no undetermined ## [111] no undetermined undetermined no no ## [116] no no yes no no ## [121] no no no no no ## [126] no no no no yes ## [131] undetermined ## Levels: no undetermined yes ## 막대 그래프를 다시 그려 봅니다. plot(memb_assoc) 막대 그래프를 보면 x 축이 벡터의 수준이고, y 축이 수준별 응답자 수임을 알 수 있습니다. 이제 x 축에 나타난 수준 값의 첫 글자를 모두 대문자로 바꾸고, 그 순서도 “Yes,” “No,” “Undetermined”의 순서로 출력하면 훨씬 막대 그래프가 보기 좋을 것 같습니다. 수준의 첫 글자를 대문자로 변환시키기 위해 stringr 패키지의 str_to_title() 함수를 사용하면 됩니다. : str_to_title(levels()) 수준의 순서를 바꾸기 위해서는 factor() 함수를 이용하여 levels = 인수에 순서대로 문자형 벡터로 지정합니다 : factor( , levels = c()) 이 내용들을 반영해서 코딩을 다시 해 보겠습니다. ## 패키지 불러오기 : stringr 패키지는 tidyverse 패키지에 포함되어 있습니다. ## interview 데이터 프레임의 memb_assoc 컬럼을 벡터로 만들기 memb_assoc &lt;- interviews$memb_assoc ## 결측치를 &quot;undetermined&quot;로 대체합니다. memb_assoc[is.na(memb_assoc)] &lt;- &quot;undetermined&quot; # is.na() 함수를 사용합니다. ## 벡터를 요인으로 변환시킵니다. : as.factor() 함수 이용. 수준도 순서를 정해줍니다. memb_assoc &lt;- factor(memb_assoc, levels = c(&quot;yes&quot;, &quot;no&quot;, &quot;undetermined&quot;)) levels(memb_assoc) &lt;- str_to_title(levels(memb_assoc)) # 수준의 첫글자를 대문자로 바꿔 줍니다. ## 다시 요인의 값들을 확인합니다. memb_assoc # 요인의 수준과 순서가 변경되었습니다. ## [1] Undetermined Yes Undetermined Undetermined Undetermined ## [6] Undetermined No Yes No No ## [11] Undetermined Yes No Undetermined Yes ## [16] Undetermined Undetermined Undetermined Undetermined Undetermined ## [21] No Undetermined Undetermined No No ## [26] No Undetermined No Yes Undetermined ## [31] Undetermined Yes No Yes Yes ## [36] Yes Undetermined Yes Undetermined Yes ## [41] Undetermined No No Undetermined No ## [46] No Yes Undetermined Undetermined Yes ## [51] Undetermined No Yes No Undetermined ## [56] Yes No No Undetermined No ## [61] Yes Undetermined Undetermined Undetermined No ## [66] Yes No No No No ## [71] Yes Undetermined No Yes Undetermined ## [76] Undetermined Yes No No Yes ## [81] No No Yes No Yes ## [86] No No Undetermined Yes Yes ## [91] Yes Yes Yes No No ## [96] No No Yes No No ## [101] Yes Yes No Undetermined No ## [106] No Undetermined No No Undetermined ## [111] No Undetermined Undetermined No No ## [116] No No Yes No No ## [121] No No No No No ## [126] No No No No Yes ## [131] Undetermined ## Levels: Yes No Undetermined ## 막대 그래프를 다시 그려 봅니다. plot(memb_assoc) "],["행렬matrix.html", "Chapter 7 행렬(matrix)", " Chapter 7 행렬(matrix) 이 장에서는 R에서 행렬로 작업하는 방법을 학습하겠습니다. 행렬을 만들고 수정하고 행렬 요소에 액세스하는 방법을 살펴 보겠습니다. 행렬은 R 프로그래밍에서 2 차원 데이터 구조입니다. 행렬은 벡터와 유사하지만 차원 속성을 추가로 포함합니다. 객체의 모든 속성은 attributes() 함수로 확인할 수 있습니다. 차원(dimension)은 dim() 함수로 직접 확인할 수 있습니다. class() 함수로 변수가 행렬인지 아닌지 확인할 수 있습니다. "],["행렬-만들기-matrix-함수이용.html", "7.1 행렬 만들기 : matrix() 함수이용", " 7.1 행렬 만들기 : matrix() 함수이용 matrix() 함수를 사용하여 행렬(matrix)을 만들 수 있습니다. 행렬의 차원은 nrow와 ncol 인수에 적절한 값을 전달하여 정의할 수 있습니다. 두 차원 모두에 대한 값을 제공할 필요는 없습니다. 차원 중 하나가 제공되면 다른 차원은 데이터 길이에서 유추가 되어 처리됩니다. matrix() 함수의 형식은 다음과 같습니다. matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) data : 데이터 nrow : 행의 차원(갯수) ncol: 열의 차원(갯수) byrow : 행 우선 여부 (기본값은 FASLE, 즉 열 우선) dimnames : 행과 열의 이름 7.1.1 행렬 만들기 행렬을 생성하는 예를 들어 보겠습니다. x1 &lt;- matrix(c(4, 2, 3, 5, 4, 7), nrow = 2) # 6개의 요소를 갖는 벡터를 2차원 행렬로 생성합니다. 행은 2입니다. x1 # 열 우선(첫 번째 열부터 행을 채워감)으로 요소가 채워집니다. ## [,1] [,2] [,3] ## [1,] 4 3 4 ## [2,] 2 5 7 x2 &lt;- matrix(c(4, 2, 3, 5, 4, 7), ncol = 2) # 열의 차원을 2로 정하고 있습니다. 행의 차원은 3으로 유추됩니다. x2 # 열 우선으로 요소가 채워집니다. ## [,1] [,2] ## [1,] 4 5 ## [2,] 2 4 ## [3,] 3 7 7.1.2 행 우선으로 채우기 행렬이 열 우선으로 채워진 것을 볼 수 있습니다. byrow 인수에 TRUE값을 전달하여 행 우선 채우기로 되돌릴 수 있습니다. x3 &lt;- matrix(c(4, 2, 3, 5, 4, 7), nrow = 2, byrow = TRUE) # 행 우선으로 요소가 채워집니다 x3 ## [,1] [,2] [,3] ## [1,] 4 2 3 ## [2,] 5 4 7 x4 &lt;- matrix(c(4, 2, 3, 5, 4, 7), ncol = 2, byrow = TRUE) # 열 우선으로 요소가 채워집니다. x4 ## [,1] [,2] ## [1,] 4 2 ## [2,] 3 5 ## [3,] 4 7 그러나 모든 경우에 행렬은 이후 절에서도 볼 수 있듯이 내부적으로 열 우선 순서로 저장됩니다. 7.1.3 차원에 이름 붙이기 한편 2개의 요소(행의 이름과 열의 이름 각각의 문자형 벡터)를 갖는 리스트를 인수 dimnames에 전달하여 행렬을 생성하면서 행렬의 행과 열에 이름을 지정할 수 있습니다. data &lt;- c(4, 2, 3, 5, 4, 7) # 행렬을 이루는 요소들의 1차원 벡터입니다. mat.names &lt;- list(c(&quot;row1&quot;, &quot;row2&quot;), # 첫번째 요소는 행의 이름을 나타내는 문자형 벡터입니다. c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;)) # 두번째 요소는 열의 이름을 나타내는 문자형 벡터입니다. x5 &lt;- matrix(data, nrow = 2, dimnames = mat.names) # dimnames의 인수로 리스트를 할당합니다. x5 ## col1 col2 col3 ## row1 4 3 4 ## row2 2 5 7 "],["벡터-결합에-의한-행렬-만들기.html", "7.2 벡터 결합에 의한 행렬 만들기", " 7.2 벡터 결합에 의한 행렬 만들기 행렬을 만드는 또 다른 방법은 열 결합과 행 결합에서와 같이 cbind() 함수와 rbind() 함수를 사용하는 것입니다. # 3개의 벡터입니다. v1 &lt;- c(1, 2, 3, 4) v2 &lt;- c(5, 6, 7, 8) v3 &lt;- c(9, 10, 11, 12) # cbind() 함수와 rbind() 함수를 이용하면 행렬을 생성합니다. x6 &lt;- rbind(v1, v2, v3) # v1, v2, v3가 행렬의 행을 구성합니다. x6 # 각 행의 이름은 벡터의 이름이 할당됩니다. ## [,1] [,2] [,3] [,4] ## v1 1 2 3 4 ## v2 5 6 7 8 ## v3 9 10 11 12 x7 &lt;- cbind(v1, v2, v3) # v1, v2, v3가 행렬의 열을 구성합니다. x7 # 각 열의 이름은 벡터의 이름이 할당됩니다. ## v1 v2 v3 ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 "],["행렬의-차원-확인.html", "7.3 행렬의 차원 확인", " 7.3 행렬의 차원 확인 dim() 함수로 생성되어 있는 행렬 변수의 차원을 확인할 수 있습니다. 또한 nrow() 함수와 ncol() 함수를 이용하여 행과 열의 갯수를 확인할 수 있습니다. dim(x1) # 행렬 x1의 행과 열의 갯수를 동시에 반환합니다. ## [1] 2 3 dim(x1)[1] # 행렬 x1의 행의 갯수를 반환합니다. ## [1] 2 dim(x1)[2] # 행렬 x1의 열의 갯수를 반환합니다. ## [1] 3 nrow(x1) # 행렬 x1의 행의 갯수를 반환합니다. ## [1] 2 ncol(x1) # 행렬 x1의 열의 갯수를 반환합니다. ## [1] 3 7.3.1 행렬의 생성 dim() 함수에 행렬의 차원을 인수로 설정함으로써 벡터를 행렬로 만들 수도 있습니다. data &lt;- c(4, 2, 3, 5, 4, 7) dim(data) &lt;- c(2, 3) # data를 2행 3열의 행렬로 변환합니다. data # 열 우선순으로 요소가 채워집니다. ## [,1] [,2] [,3] ## [1,] 4 3 4 ## [2,] 2 5 7 "],["차원의-이름-수정하기.html", "7.4 차원의 이름 수정하기", " 7.4 차원의 이름 수정하기 이 행과 열의 이름은 두 개의 유용한 함수 colnames() 와 rownames()를 사용하여 액세스하거나 변경할 수 있습니다. rownames(x5) # x5 변수의 행의 이름을 반환합니다. ## [1] &quot;row1&quot; &quot;row2&quot; colnames(x5) # x5 변수의 열의 이름을 반환합니다. ## [1] &quot;col1&quot; &quot;col2&quot; &quot;col3&quot; rownames(x5) &lt;- c(&quot;1행&quot;, &quot;2행&quot;) # x5 변수의 행의 이름을 변경합니다. colnames(x5) &lt;- c(&quot;1열&quot;, &quot;2열&quot;, &quot;3열&quot;) # x5 변수의 열의 이름을 변경합니다. "],["행렬-요소에-접근하기.html", "7.5 행렬 요소에 접근하기", " 7.5 행렬 요소에 접근하기 7.5.1 행과 열의 인덱싱에 의한 접근 대괄호 [ 인덱싱 방법을 사용하여 행렬의 요소에 액세스할 수 있습니다. 요소는var[row, column]으로 액세스 할 수 있습니다. 여기서row와 col은 벡터입니다. 이 때, 벡터 요소의 접근과 마찬가지로 row와 col을 각각 정수형 벡터, 문자형 벡터 그리고 논리형 벡터로 지정할 수도 있으며, 동시에 지정할 수도 있습니다. 마이너스 기호(-)를 사용하여 해당하는 행이나 열을 제외시킬 수도 있습니다. row나 col 중 비어있으면 모든 것을 선택합니다. var[ 1, ]은 행렬 var의 1행, 전체 열을 선택하는 것이 됩니다. 다음의 예에서 살펴보도록 하겠습니다. # 행렬 mat를 생성합니다. mat &lt;- rbind(c(1, 5, 3, 6), c(3, 6, 4, 8), c(2, 4, 8, 7)) mat ## [,1] [,2] [,3] [,4] ## [1,] 1 5 3 6 ## [2,] 3 6 4 8 ## [3,] 2 4 8 7 # 행과 열에 이름을 붙입니다. rownames(mat) &lt;- c(&quot;row.1&quot;, &quot;row.2&quot;, &quot;row.3&quot;) colnames(mat) &lt;- c(&quot;col.1&quot;, &quot;col.2&quot;, &quot;col.3&quot;, &quot;col.4&quot;) mat ## col.1 col.2 col.3 col.4 ## row.1 1 5 3 6 ## row.2 3 6 4 8 ## row.3 2 4 8 7 ## row와 col을 정수형 벡터로 색인합니다. mat[c(1,2),c(2,3)] # 1 &amp; 2행과 2 &amp; 3열이 교차하는 요소를 출력합니다. ## col.2 col.3 ## row.1 5 3 ## row.2 6 4 mat[c(3,2), ] # 3행과 2열의 순서로 전체 열의 요소를 출력합니다. ## col.1 col.2 col.3 col.4 ## row.3 2 4 8 7 ## row.2 3 6 4 8 mat[,] # mat와 같습니다. ## col.1 col.2 col.3 col.4 ## row.1 1 5 3 6 ## row.2 3 6 4 8 ## row.3 2 4 8 7 mat[-1,] # 1행을 제외한 요소를 출력합니다. ## col.1 col.2 col.3 col.4 ## row.2 3 6 4 8 ## row.3 2 4 8 7 ## row와 col을 문자형 벡터로 색인합니다. (행과 열에 이름이 붙여진 경우) mat[c(&quot;row.1&quot;, &quot;row.2&quot;), c(&quot;col.2&quot;, &quot;col.3&quot;)] ## col.2 col.3 ## row.1 5 3 ## row.2 6 4 mat[c(&quot;row.3&quot;, &quot;row.2&quot;), ] ## col.1 col.2 col.3 col.4 ## row.3 2 4 8 7 ## row.2 3 6 4 8 mat[-&quot;row.1&quot;, ] # 문자형 벡터에서 - 기호는 Error를 유발합니다. ## Error in -&quot;row.1&quot;: 단항연산자에 유효한 인자가 아닙니다 ## row와 col을 논리형 벡터로 색인합니다. mat[c(T, T, F), c(F, T, T, F)] ## col.2 col.3 ## row.1 5 3 ## row.2 6 4 mat[c(F, T, T), c(F, T, T)] # row의 c(&quot;row.3&quot;, &quot;row.2&quot;)와 같이 위치를 바꿀 수는 없습니다. ## col.2 col.3 ## row.2 6 4 ## row.3 4 8 mat[c(T, T, T), c(T, T, T, T)] ## col.1 col.2 col.3 col.4 ## row.1 1 5 3 6 ## row.2 3 6 4 8 ## row.3 2 4 8 7 mat[c(F, T, T), ] ## col.1 col.2 col.3 col.4 ## row.2 3 6 4 8 ## row.3 2 4 8 7 여기서 주목해야 할 점은 인덱싱 후 반환된 행렬이 단일 행 행렬 또는 단일 열 행렬이면 결과가 벡터로 제공된다는 것입니다. 이를 벡터 형태가 아닌 행렬 형태로 출력하고 싶으면 [ ] 안에 drop = FALSE 인수를 입력해 줍니다. mat[1,] # 1행으로 된 단일 행렬이라 &quot;벡터 형태&quot;로 출력합니다. ## col.1 col.2 col.3 col.4 ## 1 5 3 6 mat[1, drop=FALSE] # 1행으로 된 &quot;단일 행렬 형태&quot;로 출력합니다. ## [1] 1 7.5.2 벡터 형태의 접근 한편 행렬을 마치 하나의 벡터처럼 인덱싱할 수도 있습니다. 이 경우 행렬은 열 단위로 요소들을 결합하여 형성된 벡터와 같아 집니다. mat # 행렬의 요소 값들을 확인합니다. ## col.1 col.2 col.3 col.4 ## row.1 1 5 3 6 ## row.2 3 6 4 8 ## row.3 2 4 8 7 mat[1:4] # 단일 벡터의 요소를 접근하듯이 인덱싱을 했습니다. ## [1] 1 3 2 5 mat[c(2, 5, 8)] # 결과를 확인해 보기 바랍니다. 2번째, 5번째, 8번째 요소가 무엇일까요? ## [1] 3 6 4 mat[c(TRUE, FALSE)] # 이 경우 논리형 벡터로 인덱싱을 했습니다. 그러면 2개의 요소가 자동반복됩니다. ## [1] 1 2 6 3 8 8 즉 위의 mat 행렬은 (1 3 2 5 6 4 3 4 8 6 8 7)와 같이 열 우선으로 결합된 벡터와 같이 작동하는 것을 알 수 있습니다. 7.5.3 행과 열에 조건식을 입력하여 접근하기 다음과 같이 row와 col에 행렬의 요소에 대한 필터링 조건을 입력하여 접근할 수도 있습니다. mat[mat &gt; 5] # 행렬의 요소 값이 5보다 큰 요소만 출력합니다. ## [1] 6 8 6 8 7 mat[mat %% 2 == 0] # 행렬의 요소 값이 짝수인 요소만 출력합니다. ## [1] 2 6 4 4 8 6 8 mat[mat[, &quot;col.2&quot;] &gt; 5, ] ## col.2 열의 값이 5보다 큰 행만 출력합니다. ## col.1 col.2 col.3 col.4 ## 3 6 4 8 특히 mat[, \"col.2\"] &gt; 5 식은 mat 의 col.2 요소의 값이 5보다 큰지를 테스트합니다. 이 결과는 (FALSE TRUE TRUE)가 됩니다. 즉, col.2 의 첫 번째 요소는 5보다 크지 않으며, 2 번째와 3 번째 요소는 5보다 큰 것을 알 수 있습니다. 이제 이 결과를 mat[c(F, T, T), ]와 같이 행의 접근을 위한 논리형 벡터로 입력해 주면 우리가 원하는 결과가 출력이 되는 것입니다. mat[ , “col.2”] &gt; 5 : col.2 열의 요소들을 5보다 큰지 비교합니다. 1번째 (행) 요소와 2번째 (행) 요소가 해당됩니다. mat[mat[, \"col.2\"] &gt; 5 , ] 식은 결국 mat[c(1, 2), ] 또는 mat[c(T, T, F), ]와 같은 식이 됩니다. "],["행렬의-수정.html", "7.6 행렬의 수정", " 7.6 행렬의 수정 7.6.1 행렬의 수정 위에서 행렬에 대한 접근방법을 할당 연산자와 결합하면 행렬을 수정할 수 있다. mat ## col.1 col.2 col.3 col.4 ## row.1 1 5 3 6 ## row.2 3 6 4 8 ## row.3 2 4 8 7 mat[2,2] &lt;- 10; mat # 2행 2열의 단일 요소 값을 수정합니다. ## col.1 col.2 col.3 col.4 ## row.1 1 5 3 6 ## row.2 3 10 4 8 ## row.3 2 4 8 7 mat[mat &lt; 5] &lt;- 0; mat # 5보다 작은 요소의 값은 모두 0으로 수정합니다. ## col.1 col.2 col.3 col.4 ## row.1 0 5 0 6 ## row.2 0 10 0 8 ## row.3 0 0 8 7 7.6.2 행과 열의 추가 rbind()와cbind()함수를 사용하여 행이나 열을 각각 추가 할 수 있습니다. mat ## col.1 col.2 col.3 col.4 ## row.1 0 5 0 6 ## row.2 0 10 0 8 ## row.3 0 0 8 7 # cbind() 함수를 이용하여 열 벡터를 추가합니다. mat &lt;- cbind(mat, c(7, 6, 7)) # mat 행렬에 (7 6 7) 컬럼을 추가합니다 mat ## col.1 col.2 col.3 col.4 ## row.1 0 5 0 6 7 ## row.2 0 10 0 8 6 ## row.3 0 0 8 7 7 # rbind() 함수를 이용하여 행 벡터를 추가합니다. mat &lt;- rbind(mat, c(1,2,3)) # c(1, 2, 3)과 같이 요소 수가 적은 경우 ## Warning in rbind(mat, c(1, 2, 3)): number of columns of result is not a multiple ## of vector length (arg 2) mat # 경고메시지가 나타나며, 자동반복으로 채워집니다. ## col.1 col.2 col.3 col.4 ## row.1 0 5 0 6 7 ## row.2 0 10 0 8 6 ## row.3 0 0 8 7 7 ## 1 2 3 1 2 7.6.3 행렬의 서브세팅 앞에서 학습한 행렬 요소의 접근 방법으로 접근한 요소들을 새로운 변수에 할당연산자로 할당하여 행렬을 서브 세팅할 수 있습니다. # 행렬 mat를 생성합니다. mat &lt;- rbind(c(1, 5, 3, 6), c(3, 6, 4, 8), c(2, 4, 8, 7)) mat ## [,1] [,2] [,3] [,4] ## [1,] 1 5 3 6 ## [2,] 3 6 4 8 ## [3,] 2 4 8 7 # 행과 열에 이름을 붙입니다. rownames(mat) &lt;- c(&quot;row.1&quot;, &quot;row.2&quot;, &quot;row.3&quot;) colnames(mat) &lt;- c(&quot;col.1&quot;, &quot;col.2&quot;, &quot;col.3&quot;, &quot;col.4&quot;) mat ## col.1 col.2 col.3 col.4 ## row.1 1 5 3 6 ## row.2 3 6 4 8 ## row.3 2 4 8 7 ## row와 col을 정수형 벡터로 색인합니다. mat1 &lt;- mat[c(1,2),c(2,3)] # 1 &amp; 2행과 2 &amp; 3열이 교차하는 요소를 서브세팅하여 mat1에 할당합니다. mat2 &lt;- mat[c(3,2), ] # 3행과 2열의 순서로 전체 열의 요소를 서브세팅하여 mat2로 할당합니다. mat3 &lt;- mat[-1,] # 1행을 제외한 요소를 서브세팅하여 mat3에 할당합니다. "],["행렬의-연산-함수.html", "7.7 행렬의 연산 함수", " 7.7 행렬의 연산 함수 7.7.1 행렬의 연산 행렬 x와y가 다음과 같이 있을 때 일반적인 산술연산자의 경우는 행렬의 요소별로 연산이 이루어 집니다. # 두 개의 예제 행렬을 만듭니다. 두 행렬의 행과 열의 갯수가 같습니다 x &lt;- matrix(c(1:6), ncol = 3); x ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 y &lt;- matrix(c(1, -1, 2, 3, 2, -1), ncol = 3); y ## [,1] [,2] [,3] ## [1,] 1 2 2 ## [2,] -1 3 -1 # 산술연산자를 이용한 연산의 경우 요소별로 연산이 됩니다. x + y ## [,1] [,2] [,3] ## [1,] 2 5 7 ## [2,] 1 7 5 x - y ## [,1] [,2] [,3] ## [1,] 0 1 3 ## [2,] 3 1 7 x * y ## [,1] [,2] [,3] ## [1,] 1 6 10 ## [2,] -2 12 -6 x / y ## [,1] [,2] [,3] ## [1,] 1 1.500000 2.5 ## [2,] -2 1.333333 -6.0 x %% y ## [,1] [,2] [,3] ## [1,] 0 1 1 ## [2,] 0 1 0 x %/% y ## [,1] [,2] [,3] ## [1,] 1 1 2 ## [2,] -2 1 -6 # sum(), mean() 함수 등 sum(x) # 모든 요소의 합을 반환합니다. ## [1] 21 mean(x) # 모든 요소의 평균을 반환합니다. ## [1] 3.5 rowSums(x) # 행별로 합계를 반환합니다. ## [1] 9 12 colSums(x) # 열별로 합계를 반환합니다. ## [1] 3 7 11 apply(x, 1, sum) # 행별로 합계를 반환합니다. ## [1] 9 12 apply(x, 2, sum) # 열별로 합계를 반환합니다. ## [1] 3 7 11 proportions(x) # 각 요소의 비율을 반한홥니다. ## [,1] [,2] [,3] ## [1,] 0.04761905 0.1428571 0.2380952 ## [2,] 0.09523810 0.1904762 0.2857143 위에서 apply() 함수의 사용에 대하여 간단히 살펴보겠습니다. apply(x, MARGIN, FUN, …) 인수 : x : 함수를 적용할 행렬을 포함한 배열 데이터입니다. MARGIN = : 1이면 행단위, 2이면 열단위로 FUN을 적용합니다. FUN : 적용할 함수 (sum, mena, sd, median, … 사용자 정의 함수도 가능) apply() 함수의 사용에 대한 간단한 예를 살펴 보겠습니다. x &lt;- matrix(c(2,4,6,8,10,12), nrow = 2) # MARGIN = 1 : 행단위의 연산을 합니다. apply(x, MARGIN = 1, FUN = sum) # 행렬 x를 행 단위로(MARTGIN = 1) 합계(sum)를 반환합니다. ## [1] 18 24 apply(x, 1, mean) # MARGIN =와 FUN = 는 생략가능합니다. 행 단위의 평균을 반환합니다. ## [1] 6 8 apply(x, 1, sd) # 행 단위의 표준편차를 반환합니다. ## [1] 4 4 # MARGIN = 2 : 열단위의 연산을 합니다. apply(x, MARGIN = 2, FUN = sum) ## [1] 6 14 22 apply(x, 2, mean) ## [1] 3 7 11 apply(x, 2, sd) ## [1] 1.414214 1.414214 1.414214 7.7.2 행렬 곱하기 행렬 X와 행렬 Y가 있고, 행렬 X의 열의 갯수와 행렬 Y의 행의 갯수가 같을 때 행렬 X와 행렬 Y를 곱할 수 있습니다. 이를 행렬 X와 행렬 Y의 곱하기라고 %*% 연산자를 이용하여 구합니다. a &lt;- matrix(c(2, 1, 0, 1, 2, 1, 0, 1, 2), ncol = 3); a ## [,1] [,2] [,3] ## [1,] 2 1 0 ## [2,] 1 2 1 ## [3,] 0 1 2 p &lt;- matrix(c(1, 0, 0, 0, 0, 1, 0, 1, 0), ncol = 3); p ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 0 1 ## [3,] 0 1 0 p %*% a # p의 열의 갯수와 a의 행의 갯수가 같아야 함. ## [,1] [,2] [,3] ## [1,] 2 1 0 ## [2,] 0 1 2 ## [3,] 1 2 1 7.7.3 전치행렬 구하기 행렬의 일반적인 연산은 행과 열의 위치를 바꾸는 것입니다. 이렇게 A 행렬에 대해 행과 열이 바뀐 행렬 B가 있다면 B행렬을 A행렬의 전치행렬(transpose matrix) 이라고 합니다. 전치행렬을 t() 함수를 이용하여 구합니다. mat ## col.1 col.2 col.3 col.4 ## row.1 1 5 3 6 ## row.2 3 6 4 8 ## row.3 2 4 8 7 t.mat &lt;- t(mat); t.mat # t.mat을 mat의 전치행렬이라고 합니다. ## row.1 row.2 row.3 ## col.1 1 3 2 ## col.2 5 6 4 ## col.3 3 4 8 ## col.4 6 8 7 z &lt;- t(x)%*%y ; z ## [,1] [,2] [,3] ## [1,] -2 16 0 ## [2,] -2 36 4 ## [3,] -2 56 8 7.7.4 역행렬 A가n×n 행렬일 때, 아래를 만족하는 n×n 행렬 B가 존재하면, B를 A의 역행렬(inverse matrix)이라고 하고, \\[ A^{-1} \\] 로 표시함. \\[ A \\star\\% B = B \\star A = I -&gt; (Identity matrix) \\] 이러한 역행렬은 solve() 함수로 구합니다. a &lt;- matrix(c(1, 2, 3, 3, 0, 1, 5, 4, 2), ncol = 3); a ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 0 4 ## [3,] 3 1 2 solve(a) ## [,1] [,2] [,3] ## [1,] -0.13333333 -0.03333333 0.4 ## [2,] 0.26666667 -0.43333333 0.2 ## [3,] 0.06666667 0.26666667 -0.2 7.7.5 행렬식(determinant) 행렬식(determinant)은 딱히 정의(definition)가 없습니다. 그냥 어떤 특별한 계산식에 따라 행렬의 원소들을 대입하여 얻은 결과값(수치)을 지칭합니다 (즉, 행렬에 대해 계산되는 하나의 숫자값이다). 다만 그 결과값이 그 행렬의 특성을 결정짓는 중요한 값이기에 determinant라 부릅니다. 행렬식(determinant)은 또한 역행렬과 마찬가지로 정방행렬(행과 열의 개수가 같은 행렬)에 대해서만 정의된다..9 이러한 행렬의 행렬식은 det() 함수를 이용하여 구할 수 있습니다. a &lt;- matrix(c(1,2,3,4,5,6,7,8,9), c(3,3)) det(a) ## [1] 0 b &lt;- matrix(c(0,1,2,3,4,5,6,7,9), c(3,3)) det(b) ## [1] -3 7.7.6 대각행렬 만들기 행렬의 (주)대각선 요소를 제외한 나머지 요소가 모두 0인 행렬을 대각행렬(diagonal matrix)이라고 합니다. 이러한 대각행렬은 diag() 함수를 이용하여 만들 수 있습니다. i.mat &lt;- diag(1, 5) # 주대각선이 모두 1인 행렬을 항등행렬(Identity Matrix)이라고 합니다. i.mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0 0 0 0 ## [2,] 0 1 0 0 0 ## [3,] 0 0 1 0 0 ## [4,] 0 0 0 1 0 ## [5,] 0 0 0 0 1 dia.mat1 &lt;- diag(5) # diag(1, 5)와 같습니다. dia.mat1 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0 0 0 0 ## [2,] 0 1 0 0 0 ## [3,] 0 0 1 0 0 ## [4,] 0 0 0 1 0 ## [5,] 0 0 0 0 1 dia.mat2 &lt;- diag(1:10) # 주대각선의 요소가 1:10인 대각행렬을 만듭니다. dia.mat2 ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 0 0 0 0 0 0 0 0 0 ## [2,] 0 2 0 0 0 0 0 0 0 0 ## [3,] 0 0 3 0 0 0 0 0 0 0 ## [4,] 0 0 0 4 0 0 0 0 0 0 ## [5,] 0 0 0 0 5 0 0 0 0 0 ## [6,] 0 0 0 0 0 6 0 0 0 0 ## [7,] 0 0 0 0 0 0 7 0 0 0 ## [8,] 0 0 0 0 0 0 0 8 0 0 ## [9,] 0 0 0 0 0 0 0 0 9 0 ## [10,] 0 0 0 0 0 0 0 0 0 10 (x5 &lt;- diag(seq(1, 10, 2))) # 주대각선의 요소가 (1 3 5 7 9)인 대각행렬을 만듭니다. ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 0 0 0 0 ## [2,] 0 3 0 0 0 ## [3,] 0 0 5 0 0 ## [4,] 0 0 0 7 0 ## [5,] 0 0 0 0 9 추가적인 행렬 연산에 대하여 R에서 하는 벡터/행렬 연산을 참고하기 바랍니다. https://darkpgmr.tistory.com/104 "],["배열array.html", "Chapter 8 배열(array) ", " Chapter 8 배열(array) "],["배열의-생성.html", "8.1 배열의 생성", " 8.1 배열의 생성 배열은 2 차원 이상의 데이터를 저장할 수있는 R 데이터 객체입니다. 예를 들어, 3 차원 배열 (2, 3, 4)을 생성하면 각각 2 개의 행과 3 개의 열이있는 4 개의 직사각형 행렬이 생성됩니다. 배열은 데이터 유형만 저장할 수 있습니다. array() 함수를 사용하여 배열을 만듭니다. 벡터를 입력으로 사용하고 dim 매개 변수의 값을 사용하여 배열을 만듭니다. array(data = NA, dim = length(data), dimnames = NULL) data : 배열을 생성할 데이터입니다. dim : 배열의 차원을 나타내는 정수형 벡터입니다. 예, dim = c(2, 3, 4) dimnames : 리스트 형태의 각 차원의 이름입니다. 예 다음 예제에서는 2 X 3 X 4 배열을 생성합니다. 이는 2 X 3 행렬이 4개 있는 것과 같습니다. 따라서 전체 요소의 갯수는 2 X 3 X 4 = 24개가 됩니다. # 2 X 3 X 4 배열을 생성을 위한 요소 data를 생성합니다. set.seed(10) # 난수 발생 지점을 정합니다. data &lt;- sample(1:20, 24, rep=TRUE) # 요소 생성 : 1:20 사이의 숫자 24개를 임의로 복원추출합니다. data ## [1] 11 9 10 16 12 8 7 19 15 15 10 7 10 2 13 8 14 7 6 7 18 18 13 5 # 생성된 data를 array() 함수를 이용하여 배열로 전환합니다. arr.1 &lt;- array(data, dim = c(2, 3, 4)) # 배열을 생성합니다. arr.1 ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 11 10 12 ## [2,] 9 16 8 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 15 10 ## [2,] 19 15 7 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 10 13 14 ## [2,] 2 8 7 ## ## , , 4 ## ## [,1] [,2] [,3] ## [1,] 6 18 13 ## [2,] 7 18 5 배열을 생성할 때 제일 왼쪽의 2개의 차원으로 구성되는 행렬이 “기본 행렬”을 이룹니다. 그리고 다음 차원의 갯수가 바로 이 기본행렬의 갯수를 정하는 것입니다. 즉, 위의 에에서 arr.1 베열을 (2 X 3) 행렬을 기본행렬로 하여 이 기본 행렬이 4개 만들어지는 형태의 배열이 되는 것입니다. 한편 배열을 생성할 때 data의 요소의 갯수가 배열의 전체 요소의 갯수와 일치하지 않는 경우의 배열 생성에 대하여 살펴 보겠습니다. 이러한 경우는 data의 요소가 자동 반복(recycling)되어 배열의 요소로 채워집니다. # 12개의 요소로 구성된 벡터 data를 생성합니다. set.seed(10) # 난수 발생 지점을 정합니다. data &lt;- sample(1:20, 12, rep=TRUE) # 요소 생성 : 1:20 사이의 숫자 24개를 임의로 복원추출합니다. data ## [1] 11 9 10 16 12 8 7 19 15 15 10 7 # 2 X 3 X 4 배열을 생성합니다. arr.2 &lt;- array(data, dim = c(2, 3, 4)) # 배열의 전체 갯수가 24개여야 하는데, data의 요소 갯수는 12개 입니다. arr.2 # data의 12개 요소가 자동 반복되어 배열의 요소로 입력됩니다. ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 11 10 12 ## [2,] 9 16 8 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 15 10 ## [2,] 19 15 7 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 11 10 12 ## [2,] 9 16 8 ## ## , , 4 ## ## [,1] [,2] [,3] ## [1,] 7 15 10 ## [2,] 19 15 7 8.1.1 차원의 이름 지정 8.1.1.1 차원별 요소들의 이름 지정 dimnames 매개 변수에 리스트를 사용하여 배열의 각 차원의 요소들에 대한 이름을 지정할 수 있습니다. # array() 함수에 dimnames 인수에 배열의 각 차원의 이름을 지정합니다. arr.3 &lt;- array(data, dim = c(2, 3, 4), # 2 X 3 X 4 배열을 생성합니다. dimnames = list(c(&quot;male&quot;, &quot;female&quot;), # 첫 번째 차원의 이름을 지정합니다. c(&quot;low&quot;, &quot;middle&quot;, &quot;high&quot;), # 두 번째 차원의 이름을 지정합니다. c(&quot;S&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;))) # 세 번째 차원의 이름을 지정합니다. arr.3 # 각 차원의 이름이 출력됩니다. ## , , S ## ## low middle high ## male 11 10 12 ## female 9 16 8 ## ## , , A ## ## low middle high ## male 7 15 10 ## female 19 15 7 ## ## , , B ## ## low middle high ## male 11 10 12 ## female 9 16 8 ## ## , , C ## ## low middle high ## male 7 15 10 ## female 19 15 7 8.1.1.2 차원의 이름 지정 한편, names() 함수를 이용하여 각 차원의 이름을 지정할 수 있습니다. 즉 첫번째 차원은 “Gender,” 두분째 차원은 “Level” 그리고 세 번째 차원은 “Grade” 등의 이름을 부여해 보겠습니다. names(dimnames(arr.3)) &lt;- c(&quot;Gender&quot;, &quot;Level&quot;, &quot;Grade&quot;) arr.3 # 각 차원별로 이름이 지정된 것을 확인할 수 있습니다. ## , , Grade = S ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 ## ## , , Grade = A ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 ## ## , , Grade = B ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 ## ## , , Grade = C ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 str(arr.3) # arr.3 배열의 구조를 확인해 보겠습니다. ## int [1:2, 1:3, 1:4] 11 9 10 16 12 8 7 19 15 15 ... ## - attr(*, &quot;dimnames&quot;)=List of 3 ## ..$ Gender: chr [1:2] &quot;male&quot; &quot;female&quot; ## ..$ Level : chr [1:3] &quot;low&quot; &quot;middle&quot; &quot;high&quot; ## ..$ Grade : chr [1:4] &quot;S&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; "],["배열-요소-접근.html", "8.2 배열 요소 접근", " 8.2 배열 요소 접근 배열 요소의 접근도 행렬의 접근과 유사한 방법으로 할 수 있습니다. 예를 들어 3차원 배열의 경우 [1st.Dim, 2nd.Dim, 3rd.dim ]와 같이 각 차원을 컴마(,)로 구분하고 각각에 대하여 정수형 벡터, 문자형 벡터 그리고 논리형 벡터로 접근할 수 있습니다. ## arr.3 배열을 이용하여 배열 요소를 접근해 보겠습니다. # 정수형 벡터에 의한 접근 arr.3[1, ,] # 1차원의 1행에 대해 2차원과 3차원의 모든 요소를 출력합니다. 2차원 행렬형태로 반합니다. ## Grade ## Level S A B C ## low 11 7 11 7 ## middle 10 15 10 15 ## high 12 10 12 10 arr.3[ , 1:2, ] # 1차원 전체(2개 벡터), 2차원 (1,2 벡터), 3차원 전체, 즉 2 X 2 X 4 배열을 반환합니다. ## , , Grade = S ## ## Level ## Gender low middle ## male 11 10 ## female 9 16 ## ## , , Grade = A ## ## Level ## Gender low middle ## male 7 15 ## female 19 15 ## ## , , Grade = B ## ## Level ## Gender low middle ## male 11 10 ## female 9 16 ## ## , , Grade = C ## ## Level ## Gender low middle ## male 7 15 ## female 19 15 arr.3[ , , 2:3] # 1차원 전체(2개 벡터), 2차원 (3개 벡터), 3차원 2개 벡터, 즉 2 X 3 X 2 배열을 반환합니다. ## , , Grade = A ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 ## ## , , Grade = B ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 # 문자형 벡터에 의한 접근 (위의 예를 문자형으로 표시해 보겠습니다.) arr.3[&quot;male&quot;, , ] ## Grade ## Level S A B C ## low 11 7 11 7 ## middle 10 15 10 15 ## high 12 10 12 10 arr.3[ , c(&quot;low&quot;, &quot;middle&quot;), ] ## , , Grade = S ## ## Level ## Gender low middle ## male 11 10 ## female 9 16 ## ## , , Grade = A ## ## Level ## Gender low middle ## male 7 15 ## female 19 15 ## ## , , Grade = B ## ## Level ## Gender low middle ## male 11 10 ## female 9 16 ## ## , , Grade = C ## ## Level ## Gender low middle ## male 7 15 ## female 19 15 arr.3[ , , c(&quot;A&quot;, &quot;B&quot;)] ## , , Grade = A ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 ## ## , , Grade = B ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 # 논리형 벡터에 의한 접근 (마찬가지로 위의 예를 논리형으로 표시해 보겠습니다.) arr.3[c(T, F), , ] ## Grade ## Level S A B C ## low 11 7 11 7 ## middle 10 15 10 15 ## high 12 10 12 10 arr.3[ , c(T, T, F), ] ## , , Grade = S ## ## Level ## Gender low middle ## male 11 10 ## female 9 16 ## ## , , Grade = A ## ## Level ## Gender low middle ## male 7 15 ## female 19 15 ## ## , , Grade = B ## ## Level ## Gender low middle ## male 11 10 ## female 9 16 ## ## , , Grade = C ## ## Level ## Gender low middle ## male 7 15 ## female 19 15 arr.3[ , , c(F, T, T, F)] ## , , Grade = A ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 ## ## , , Grade = B ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 8.2.1 배열 요소의 서브 세팅과 수정 배열 요소의 서브 세팅은 배열 요소에 접근한 다음 새로운 변수에 할당하면 이루어 집니다. 그리고 데이터 수정은 수정을 원하는 배열 요소에 접근한 다음 원하는 데이터로 할당 연산자를 이용하여 재할당하면 되는 것입니다. "],["다차원-배열의-변환과-요약.html", "8.3 다차원 배열의 변환과 요약", " 8.3 다차원 배열의 변환과 요약 다차원 배열은 차원의 수가 늘어날 수록 배열을 적절하게 처리하는 것이 어려워 집니다. 이러한 문제를 해결하기 위한 방법에 대하여 살펴 보겠습니다. 첫 번째 방법은 자료를 원하는 형식으로 변형하는 것입니다. 이를 위한 방법이 배열의 차원을 재배열하는 것입니다. 두 번째 방법은 자료를 요약하여 차원의 수를 줄이는 것입니다. 이를 위해 배열을 큰 표로 만들고 차원을 줄이는 방법입니다. 세 번째 방법은 요약정보를 산출하는 것입니다. 세 번째 방법은 배열을 데이터 프레임 표로 변환하는 것입니다. 다음에서 이러한 방법에 대하여 학습하겠습니다. 8.3.1 차원의 순서 바꾸기 (재배열) 앞의 arr.3 배열을 예로 설명하겠습니다. 이 배열을 출력해 보면 세 번째 차원인 “Grade” 등급별로 첫 번째 차원은 “Gender” 차원과 두 번째 차원인 “Level” 차원이 비교하는 행렬이 출력되고 있습니다. 그런데 이를 “Gender”별로 “Grade” 차원과 “Level” 차원을 비교하는 결과로 출력하고 싶다고 가정해 보지요. 즉 원래 arr.3 배열의 첫 번째 차원과 세 번째 차원을 바꿔서 재배열을 하고자 하는 것입니다. 이러한 배열의 차원을 재배열하는데 사용하는 함수가 aperm() 함수입니다. aperm() 함수의 형식은 다음과 같습니다. aperm(a, perm, ...) a : 전환하고자 하는 배열 perm : 첨자 순열 벡터입니다. 일반적으로 정수 1:n의 순열입니다. 여기서 n은 a의 차원 수 입니다. 앞의 arr.3 배열의 예를 aperm() 함수를 이용하여 구현해 보겠습니다. arr.3 # 1차원과 2차원의 행렬을 3차원 별로 출력합니다. ## , , Grade = S ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 ## ## , , Grade = A ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 ## ## , , Grade = B ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 ## ## , , Grade = C ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 # perm = c() 함수를 이용하여 ()안에 원하는 차원의 번호를 순서대로 기입합니다. c(3, 2, 1) arr.4 &lt;- aperm(arr.3, perm = c(3, 2, 1)) # 차원의 배열을 3차원, 2차원, 1차원 순으로 재별합니다. arr.4 # 이제 Grade와 Level로 구성된 기본 행렬이 Gender 별로 출력됩니다. ## , , Gender = male ## ## Level ## Grade low middle high ## S 11 10 12 ## A 7 15 10 ## B 11 10 12 ## C 7 15 10 ## ## , , Gender = female ## ## Level ## Grade low middle high ## S 9 16 8 ## A 19 15 7 ## B 9 16 8 ## C 19 15 7 # perm = c(1, 3, 2)로 해서 배열을 재배열해 보겠습니다. # 1차원인 Gender와 3차원인 Grade가 기본행렬이 되고 이를 Level별로 출력하는 형태가 될 것입니다. arr.5 &lt;- aperm(arr.3, perm = c(1, 3, 2)) arr.5 ## , , Level = low ## ## Grade ## Gender S A B C ## male 11 7 11 7 ## female 9 19 9 19 ## ## , , Level = middle ## ## Grade ## Gender S A B C ## male 10 15 10 15 ## female 16 15 16 15 ## ## , , Level = high ## ## Grade ## Gender S A B C ## male 12 10 12 10 ## female 8 7 8 7 이렇게 배열의 차원을 재배열함으로써 기본 행렬의 구성을 우리가 원하는 형태로 지정하면, 배열에 담긴 정보를 이해하는데 도움이 될 것입니다. 8.3.2 큰 표로 만들기 배열에 있어서 3번째 이후의 차원을 독립된 행렬이 아닌 하나의 행렬 형태로 모두 출력하여 하나의 큰 표로 만든다면 배열에 담긴 정보를 이해하는데 도움이 될 것입니다. 이러한 다차원을 배열을 2차원 행렬 형태의 큰 표로 만들 때 사용하는 함수할 수 있는 함수는 stats 패키지에 있는 ftable() 함수입니다. ftable() 함수의 기본 형식은 다음과 같습니다. ftable(x, ..., exclude = c(NA, NaN), row.vars = NULL, col.vars = NULL) x : 인자(문자열 포함)로 해석되거나, 리스트 (또는 데이터 프레임)로 해석될 수 있는 R 객체, 또는 “table”이나 “ftable”의 분할 테이블 객체 row.vars : 플랫 분할표의 행에 사용할 변수의 수를 제공하는 정수형 벡터 또는 변수의 이름을 제공하는 문자형 벡터. col.vars : 플랫 분할 표의 열에 사용할변수의 수를 제공하는 정수형 벡터 또는 변수의 이름을 제공하는 문자형 벡터. arr.3의 예를 살펴 보겠습니다. # 패키지 설치와 불러오기 # install.packages(&quot;stats&quot;) library(stats) # row.vars = c(1,3)과 정수형 벡터를 지정하는 경우입니다. arr.3 ## , , Grade = S ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 ## ## , , Grade = A ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 ## ## , , Grade = B ## ## Level ## Gender low middle high ## male 11 10 12 ## female 9 16 8 ## ## , , Grade = C ## ## Level ## Gender low middle high ## male 7 15 10 ## female 19 15 7 ftab.1 &lt;- ftable(arr.3, row.vars = c(1, 3)) # 1번째, 3번째 차원을 큰 표의 행에 함께 나열합니다. ftab.1 # Gender, Grade 가 표의 행에, 열에는 Level이 표시가 됩니다. ## Level low middle high ## Gender Grade ## male S 11 10 12 ## A 7 15 10 ## B 11 10 12 ## C 7 15 10 ## female S 9 16 8 ## A 19 15 7 ## B 9 16 8 ## C 19 15 7 # row.vars = c(3)으로 해서 큰 표의 각 행에 3번째 차원만 표현해 보겠습니다. ftab.2 &lt;- ftable(arr.3, row.vars = c(3)) ftab.2 ## Gender male female ## Level low middle high low middle high ## Grade ## S 11 10 12 9 16 8 ## A 7 15 10 19 15 7 ## B 11 10 12 9 16 8 ## C 7 15 10 19 15 7 # row.vars = c()에 문자형 벡터를 지정하는 경우입니다. ftab.3 &lt;- ftable(arr.3, row.vars = c(&quot;Gender&quot;, &quot;Grade&quot;)) ftab.3 ## Level low middle high ## Gender Grade ## male S 11 10 12 ## A 7 15 10 ## B 11 10 12 ## C 7 15 10 ## female S 9 16 8 ## A 19 15 7 ## B 9 16 8 ## C 19 15 7 ftab.4 &lt;- ftable(arr.3, row.vars = &quot;Grade&quot;) ftab.4 ## Gender male female ## Level low middle high low middle high ## Grade ## S 11 10 12 9 16 8 ## A 7 15 10 19 15 7 ## B 11 10 12 9 16 8 ## C 7 15 10 19 15 7 다차원 배열을 큰 표로 만들고 나니 배열로 출력될 때 보다 전체 데이터에 대한 이해가 더 좋아짐을 알 수 있습니다. 8.3.3 배열의 요약 정보 행렬에서 배운 apply() 함수를 이용하면 배열의 요약정보를 산출할 수 있습니다. # MARGIN 인수에 원하는 출력하고자 하는 차원의 번호를 정수형 벡터로 입력합니다. apply(arr.3, MARGIN = 1, FUN = mean) # MARGIN = 1, 1번째 차원 즉 Gender를 기준으로 평균을 구합니다. ## male female ## 10.83333 12.33333 apply(arr.3, MARGIN = c(1, 2), FUN = mean) # 1번째, 2번째 차원을 기준으로 평균을 구합니다. ## Level ## Gender low middle high ## male 9 12.5 11.0 ## female 14 15.5 7.5 # MARGIN 인수에 원하는 출력하고자 하는 차원의 이름을 문자형 벡터로 입력합니다. apply(arr.3, MARGIN = &quot;Gender&quot;, FUN = mean) # Gender를 기준으로 평균을 구합니다. ## male female ## 10.83333 12.33333 apply(arr.3, MARGIN = c(&quot;Gender&quot;, &quot;Level&quot;), FUN = mean) # Gender차원과 Level 차원을 기준으로 평균(행렬)을 구합니다. ## Level ## Gender low middle high ## male 9 12.5 11.0 ## female 14 15.5 7.5 8.3.4 배열을 데이터 프레임으로 변환하기 한편 배열에 있는 개별적인 요소의 값을 중심으로 각 차원을 컬럼으로 하는 데이터 프레임으로도 변환할 수 있습니다.10 배열을 데이터 프레임으로 변경하기 위해서는 as.data.fram() 함수를 이용합니다. as.data.frame.table() 함수의 형식은 다음과 같습니다. as.data.frame.table(x, row.names = NULL, ..., responseName = \"Freq\", stringsAsFactors = TRUE, sep = \"\", base = list(LETTERS)) x : R의 객체 responseName: 테이블 항목의 열에 사용할 이름. 일반적으로 “count”를 사용합니다. arr.3 배열을 데이터 프레임으로 변환해 보겠습니다. 이를 위해 먼저 arr.3 배열을 분석해 보겠습니다. 배열 arr.3는 다음과 같이 구성되어 있습니다. 3개의 차원인 Gender, Level, Grade 으로 구성되고, 이 차원들은 Gender의 경우 “male”과 “female,” Level의 경우 “low,” “middle,” “high” 그리고 Grade 차원의 경우는 “S” ,”A”, “B,” “C” 등의 값을 가집니다.이러한 차원의 이름은 데이터 프레임의 열 이름이 되고, 차원의 값들은 데이터 프레임의 행을 이루게 됩니다. 그리고 데이터 입니다. 이 데이터를 데이터 프레임을 변환하기 위해서는 이 데이터를 설명하기 위한 열 이름을 지정해야 하는데 이때 사용되는 인수가 responseName입니다. arr.3의 데이터는 각 차원에 대한 빈도수로 본다면 responseName = “count”라고 설정하면 되겠습니다. 그러면 이제 arr.3 배열을 데이터 프레임을 변환하는 스크립트를 생성하여 확인해 보겠습니다. df.arr.3 &lt;- as.data.frame.table(arr.3, responseName = &quot;count&quot;) df.arr.3 # arr.3의 요소의 갯수 24 만큼의 행으로 구성된 데이터 프레임입니다. ## Gender Level Grade count ## 1 male low S 11 ## 2 female low S 9 ## 3 male middle S 10 ## 4 female middle S 16 ## 5 male high S 12 ## 6 female high S 8 ## 7 male low A 7 ## 8 female low A 19 ## 9 male middle A 15 ## 10 female middle A 15 ## 11 male high A 10 ## 12 female high A 7 ## 13 male low B 11 ## 14 female low B 9 ## 15 male middle B 10 ## 16 female middle B 16 ## 17 male high B 12 ## 18 female high B 8 ## 19 male low C 7 ## 20 female low C 19 ## 21 male middle C 15 ## 22 female middle C 15 ## 23 male high C 10 ## 24 female high C 7 str(df.arr.3) # df.arr.3 데이터 프레임의 구조를 확인합니다. ## &#39;data.frame&#39;: 24 obs. of 4 variables: ## $ Gender: Factor w/ 2 levels &quot;male&quot;,&quot;female&quot;: 1 2 1 2 1 2 1 2 1 2 ... ## $ Level : Factor w/ 3 levels &quot;low&quot;,&quot;middle&quot;,..: 1 1 2 2 3 3 1 1 2 2 ... ## $ Grade : Factor w/ 4 levels &quot;S&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;: 1 1 1 1 1 1 2 2 2 2 ... ## $ count : int 11 9 10 16 12 8 7 19 15 15 ... 이제 arr.3 배열과 df.arr.3을 비교해 보기 바랍니다. 이렇듯 다차원 배열을 데이터 프레임 형태로 변환시키면 다양한 데이터 분석과 시각화를 수행할 수 있게 됩니다. 참고문헌 참고자료 : 다차원 배열 : 변환하고 요약하기 데이터 프레임에 대에서는 제2부의 제7장에서 학습하겠습니다. "],["리스트list.html", "Chapter 9 리스트(list)", " Chapter 9 리스트(list) 이 장에서는 R 프로그래밍에서 리스트로 작업하는 방법을 학습하겠습니다. 구체적으로 리스트 구성 요소를 생성하고, 액세스하고, 수정하고 삭제하는 방법을 살펴 보겠습니다. 리스트(list)는 혼합 데이터 유형의 구성 요소를 포함하는 데이터 구조입니다. 동질적(homogeneour) 유형의 모든 요소를 갖는 벡터를 원자 벡터라고하고, 다른 유형(heterogeneous)의 요소를 갖는 벡터를 리스트(list)라고합니다. typeof() 함수로 리스트인지 확인하고, 벡터와 마찬가지로 length() 함수를 이용하여 리스트의 길이를 확인할 수 있습니다. 다음은 데이터 유형이 서로 다른 세 가지 구성 요소가 있는 리스트의 예입니다. x &lt;- list(&quot;a&quot; = 2.5, &quot;b&quot; = TRUE, &quot;c&quot; = 1:3) x ## $a ## [1] 2.5 ## ## $b ## [1] TRUE ## ## $c ## [1] 1 2 3 "],["리스트의-생성.html", "9.1 리스트의 생성", " 9.1 리스트의 생성 9.1.1 키워드가 없는 리스트의 생성 그러나 이 태그는 선택 사항입니다. 다음과 같이 태그없이도 동일한 리스트를 생성할 수 있습니다. 이러한 리스트의 생성에서 키워드를 지정하지 않고 생성하는 경우에는 기본적으로 숫자 인덱스가 사용됩니다. # list 함수를 이용하여 4개의 요소를 갖는 x 변수를 생성합니다. x &lt;- list(&quot;홍길동&quot;, &quot;2016001&quot;, 20, c(&quot;IT융합&quot;, &quot;데이터 관리&quot;)) x ## [[1]] ## [1] &quot;홍길동&quot; ## ## [[2]] ## [1] &quot;2016001&quot; ## ## [[3]] ## [1] 20 ## ## [[4]] ## [1] &quot;IT융합&quot; &quot;데이터 관리&quot; 9.1.2 키워드가 있는 리스트의 생성 list() 함수를 이용하여 리스트를 생성할 수 있습니다. 다음과 같이 list() 함수안에 컴마로 각각의 요소를 구분하여 나열하면 됩니다. 이때 각 요소의 데이터 유형은 동일하지 않아도 됩니다. # list 함수를 이용하여 4개의 요소를 갖는 x 변수를 생성합니다. x &lt;- list(name = &quot;홍길동&quot;, # 각각의 요소는 keyword = value 형식으로 입력합니다. stud.id = &quot;2016001&quot;, age = 20, class = c(&quot;IT융합&quot;, &quot;데이터 관리&quot;)) x ## $name ## [1] &quot;홍길동&quot; ## ## $stud.id ## [1] &quot;2016001&quot; ## ## $age ## [1] 20 ## ## $class ## [1] &quot;IT융합&quot; &quot;데이터 관리&quot; # https://www.tutorialspoint.com/r/r_lists.htm # 다음은 문자열, 숫자형 벡터, 논리 값 그리고 실수형 숫자 등을 포함하는 목록을 만드는 예입니다. list_data1 &lt;- list(&quot;Red&quot;, &quot;Green&quot;, c(21,32,11), TRUE, 51.23, 119.1) list_data1 ## [[1]] ## [1] &quot;Red&quot; ## ## [[2]] ## [1] &quot;Green&quot; ## ## [[3]] ## [1] 21 32 11 ## ## [[4]] ## [1] TRUE ## ## [[5]] ## [1] 51.23 ## ## [[6]] ## [1] 119.1 # Create a list containing a vector, a matrix and a list. list_data2 &lt;- list(c(&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;), matrix(c(3,9,5,1,-2,8), nrow = 2), list(&quot;green&quot;,12.3)) 여기에서는 4 개의 키워드(name, stud.id, age, class 등) 즉 요소의 이름이 지정되어 있으며, 각각의 데이터 유형은 문자형, 문자형, double 형, 그리고 문자형 벡터 등입니다. "],["리스트에-이름-붙이기.html", "9.2 리스트에 이름 붙이기", " 9.2 리스트에 이름 붙이기 리스트의 요소에 이름(키워드 또는 태그 등)은 names() 함수를 이용하여 지정할 이름을 문자형 벡터로 할당하여 지정할 수 있으며 이러한 이름을 사용하여 리스트의 요소에 액세스 할 수 있습니다. # 앞에서 생성된 list_data2 리스트에 붙일 이름을 문자형 벡터로 지정해 줍니다. names(list_data2) &lt;- c(&quot;1st Quarter&quot;, &quot;A_Matrix&quot;, &quot;A Inner list&quot;) list_data2 # 이름이 지정된 리스트를 확인합니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 ## ## $`A Inner list` ## $`A Inner list`[[1]] ## [1] &quot;green&quot; ## ## $`A Inner list`[[2]] ## [1] 12.3 "],["리스트의-구조-확인.html", "9.3 리스트의 구조 확인", " 9.3 리스트의 구조 확인 리스트는 각각의 요소가 키워드와 값으로 구성이 되는 것을 알 수 있습니다. 따라서 리스트의 이러한 구조를 확인할 필요가 있습니다. 이러한 리스트의 구조는 str() 함수를 이용하면 확인할 수 있습니다. str(x) # ## List of 4 ## $ name : chr &quot;홍길동&quot; ## $ stud.id: chr &quot;2016001&quot; ## $ age : num 20 ## $ class : chr [1:2] &quot;IT융합&quot; &quot;데이터 관리&quot; 이 예에서는 name, stud.id, age 그리고class는 리스트의 구성 요소를 보다 쉽게 참조 할 수 있게 해주는 키워드 혹은 태그(tag)라고합니다. "],["리스트의-길이-확인-length.html", "9.4 리스트의 길이 확인 : length()", " 9.4 리스트의 길이 확인 : length() 리스트 요소의 길이(요소의 갯수)는 벡터와 마찬가지로 length() 함수를 이용하여 확인할 수 있습니다. length(x) ## [1] 4 length(list_data1) ## [1] 6 length(list_data2) ## [1] 3 "],["리스트-요소-접근.html", "9.5 리스트 요소 접근", " 9.5 리스트 요소 접근 리스트는 벡터와 유사한 방식으로 액세스할 수 있습니다. 색인에 정수형, 논리형 또는 문자형 벡터를 사용할 수 있습니다. 또한 이 접근 방식에 의해 접근된 요소를 변수에 할당하면 리스트의 서브 세팅도 이루어 지는 것입니다. # 벡터, 행렬 그리고 리스트로 구성되는 리스트를 생성합니다. list_data &lt;- list(c(&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;), matrix(c(3,9,5,1,-2,8), nrow = 2), list(&quot;green&quot;,12.3)) # 리스트의 요소에 이름을 부여합니다. names(list_data) &lt;- c(&quot;1st Quarter&quot;, &quot;A_Matrix&quot;, &quot;A Inner list&quot;) ## 리스트 요소의 정수형 색인을 이용한 접근의 예입니다. list_data[1] # 리스트의 1번째 요소에 접근합니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; list_data[3] # 리스트의 3번째 요소에 접근합니다. ## $`A Inner list` ## $`A Inner list`[[1]] ## [1] &quot;green&quot; ## ## $`A Inner list`[[2]] ## [1] 12.3 list_data[c(1, 3)] # 리스트의 1번째, 3번째 요소에 접근합니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $`A Inner list` ## $`A Inner list`[[1]] ## [1] &quot;green&quot; ## ## $`A Inner list`[[2]] ## [1] 12.3 list_data[-2] # 리스트의 2번째 요소를 제외하고 접근합니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $`A Inner list` ## $`A Inner list`[[1]] ## [1] &quot;green&quot; ## ## $`A Inner list`[[2]] ## [1] 12.3 ## 논리형 벡터를 색인으로 이용한 접근의 예입니다. list_data[c(T, F, F)] # T에 해당하는 1번째 요소만 접근합니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## 리스트 요소의 이름을 이용한 접근의 예입니다. list_data$A_Matrix # $ 연산자를 이용하여 A_Matrix 요소에 접근합니다. ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 list_data[&quot;A_Matrix&quot;] # []를 이용하여 A_Matrix 요소에 접근합니다. ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 list_data$`A Inner list` # $ 연산자를 이용하는 경우 이름에 공란이 있는 경우 ``를 이용합니다. ## [[1]] ## [1] &quot;green&quot; ## ## [[2]] ## [1] 12.3 list_data[&quot;`A Inner list`&quot;] ### []를 이용한 경우에는 공란이 있는 이름은 접근이 안됩니다. ## $&lt;NA&gt; ## NULL list_data$`A Inner list`[[1]] # `A Inner list`의 첫 번째 요소 데이터를 출력합니다. ## [1] &quot;green&quot; list_data$`A Inner list`[[2]] # `A Inner list`의 두 번째 요소 데이터를 출력합니다. ## [1] 12.3 위와 같이 [로 인덱싱하면 구성 요소 내부의 콘텐츠가 아닌 하위 리스트가 제공됩니다. 구체적인 데이터 값을 검색하려면 [[을 이용합니다. 그러나 이 접근 방식을 사용하면 한 번에 하나의 구성 요소에만 액세스 할 수 있습니다. list_data[&quot;A_Matrix&quot;] # A_Matrix를 리스트 형태로 반환합니다. ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 typeof(list_data[&quot;A_Matrix&quot;]) # 리스트 형임을 확인할 수 있습니다. ## [1] &quot;list&quot; list_data[[&quot;A_Matrix&quot;]] # A_Matrix의 실제 데이터인 행렬을 반환합니다. ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 typeof(list_data[[&quot;A_Matrix&quot;]]) # double 형임을 확인할 수 있습니다. ## [1] &quot;double&quot; 지금까지 살펴본 바와 같이 리스트의 내용에 액세스하는 동안 자주 사용되는 [[의 대안은 $ 연산자입니다. $는 태그에서 부분 일치를 수행할 수 있다는 점을 제외하면 둘 다 동일합니다. 여기에서 태그의 부분일치의 예를 들면 다음과 같습니다. x &lt;- list(name = c(&quot;Kim&quot;, &quot;Lee&quot;, age = c(20, 30)) x$n # x$name이 출력됨을 알 수 있습니다. 즉, n이 name에 부분일치한 것입니다. x$a # x$age가 출력됨을 알 수 있습니다. x[&quot;n&quot;] # $ 연산자는 키워드의 부분일치를 허용하지만, []는 부분일치를 허용하지 않습니다. x[[&quot;n&quot;]] # $ 연산자는 키워드의 부분일치를 허용하지만, [[]]는 부분일치를 허용하지 않습니다. # $ 연산자를 이용한 접근은 그 요소의 데이터 유형으로 접근이 됩니다. x$name # 문자형 벡터로 출력됨을 알 수 있습니다. # 다음과 같이 []의 사용과 [[]]의 차이점을 확인할 필요가 있습니다. x[&quot;name&quot;][1] # name 요소를 리스트로 접근하여 그에 대한 첫번째 요소를 리스트로 출력합니다. x[[&quot;name&quot;]][1] # name 요소의 문자형 벡터로 접근하여 그에 대한 첫번째 요소를 문자열로 출력합니다. ## Error: &lt;text&gt;:2:1: 예상하지 못한 기호(symbol)입니다. ## 1: x &lt;- list(name = c(&quot;Kim&quot;, &quot;Lee&quot;, age = c(20, 30)) ## 2: x ## ^ []]와 [[ ]]의 차이 : 왼쪽에서 오른쪽 방향으로 파악하면 도움이 됩니다. [] : [] 안의 키워드 요소에 접근하여 리스트로 출력을 합니다. [[]] : [[]] 안의 키워드 요소에 접근하여 벡터로 출력을 합니다. [][] : 왼쪽의 [] 안의 키워드 요소가 리스트로 접근이 되고, 그 다음의 오른쪽 [] 안의 키워드 요소를 리스트로 출력합니다. [][[]] : 왼쪽의 [] 안의 키워드 요소가 리스트로 접근이 되고, 그 다음의 오른쪽 [] 안의 키워드 요소를 벡터로 출력합니다. [[]][] : 왼쪽의 [[]] 안의 키워드 요소가 벡터로 접근이 되고, 그 다음의 오른쪽 [[]] 안의 키워드 요소에 대해 벡터 요소로 출력합니다. "],["리스트의-조작.html", "9.6 리스트의 조작", " 9.6 리스트의 조작 아래와 같이 리스트에 요소를 추가, 삭제 그리고 업데이트 할 수 있습니다. 리스트 요소의 추가는 리스트의 끝에서만 이루어집니다. 키워드가 정해지지 않은 리스트의 경우는 정수형의 색인 번호를 이용합니다. # 벡터, 행렬 그리고 리스트를 요소로 포함하는 리스트를 생성합니다. list_data &lt;- list(c(&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;), matrix(c(3,9,5,1,-2,8), nrow = 2), list(&quot;green&quot;,12.3)) list_data # 리스트의 요소가 정수형으로 색인이 됩니다. ## [[1]] ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## [[2]] ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 ## ## [[3]] ## [[3]][[1]] ## [1] &quot;green&quot; ## ## [[3]][[2]] ## [1] 12.3 # 리스트 요소에 이름을 부여합니다. names(list_data) &lt;- c(&quot;1st Quarter&quot;, &quot;A_Matrix&quot;, &quot;A Inner list&quot;) list_data # 리스트의 요소에 정수형 이름이 부여되어 있습니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 ## ## $`A Inner list` ## $`A Inner list`[[1]] ## [1] &quot;green&quot; ## ## $`A Inner list`[[2]] ## [1] 12.3 ## 정수형의 색인 번호를 이용하여 리스트를 조작할 수 있습니다. # 리스트에 요소를 추가합니다. list_data[4] &lt;- &quot;New element&quot; # 리스트에 4번째 요소를 추가하고 &quot;New Element&quot; 값을 할당합니다. list_data # 수정된 리스트를 확인합니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 ## ## $`A Inner list` ## $`A Inner list`[[1]] ## [1] &quot;green&quot; ## ## $`A Inner list`[[2]] ## [1] 12.3 ## ## ## [[4]] ## [1] &quot;New element&quot; # NULL을 이용하여 마지막 요소를 제거합니다. list_data[4] &lt;- NULL # NULL 값을 입력하면 4번째 요소가 리스트에서 제거됩니다. list_data # 4번째 요소가 없음을 알 수 있습니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 ## ## $`A Inner list` ## $`A Inner list`[[1]] ## [1] &quot;green&quot; ## ## $`A Inner list`[[2]] ## [1] 12.3 # 3번째 요소 값을 수정합니다. list_data[3] &lt;- &quot;updated element&quot; list_data ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 ## ## $`A Inner list` ## [1] &quot;updated element&quot; ## 키워드를 이용하여 리스트를 조작하면 다음과 같습니다. # 리스트에 요소를 추가합니다. list_data$new &lt;- &quot;New element&quot; # 네 번째 요소의 태그가 new가 되면, 그 값은 &quot;New Element&quot;가 할당됩니다. names(list_data) # list_data의 키워드 목록을 확인합니다. ## [1] &quot;1st Quarter&quot; &quot;A_Matrix&quot; &quot;A Inner list&quot; &quot;new&quot; list_data$new # $ 연산자를 이용하여 new 요소의 값을 확인합니다. ## [1] &quot;New element&quot; # NULL을 이용하여 마지막 요소를 제거합니다. list_data$new &lt;- NULL # new 요소의 값을 제거합니다. list_data # 수정된 리스트를 확인합니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 ## ## $`A Inner list` ## [1] &quot;updated element&quot; # 3번째 요소 값을 수정합니다. list_data$`A Inner list` &lt;- list(&quot;green&quot;,12.3) # 태그에 공란이 있는 경우 ``로 태그를 묶어 줍니다. # `A Inner list`의 데이터를 &quot;list(&quot;green&quot;,12.3)&quot;로 수정합니다. list_data # 수정된 값을 확인합니다. ## $`1st Quarter` ## [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; ## ## $A_Matrix ## [,1] [,2] [,3] ## [1,] 3 5 -2 ## [2,] 9 1 8 ## ## $`A Inner list` ## $`A Inner list`[[1]] ## [1] &quot;green&quot; ## ## $`A Inner list`[[2]] ## [1] 12.3 # $`A Inner list` 요소가 다음과 같음을 확인할 수 있습니다. # $`A Inner list`[[1]], $`A Inner list`[[2]] "],["리스트의-결합.html", "9.7 리스트의 결합", " 9.7 리스트의 결합 여러 개의 리스트를 하나의 리스트로 결합하기 위해서는 벡터의 결합과 마찬가지로 c() 함수를 이용합니다. # 두 개의 리스트를 생성합니다. list1 &lt;- list(1,2,3) list2 &lt;- list(&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;) # 두 개의 리스트를 하나의 리스트로 결합합니다. merged.list &lt;- c(list1,list2) # 6개의 요소를 가지는 리스트가 됩니다. # 결합된 리스트를 출력합니다. merged.list ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] &quot;Sun&quot; ## ## [[5]] ## [1] &quot;Mon&quot; ## ## [[6]] ## [1] &quot;Tue&quot; "],["리스트의-벡터-변환.html", "9.8 리스트의 벡터 변환", " 9.8 리스트의 벡터 변환 벡터의 요소를 추가적으로 조작하기 위해 리스트를 벡터로 변환할 수 있습니다. 벡터의 모든 (산술) 연산을 적용하기 위해 리스트를 벡터 변환합니다. 이 변환을 수행하기 위해 unlist() 함수를 사용합니다. 이 함수는 리스트를 입력으로 받아 벡터를 반환합니다. # 리스트를 생성합니다. list1 &lt;- list(1:5) list2 &lt;-list(10:14) # 리스트를 벡터로 강제변환합니다. v1 &lt;- unlist(list1) v2 &lt;- unlist(list2) # 이제 벡터의 연산을 적용할 수 있습니다. result &lt;- v1 + v2 # 두 개의 벡터를 덧셈합니다. result ## [1] 11 13 15 17 19 "],["데이터-프레임.html", "Chapter 10 데이터 프레임", " Chapter 10 데이터 프레임 이 장에서는 R의 데이터 프레임에 대해 알아 봅니다. 작성 방법, 해당 요소에 액세스하고 프로그램에서 방법. 데이터 프레임(data frame)은 2 차원 데이터 구조입니다. 각 열을 구성하고 있는 요소의 길이가 같은 특수한 경우입니다. 데이터 프레임은 각 구성요소의 길이가 같은 리스트의 특수한 형태라고 할 수 있습니다. 리스트의 각 구성요소가 열(columns)을 형성하고, 각각의 열의 요소를 묶으면 행을 형성하는 구조가 데이터 프레임입니다. 이러한 데이터 프레임은 R의 핵심적인 자료구조 중의 하나입니다. 데이터 프레임은 엑셀의 워크시트와 같이 숫자, 문자 등 다양한 데이터를 담고있는 테이블(Table, 표)을 처리할 수 있는 데이터 구조로서, R이 제공하는 다양한 함수들을 이용하여 다양한 데이터 분석과 시각화를 할 수 있게 해 줍니다.11 class() 함수를 사용하여 변수가 데이터 프레임인지 여부를 확인할 수 있습니다. emp.data # emp.data 변수의 데이터를 확인합니다. ## emp_id emp_name salary start_date ## 1 1 Rick 623.30 2012-01-01 ## 2 2 Dan 515.20 2013-09-23 ## 3 3 Michelle 611.00 2014-11-15 ## 4 4 Ryan 729.00 2014-05-11 ## 5 5 Gary 843.25 2015-03-27 typeof(emp.data) # emp.data의 데이터 유형을 확인합니다. &quot;List&quot;를 반환합니다. ## [1] &quot;list&quot; class(emp.data) # emp.data의 클래스를 확인합니다. &quot;data.frame&quot;을 반환합니다. ## [1] &quot;data.frame&quot; str(emp.data) # emp.data의 구조를 확인합니다. 각 요소(컬럼)룰 $로 구분하고 있습니다. ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ emp_id : int 1 2 3 4 5 ## $ emp_name : chr &quot;Rick&quot; &quot;Dan&quot; &quot;Michelle&quot; &quot;Ryan&quot; ... ## $ salary : num 623 515 611 729 843 ## $ start_date: Date, format: &quot;2012-01-01&quot; &quot;2013-09-23&quot; ... 위의 예에서 emp.datat는 각각 5 개의 요소를 갖는(5개 행) 4 개의 벡터(emp_id, emp_name, salary, start_date)로 구성된(4개 열) 리스트로 간주할 수 있습니다. 데이터 프레임은 각 열이 하나의 변수로서 벡터(vector) 형태이고, 각 행은 각 열의 값을 집합으로 하여 리스트 형태로 구성되는 사각형 모양의 2차원 테이블 구조를 갖습니다. 이러한 데이터 프레임의 특징은 다음과 같습니다. 각 열의 이름은 비워 둘 수 없습니다. 비워두면 R이 알아서 자동으로 채워줍니다. 각 행은 중복되는 행이 없이 유일(unique)해야 합니다 (중복되는 행이 있으면 중복을 제거해 주는 것이 좋습니다.) 데이터 프레임에 저장된 데이터는 숫자, 요인 또는 문자 유형일 수 있습니다. 각 열은 동일한 데이터 유형을 갖는 벡터 형태여야 하며, 모든 열에 있는 요소들의 갯수는 같아야 합니다. 이번 장에서는 이러한 데이터 프레임에 대해 더 많이 알 수있는 몇 가지 유용한 기능에 대하여 학습하겠습니다. R에서는 우리가 일반적으로 작성하는 표 형태의 데이터를 데이터 프레임이나 티블(tibble)의 데이터 구조로 처리합니다. "],["데이터-프레임의-생성.html", "10.1 데이터 프레임의 생성", " 10.1 데이터 프레임의 생성 data.frame() 함수를 사용하여 데이터 프레임을 만들 수 있습니다. data.frame() 함수의 형식은 다음과 같습니다. data.frame(..., row.names = NULL, check.rows = FALSE, check.names = TRUE, fix.empty.names = TRUE, stringsAsFactors = default.stringsAsFactors()) ... : 이 인수는 폼 값이나 tag = value 형태이다. 구성 요소명(컬럼 명)은 tag 이름으로 또는 deparsed 인수 자체로 생성됩니다. row.names = : NULL, 단일 정수, 또는 행 이름으로 사용될 컬럼을 지정하는 문자열, 또는 데이터 프레임을 위한 행 이름을 주는 문자 또는 정수 벡터입니다. check.rows = : FALSE 값이 디폴트 값. TRUE이면, 행들에 대한 길이와 이름에 대한 일관성 검토하고 위배되면 데이터 프레임을 생성하지 않습니다. check.names = : 논리값. TRUE이면 데이터 프레임에 있는 변수 이름들이 문법적으로 타당하고 증복이 없는 변수 이름들인지 검토합니다. 필요하면 (make.names에 의해) 조정됩니다. fix.empty.names = : 논리값 이름이 붙여지지 않은 컬럼(someName = arg 형태로 지정되지 않으면)이 자동으로 생성된 이름이나 name”.”을 가지고 있는지를 나타내는 논리값으로, “” 이름이 유지되어야 하지만 check.names가 false일 때에도 FALSE로 설정되어야 합니다. stringsAsFactors = default.stringsAsFactors() : 버전 4.0.0 이후로 기능이 없어짐. 이전 버전의 경우, 디폴트로 문자 벡터 컬럼의 경우 factor 형으로 생성되었음. 예를 들어, 앞에서 예를 든 데이터 프레임은 data.frame() 함수를 사용하여 다음과 같이 생성할 수 있습니다. # 4개 열, 5개 행으로 구성된 데이터 프레임을 생성합니다. emp.data &lt;- data.frame(emp_id = c(1:5), # 1번쨰 컬럼 : emp_id emp_name = c(&quot;Rick&quot;,&quot;Dan&quot;,&quot;Michelle&quot;,&quot;Ryan&quot;,&quot;Gary&quot;), # 2번째 컬럼 : emp_name salary = c(623.3,515.2,611.0,729.0,843.25), # 3번쨰 컬럼 : salary start_date = as.Date(c(&quot;2012-01-01&quot;, &quot;2013-09-23&quot;, &quot;2014-11-15&quot;, &quot;2014-05-11&quot;, &quot;2015-03-27&quot;)), # 4번째 컬럼 : start_date stringsAsFactors = FALSE # R 4.0 이후 기본값입니다. ) str(emp.data) # emp.data 데이터 프레임의 구조를 반환합니다. ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ emp_id : int 1 2 3 4 5 ## $ emp_name : chr &quot;Rick&quot; &quot;Dan&quot; &quot;Michelle&quot; &quot;Ryan&quot; ... ## $ salary : num 623 515 611 729 843 ## $ start_date: Date, format: &quot;2012-01-01&quot; &quot;2013-09-23&quot; ... 위의 예에서 emp.data는 각각 5 개의 요소를 갖는(5개 행) 4 개의 벡터(emp_id, emp_name, salary, start_date)로 구성된(4개 열) 리스트로 볼 수 있 수 있습니다. 그런데 마지막에 있는 stringsAsFactors = 인수는 컬럼에 있는 문자형 벡터를 요인(factor)로 변환할 것인지를 설정하는 옵션입니다. R 버전이 4.0 이전에는 이 인수의 기본값이 TRUE로 되어 있었지만, R 버전 4.0 이후에는 FALSE를 기본값으로 하고 있습니다. 10.1.1 열 이름을 지정하지 않으면 그런데 데이터 프레임을 생성할 때 컬럼 명을 지정하지 않으면 어떻게 될까요? 예를 들어, df1 데이터 프레임이 두 개의 컬럼으로 구성되어 있는데 이름을 지정하지 않고 싶다면 다음과 같이 컬럼의 이름을 지정하지 않고 데이터만 지정해 주면 됩니다. df1 &lt;- data.frame(letters[1:5], LETTERS[11:15]) # 컬럼 명을 지정하지 않고 데이터 프레임을 생성합니다. str(df1) # 컬럼 명을 데이터 부분을 반영하여 자동생성함을 알 수 있습니다. ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.1.5. : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ LETTERS.11.15.: chr &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; ... df1 # df1의 데이터를 확인합니다. ## letters.1.5. LETTERS.11.15. ## 1 a K ## 2 b L ## 3 c M ## 4 d N ## 5 e O 데이터 프레임의 각 구성 요소(컬럼)의 이름을 지정하지 않으면 각 구성 요소의 데이터가 하나의 변수로 변환됨을 알 수 있습니다. 따라서 이러한 일이 일어나지 않게 각 구성요소(컬럼)에 대한 이름을 지정해 주는 것이 좋습니다. 혹시 컬럼의 이름을 그래도 지정하고 싶지 않은 경우에는 fix.empty.names = FALSE 옵션을 지정해 주면, 컬럼명이 자동생성되지 않고 공란(“”)으로 남게 할 수 있습니다. df2 &lt;- data.frame(letters[1:5], LETTERS[11:15], fix.empty.names = FALSE) str(df2) # 컬럼 명을 데이터 부분을 반영하여 자동생성함을 알 수 있습니다. ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ : chr &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; ... df2 ## ## 1 a K ## 2 b L ## 3 c M ## 4 d N ## 5 e O # 컬럼 이름을 지정하려면 colnames() 함수를 이용합니다. colnames(df2) &lt;- c(&quot;No&quot;, &quot;Char&quot;) # 컬럼 이름을 설정합니다. str(df2) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ No : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ Char: chr &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; ... colnames() 함수를 이용하면 각 컬럼의 이름을 설정할 수 있습니다. 10.1.2 같은 컬럼명이 있는 경우 만일 다음의 예에서와 같이 데이터 프레임을 생성할 때 컬럼의 이름이 같은 것이 있는 경우는 어떻게 될까요? R의 data.frame() 함수는 데이터 프레임의 컬럼명이 같은 것이 있는 경우 컬럼명을 자동으로 수정합니다. # df3의 컬럼이 모두 a로 설정되어 있습니다. df3 &lt;- data.frame(a = letters[1:5], a = LETTERS[11:15]) str(df3) # 두 번째 컬럼명이 a.1으로 자동변경되어 있씁니다. ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ a : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ a.1: chr &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; ... df3 ## a a.1 ## 1 a K ## 2 b L ## 3 c M ## 4 d N ## 5 e O 즉, 데이터 프레임을 생성할 때 data.frame() 함수는 컬럼의 이름을 확인해 보고 같은 이름이 있으면 그 이름을 자동으로 변경해 줍니다. 그럼에도 만일 컬럼 이름을 그대로 같은 이름으로 남기고 싶다면 check.names = 인수를 FALSE로 설정해 주면 됩니다. # df4의 컬럼이 모두 a로 설정하고 싶습니다. df4 &lt;- data.frame(a = letters[1:5], a = LETTERS[11:15], check.names = TRUE) # 컬럼 이름을 지정한 대로 설정합니다. str(df4) # 두 번째 컬럼명도 a로 남아 있습니다. ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ a : chr &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... ## $ a.1: chr &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; ... df4 ## a a.1 ## 1 a K ## 2 b L ## 3 c M ## 4 d N ## 5 e O 10.1.3 행의 이름을 지정하기 데이터 프레임은 열을 구성 요소로 하고 각 열의 요소 값들이 결합하여 하나의 행을 이루게 됩니다. 데이터 프레임을 생성할 때 열의 이름과 함께 행의 이름도 설정할 수 있습니다. 이 때 사용하는 인수는 row.names = 입니다. df5 &lt;- data.frame(a = letters[1:5], b = LETTERS[11:15], row.names = &quot;a&quot;) # 구성 요소 a는 컬럼이 아닌 행의 이름에 이용됩니다. str(df5) ## &#39;data.frame&#39;: 5 obs. of 1 variable: ## $ b: chr &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; ... df5 ## b ## a K ## b L ## c M ## d N ## e O df5는 row.names = “a”를 인수로 하고 있습니다. 즉, a 구성 요소는 열이 아닌 행 이름으로 활용되도록 지정하고 있는 것입니다. 따라서 df5의 구조를 보면 열이 b 하나인 데이터 프레임임을 알 수 있습니다. 데이터를 확인해 보면 a의 요소들이 행 번호 대신에 출력되어 있음을 알 수 있습니다. 위의 예에서 row.names = 인수의 값을 “b”로 변경해서 실행을 해 보기 바랍니다. 10.1.4 컬럼의 길이가 다른 경우 데이터 프레임은 기본적으로 생김새가 사각형 형태여야 합니다. 열을 구성하는 각 요소의 길이가 같아야 한다는 것이 전제되어 있습니다. 따라서 각 열의 길이가 다른 데이터 프레임은 data.frame() 함수로 생성할 수 없습니다. 다음과 같이 a컬럼은 요소가 6개, b컬럼은 요소가 5개로 지정되는 경우 data.frame() 함수는 error를 발생시킵니다. # 다음과 같이 각 열의 길이가 다른 경우 error가 발생합니다. df6 &lt;- data.frame(a = 1:6, # a 컬럼의 길이가 6입니다. b = letters[1:5]) # b 컬럼의 길이는 5입니다. ## Error in data.frame(a = 1:6, b = letters[1:5]): arguments imply differing number of rows: 6, 5 이러한 데이터 구조를 만들고 싶다면, 리스트 구조를 이용해야 한다. read.table(), read.csv(), read.delim(), read.fwf()와 같은 R의 많은 데이터 입력 함수는 데이터 프레임으로 데이터를 읽습니다.12 제3부 제1장에서 자세히 살펴보겠습니다 "],["데이터-프레임의-구조.html", "10.2 데이터 프레임의 구조", " 10.2 데이터 프레임의 구조 데이터 프레임의 구조 즉 행과 열에 대한 정보를 파악하는 것은 매우 중요합니다. 데이터 프레임의 구조는 str() 함수를 사용하여 확인할 수 있습니다. 앞에서 살펴보았던 예를 다시 한번 더 살표 보겠습니다. # 4개 열, 5개 행으로 구성된 데이터 프레임을 생성합니다. emp.data1 &lt;- data.frame(emp_id = c(1:5), # 1번쨰 컬럼 : emp_id emp_name = c(&quot;Rick&quot;,&quot;Dan&quot;,&quot;Michelle&quot;,&quot;Ryan&quot;,&quot;Gary&quot;), # 2번째 컬럼 : emp_name salary = c(623.3,515.2,611.0,729.0,843.25), # 3번쨰 컬럼 : salary start_date = as.Date(c(&quot;2012-01-01&quot;, &quot;2013-09-23&quot;, &quot;2014-11-15&quot;, &quot;2014-05-11&quot;, &quot;2015-03-27&quot;)), # 4번째 컬럼 : start_date stringsAsFactors = TRUE # 문자형 컬럼인 emp_name을 요인형으로 변환합니다. ) # emp.data의 구조를 확인합니다. str(emp.data1) ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ emp_id : int 1 2 3 4 5 ## $ emp_name : Factor w/ 5 levels &quot;Dan&quot;,&quot;Gary&quot;,&quot;Michelle&quot;,..: 4 1 3 5 2 ## $ salary : num 623 515 611 729 843 ## $ start_date: Date, format: &quot;2012-01-01&quot; &quot;2013-09-23&quot; ... # head() 함수와 tail() 함수를 이용하여 emp.data의 앞 부분의 데이터와 뒷 부분의 데이터를 확인할 수 있습니다 head(emp.data1) # head() 함수는 앞의 6개 행을 보여줍니다. ## emp_id emp_name salary start_date ## 1 1 Rick 623.30 2012-01-01 ## 2 2 Dan 515.20 2013-09-23 ## 3 3 Michelle 611.00 2014-11-15 ## 4 4 Ryan 729.00 2014-05-11 ## 5 5 Gary 843.25 2015-03-27 tail(emp.data1) # tail() 함수는 뒤의 6개 행을 보여줍니다. ## emp_id emp_name salary start_date ## 1 1 Rick 623.30 2012-01-01 ## 2 2 Dan 515.20 2013-09-23 ## 3 3 Michelle 611.00 2014-11-15 ## 4 4 Ryan 729.00 2014-05-11 ## 5 5 Gary 843.25 2015-03-27 "],["데이터-프레임의-통계적-요약-정보.html", "10.3 데이터 프레임의 통계적 요약 정보", " 10.3 데이터 프레임의 통계적 요약 정보 summary() 함수를 적용하여 통계 요약 및 데이터의 특성을 파악할 수도 있습니다. summary(emp.data1) # emp.data의 통계 요약정보를 반환합니다. ## emp_id emp_name salary start_date ## Min. :1 Dan :1 Min. :515.2 Min. :2012-01-01 ## 1st Qu.:2 Gary :1 1st Qu.:611.0 1st Qu.:2013-09-23 ## Median :3 Michelle:1 Median :623.3 Median :2014-05-11 ## Mean :3 Rick :1 Mean :664.4 Mean :2014-01-14 ## 3rd Qu.:4 Ryan :1 3rd Qu.:729.0 3rd Qu.:2014-11-15 ## Max. :5 Max. :843.2 Max. :2015-03-27 summary() 함수는 emp.data1을 구성하고 있는 각 컬럼별로 통계적 요약정보를 반환합니다. emp_id, salary 그리고 start_date 등과 같은 숫자형과 날짜형 컬럼에 대하여는최솟갑, 최댓갑, 평균값 그리고 4분위수 등의 통계적 요약정보를 반환합니다. 반면에 문자형 컬럼의 경우는 데이터의 갯수, 클래스 그리고 모드 등을 반환합니다. 그리고 요인형 컬럼인 경우는 도수 분포(frequency)에 대한 정보를 반환합니다. "],["데이터-프레임의-구성요소에-접근하기.html", "10.4 데이터 프레임의 구성요소에 접근하기", " 10.4 데이터 프레임의 구성요소에 접근하기 데이터 프레임의 구성요소(행과 열)에 접근하는 방법에는 리스트식 접근 또는 행렬식 접근 방법이 있습니다. 10.4.1 리스트 접근 데이터 프레임의 컬럼(열)에 대한 접근은 리스트처럼 [ ], [[]], 또는 $ 등을 이용하여 접근할 수 있습니다. 이러한 데이터 프레임 컬럼의 접근 결과를 변수 할당연산자로 할당하면 이것을 컬럼을 선택(select)한다고 합니다. ## []를 이용하여 데이터 프레임의 컬럼에 접근할 수 있습니다. ## 반환되는 결과들은 &quot;데이터 프레임&quot;의 구조입니다. emp.data1[c(1, 3)] # 컬럼의 위치를 정수형 벡터로 표현할 수 있습니다. emp.data1[c(&quot;emp_id&quot;, &quot;salary&quot;)] # 문자형 벡터로 표현할 수 있습니다. emp.data1[c(F, T, F, F)] # 논리형 벡터로 표현할 수 있습니다. ## [[]]를 이용하여 데이터 프레임의 특정 컬럼에 접근할 수 있습니다. ## 반환되는 결과는 &quot;벡터&quot; 구조입니다. emp.data1[[2]] # 컬럼의 위치를 정수형으로 지정합니다. emp.data1[[&quot;emp_name&quot;)]] # 원하는 컬럼의 이름을 문자열로 지정합니다. emp.data1[[c(F, T, F, F)]] # 논리형 벡터로는 특정 컬럼을 지정할 수 없습니다. ## $기호를 이용하여 데이터 프레임의 특정 컬럼에 접근하기 위해서는 컬럼의 이름을 지정합니다. ## 반환되는 결과는 &quot;벡터&quot; 구조입니다. emp.data1$&quot;emp_name&quot; # 원하는 컬럼의 이름을 문자열로 지정합니다. ## Error: &lt;text&gt;:10:22: 예기치 않은 &#39;)&#39;입니다 ## 9: emp.data1[[2]] # 컬럼의 위치를 정수형으로 지정합니다. ## 10: emp.data1[[&quot;emp_name&quot;) ## ^ [[또는 $ 기호를 이용한 접근은 유사한 면이 있습니다. [로 접근하면 복수 개의 컬럼에 접근할 수 있고 접근한 결과를 데이터 프레임 구조로 결과를 반환하는 반면에 [[]]와 $ 를 이용하면 하나의 컬럼에 대해서만 접근할 수 있고 그 결과를 벡터로 반환한다는 점에서 차이점이 있습니다. 10.4.2 행렬 접근 데이터 프레임은 행과 열에 대한 인덱스를 제공하고 있기 때문에 행렬처럼 액세스 할 수도 있습니다. 이를 설명하기 위해 R에서 이미 사용 가능한 데이터 세트를 사용합니다. 사용 가능한 데이터 세트는 명령 library(help = \"datasets\") 또는 data() 함수로 나열 할 수 있습니다. library(help = &quot;datasets&quot;) # 또는 data() ## 특정 패키지에서 제공하는 데이터 세트를 확인할 수도 있습니다. (예; nycflights13 패키지) data(package=&quot;nycflights13&quot;) # nycflights13 패키지에 있는 데이터 세트를 보여 줍니다. 다음에서는 trees 데이터 세트를 이용해서 행렬식 접근을 해 보겠습니다. 이 trees 데이터 세트는 검은 체리 나무의 둘레(Girth), 높이(Height) 그리고 부피(Volume)에 대한 데이터를 포함하고 있습니다. # trees 데이터 세트의 구조를 파악합니다. str(trees) # 31개의 행과 3개의 컬럼으로 구성된 것을 확인할 수 있습니다. ## &#39;data.frame&#39;: 31 obs. of 3 variables: ## $ Girth : num 8.3 8.6 8.8 10.5 10.7 10.8 11 11 11.1 11.2 ... ## $ Height: num 70 65 63 72 81 83 66 75 80 75 ... ## $ Volume: num 10.3 10.3 10.2 16.4 18.8 19.7 15.6 18.2 22.6 19.9 ... # 데이터를 확인합니다. head(trees, 3) # 데이터 세트의 앞에 있는 3개의 데이터를 확인합니다. ## Girth Height Volume ## 1 8.3 70 10.3 ## 2 8.6 65 10.3 ## 3 8.8 63 10.2 tail(trees, 5) # 데이터 세트의 맨 뒤에 있는 5개의 데이터를 확인합니다. ## Girth Height Volume ## 27 17.5 82 55.7 ## 28 17.9 80 58.3 ## 29 18.0 80 51.5 ## 30 18.0 80 51.0 ## 31 20.6 87 77.0 ## 행렬식 접근을 해 보겠습니다. # 행의 접근 trees[2:3,] # 2번째, 3번째 행의 모든 컬럼을 반환합니다. (정수형 벡터) ## Girth Height Volume ## 2 8.6 65 10.3 ## 3 8.8 63 10.2 trees[trees$Height &gt; 82,] # Height 컬럼의 조건( &gt; 82)을 만족하는 행을 반환합니다. ## Girth Height Volume ## 6 10.8 83 19.7 ## 17 12.9 85 33.8 ## 18 13.3 86 27.4 ## 31 20.6 87 77.0 # 이러한 행의 선택을 필터링한다고 합니다. (filtering) # 열의 접근 trees[ , 2:3] # 2번째, 3번째 열의 모든 행을 반환합니다 (selection) ## Height Volume ## 1 70 10.3 ## 2 65 10.3 ## 3 63 10.2 ## 4 72 16.4 ## 5 81 18.8 ## 6 83 19.7 ## 7 66 15.6 ## 8 75 18.2 ## 9 80 22.6 ## 10 75 19.9 ## 11 79 24.2 ## 12 76 21.0 ## 13 76 21.4 ## 14 69 21.3 ## 15 75 19.1 ## 16 74 22.2 ## 17 85 33.8 ## 18 86 27.4 ## 19 71 25.7 ## 20 64 24.9 ## 21 78 34.5 ## 22 80 31.7 ## 23 74 36.3 ## 24 72 38.3 ## 25 77 42.6 ## 26 81 55.4 ## 27 82 55.7 ## 28 80 58.3 ## 29 80 51.5 ## 30 80 51.0 ## 31 87 77.0 # 행과 열의 동시 접근 trees[10:12,2] # 10~12번째의 2번깨 컬럼 값을 반환합니다. (벡터 반환) ## [1] 75 79 76 trees[10:12, 2, drop = FALSE] # 데이터 프레임으로 반환합니다. ## Height ## 10 75 ## 11 79 ## 12 76 한 개의 컬럼에 대하여 반환할 때는 그 결과가 벡터 형으로 반환됩니다. 이를 데이터 프레임 형태로 반환하고 싶을 때에는 drop = FALSE 인수를 설정해 주면 됩니다. "],["데이터-프레임의-서브-세팅.html", "10.5 데이터 프레임의 서브 세팅", " 10.5 데이터 프레임의 서브 세팅 지금까지 살펴본 바와 같이 데이터 프레임은 리스트 접근방법과 행렬 접근 방법으로 접근할 수 있습니다. 그런데 데이터 프레임에 접근할 결과를 하나의 변수에 할당연산자(&lt;-)를 이용하여 할당하면 데이터 프레임의 서브세팅(subsetting)이 됩니다. 데이터 프레임의 서브세팅은 컬럼 중심의 서브 세팅과 행 중심의 서브 세팅으로 나누어 볼 수 있습니다. 컬럼 중심의 서브 세팅을 selection(선택)이라 하고, 행 중심의 서브 세팅을 필터링(filtering) 이라고 합니다. ## 열을 서브세팅해 보겠습니다. : selection trees.2.3 &lt;- trees[ , 2:3] # 2번째, 3번째 컬럼을 서브 세팅합니다. trees.2.3 ## Height Volume ## 1 70 10.3 ## 2 65 10.3 ## 3 63 10.2 ## 4 72 16.4 ## 5 81 18.8 ## 6 83 19.7 ## 7 66 15.6 ## 8 75 18.2 ## 9 80 22.6 ## 10 75 19.9 ## 11 79 24.2 ## 12 76 21.0 ## 13 76 21.4 ## 14 69 21.3 ## 15 75 19.1 ## 16 74 22.2 ## 17 85 33.8 ## 18 86 27.4 ## 19 71 25.7 ## 20 64 24.9 ## 21 78 34.5 ## 22 80 31.7 ## 23 74 36.3 ## 24 72 38.3 ## 25 77 42.6 ## 26 81 55.4 ## 27 82 55.7 ## 28 80 58.3 ## 29 80 51.5 ## 30 80 51.0 ## 31 87 77.0 ## 행을 서브세팅해 보겠습니다. 필터링(filtering) trees.fil &lt;- trees[trees$Height &gt; 82, ] # Height 컬럼의 조건을 만족시키는 행만 필터링합니다. trees.fil ## Girth Height Volume ## 6 10.8 83 19.7 ## 17 12.9 85 33.8 ## 18 13.3 86 27.4 ## 31 20.6 87 77.0 이러한 선택과 필터링은 데이터 관리를 위한 dplyr 패키지의 select() 함수와 filter() 함수로 더 정밀하게 수행할 수 있습니다. "],["데이터-프레임에-행열의-확장.html", "10.6 데이터 프레임에 행/열의 확장", " 10.6 데이터 프레임에 행/열의 확장 데이터 프레임에 열과 행을 추가하여 데이터 프레임을 확장할 수 있습니다. 10.6.1 열 추가 새 열 이름을 사용하여 열 벡터를 추가하기 만하면 됩니다. # emp.data 데이터 프레임에 dept 컬럼을 추가해 보겠습니다. # emp.data를 v변수에 복사하겠습니다. v &lt;- emp.data # 이제 v 변수에 dept 컬럼을 추가헤 보겠습니다. v$dept &lt;- c(&quot;IT&quot;,&quot;Operations&quot;,&quot;IT&quot;,&quot;HR&quot;,&quot;Finance&quot;) # 변화된 v의 구조를 확인해 봅니다. str(v) ## &#39;data.frame&#39;: 5 obs. of 5 variables: ## $ emp_id : int 1 2 3 4 5 ## $ emp_name : chr &quot;Rick&quot; &quot;Dan&quot; &quot;Michelle&quot; &quot;Ryan&quot; ... ## $ salary : num 623 515 611 729 843 ## $ start_date: Date, format: &quot;2012-01-01&quot; &quot;2013-09-23&quot; ... ## $ dept : chr &quot;IT&quot; &quot;Operations&quot; &quot;IT&quot; &quot;HR&quot; ... 10.6.2 행 추가 기존 데이터 프레임에 더 많은 행을 영구적으로 추가하려면 기존 데이터 프레임과 동일한 구조로 새 행을 가져와 rbind() 함수를 사용해야 합니다. 아래 예에서는 새 행이 있는 데이터 프레임을 만들고 기존 데이터 프레임과 병합하여 최종 데이터 프레임을 만듭니다. # 첫 번째 데이터 프레임입니다. emp.data &lt;- data.frame( emp_id = c(1:5), emp_name = c(&quot;Rick&quot;,&quot;Dan&quot;,&quot;Michelle&quot;,&quot;Ryan&quot;,&quot;Gary&quot;), salary = c(623.3,515.2,611.0,729.0,843.25), start_date = as.Date(c(&quot;2012-01-01&quot;, &quot;2013-09-23&quot;, &quot;2014-11-15&quot;, &quot;2014-05-11&quot;, &quot;2015-03-27&quot;)), dept = c(&quot;IT&quot;,&quot;Operations&quot;,&quot;IT&quot;,&quot;HR&quot;,&quot;Finance&quot;), stringsAsFactors = TRUE ) # 추가할 데이터를 담고 이는 데이터 프레임입니다. emp.newdata &lt;- data.frame( emp_id = c(6:8), emp_name = c(&quot;Rasmi&quot;,&quot;Pranab&quot;,&quot;Tusar&quot;), salary = c(578.0,722.5,632.8), start_date = as.Date(c(&quot;2013-05-21&quot;,&quot;2013-07-30&quot;,&quot;2014-06-17&quot;)), dept = c(&quot;IT&quot;,&quot;Operations&quot;,&quot;Fianance&quot;), stringsAsFactors = TRUE ) # emp.data 밑에 emp.newdata를 결합한 후, emp.finaldata 변수에 복사합니다. emp.finaldata &lt;- rbind(emp.data, emp.newdata) # 결합된 데이터를 확인합니다. 총 8개 행, 5개 열로 구성되어 있습니다. emp.finaldata ## emp_id emp_name salary start_date dept ## 1 1 Rick 623.30 2012-01-01 IT ## 2 2 Dan 515.20 2013-09-23 Operations ## 3 3 Michelle 611.00 2014-11-15 IT ## 4 4 Ryan 729.00 2014-05-11 HR ## 5 5 Gary 843.25 2015-03-27 Finance ## 6 6 Rasmi 578.00 2013-05-21 IT ## 7 7 Pranab 722.50 2013-07-30 Operations ## 8 8 Tusar 632.80 2014-06-17 Fianance 10.6.3 열과 행의 삭제 데이터 프레임 열은 NULL을 할당하여 데이터 프레임에서 삭제할 수 있으며, 마찬가지로 행은 (-)기호를 이용하여 서브세팅함으로써 삭제할 수 있습니다. # 다음과 같은 데이터 프레임이 있다고 생각하겠습니다. x &lt;- data.frame(&quot;SN&quot; = 1:2, &quot;Age&quot; = c(21,15), &quot;Name&quot; = c(&quot;John&quot;,&quot;Dora&quot;)) str(x) ## &#39;data.frame&#39;: 2 obs. of 3 variables: ## $ SN : int 1 2 ## $ Age : num 21 15 ## $ Name: chr &quot;John&quot; &quot;Dora&quot; # 열을 삭제할 수 있습니다. # SN 컬럼을 x에서 제거해 보겠습니다. x$SN &lt;- NULL # SN 컬럼에 NULL 값을 할당합니다. str(x) # x 데이터 프레임에서 SN 컬럼이 삭제되었습니다. ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ Age : num 21 15 ## $ Name: chr &quot;John&quot; &quot;Dora&quot; # 열을 삭제할 수 있습니다. x &lt;- x[x$Age &gt;= 16, ] # Age 컬럼의 값이 16보다 작은 행은 삭제합니다. x # 데이터를 확인해 봅니다. ## Age Name ## 1 21 John "],["데이터-프레임의-행과-열의-이름-확인변경하기.html", "10.7 데이터 프레임의 행과 열의 이름 확인/변경하기", " 10.7 데이터 프레임의 행과 열의 이름 확인/변경하기 10.7.1 열 이름 확인/변경하기 데이터 프레임에서 가장 중요한 요소는 열입니다. 이 열의 이름은 colnames() 또는 names()함수를 이용하여 확인할 수 있고, 언제든지 변경할 수 있습니다. # trees 데이터 세트의 컬럼의 이름을 확인합니다. colnames(trees) ## [1] &quot;Girth&quot; &quot;Height&quot; &quot;Volume&quot; names(trees) ## [1] &quot;Girth&quot; &quot;Height&quot; &quot;Volume&quot; # trees 데이터 세트의 컬럼 이름을 변경합니다. colnames(trees) &lt;- c(&quot;둘레&quot;, &quot;높이&quot;, &quot;부피&quot;) colnames(trees) # 변경된 컬럼의 이름을 확인합니다. ## [1] &quot;둘레&quot; &quot;높이&quot; &quot;부피&quot; 10.7.2 행 이름 확인/변경하기 데이터 프레임에서 행의 이름은 열의 이름만큰 중요하지은 않습니다. 그래도 rownames() 함수를 이용하여 행의 이름을 확인할 수 있고 행의 이름을 설정할 수 있습니다. # trees 데이터 세트의 행의 이름을 확인합니다. rownames(trees) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; ## [16] &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; ## [31] &quot;31&quot; # trees 데이터 세트의 행 이름을 지정합니다. rownames(trees) &lt;- paste0(&quot;Row#-&quot;, 1:31) rownames(trees) ## [1] &quot;Row#-1&quot; &quot;Row#-2&quot; &quot;Row#-3&quot; &quot;Row#-4&quot; &quot;Row#-5&quot; &quot;Row#-6&quot; &quot;Row#-7&quot; ## [8] &quot;Row#-8&quot; &quot;Row#-9&quot; &quot;Row#-10&quot; &quot;Row#-11&quot; &quot;Row#-12&quot; &quot;Row#-13&quot; &quot;Row#-14&quot; ## [15] &quot;Row#-15&quot; &quot;Row#-16&quot; &quot;Row#-17&quot; &quot;Row#-18&quot; &quot;Row#-19&quot; &quot;Row#-20&quot; &quot;Row#-21&quot; ## [22] &quot;Row#-22&quot; &quot;Row#-23&quot; &quot;Row#-24&quot; &quot;Row#-25&quot; &quot;Row#-26&quot; &quot;Row#-27&quot; &quot;Row#-28&quot; ## [29] &quot;Row#-29&quot; &quot;Row#-30&quot; &quot;Row#-31&quot; "],["컬럼의-데이터-타입-변환.html", "10.8 컬럼의 데이터 타입 변환", " 10.8 컬럼의 데이터 타입 변환 10.8.1 컬럼의 데이터 타입 확인 컬럼의 데이터 타입은 str() 함수로도 확인할 수 있습니다. 또한 다음의 함수들을 사용하여 데이터 타입을 손쉽게 확인할 수 있습니다. 함수 설명 is.factor(x) 주어진 객체 x가 팩터인가 is.numeric(x) 주어진 객체 x가 숫자를 저장한 벡터인가 is.character(x) 주어진 객체 x가 문자열을 저장한 벡터인가 is.matrix(x) 주어진 객체 x가 행렬인가 is.array(x) 주어진 객체 x가 배열인가 is.data.frame(x) 주어진 객체 x가 데이터 프레임인가 10.8.2 데이터 구조의 변환 10.8.2.1 리스트를 데이터 프레임으로 변환하기 리스트 구조의 데이터 경우, 각 요소의 길이가 같다면 data.frame() 함수 또는 as.data.frame() 함수를 이용하여 데이터 프레임으로 변경할 수 있습니다. lst &lt;- list(x=c(1,2),y=c(&quot;A&quot;,&quot;B&quot;)) df1 &lt;- as.data.frame(lst); str(df1) ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ x: num 1 2 ## $ y: chr &quot;A&quot; &quot;B&quot; 10.8.2.2 행렬을 데이터 프레임으로 변환하기 행렬의 경우는 각 열의 길이가 같기 때문에 data.frame() 함수 또는 as.data.frame() 함수를 이용하여 데이터 프레임으로 변경할 수 있습니다. mat &lt;- matrix(c(1,2,3,4), ncol=2) df2 &lt;- data.frame(mat); str(df2) ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ X1: num 1 2 ## $ X2: num 3 4 10.8.3 열의 데이터 구조 변환 10.8.3.1 문자형 벡터를 요인으로 , 요인을 문자형 벡터로 변환하기 df1 과 같은 경우 y 컬럼이 문자형으로 되어 있습니다. 이를 as.factor() 함수를 이용하여 요인형으로 변환할 수 있습니다. 요인형으로 변환한 다음, factor() 함수를 이용 levels 인수를 설정하여 레벨의 순서를 바꿀 수도 있으며, ordered 함수를 이용하여 서열형으로도 변경할 수 있습니다. # df1의 문자형 y 컬럼을 요인형으로 강제 변환합니다 df1$y &lt;- as.factor(df1$y) # y 컬럼을 요인형으로 변경합니다. str(df1) # 변경된 구조를 확인합니다. ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ x: num 1 2 ## $ y: Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 2 # levels 인수를 이용하여 y 컬럼의 수준 순서를 바꿀 수 있습니다. df1$y &lt;- factor(df1$y, levels = c(&quot;B&quot;, &quot;A&quot;)) str(df1) ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ x: num 1 2 ## $ y: Factor w/ 2 levels &quot;B&quot;,&quot;A&quot;: 2 1 # ordered() 함수를 이용하여 y 컬럼을 서열형 요인으로 변환할 수 있습니다. df1$y &lt;- ordered(df1$y, c(&quot;B&quot;, &quot;A&quot;) ) str(df1) ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ x: num 1 2 ## $ y: Ord.factor w/ 2 levels &quot;B&quot;&lt;&quot;A&quot;: 2 1 # y 컬럼을 요인형에서 다시 문자형으로 변환해 보겠습니다. df1$y &lt;- as.character(df1$y) str(df1) ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ x: num 1 2 ## $ y: chr &quot;A&quot; &quot;B&quot; 이러한 컬럼의 데이터 유형 변환은 제2부 제2장에서 살펴본 벡터의 데이터 유형 강제 변환을 참고하기 바랍니다. 10.8.4 데이터 구조의 변환 함수 한편 지금까지 살펴본 벡터, 요인, 행렬, 배열, 리스트 그리고 데이터 프레임 간의 데이터 구조 변환은 다음의 함수들을 이용할 수 있습니다. 함수 의미 as.factor(x) 주어진 객체 x를 팩터로 변환 as.numeric(x) 주어진 객체 x를 숫자를 저장한 벡터로 변환 as.character(x) 주어진 객체 x를 문자열을 저장한 벡터로 변환 as.matrix(x) 주어진 객체 x를 행렬로 변환 as.array(x) 주어진 객체 x를 배열로 변환 as.data.frame(x) 주어진 객체 x를 데이터 프레임으로 변환 "],["데이터-프레임의-재구성.html", "10.9 데이터 프레임의 재구성", " 10.9 데이터 프레임의 재구성 https://www.tutorialspoint.com/r/r_data_reshaping.htm R에서 데이터 프레임의 재구성(reshaping)은 데이터가 행과 열로 조직된 방식을 변경하는 것입니다. R에서 대부분의 데이터 처리는 입력 데이터를 데이터 프레임으로 사용하여 수행됩니다. 데이터 프레임의 행과 열에서 데이터를 추출하는 것은 쉽지만 데이터 프레임을 원래의 형식과 다른 형식의 데이터 프레임으로 변형할 필요가 있는 경우가 있습니다. R에는 데이터 프레임에서 열의 분할(split)과 병합(merge) 그리고 행을 열로 변경하는 많은 함수들이 있습니다. 10.9.1 데이터 프레임의 열과 행의 결합 cbind() 함수를 사용하여 여러 벡터를 결합하여 데이터 프레임을 만들 수 있고, 또한 rbind() 함수를 사용하여 두 개의 데이터 프레임을 병합할 수 있음을 우리는 이미 살펴 보았습니다. 이러한 행과 열의 결합을 통해 데이터 프레임을 재구성할 수 있습니다. 10.9.2 데이터 프레임의 병합 merge() 함수를 사용하여 서로 다른 구조를 갖는 두 개의 데이터 프레임을 공통을 컬럼을 이용하여 병합할 수 있습니다. 데이터 프레임은 병합이 발생하는 두 데이터 프레임에는 공통의 열이 있어야 합니다. merge() 함수의 형식은 다음과 같습니다. merge(x, y, by = intersect(names(x), names(y)), by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all, sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE, incomparables = NULL, ...) x, y : 병합할 데이터 프레임 by, by.x, by.y : 병합에 사용할 컬럼을 지정합니다. all : 기본값은 FALSE. by에 지정된 공통 컬럼에 부합하는 행만 선택한다. all.x, all.y : TRUE 값으로 지정하면, 병합할 조건과 일치하지 않더라도 모든 x행(또는 y 행)을 추가한다. FALSE이면 병합 조건과 일치하는 행만 추가한다. 예를 들어 학생들의 중간고사 성적과 기말고사 성적을 별도의 데이터 프레임으로 생성하였다고 생각해 보겠습니다. 학기말에 성적을 처리하려면 이 두 개의 데이터 프레임을 병합하여 하나의 데이터 프레임으로 만들어야 합니다. # 두 개의 데이터 프레임이 있습니다. mid &lt;- data.frame(name = c(&quot;Kim&quot;, &quot;Lee&quot;, &quot;Park&quot;, &quot;Choi&quot;, &quot;Hwang&quot;), mid.score = c(95, 80, 88, 92, 76)) str(mid) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ name : chr &quot;Kim&quot; &quot;Lee&quot; &quot;Park&quot; &quot;Choi&quot; ... ## $ mid.score: num 95 80 88 92 76 final &lt;- data.frame(name = c(&quot;Kim&quot;, &quot;Lee&quot;, &quot;Park&quot;, &quot;Hong&quot;, &quot;Choi&quot;), final.score = c(90, 88, 90, 87, 90)) str(final) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ name : chr &quot;Kim&quot; &quot;Lee&quot; &quot;Park&quot; &quot;Hong&quot; ... ## $ final.score: num 90 88 90 87 90 # 이제 두 개의 데이터 프레임으로 병합하겠습니다. # 공통의 컬럼 : name 컬럼 # 두 개의 데이터 프레임에서 name 컬럼의 값이 일치하는 경우에만 병합합니다 grade.inner &lt;- merge(mid, final, by = &quot;name&quot;) # 이러한 경우를 inner join 이라고 합니다. grade.inner # name 컬럼의 같이 일치하는 경우만 병합합니다. ## name mid.score final.score ## 1 Choi 92 90 ## 2 Kim 95 90 ## 3 Lee 80 88 ## 4 Park 88 90 # 중간고사를 본 모든 학생은 병합할 때 모두 포함시킵니다. 기말고사를 보지 않은 학생의 성적은 NA로 출력됩니다. grade.left &lt;- merge(mid, final, by = &quot;name&quot;, all.x = TRUE) grade.left # 이러한 경우를 left join 이라고 합니다. ## name mid.score final.score ## 1 Choi 92 90 ## 2 Hwang 76 NA ## 3 Kim 95 90 ## 4 Lee 80 88 ## 5 Park 88 90 # 기말고사를 본 모든 학생은 병합할 때 모두 포함시킵니다. 중간고사를 보지 않은 학생의 성적은 NA로 출력됩니다. grade.right &lt;- merge(mid, final, by = &quot;name&quot;, all.y = TRUE) grade.right # 이러한 경우를 right join 이라고 합니다. ## name mid.score final.score ## 1 Choi 92 90 ## 2 Hong NA 87 ## 3 Kim 95 90 ## 4 Lee 80 88 ## 5 Park 88 90 # mid와 final에 있는 모든 학생을 병합합니다. 중간고사나 기말고사를 보지 않은 학생의 성적은 NA로 출력됩니다. grade.full &lt;- merge(mid, final, by = &quot;name&quot;, all = TRUE) grade.full # 이러한 경우를 full join 이라고 합니다. ## name mid.score final.score ## 1 Choi 92 90 ## 2 Hong NA 87 ## 3 Hwang 76 NA ## 4 Kim 95 90 ## 5 Lee 80 88 ## 6 Park 88 90 만일 두 데이터 프레임의 공통 컬럼 이름이 다른 경우 by 대신에 by.x와 by.y로 각각 지정해 주면 됩니다. 예를 들어 mid 데이터 프레임의 공통 컬럼이 name이고 final 데이터 프레임의 공통 컬럼이 std_name인 경우 by 대신에 by.x = “name”와 by.y = “std_name”이라고 설정하면 됩니다. 또한, 공통 컬럼이 하나가 아닌 두 개인 경우는 by = c(col1, col2)와 같이 지정해 주면 됩니다. 10.9.3 Melting과 Casting 앞에서 살펴본 grade.full 데이터 프레임의 경우, name 컬럼, mid.score 컬럼 그리고 final.score 컬럼으로 구성이 되어 있습니다. 그런데 사실상mid.score컬럼도 score(점수) 컬럼이고, final.score 컬럼도 score(점수) 컬럼으로 볼 수 있습니다. 다만 mid.score는 시험의 종류(type)가 중간고사이고, final.score는 시험의 종류가 final이 되는 겁니다. 만일 중간고사, 기말고사 이외에도 수시시험이 있거나 출석 점수 등이 있다면 grade.full 의 데이터 프레임에는 그만큼의 열들이 추가되어야 할 것입니다. 그러나 수시시험 점수나 출석 점수도 결국은 점수(score)이며, 다만 시험의 종류(type) 만이 다를 뿐입니다. 이러한 관점에서 볼 때 grade.full과 같이 시험의 종류가 증가하면 데이터 프레임의 열이 증가하는 데이터 테이블을 넓은(wide-format) 데이터 프레임이라고 합니다. 반면에 시험의 종류를 type 컬럼으로 설정하고 시험 점수를 score 컬럼으로 설정한다면 데이터 프레임의 구조에서 보면 열이 늘어나는 것이 아니라 행이 추가될 뿐입니다. 이러한 데이터 프레임을 긴(long-format) 데이터 프레임이라고 합니다. 10.9.3.1 넓은 형식을 긴 형식으로 변환하기 지금의 예제에서와 같이 grade.full과 같은 넓은 데이터 프레임을 긴 데이터 프레임으로 변형하는데 이용하는 함수가 reshape 패키지에 있는 melt() 함수입니다. # 패키지 불러오기 # install.packages(&quot;reshape&quot;) library(reshape) ## ## Attaching package: &#39;reshape&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## rename ## The following objects are masked from &#39;package:tidyr&#39;: ## ## expand, smiths grade.molten &lt;- melt(grade.full, id = c(&quot;name&quot;)) # name 컬럼을 중심으로 long format으로 변환합니다. grade.molten # variable과 value 컬럼이 생성되었습니다. ## name variable value ## 1 Choi mid.score 92 ## 2 Hong mid.score NA ## 3 Hwang mid.score 76 ## 4 Kim mid.score 95 ## 5 Lee mid.score 80 ## 6 Park mid.score 88 ## 7 Choi final.score 90 ## 8 Hong final.score 87 ## 9 Hwang final.score NA ## 10 Kim final.score 90 ## 11 Lee final.score 88 ## 12 Park final.score 90 str(grade.molten) # variable 컬럼은 factor형 입니다. ## &#39;data.frame&#39;: 12 obs. of 3 variables: ## $ name : chr &quot;Choi&quot; &quot;Hong&quot; &quot;Hwang&quot; &quot;Kim&quot; ... ## $ variable: Factor w/ 2 levels &quot;mid.score&quot;,&quot;final.score&quot;: 1 1 1 1 1 1 2 2 2 2 ... ## $ value : num 92 NA 76 95 80 88 90 87 NA 90 ... grade.full 데이터 프레임을 name 컬럼을 중심으로 melt() 함수를 적용하면, 시험의 종류가 variable 컬럼으로 그리고 시험의 점수가 value 컬럼으로 정리가 됨을 알 수 있습니다. 이때 variable 컬럼에는 mid.score와final.score 등의 컬럼 이름이 문자열 값으로 입력되어 있습니다. 그리고 value 컬럼에는 점수가 데이터로 입력이 되어 있습니다. 특히 variable 컬럼은 요인(factor)형임을 주목하기 바랍니다. 이제 grade.molten 데이터 프레임은 넓은 형식에서 긴 형식의 데이터 프레임으로 재구성이 된 것입니다. tidyr 패키지의 pivot_longer() 함수를 참고하기 바랍니다. 10.9.3.2 긴 형식을 넓은 형식으로 변환하기 한편 긴 형식의 grade.molten 데이터 프레임을 넓은 형식으로 변환할 수 있는데, 이때 reshape 패키지의 cast() 함수를 사용합니다. 다음은 grade.molten 데이터 프레임의 name 컬럼을 기준으로 variable 컬럼에 있는 데이터를 새로운 데이터 프레임의 컬럼으로 설정하고 그 값의 합(sum)을 새로운 컬럼의 데이터로 생성하도록 해 줍니다. # 패키지 불러오기 # install.packages(&quot;reshape&quot;) library(reshape) grade.cast &lt;- cast(grade.molten, name ~ variable, sum) # name 컬럼을 중심으로 long format으로 변환합니다. grade.cast ## name mid.score final.score ## 1 Choi 92 90 ## 2 Hong NA 87 ## 3 Hwang 76 NA ## 4 Kim 95 90 ## 5 Lee 80 88 ## 6 Park 88 90 str(grade.cast) ## List of 3 ## $ name : chr [1:6] &quot;Choi&quot; &quot;Hong&quot; &quot;Hwang&quot; &quot;Kim&quot; ... ## $ mid.score : num [1:6] 92 NA 76 95 80 88 ## $ final.score: num [1:6] 90 87 NA 90 88 90 ## - attr(*, &quot;row.names&quot;)= int [1:6] 1 2 3 4 5 6 ## - attr(*, &quot;idvars&quot;)= chr &quot;name&quot; ## - attr(*, &quot;rdimnames&quot;)=List of 2 ## ..$ :&#39;data.frame&#39;: 6 obs. of 1 variable: ## .. ..$ name: chr [1:6] &quot;Choi&quot; &quot;Hong&quot; &quot;Hwang&quot; &quot;Kim&quot; ... ## ..$ :&#39;data.frame&#39;: 2 obs. of 1 variable: ## .. ..$ variable: Factor w/ 2 levels &quot;mid.score&quot;,&quot;final.score&quot;: 1 2 # grade.cast와 grade.full이 동일한 데이터 프레임인지 setequal() 함수로 확인합니다. setequal(grade.cast, grade.full) # TRUE를 반환하므로 동일한 데이터 프레임입니다. ## [1] TRUE 이제 grade.cast 데이터 프레임은 긴 형식에서 넓은 형식으로 재구성이 된 것입니다. 이 grade.cast 데이터 프레임을 앞에서 생성한 grade.full과 비교해 보면 동일한 데이터 프레임인 것을 알 수 있습니다. tidyr 패키지의 pivot_wider() 함수를 참고하기 바랍니다. "],["티블.html", "Chapter 11 티블", " Chapter 11 티블 티블(Tibbles)는 데이터 프레임이지만 좀 더 쉽게 활용할 수 있게 일부 오래된 동작을 조정하고 있습니다. 이 데이터 구조의 이름은 dplyr 패키지에서 유래했습니다. 원래는 tbl_df() 함수로 이 개체를 만들었는데, 지금은 tibbles 패키지 (tidyverse 패키지에도 자동으로 제공됨)에서 티블을 제공합니다. 이 절은 이러한 티블의 기초를 다루겠습니다. 추가적인 내용은 vignette( \"tibble\")를 참고하기 바랍니다. 여기에서는 다음과 같은 내용을 중심으로 살펴보겠습니다. 티블의 생성 티블과 데이터 프레임의 비교 11.0.1 패키지 불러오기 티블을 사용하기 위해서는 다음 중의 한 방법을 이용하여 tibbles 패키지를 불러옵니다. # 직접 불러올 수 있습니다. # install.packages(&quot;tibble&quot;) library(tibble) # `tidyverse` 패키지 집합을 불러오면 같이 따라 옵니다 : readr, tidyr, dplyr, purrr 패키지들 # install.packages(&quot;tidyverse&quot;) library(tidyverse) "],["티블-생성.html", "11.1 티블 생성", " 11.1 티블 생성 11.1.1 데이터 프레임을 티블로 변환하기 대부분의 다른 R 패키지는 일반 데이터 프레임을 사용하고 있습니다. 따라서 여러분은 이러한 데이터 프레임을 티블로 as_tibble() 함수를 사용하여 강제 변환할 수 있습니다. 예를 들어 R에 내장되어 있는 iris 데이터 세트는 데이터 프레임을 구조를 가지고 있는데, as_tibble() 함수로 이 데이터 세트를 티블로 변환할 수 있습니다. # iris 데이터 세트를 티블로 변환할 수 있습니다. as_tibble(iris) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows 11.1.2 tibble() 함수 tibble() 함수를 사용하여 개별 벡터를 이용하여 새 티블을 생성할 수도 있습니다. 이 때 tibble()은 길이가 1 인 벡터 요소에 대해서는 입력을 자동 반복으로 재활용하고 아래와 같이 티블을 생성하면서 그 구조 안에 정의하고 있는 변수를 참조할 수도 있습니다. # tibble() 함수를 이용하여 x, y, z 세 개의 컬럼으로 구성되는 티블을 생성합니다. tibble( x = 1:5, # 1번째 컬럼 : x y = 1, # 2번째 컬럼 : y (길이가 1입니다 - 다른 컬럼의 요소 길이에 맞춰 자동반복됩니다.) z = x ^ 2 + y # 3번째 컬럼 : z (앞의 x와 y를 참조하고 있습니다) ) ## # A tibble: 5 x 3 ## x y z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2 ## 2 2 1 5 ## 3 3 1 10 ## 4 4 1 17 ## 5 5 1 26 이미 data.frame()에 익숙하겠지만, tibble()은 입력 유형을 절대로 변경시키지 않습니다. 예를 들어, 문자열을 요인(factor)으로 변환하지 않습니다!. 그리고 컬럼의 이름도 변경시키지 않습니다. 행의 이름도 생성하지 않습니다. 티블에 유효한 R 변수 이름 (비구문 이름)이 아닌 열 이름을 가질 수 있습니다. 예를 들어, 문자로 시작하지 않거나 공백과 같은 비정상적인 문자를 포함할 수 있습니다. 다만, 이러한 변수를 참조하려면 백틱 (`)으로 묶어야 합니다. # 티블은 다양한 형태의 컬럼 이름을 가질 수 있습니다. tb &lt;- tibble( `:)` = &quot;smile&quot;, ` ` = &quot;space&quot;, `2000` = &quot;number&quot; ) tb ## # A tibble: 1 x 3 ## `:)` ` ` `2000` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 smile space number 11.1.3 tribble() 함수 ggplot2, dplyr 그리거 tidyr 등과 같은 다른 패키지에서 이러한 변수로 작업하려면 백틱을 사용해야 합니다. 티블을 생성하는 또 다른 방법은 transposed tibble의 줄임말인 tribble() 함수를 사용하는 것입니다. tribble() 함수는 코드의 데이터 입력에 맞게 사용자 정의됩니다. 열 제목은 수식으로 정의되고(즉,~로 시작), 데이터 항목은 쉼표로 구분됩니다. 이를 통해 적은 양의 데이터를 읽기 쉬운 형식으로 배치할 수 있습니다. # tribble() 함수를 이용하여 티블을 생성할 수 있습니다. tribble( ~x, ~y, ~z, # 열 제목을 정의합니다. (열제목은 ~ 기호로 시작합니다.) #--|--|---- # 주석문입니다. &quot;a&quot;, 2, 3.6, # 데이터 행입니다. 각 항목은 쉽표(,)로 구분합니다. &quot;b&quot;, 1, 8.5 ) ## # A tibble: 2 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2 3.6 ## 2 b 1 8.5 #로 시작하는 주석문을 추가하면 열 제목이 있는지 명확하게 알 수 있습니다. "],["데이터-프레임과-티블의-비교.html", "11.2 데이터 프레임과 티블의 비교", " 11.2 데이터 프레임과 티블의 비교 티블과 전통적인 데이터 프레임의 사용에는 화면 출력 형태와 서브 세팅의 두 가지 주요한 차이점이 있습니다. 11.2.1 화면 출력 티블은 화면의 크기에 맞춰 화면에 출력되는 열의 수를 자동제어하고, 데이터 행도 처음 10 개 행만 표시하는 세련된 인쇄 방법이 있습니다. 이렇게 하면 대용량 데이터 작업이 훨씬 쉬워집니다. 이름 외에도 각 열에는 str() 함수에서 차용한 멋진 기능인 각 컬럼의 데이터 유형을 표시해 줍니다. set.seed(1234) tibble( a = lubridate::now() + runif(1e3) * 86400, b = lubridate::today() + runif(1e3) * 30, c = 1:1e3, d = runif(1e3), e = sample(letters, 1e3, replace = TRUE) ) ## # A tibble: 1,000 x 5 ## a b c d e ## &lt;dttm&gt; &lt;date&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2021-02-08 19:34:09 2021-03-05 1 0.114 o ## 2 2021-02-09 07:46:32 2021-02-22 2 0.192 o ## 3 2021-02-09 07:27:47 2021-02-11 3 0.618 r ## 4 2021-02-09 07:48:05 2021-02-18 4 0.599 n ## 5 2021-02-09 13:30:09 2021-03-02 5 0.0619 z ## 6 2021-02-09 08:12:28 2021-02-19 6 0.699 z ## 7 2021-02-08 17:04:06 2021-02-21 7 0.737 u ## 8 2021-02-08 22:25:18 2021-02-11 8 0.0233 o ## 9 2021-02-09 08:49:35 2021-03-08 9 0.759 x ## 10 2021-02-09 05:10:57 2021-03-09 10 0.362 v ## # ... with 990 more rows 티블은 대용량 데이터 프레임을 인쇄할 때 실수로 콘솔에 부담을 주지 않도록 설계되었습니다. 그러나 때로는 기본 디스플레이보다 더 많은 출력이 필요할 수 있는데 이럴 때 사용할 수 있는 몇 가지 옵션이 있습니다. 첫째, 명시적으로 print() 함수를 이용하여 데이터 프레임을 출력할 수 있습니다. 이때 행의 수 (n = 인수)와 화면의 너비를 제어할 수 있습니다. width = Inf 인수를 설정하면 모든 열을 표시합니다. 다음의 예는 nycflights13 패키지에서 제공하고 있는 flights 데이터 세트의 화면 출력을 제어하는 예입니다. # 규모가 큰 티블의 경우 print() 함수에 인수를 설정하여 출력 형식을 변경할 수 있습니다. nycflights13::flights %&gt;% print(n = 10, width = Inf) ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 ## 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 ## 3 33 AA 1141 N619AA JFK MIA 160 1089 5 40 ## 4 -18 B6 725 N804JB JFK BQN 183 1576 5 45 ## 5 -25 DL 461 N668DN LGA ATL 116 762 6 0 ## 6 12 UA 1696 N39463 EWR ORD 150 719 5 58 ## 7 19 B6 507 N516JB EWR FLL 158 1065 6 0 ## 8 -14 EV 5708 N829AS LGA IAD 53 229 6 0 ## 9 -8 B6 79 N593JB JFK MCO 140 944 6 0 ## 10 8 AA 301 N3ALAA LGA ORD 138 733 6 0 ## time_hour ## &lt;dttm&gt; ## 1 2013-01-01 05:00:00 ## 2 2013-01-01 05:00:00 ## 3 2013-01-01 05:00:00 ## 4 2013-01-01 05:00:00 ## 5 2013-01-01 06:00:00 ## 6 2013-01-01 05:00:00 ## 7 2013-01-01 06:00:00 ## 8 2013-01-01 06:00:00 ## 9 2013-01-01 06:00:00 ## 10 2013-01-01 06:00:00 ## # ... with 336,766 more rows 또한 options() 함수내의 인수를 설정하여 기본 인쇄 동작을 제어할 수도 있습니다. options(tibble.print_max = n, tibble.print_min = m): 티블이 m 행 이상이면 n 행만 출력합니다. options (dplyr.print_min = Inf) : 항상 모든 행을 표시합니다. options (tibble.width = Inf) : 화면 너비에 관계없이 항상 모든 열을 인쇄합니다. package? tibble의 패키지 도움말을 보면 전체 옵션 목록을 볼 수 있습니다. 마지막 옵션은 View() 함수를 이용하여 RStudio에 내장되어 있는 데이터 뷰어를 사용하여 전체 데이터 세트를 스크롤 가능한 보기로 보는 것입니다. # View() 함수를 이용하여 규모가 큰 티블을 화면출력할 수 있습니다. nycflights13::flights %&gt;% View() 11.2.2 서브 세팅 단일 변수를 가져 오려면 다른 데이터 구조를 서브 세팅/인덱하는 데 사용한 것과 동일한 $와 [[ 등의 도구가 필요합니다. [[는 이름이나 위치로 추출 할 수 있습니다. $는 이름으로만 추출할 수 있습니다. # 티블을 생성합니다. set.seed(1234) df &lt;- tibble( g = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;A&quot;), x = runif(5), y = rnorm(5) ) # 컬럼의 이름을 이용하여 서브세팅할 수 있습니다. df$x ## [1] 0.1137034 0.6222994 0.6092747 0.6233794 0.8609154 df[[&quot;x&quot;]] ## [1] 0.1137034 0.6222994 0.6092747 0.6233794 0.8609154 # 컬럼의 위치 번호를 이용하여 서브세팅할 수 있습니다. df[[1]] # 1번째 컬럼 즉 x 컬럼을 추출합니다. ## [1] &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; 파이프 연산자와 함께 사용하려면 특수 위치 표시자인 .기호를 를 사용해야합니다. # 파이프 연산자와 . 기호를 사용할 수 있습니다. df %&gt;% .$x ## [1] 0.1137034 0.6222994 0.6092747 0.6233794 0.8609154 df %&gt;% .[[&quot;x&quot;]] ## [1] 0.1137034 0.6222994 0.6092747 0.6233794 0.8609154 # 파이프 연산자를 이용하여 티블의 요약 통계 정보를 보여줄 수 있습니다. df %&gt;% group_by(g) %&gt;% summarise(m.x = mean(x), m.y = mean(y), n = n()) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 4 ## g m.x m.y n ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 A 0.528 0.608 3 ## 2 B 0.623 -0.309 2 데이터 프레임에 비해 티블은 서브 세팅하는데 있어서 더 엄격합니다. 열 제목에 대한 부분 일치를 수행하지 않습니다. 그리고 접근 하려는 열이 존재하지 않으면 경고를 생성합니다. "],["exercises.html", "11.3 Exercises", " 11.3 Exercises How can you tell if an object is a tibble? (Hint: try printing mtcars, which is a regular data frame). In your console print the built-in data frame airquality. Now convert airquality to a tibble, print it in your console and compare the difference. Install the nycflights13 package and print off the data frame flights contained within this package. Now convert flights to a tibble, print it in your console and compare the difference. 참고 자료 http://uc-r.github.io/tibbles https://misdb.github.io/R/R-for-Data-Management/df-tibble-factor.html#tibble "],["레이블과-결측치-처리.html", "Chapter 12 레이블과 결측치 처리 ", " Chapter 12 레이블과 결측치 처리 "],["변수-레이블.html", "12.1 변수 레이블", " 12.1 변수 레이블 변수 레이블(Variable labels)을 처리하는 R의 능력은 다소 불만족 스럽습니다. 변수 레이블은 변수에 대한 설명을 담고 있는 문자열입니다. 벡터 개체의 레이블 속성을 label(x)는 x의 레이블 속성을 검색합니다. label(x) &lt;- \"레이블\"은 레이블의 속성을 지정합니다. Hmisc 패키지를 사용하면 일부 라벨링 기능을 활용할 수 있습니다. # 패키지 불러오기 # install.packages(&quot;Hmisc&quot;) library(Hmisc) ## Loading required package: lattice ## Loading required package: survival ## Loading required package: Formula ## ## Attaching package: &#39;Hmisc&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## src, summarize ## The following objects are masked from &#39;package:base&#39;: ## ## format.pval, units # df 데이터 프레임을 생성합니다. df &lt;- data.frame(name = c(&quot;Kim&quot;, &quot;Lee&quot;, &quot;Park&quot;), gender = c(&quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;), myvar1 = c(1, NA, 3), myvar2 = c(1, 3, 5)) str(df) ## &#39;data.frame&#39;: 3 obs. of 4 variables: ## $ name : chr &quot;Kim&quot; &quot;Lee&quot; &quot;Park&quot; ## $ gender: chr &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; ## $ myvar1: num 1 NA 3 ## $ myvar2: num 1 3 5 # df$name 컬럼에 레이블을 설정합니다. label(df$name) # df$name에 레이블이 지정되어 있지 않습니다. ## [1] &quot;&quot; label(df$name) &lt;- c(&quot;회원들의 이름입니다.&quot;) # df$name에 래이블을 지정합니다. label(df$name) # df$name의 레이블을 확인합니다. ## [1] &quot;회원들의 이름입니다.&quot; attributes(df$name) # df$name의 속성에서 label 속성이 확인되고, ## $label ## [1] &quot;회원들의 이름입니다.&quot; ## ## $class ## [1] &quot;labelled&quot; &quot;character&quot; # class 속성에 labelled가 추가되어 있습니다. class(df$name) # df$name의 클래스를 확인합니다. ## [1] &quot;labelled&quot; &quot;character&quot; # df의 통계적 요약정보를 확인합니다. describe(df) # df의 통계적 요약정보를 보여줍니다. df$name에 레이블이 출력됩니다. ## df ## ## 4 Variables 3 Observations ## -------------------------------------------------------------------------------- ## name : 회원들의 이름입니다. ## n missing distinct ## 3 0 3 ## ## Value Kim Lee Park ## Frequency 1 1 1 ## Proportion 0.333 0.333 0.333 ## -------------------------------------------------------------------------------- ## gender ## n missing distinct ## 3 0 2 ## ## Value Female Male ## Frequency 2 1 ## Proportion 0.667 0.333 ## -------------------------------------------------------------------------------- ## myvar1 ## n missing distinct Info Mean Gmd ## 2 1 2 1 2 2 ## ## Value 1 3 ## Frequency 1 1 ## Proportion 0.5 0.5 ## -------------------------------------------------------------------------------- ## myvar2 ## n missing distinct Info Mean Gmd ## 3 0 3 1 3 2.667 ## ## Value 1 3 5 ## Frequency 1 1 1 ## Proportion 0.333 0.333 0.333 ## -------------------------------------------------------------------------------- summary(df) # 레이블이 표시되지 않습니다. ## name gender myvar1 myvar2 ## Length:3 Length:3 Min. :1.0 Min. :1 ## Class1:labelled Class :character 1st Qu.:1.5 1st Qu.:2 ## Class2:character Mode :character Median :2.0 Median :3 ## Mode :character Mean :2.0 Mean :3 ## 3rd Qu.:2.5 3rd Qu.:4 ## Max. :3.0 Max. :5 ## NA&#39;s :1 안타깝게도 레이블은 describe() 함수와 같이 Hmisc 패키지에서 제공하는 함수에만 적용됩니다. 다른 옵션은 names() 함수를 이용하여 변수 레이블을 변수 이름으로 사용한 다음, 위치 색인으로 변수를 참조하는 것입니다. 그런데 이 방법은 변수명이 너무 길어지는 문제가 있습니다. ## names() 함수를 이용하여 변수 레이블을 변수명으로 사용할 수 있습니다. attributes(df) # names 속성이 변수명으로 저장되어 있습니다. ## $names ## [1] &quot;name&quot; &quot;gender&quot; &quot;myvar1&quot; &quot;myvar2&quot; ## ## $row.names ## [1] 1 2 3 ## ## $class ## [1] &quot;data.frame&quot; names(df)[3] &lt;- &quot;이것은 세번째 변수의 레이블입니다.&quot; str(df) # 3번째 변수명이 변경되었습니다. ## &#39;data.frame&#39;: 3 obs. of 4 variables: ## $ name : &#39;labelled&#39; chr &quot;Kim&quot; &quot;Lee&quot; &quot;Park&quot; ## ..- attr(*, &quot;label&quot;)= chr &quot;회원들의 이름입니다.&quot; ## $ gender : chr &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; ## $ 이것은 세번째 변수의 레이블입니다.: num 1 NA 3 ## $ myvar2 : num 1 3 5 attributes(df) # names 속성의 3번째 변수명이 변경되었습니다. ## $names ## [1] &quot;name&quot; &quot;gender&quot; ## [3] &quot;이것은 세번째 변수의 레이블입니다.&quot; &quot;myvar2&quot; ## ## $row.names ## [1] 1 2 3 ## ## $class ## [1] &quot;data.frame&quot; df[3] # df의 3번째 변수 값을 출력합니다. ## 이것은 세번째 변수의 레이블입니다. ## 1 1 ## 2 NA ## 3 3 names(df)[3] &lt;- &quot;myvar1&quot; "],["값-레이블.html", "12.2 값 레이블", " 12.2 값 레이블 R의 값 레이블(data label)을 이해하려면 제2부 제3장의 요인(factor) 데이터 구조를 이해해야 합니다. factor() 함수를 사용하여 고유한 값 레이블(unique value label)을 만들 수 있습니다. # df의 myvar1 변수의 값이 1, 2, 또는 3으로 코드가 되어 있습니다. # 이 값들에 1 = red, 2 = blue, 3 = green과 같은 값 레이블을 첨부하고 싶습니다. df$myvar1 &lt;- factor(df$myvar1, # df$myvar1을 요인형으로 변환합니다. levels = c(1, 2, 3), # 수준은 1, 2, 3입니다 labels = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) # 수준의 값 레이블을 지정합니다. describe(df) ## df ## ## 4 Variables 3 Observations ## -------------------------------------------------------------------------------- ## name : 회원들의 이름입니다. ## n missing distinct ## 3 0 3 ## ## Value Kim Lee Park ## Frequency 1 1 1 ## Proportion 0.333 0.333 0.333 ## -------------------------------------------------------------------------------- ## gender ## n missing distinct ## 3 0 2 ## ## Value Female Male ## Frequency 2 1 ## Proportion 0.667 0.333 ## -------------------------------------------------------------------------------- ## myvar1 ## n missing distinct ## 2 1 2 ## ## Value red green ## Frequency 1 1 ## Proportion 0.5 0.5 ## -------------------------------------------------------------------------------- ## myvar2 ## n missing distinct Info Mean Gmd ## 3 0 3 1 3 2.667 ## ## Value 1 3 5 ## Frequency 1 1 1 ## Proportion 0.333 0.333 0.333 ## -------------------------------------------------------------------------------- # df의 myvar2 변수의 값이 1, 3, 또는 5로 코드가 되어 있습니다. # 이 값들에 1 = Low, 2 = Medium, 5 = High 와 같은 값 레이블을 첨부하고 싶습니다. df$myvar2 &lt;- factor(df$myvar2, # df$myvar2를 요인형으로 변환합니다. levels = c(1,3,5), # 수준은 1, 3, 5입니다 labels = c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)) # 수준의 값 레이블을 지정합니다. describe(df) ## df ## ## 4 Variables 3 Observations ## -------------------------------------------------------------------------------- ## name : 회원들의 이름입니다. ## n missing distinct ## 3 0 3 ## ## Value Kim Lee Park ## Frequency 1 1 1 ## Proportion 0.333 0.333 0.333 ## -------------------------------------------------------------------------------- ## gender ## n missing distinct ## 3 0 2 ## ## Value Female Male ## Frequency 2 1 ## Proportion 0.667 0.333 ## -------------------------------------------------------------------------------- ## myvar1 ## n missing distinct ## 2 1 2 ## ## Value red green ## Frequency 1 1 ## Proportion 0.5 0.5 ## -------------------------------------------------------------------------------- ## myvar2 ## n missing distinct ## 3 0 3 ## ## Value Low Medium High ## Frequency 1 1 1 ## Proportion 0.333 0.333 0.333 ## -------------------------------------------------------------------------------- 범주형 데이터에 factor() 함수를 사용하고 서열형 데이터를 생성하기 위해 ordered() 함수를 사용합니다. 그러면 R의 통계 분석과 그래픽 함수들이 이 데이터를 적절하게 처리할 것입니다. factor() 함수와 ordered() 함수는 동일한 인수로 동일한 방식으로 사용됩니다. factor() 함수는 요인을 생성하고, ordered() 함수는 요인을 서열화하여 서열형 데이터를 생성합니다. "],["결측치의-처리.html", "12.3 결측치의 처리", " 12.3 결측치의 처리 R에서 누락된 값은 NA (not available) 기호로 표시됩니다. 불가능한 값(예 : 0으로 나누기)은 기호 NaN (Not a Number)로 표시됩니다. R은 문자 및 숫자 데이터에 동일한 기호를 사용합니다. 결측치의 처리는 여러 가지 방법이 있습니다. 여기서는 결측치를 다른 값으로 대체하는 방법과 결측치를 제외시키는 방법에 대하여 살펴보겠습니다. 결측치를 처리하기 전에 데이터 세트에 결측치가 있는지 확인하는 방법 먼저 학습하겠습니다. 12.3.1 결측치 확인 is.na() 함수를 이용하여 결측치를 확인할 수 있습니다. 또한 which() 함수와 결합하여 NA가 있는 위치를 확인할 수 있으며, sum() 함수와 mean() 함수와 결합하여 NA의 갯수와 NA의 비율을 구할 수도 있습니다. ## 결측치가 있는 데이터 프레임에서 NA값을 확인합니다. is.na(df) # df의 데이터 요소별로 NA이면 TRUE를 반환합니다. ## name gender myvar1 myvar2 ## [1,] FALSE FALSE FALSE FALSE ## [2,] FALSE FALSE TRUE FALSE ## [3,] FALSE FALSE FALSE FALSE # 데이터 프레임은 사작형 모양으로 is.na() 함수는 # &quot;논리형 행렬/배열형&quot;으로 반환합니다. ## 데이터 프레임의 특정 컬럼(벡터)에 NA가 있는지 확인합니다. is.na(df$myvar1) # 논리형 벡터를 반환합니다. ## [1] FALSE TRUE FALSE ## 결측치가 있는 벡터에서 NA값을 확인합니다. y &lt;- c(1,2,3,NA) is.na(y) # 논리형 벡터 (F F F T)를 반환합니다. ## [1] FALSE FALSE FALSE TRUE ## which(is.na()) 함수를 이용하여 NA가 있는 색인 번호를 확인할 수 있습니다. which(is.na(df)) # 열 우선에 의한 요소의 위치인 8을 출력됩니다. ## [1] 8 which(is.na(y)) # 4를 출력합니다. ## [1] 4 ## sum(is.na()) 함수를 이용하여 NA의 갯수를 확인할 수 있습니다. sum(is.na(df)) # 1을 출력합니다. ## [1] 1 sum(is.na(y)) # 1을 출력합니다. ## [1] 1 ## mean(is.na()) 함수를 이용하여 NA의 비율을 구할 수 있습니다. mean(is.na(df)) # 1/12인 0.0833을 출력합니다. ## [1] 0.08333333 mean(is.na(y)) # 1/4인 0.25를 출력합니다. ## [1] 0.25 12.3.1.1 일반 데이터를 결측치 NA로 변경하기 데이터 프레임에 NA로 입력이 되어 있지 않은 데이터를 NA로도 변경할 수 있습니다. 예를 들어, my.df 데이터 프레임의 myvar1 열에 있는99의 값을 NA로 변경하고, myvar2열에 있는7의 값을 NA로 변경해 보겠습니다. # my.df 데이터 프레임을 생성합니다. my.df &lt;- data.frame(name = c(&quot;Kim&quot;, &quot;Lee&quot;, &quot;Park&quot;, &quot;Choi&quot;, &quot;Suh&quot;), gender = c(&quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;), myvar1 = c(1, NA, 3, 2, 99), myvar2 = c(1, 3, 5, 7, 7)) str(my.df) ## &#39;data.frame&#39;: 5 obs. of 4 variables: ## $ name : chr &quot;Kim&quot; &quot;Lee&quot; &quot;Park&quot; &quot;Choi&quot; ... ## $ gender: chr &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; &quot;Male&quot; ... ## $ myvar1: num 1 NA 3 2 99 ## $ myvar2: num 1 3 5 7 7 # myvar1 컬럼의 99값은 실제로 결측치로 입력한 값입니다. 이를 NA로 변경합니다. # my.df$myvar1 의 값이 99인 요소를 선택한 다음, 그 값을 NA로 변경합니다. my.df$myvar1[my.df$myvar1 == 99] &lt;- NA # myvar2 컬럼의 7값은 실제로 결측치로 입력한 값입니다. 이를 NA로 변경합니다. # my.df$myvar2 의 값이 7인 요소를 선택한 다음, 그 값을 NA로 변경합니다. my.df$myvar2[my.df$myvar2 == 7] &lt;- NA 12.3.1.2 NA를 제거한 연산 벡터의 연산을 위한 다양한 함수들에 대하여 제2부 제2장에서 살펴보았습니다. 이러한 함수들은 벡터에 NA값이 있으면 그 결과로 NA를 반환합니다. 이때 함수에 na.rm = TRUE 인수를 설정해 주면 벡터 요소에서 NA를 제거하고 연산을 하게 됩니다. # my.df의 myvar1 컬럼의 합계와 평균을 구해 보겠습니다. sum() 함수와 mean() 함수 이용 sum(my.df$myvar1) # 결과로 NA를 반환합니다. ## [1] NA mean(my.df$myvar2) # 결과로 NA를 반환합니다. ## [1] NA # sum() 함수와 mean() 함수에 na.rm = TRUE 인수를 지정해 줍니다. sum(my.df$myvar1, na.rm = TRUE) # 결과로 6을 반환합니다. ## [1] 6 mean(my.df$myvar2, na.rm = TRUE) # 결과로 3을 반환합니다. ## [1] 3 complete.cases() 함수를 이용하여 데이터 세트의 각 행 별로 NA가 존재하는지 확인할 수 있습니다. 이 complete.cases() 함수는 논리형 벡터를 반환합니다. na.omit() 함수는 결측치가 있는 행들을 제거한 개체를 반환합니다. 예를 들어, 앞에서 my.df 데이터 프레임에 대하여 각 행 단위로 NA가 있는 행은 제거하여 새로운 데이터 세트를 생성해 보겠습니다. # my.df 파일의 내용을 확인합니다. my.df # 2, 4, 5번째 행에 NA가 잆습니다. ## name gender myvar1 myvar2 ## 1 Kim Female 1 1 ## 2 Lee Male NA 3 ## 3 Park Female 3 5 ## 4 Choi Male 2 NA ## 5 Suh Female NA NA # complete.case() 함수를 이용해 보겠습니다. comp.index &lt;- complete.cases(my.df) # my.df의 행별로 NA가 있는지 확인합니다. comp.index # T, F, T, F, F가 반환됩니다. ## [1] TRUE FALSE TRUE FALSE FALSE my.comp.df &lt;- my.df[comp.index, ] # comp.index가 T인 행만 선택해서 my.comp.df 개체에 복사합니다. my.comp.df ## name gender myvar1 myvar2 ## 1 Kim Female 1 1 ## 3 Park Female 3 5 # na.omit() 함수를 이용해 보겠습니다. my.new.df &lt;- na.omit(my.df) # my.df의 각 행에서 NA가 없는 행만 my.new.df 개체에 복사합니다. my.new.df ## name gender myvar1 myvar2 ## 1 Kim Female 1 1 ## 3 Park Female 3 5 # my.comp.df와 my.new.df는 동일한 데이터 세트 입니다. : setequal() 함수로 확인합니다. setequal(my.comp.df, my.new.df) # TRUE를 반환합니다. ## [1] TRUE 12.3.1.3 NA값을 다른 값으로 대체하기 데이터 프레임의 특정 컬럼에 NA가 있는 경우 앞에서 살펴본 것처럼 NA를 제거하고 연산을 하는 방법도 있지만, 이 NA 값을 컬럼의 대표값 예를 들면 평균값이나 중앙값 등으로 변경하여 처리하기도 합니다. 앞의 예에서 my.df 데이터 프레임의 myvar1 컬럼의 NA 값을 평균값으로 대체해 보겠습니다. # my.df$myvar1의 NA 요소 값을 my.df$myvar1의 평균값을 대체합니다. # my.df$myvar1 컬럼의 요소 값을 확인합니다. my.df$myvar1 ## [1] 1 NA 3 2 NA # 먼저 my.df$myvar1의 평균을 구합니다. mean.myvar1 &lt;- mean(my.df$myvar1, na.rm = TRUE) # NA를 제거한 평균을 구합니다. mean.myvar1 # NA를 제거한 평균은 2입니다. ## [1] 2 # my.df$myvar1의 요소 값이 NA인 것들을 찾아서 mean.myvar1으로 대체합니다. my.df$myvar1[is.na(my.df$myvar1)] &lt;- mean.myvar1 my.df$myvar1 # NA가 모두 평균값 2로 대체되었습니다. ## [1] 1 2 3 2 2 R의 대부분의 모델링 함수는 결측값을 처리하기위한 옵션을 제공합니다. 다중 대체와 같은 방법을 통해 결측값을 리스트 요소별로(행별로) 삭제하는 것 이상으로 진행할 수 있습니다. R을 통해 액세스할 수 있는 좋은 구현에는 Amelia II, Mice 그리고 mitools 등이 있습니다.13 https://www.statmethods.net/input/missingdata.html "],["날짜-데이터.html", "12.4 날짜 데이터", " 12.4 날짜 데이터 R에서의 날짜는 1970-01-01 이후의 일 수로 표시되며 이전 날짜는 음수 값으로 처리합니다. # as.Date( ) 함수는 문자열 날짜를 날짜형 날짜로 변경합니다. date &lt;- c(&quot;2007-06-22&quot;, &quot;2004-02-13&quot;) # 문자형 벡터입니다. mydates &lt;- as.Date(date) # 날짜형 Date형 벡터입니다. mydates ## [1] &quot;2007-06-22&quot; &quot;2004-02-13&quot; # 2007-6-22과 2004-2-13 사이의 일수는 다음과 같이 계산합니다. days &lt;- mydates[1] - mydates[2] # 날짜형 데이터는 산술연산이 가능합니다. days ## Time difference of 1225 days 한편, Sys.Date( ) 함수는 오늘 날짜를 반환합니다. 그리고 date() 함수는 현재의 날짜와 시간을 반환합니다. 12.4.1 날짜 형식의 지정 다음의 기호들은 문자형 벡터를 날짜형으로 변경할 때, as.Date() 함수의 format = “”인수로 사용할 수 있습니다. 또는 format() 함수를 이용하여 날짜형 데이터를 출력할 때 출력형식을 지정할 수도 있습니다. 기호 의미 예 %d 숫자형 날짜 (0-31) 01-31 %a %A 소문자 : 축약된 요일명, 대문자 : 완전한 요일명 Mon Monday %m 월 (00-12) 00-12 %b %B 소문자 : 축약된 월이름, 대문자 : 완전한 월이름 Jan January %y %Y 소문자 : 2 자리 연도, 대문자 : 4자리 연도 07 2007 날짜형의 경우 help(strptime) 또는 ? strptime 등으로 자세한 내용을 확인할 수 있습니다. 날짜-시간형의 경우는 help(ISOdatetime)로 자세한 내용을 확인할 수 있습니다. 예를 들면 다음과 같습니다. # 문자형 벡터를 날짜형 벡터로 변경할 때 사용할 수 있습니다. dates &lt;- c(&quot;2020 01 03&quot;, &quot;2020 03 05&quot;, &quot;2021 01 24&quot;) my.dates &lt;- as.Date(dates, format = &quot;%Y %m %d&quot;) # dates 요소에 저장된 형식을 지정해 줍니다.ㄴ my.dates # 2020-01-03, 2020-03-05, 2021-01-24와 같은 기본적인 날짜 형식으로 출력이 됩니다. ## [1] &quot;2020-01-03&quot; &quot;2020-03-05&quot; &quot;2021-01-24&quot; # 오늘 날짜의 출력형식을 지정할 수 있습니다. today &lt;- Sys.Date() # 오늘 날짜를 today 변수에 할당합니다. format(today, format=&quot;%Y년 %m월 %d일&quot;) # &quot;2021년 1월 31일&quot;의 형식으로 출력합니다. ## [1] &quot;2021년 02월 08일&quot; 12.4.2 날짜형 변환 12.4.2.1 문자형을 날짜형으로 You can use the as.Date( ) function to convert character data to dates. The format is as.Date(x, “format”), where x is the character data and format gives the appropriate format. 앞의 예에서 살펴본 바와 같이 as.Date () 함수를 사용하여 문자형 데이터를 날짜형로 변환 할 수 있습니다. as.Date() 함수의 다음과 같습니다. as.Date (x, format = “”) x : 문자형 데이터입니다. format : 문자형 데이터에 맞춰, 앞의 표에 있는 기호들을 입력합니다. 다음의 예에서 살펴 보겠습니다. # &#39;mm/dd/yyyy&#39; 형식의 문자형 벡터를 날짜형 벡터로 변경합니다. Dates.Chr &lt;- c(&quot;02/25/2015&quot;, &quot;08/15/2016&quot;) # 문자형 벡터에 &quot;월/일/년&quot;의 형태로 입력이 되어 있습니다. my.dates &lt;- as.Date(Dates.Chr, &quot;%m/%d/%Y&quot;) # format 인수에 &quot;%m/%d/%Y&quot;로 맞춰 줍니다. my.dates # 기본 출력형식인 yyyy-mm-dd 형식으로 출력됩니다. ## [1] &quot;2015-02-25&quot; &quot;2016-08-15&quot; 12.4.2.2 날짜형을 문자형으로 as.character() 함수를 사용하여 날짜형 데이터를 문자형 데이터로 변환할 수 있습니다. # 문자형 벡터인 my.dates를 날짜형 벡터인 dates로 변경합니다. dates &lt;- as.character(my.dates) # format() 함수를 같이 사용하면 다음과 같은 문자형 벡터로 변경할 수 있습니다. dates &lt;- as.character(format(my.dates, format=&quot;%Y년 %m월 %d일&quot;)) dates # &quot;2015년 2월 25일&quot;, &quot;2016년 8월 15일&quot; ## [1] &quot;2015년 02월 25일&quot; &quot;2016년 08월 15일&quot; 참고자료 https://www.statmethods.net/input/variablelables.html https://www.statmethods.net/input/missingdata.html https://www.statmethods.net/input/dates.html "],["데이터-불러오기와-저장하기.html", "Chapter 13 데이터 불러오기와 저장하기", " Chapter 13 데이터 불러오기와 저장하기 R로 데이터를 가져 오는 것은 매우 간단합니다. Stata 및 Systat의 경우 외부 패키지를 사용해야 합니다. SPSS와 SAS의 경우 Hmisc 패키지를 이용하면 편리합니다. 이러한 패키지를 구하고 설치하는 방법에 대한 정보는 패키지의 Quick-R 섹션을 참조하기 바랍니다. 데이터를 R로 올바르고 쉽게 가져오기 위해 다음의 사항들에 대하여 살펴보는 것도 유용할 수 있습니다. 스프레드 시트로 작업하는 경우 일반적으로 첫 번째 행은 컬럼 제목으로 사용하고, 첫 번째 열은 샘플링 단위를 식별하기 위한 데이터를 입력하는 것이 좋습니다. 공백이 있는 이름, 값 또는 항목을 피하는 것이 좋습니다. 그렇지 않으면 각 단어가 별도의 변수로 해석되어 데이터 세트의 한 줄당 요소 수의 불일치와 관련한 오류가 발생할 가능성이 높아집니다. 단어를 연결하려면. 공백 대신 단어 사이에 점(.)을 사용하는 것이 좋습니다. 긴 이름보다는 짧은 이름이 좋습니다. ?, $, %, ^, &amp;, *, (,),-, #,? ,,, &lt;,&gt;, /, |, \\, [,], {, 그리고 }같은 기호가 포함된 이름은 사용하지 않는게 좋습니다. 파일에 상관없는 컬럼이나 NA가 추가되지 않도록 Excel 파일에 작성한 주석을 삭제하십시오. 엑셀 데이터에 입력한 결측치 값을 확인하기 바랍니다. 이 값은 데이터를 불러오기 할 때 NA로 처리해야 합니다. "],["데이터-불러오기.html", "13.1 데이터 불러오기", " 13.1 데이터 불러오기 13.1.1 쉼표로 구분된 텍스트 파일 base 함수인 read.table() 함수를 이용하면 확장자가 .txt나 탭으로 구분된 텍스트 파일을 불러올 수 있고 쉼표(,)로 구분된 텍스트 파일이나 .csv 파일도 불러올 수 있습니다. data.table() 함수의 형식은 다음과 같습니다. read.table(file, header=, sep=\"\", ...) file : 데이터를 읽을 파일의 이름입니다. 경로를 포함합니다. (또한 데이터를 제공하는 웹 페이지 주소도 가능합니다.) header : 첫 줄이 컬럼 제목이면 TRUE값으로 합니다. (기본값은 FALSE 입니다.) sep : 필드 구분 문자를 지정합니다. row.names, col.names : 행, 열 이름을 설정합니다. na.strings : NA 처리를 하고자 하는 문자열을 지정합니다. nrows : 불러올 행의 최대 갯수를 지정합니다. skip : 데이터를 불러올 때 읽지 말아야 할 행의 갯수를 지정합니다. stringsAsFactors : 문자열 컬럼을 요인화 할 것인지를 지정합니다. fileEncoding : 한글 데이터를 불러올 때 “UTF-8”로 지정합니다. 문화체육관광부의 국가도서관통계 중 “전국대학도서관통계 파일” 을 다운받아 data 폴더에 저장하고, 이를 data.table() 함수를 이용해서 불러와 보겠습니다. 다운로드 받은 파일의 이름은 University_Library_20201028.csv 로 첫 줄은 각 컬럼의 제목이 입력되어 있으며, 두번째 줄부터는 각 행의 요소들이 쉼표로 구분되어 있는 파일(csv) 입니다. # 다운받은 csv 파일을 read.table() 함수로 불러옵니다. mydata &lt;- read.table(&quot;data/University_Library_20201028.csv&quot;, # 불러올 파일의 경로입니다. head = TRUE, # 파일의 첫 줄에 컬럼 제목이 있습니다. sep = &quot;,&quot;) # 각 줄의 항목이 쉼표(,)로 구분되어 있습니다. str(mydata) ## &#39;data.frame&#39;: 1834 obs. of 9 variables: ## $ 평가년도 : int 2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ... ## $ 도서관구분: chr &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; ... ## $ 도서관코드: int 227 25 269 290 311 340 363 387 408 43 ... ## $ 면적 : chr &quot;경북&quot; &quot;대전&quot; &quot;경기&quot; &quot;서울&quot; ... ## $ 시군구 : chr &quot;영천시&quot; &quot;서구&quot; &quot;여주시&quot; &quot;종로구&quot; ... ## $ 장서수 : int 20827 31054 114815 6326 756633 1306474 1611325 136147 4421 1379785 ... ## $ 사서수 : int 1 1 2 1 6 11 30 2 0 20 ... ## $ 대출권수 : int 2044 15745 10677 4647 53358 303522 187458 26534 495 123313 ... ## $ 예산액 : num 3.44e+07 0.00 3.80e+07 7.50e+06 1.05e+08 ... 이때 파일에 BOM (Byte Order Mark)없이 일반 csv 파일로 저장했는지 확인해야 합니다 (한글이 포함된 경우가 여기에 속합니다). 이 작업을 수행한 경우 불러오기 함수에 추가 인수 fileEncoding = \"UTF-8-BOM\"을 추가하지 않으면 가져온 데이터에 이상한 문자가 표시됩니다. 데이터 파일에 한글이 포함되어 있는 경우는 fileEncoding = \"UTF-8\"로 지정하지 않아도 한글을 불러옵니다. 불러온 데이터는 ‘data.frame’ 구조로서 1,834 개의 행과 9 개의 변수(컬럼)으로 구성되어 있음을 알 수 있습니다. 탭(\\t) 이외의 기타의 구분자(delimiter)로 구분된 파일의 경우도 read.table() 함수의 sep = 인수를 이용하여 불러오기 할 수 있습니다. 13.1.2 CSV 파일 불러오기 일반적으로 .csv 파일은 , 또는 ; 로 데이터의 항목들을 구분하여 저장하고 있습니다. 이 파일을 R로 성공적으로 불러오려면 앞에서 살펴 본 구분 문자(sep =)를 지정하는 read.table() 함수를 사용하거나, read.csv() 또는 read.csv2() 함수를 사용할 수 있습니다. read.csv() 함수는 특히 구분자가 , 인 경우에, 그리고 read.csv2() 함수는 구분자가 ;일 때 사용합니다. read.csv() 함수와 read.csv2() 함수는 read.table() 함수와 거의 동일하지만 header 인수와 fill 인수가 기본적으로 TRUE로 설정되어 있다는 점에서 read.table() 함수와 차이가 납니다. read.csv(file, header = TRUE, sep = \",\", quote = \"\\\"\", dec = \".\", fill = TRUE, comment.char = \"\", ...) read.csv2(file, header = TRUE, sep = \";\", quote = \"\\\"\", dec = \",\", fill = TRUE, comment.char = \"\", ...) file : 불러올 데이터 파일의 경로를 포함한 파일명입니다. header= TRUE : 파일의 첫 행을 헤더로 처리하는 것이 기본값입니다. sep = “,” : 구분자가 ,이면 read.csv() 함수, 구분자가 ;이면 read.csv2() 함수를 사용합니다. 앞에서 read.table() 함수로 불러왔던 전국대학도서관정보 파일을 read.csv() 함수로 불러와 보겠습니다. # csv 파일은 read.csv() 함수로도 불러올 수 있습니다. mycsv &lt;- read.csv(&quot;data/University_Library_20201028.csv&quot;) str(mycsv) ## &#39;data.frame&#39;: 1834 obs. of 9 variables: ## $ 평가년도 : int 2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ... ## $ 도서관구분: chr &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; ... ## $ 도서관코드: int 227 25 269 290 311 340 363 387 408 43 ... ## $ 면적 : chr &quot;경북&quot; &quot;대전&quot; &quot;경기&quot; &quot;서울&quot; ... ## $ 시군구 : chr &quot;영천시&quot; &quot;서구&quot; &quot;여주시&quot; &quot;종로구&quot; ... ## $ 장서수 : int 20827 31054 114815 6326 756633 1306474 1611325 136147 4421 1379785 ... ## $ 사서수 : int 1 1 2 1 6 11 30 2 0 20 ... ## $ 대출권수 : int 2044 15745 10677 4647 53358 303522 187458 26534 495 123313 ... ## $ 예산액 : num 3.44e+07 0.00 3.80e+07 7.50e+06 1.05e+08 ... read.csv() 함수는 read.table() 함수와 달리 head = 인수나 sep = 인수를 지정하지 않아도 되는 것을 알 수 있습니다. 13.1.3 구분자를 포함한 파일 불러오기 탭문자(\\t), 쉼표(,) 또는 세미콜론(;) 이외의 다른 구분자가 포함된 파일의 경우 read.delim()나 read.delim2() 함수를 사용할 수 있습니다. 이것들은 read.csv() 함수와 마찬가지로 read.table() 함수의 변형입니다. 결과적으로, 이 두 함수들은 read.table() 함수와 많은 공통점이 있습니다. 다만, 첫 번째 줄에 속성 이름이 있는 헤더라고 가정하고, 공백, 쉼표 또는 세미콜론 대신 탭을 구분 기호로 사용한다는 차이가 있습니다. 또한 fill = 인수가 TRUE로 설정되어 있어서 길이가 다른 행에 공란이 추가됩니다. read.delim(file, header = TRUE, sep = \"\\t\", quote = \"\\\"\",  dec = \".\", fill = TRUE, comment.char = \"\", ...) read.delim2(file, header = TRUE, sep = \"\\t\", quote = \"\\\"\", dec = \",\", fill = TRUE, comment.char = \"\", ...) file : 불러올 데이터 파일의 경로를 포함한 파일명입니다. header = TRUE : 파일의 첫 행을 헤더로 처리하는 것이 기본값입니다. sep = “\\t” : 두 함수 모두 탭문자(\\t)를 구분자로 지정하고 있습니다. dec = : 수숫점의 기호를 점(.) 또는 쉼표(,)로 사용하는가가 두 함수의 용도를 달리합니다. read.delim() 함수와 read.delim2() 함수는 dec = 인수 값에 차이가 있습니다. read.delim() 함수는 소숫점 기호를 점(.)으로 사용하는 경우에, 그리고 read.delim2() 함수는 소숫점 기호를 쉽표(,)로 사용하는 경우에 유용합니다. 13.1.4 엑셀 파일 불러오기 Excel 파일을 읽는 가장 좋은 방법 중 하나는 쉼표로 구분 된 파일(csv)로 내보내고 위의 방법을 사용하여 가져오는 것입니다. 아니면 xlsx 패키지14의 read.xlsx() 함수를 사용하여 Excel 파일에 액세스할 수 있습니다. 첫 번째 행에는 열 이름이 포함되는 것이 좋습니다. R에서 Excel 파일을 불러오기 전에 Excel을 이용하여 데이터 파일을 열어서 파일의 구조를 미리 확인해 보는 것도좋습니다. read.xlsx() 함수의 형식은 다음과 같습니다. read.xlsx( … ) file : 불러올 파일명입니다. sheetIndex : 워크북의 시트 색인번호를 지정합니다. sheetName = NULL : 시트 이름을 지정합니다. rowIndex = NULL : 추출하고자 하는 행번호의 정수형 벡터입니다. startRow = NULL : 읽어 들일 행의 시작 색인번호입니다. endRow = NULL : 읽어 들일 행의 마지막 색인번호입니다. colIndex = NULL : 추출하고자 하는 컬럼의 정수형 벡터입니다. as.data.frame = TRUE : 읽어 들인 결과를 데이터 프레임형으로 합니다. header = TRUE : 첫 행이 컬럼 제목입니다. colClasses = NA, keepFormulas = FALSE, encoding = \"unknown\", : 한글은 UTF-8로 지정합니다. password = NULL 앞의 예에서 데이터 파일을University_Library_20201028.xlsx로 다운로드 했다면, 이를 read.xlsx() 함수를 이용하여 불어로 수 있습니다. 그런데, 경로를 지정할 때 윈도즈에서 사용하는 \\ 대신에 /를 사용하고 있습니다. # 패키지 불러오기 # install.packages(&quot;xlsx&quot;) library(xlsx) mydata1 &lt;- read.xlsx(&quot;data/University_Library_20201028.xlsx&quot;, # 불러올 파일의 경로입니다. sheetIndex = 1, # 읽어들일 시트가 1번입니다. head = TRUE, # 첫 줄이 컬럼 제목입니다. encoding = &quot;UTF-8&quot;, # 한글을 UTF-8 코드로 읽어 들입니다. ) str(mydata1) ## &#39;data.frame&#39;: 1834 obs. of 9 variables: ## $ 평가년도 : num 2014 2014 2014 2014 2014 ... ## $ 도서관구분: chr &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; ... ## $ 도서관코드: num 227 25 269 290 311 340 363 387 408 43 ... ## $ 면적 : chr &quot;경북&quot; &quot;대전&quot; &quot;경기&quot; &quot;서울&quot; ... ## $ 시군구 : chr &quot;영천시&quot; &quot;서구&quot; &quot;여주시&quot; &quot;종로구&quot; ... ## $ 장서수 : num 20827 31054 114815 6326 756633 ... ## $ 사서수 : num 1 1 2 1 6 11 30 2 0 20 ... ## $ 대출권수 : num 2044 15745 10677 4647 53358 ... ## $ 예산액 : num 3.44e+07 0.00 3.80e+07 7.50e+06 1.05e+08 ... 확장자가 xlsx인 엑셀 파일로 불러들이는 것이 csv 파일을 불러올 때 보다 시간이 더 걸리는 것을 확인할 수 있습니다. 그 밖에도 JSON 파일, XML 파일, SPSS, SAS, Stata, systat 등의 파일은 다음과 같이 불러올 수 있습니다. 다만 참고용으로 수록하겠습니다. ### JSON 파일을 불러옵니다. # install.packages(&quot;rjson&quot;) library(rjson) JsonData &lt;- fromJSON(file = &quot;&lt;filename.json&gt;&quot;) # 파일을 불러옵니다. JsonData &lt;- fromJSON(file = &quot;&lt;URL to your JSON file&quot;) # 웹 사이트에서 불러옵니다. ### XML 파일을 불러옵니다. # install.packages(&quot;XML&quot;) library(XML) xmlfile &lt;- xmlTreeParse(&quot;URL to the XML data&quot;) # XML 파일을 불러옵니다. topxml &lt;- xmlRoot(xmlfile) # 불러온 파일의 top node에 접근합니다. topxml &lt;- xmlSApply(topxml, function(x) xmlSApply(x, xmlValue)) # XML 값들을 추출합니다. xml_df &lt;- data.frame(t(topxml),row.names=NULL) # 데이터 프레임으로 변형합니다. # 위의 과정은 다음과 같이 간단하게 할 수 있습니다. url &lt;- &quot;&lt;a URL with XML data&gt;&quot; data_df &lt;- xmlToDataFrame(url) ### HTML의 표를 불러오기 (이 부분은 웹 스크래핑에서 사용하는 방법의 일부입니다.) # install.packages(&quot;RCurl&quot;) library(RCurl) url &lt;- &quot;&lt;a URL&gt;&quot; # 불러올 URL을 지정합니다. data_df &lt;- readHTMLTable(url, # HTML 표를 읽어옵니다. which=3) # HTML의 표가 여러개일 때, 순번을 지정합니다. # 또는 RCurl 패키지와 XML 패키지를 결합하여 사용할 수 있습니다. library(XML) # 패키지들을 불러옵니다. library(RCurl) url &lt;- &quot;YourURL&quot; # url 변수에 URL을 지정합니다. urldata &lt;- getURL(url) # 데이터를 불러옵니다. data &lt;- readHTMLTable(urldata, # HTML 표를 불러옵니다. stringsAsFactors = FALSE) # httr 패키지를 이용할 수도 있습니다. # install.packages(&quot;httr&quot;) library(httr) urldata &lt;- GET(url) # URL의 데이터를 불러옵니다. data &lt;- readHTMLTable(rawToChar(urldata$content), # HTML 표를 불러옵니다. stringsAsFactors = FALSE) ### SPSS 데이터 파일을 불러옵니다. # SPSS 데이터 세트를 trasport 형식으로 저장합니다. get file = &#39;c:\\mydata.sav&#39; export outfile = &#39;c:\\mydata.por&#39; # install.packages(&quot;Hmisc&quot;) library(Hmisc) sas.data &lt;- spss.get(&quot;c:/mydata.por&quot;, use.value.labels = TRUE) str(sas.data) # 또는 foreign 패키지를 사용할 수도 있습니다. library(foreign) mySPSSData &lt;- read.spss(&quot;c:\\mydata.sav&quot;, # SPSS 데이터를 불러옵니다. to.data.frame=TRUE, use.value.labels=FALSE) str(mySPSSData) ### SAS 데이터 파일을 불러옵니다. # SAS 데이터 세트를 trasport 형식으로 저장합니다. libname out xport &#39;c:/mydata.xpt&#39;; data out.mydata; set sasuser.mydata; # install.packages(&quot;Hmisc&quot;) library(Hmisc) sas.data &lt;- sasxport.get(&quot;c:/mydata.xpt&quot;) str(sas.data) # 또는 sas7bdat 패키지를 이용할 수도 있습니다. # install.packages(&quot;sas7bdat&quot;) library(sas7bdat) mySASData &lt;- read.sas7bdat(&quot;example.sas7bdat&quot;) ### Stata 데이터 파일을 불러옵니다. # install.packages(&quot;foreign&quot;) library(foreign) stata.data &lt;- read.dta(&quot;c:/mydata.dta&quot;) str(stata.data) ### systat 데이터 파일을 불러옵니다. # install.packages(&quot;foreign&quot;) library(foreign) systat.data &lt;- read.systat(&quot;c:/mydata.dta&quot;) str(systat.data) 13.1.5 R 형식의 파일 불러오기 R에서는 처리한 데이터를 R 고유의 데이터 형식으로 저장할 수 있습니다. 대표적인 형식이 .rds와 .Rdata (또는 .rda) 형식입니다. 이렇게 저장된 파일은 readRDS() 함수나 load() 함수로 불러올 수 있습니다. 자세한 내용은 다음의 R 형식으로 저장하기 부분을 참고하기 바랍니다. 13.1.6 키보드 입력 일반적으로 SAS, SPSS, Excel, Stata, 데이터베이스 또는 ASCII 파일을 데이터 프레임으로 불러올 수 있습니다. 그런데 데이터를 키보드를 통해 대화식으로도 입력할 수 있습니다. # 키보드를 통하여 대화식으로 데이터 프레임에 데이터를 입력할 수 있습니다. # 먼저 데이터 프레임의 구조를 생성합니다. data &lt;- data.frame(age = numeric(0), # age 컬럼을 숫자형으로 지정합니다. gender = character(0), # gender 컬럼을 문자형으로 지정합니다. weight = numeric(0)) # weight 컬럼을 숫자형으로 지정합니다. kbd.data &lt;- edit(data) # 데이터 입력을 위한 데이터 편집기 화면이 나타납니다. # 데이터 편집기의 [파일]-[닫기]를 선택하면 데이터가 저장됩니다. str(kbd.data) ## &#39;data.frame&#39;: 0 obs. of 3 variables: ## $ age : num ## $ gender: chr ## $ weight: num edit(data) 는 사용하는데 조심해야 합니다. 이 스크립트를 실행하면 기존의 데이터가 모두 지워집니다. 13.1.7 DBMS에 접속하기 : ODBC 인터페이스 이용하기 RODBC 패키지는 ODBC 인터페이스를 통해 데이터베이스 (Microsoft Access 및 Microsoft SQL Server 포함)에 대한 액세스를 제공합니다. 주요 함수들을 다음과 같습니다. 함수 설 명 odbcConnect(dsn, uid=\"“, pwd=”\") ODBC 데이터베이스에 대한 연결 열기 sqlFetch(channel, sqtable) ODBC 데이터베이스에서 데이터 프레임으로 테이블 읽기 sqlQuery(channel, query) ODBC 데이터베이스에 쿼리를 제출하고 그 결과를 반환받습니다. sqlSave(channel, mydf, tablename = sqtable, append = FALSE) ODBC 데이터베이스의 테이블에 데이터 프레임 쓰기 또는 업데이트 (append = True) sqlDrop(channel, sqtable) ODBC 데이터베이스에서 테이블 제거 close(channel) 연결 종료 RODBC 의 예를 들면 다음과 같습니다. 예로 DBMS에서 두 개의 테이블을 데이터 프레임으로 불러오는 것입니다. # install.packages(&quot;RODBC&quot;) library(RODBC) # mydsn에 연결합니다. myconn &lt;-odbcConnect(&quot;mydsn&quot;, # 접속명을 기입합니다. uid=&quot;접속ID&quot;, # 접속 ID를 기입합니다. pwd=&quot;접속비밀번호&quot;) # 접속 비밀번호를 기입합니다. crimedat &lt;- sqlFetch(myconn, &quot;Crime&quot;) # Crime 테이블을 crimedat로 불러옵니다. pundat &lt;- sqlQuery(myconn, &quot;select * from Punishment&quot;) # Punishment 테이블을 쿼리합니다. # mydsn 연결을 종료합니다. close(myconn) 이외에도 MySQL(RMySQL), Orcle(ROracle), 그리고 JDBC(RJDBC)에 인터페이스 접근도 할 수 있습니다. 이외에도 readxl, XLConnect 등의 패키지를 이용할 수 있습니다 "],["데이터-저장하기.html", "13.2 데이터 저장하기", " 13.2 데이터 저장하기 R 에서 처리한 개체를 다양한 형식으로 내보내 저장할 수 있습니다. SPSS, SAS 및 Stata의 경우에는 별도의 패키지를 사용해야 합니다. 그리고 Excel의 경우는 xlsx 패키지가 필요합니다. 13.2.1 R 형식으로 저장하기 R에서는 처리한 데이터를 R 고유의 데이터 형식으로 저장할 수 있습니다. 대표적인 형식이 .rds와 .Rdata (또는 .rda) 형식입니다. 이러한 형식으로 데이터를 저장하는 것은 많은 장점이 있습니다. 데이터를 R로 복원하는 것이 더 빠릅니다. 데이터에 인코딩된 R 고유의 정보들(예 : 속성, 변수 유형 등)을 그대로 유지해 줍니다. saveRDS() 함수와 readRDS() 함수는 단일 R 개체 만 처리합니다. 그러나 불러들인 개체의 개체 이름이 개체가 저장될 때의 개체 이름과 같을 필요가 없다는 점에서 다중 개체 저장 방식보다 더 유연합니다. 예를 들어 앞의 예에서 전국 대학도서관정보 파일에서 불러온 mydata 개체를 .rds 형식의 파일로 저장해 보겠습니다. ## mydata 데이터 세트를 data_output 폴더에 univ_library.rds 파일로 저장합니다. saveRDS(mydata, &quot;data_output/univ_library.rds&quot;) # 저장된 iris.rds 파일을 다시 불러들입니다. univ.libr &lt;- readRDS(&quot;data_output/univ_library.rds&quot;) str(univ.libr) ## &#39;data.frame&#39;: 1834 obs. of 9 variables: ## $ 평가년도 : int 2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ... ## $ 도서관구분: chr &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; ... ## $ 도서관코드: int 227 25 269 290 311 340 363 387 408 43 ... ## $ 면적 : chr &quot;경북&quot; &quot;대전&quot; &quot;경기&quot; &quot;서울&quot; ... ## $ 시군구 : chr &quot;영천시&quot; &quot;서구&quot; &quot;여주시&quot; &quot;종로구&quot; ... ## $ 장서수 : int 20827 31054 114815 6326 756633 1306474 1611325 136147 4421 1379785 ... ## $ 사서수 : int 1 1 2 1 6 11 30 2 0 20 ... ## $ 대출권수 : int 2044 15745 10677 4647 53358 303522 187458 26534 495 123313 ... ## $ 예산액 : num 3.44e+07 0.00 3.80e+07 7.50e+06 1.05e+08 ... 한편 복수의 개체들을 저장하기 위해서는 save() 함수를 사용하며, 그 결과는 .Rdata 형식으로 저장됩니다. 예를 들어, 전국 대학도서관정보인 mydata와 mydata1 등의 2개의 개체를 library.Rdata라는 파일로 저장해 보겠습니다. ## mydata와 mydata1 두 개의 데이터 세트를 저장합니다. save(mydata, mydata1, # 저장할 개체를 지정합니다. file = &quot;data_output/library.Rdata&quot;) # 저장할 Rdata의 경로와 파일명을 지정합니다. ## 저장된 Rdata 파일은 load() 함수로 불러옵니다. load(&quot;data_output/library.Rdata&quot;) # 변수에 할당할 필요가 없습니다. load()함수의 경우에는 Rdata에 저장되어 있는 개체들의 이름을 그대로 불러오게 됩니다. 13.2.2 CSV로 저장하기 R에서 처리한 개체를 write.csv() 함수 또는 write.table() 함수를 이용하여 csv 파일로 저장할 수 있습니다. write.csv() 함수의 형식은 다음가 같습니다. write.csv(x, file = “”, row.names = TRUE) x : 파일에 저장할 데이터 프레임 또는 행렬 등의 개체입니다. file=\"\" : 데이터를 저장할 경로와 파일명입니다. row.names=TRUE : TRUE면 행 이름을 CSV 파일에 포함시켜 저장합니다. 앞에서 mydata 개체를 write.csv() 함수를 이용하여 mydata.csv로 저장해 보겠습니다. 예를 들어, 전국대학교 도서관정보를 담고 있는 mydata 개체를 저장해 보겠습니다. 그런데 이 개체에는 한글이 있기 때문에 fileEncoding = 인수에 “UTF-8”을 입력해 줘야 합니다. ## mydata 개체를 mydata.csv로 저장합니다. write.csv(mydata, &quot;data_output/mydata.csv&quot;, fileEncoding = &quot;UTF-8&quot;) # 한글 코딩을 설정합니다. ## 또는 write.table() 함수를 이용할 수도 있습니다. write.table(mydata, &quot;data_output/mydataTable.csv&quot;, fileEncoding = &quot;UTF-8&quot;) # 한글 코딩을 설정합니다. ## 데이터 항목의 구분자를 설정할 수도 있습니다. write.table(mydata, &quot;data_output/mydataTable.csv&quot;, sep = &quot;\\t&quot;, # 구분자로 탭문자(\\t)를 설정합니다. fileEncoding = &quot;UTF-8&quot;) # 한글 코딩을 설정합니다. 13.2.3 엑셀 시트로 저장하기 xlsx 패키지의 write.xlsx() 함수를 이용하면 R의 개체를 Excel 시트로도 저장할 수 있습니다. 예를 들어, mydata 개체를 mydata.xlsx 파일로 저장해 보겠습니다. ## mydata 개체를 mydata.xlsx 파일로 저장합니다. # install.packages(&quot;xlsx&quot;) library(xlsx) write.xlsx(mydata, &quot;data_output/mydata.xlsx&quot;) # 특별히 한글코드를 지정할 필요가 없습니다. 엑셀 파일로 저장하는데 시간이 걸리는 것을 느낄 수 있습니다. 13.2.4 기타 형식으로 저장하기 SPSS, SAS, Stata 형식으로도 저장할 수 있습니다. 다음의 예를 참고하기 바랍니다. mydata 개체를 저장해 보겠습니다. ## SPSS로 저장합니다. library(foreign) write.foreign(mydata, &quot;c:/mydata.txt&quot;, &quot;c:/mydata.sps&quot;, package = &quot;SPSS&quot;) ## SAS로 저장합니다. library(foreign) write.foreign(mydata, &quot;c:/mydata.txt&quot;, &quot;c:/mydata.sas&quot;, package=&quot;SAS&quot;) ## Stata로 저장합니다. library(foreign) write.dta(mydata, &quot;c:/mydata.dta&quot;) "],["데이터-확인하기.html", "13.3 데이터 확인하기", " 13.3 데이터 확인하기 R에는 데이터의 개체 또는 데이터 세트의 내용을 확인하기 위한 함수들이 많이 있습니다. # 현재의 작업 한경에 있는 개체의 목록을 확인합니다. : ls() ls() ## [1] &quot;a&quot; &quot;arr.1&quot; &quot;arr.2&quot; ## [4] &quot;arr.3&quot; &quot;arr.4&quot; &quot;arr.5&quot; ## [7] &quot;b&quot; &quot;candy_patterns&quot; &quot;comp.index&quot; ## [10] &quot;conv1&quot; &quot;conv2&quot; &quot;conv3&quot; ## [13] &quot;conv4&quot; &quot;conv5&quot; &quot;d&quot; ## [16] &quot;data&quot; &quot;data1&quot; &quot;data2&quot; ## [19] &quot;data3&quot; &quot;date&quot; &quot;date1&quot; ## [22] &quot;dates&quot; &quot;Dates.Chr&quot; &quot;days&quot; ## [25] &quot;df&quot; &quot;df.arr.3&quot; &quot;df1&quot; ## [28] &quot;df2&quot; &quot;df3&quot; &quot;df4&quot; ## [31] &quot;df5&quot; &quot;dia.mat1&quot; &quot;dia.mat2&quot; ## [34] &quot;emp.data&quot; &quot;emp.data1&quot; &quot;emp.finaldata&quot; ## [37] &quot;emp.newdata&quot; &quot;final&quot; &quot;floor&quot; ## [40] &quot;floor_type&quot; &quot;floor_type_ordered&quot; &quot;ftab.1&quot; ## [43] &quot;ftab.2&quot; &quot;ftab.3&quot; &quot;ftab.4&quot; ## [46] &quot;grade.cast&quot; &quot;grade.full&quot; &quot;grade.inner&quot; ## [49] &quot;grade.left&quot; &quot;grade.molten&quot; &quot;grade.right&quot; ## [52] &quot;i.mat&quot; &quot;interviews&quot; &quot;kbd.data&quot; ## [55] &quot;list_data&quot; &quot;list_data1&quot; &quot;list_data2&quot; ## [58] &quot;list1&quot; &quot;list2&quot; &quot;lst&quot; ## [61] &quot;mat&quot; &quot;mat.names&quot; &quot;mat1&quot; ## [64] &quot;mat2&quot; &quot;mat3&quot; &quot;mean.myvar1&quot; ## [67] &quot;memb_assoc&quot; &quot;merged.list&quot; &quot;mid&quot; ## [70] &quot;my.comp.df&quot; &quot;my.dates&quot; &quot;my.df&quot; ## [73] &quot;my.new.df&quot; &quot;mycsv&quot; &quot;mydata&quot; ## [76] &quot;mydata1&quot; &quot;mydates&quot; &quot;myString&quot; ## [79] &quot;num1&quot; &quot;num2&quot; &quot;ordered_floor&quot; ## [82] &quot;p&quot; &quot;pi&quot; &quot;result&quot; ## [85] &quot;s&quot; &quot;s1&quot; &quot;s2&quot; ## [88] &quot;s3&quot; &quot;s4&quot; &quot;s5&quot; ## [91] &quot;s6&quot; &quot;samp.data&quot; &quot;st_data&quot; ## [94] &quot;sub_candy&quot; &quot;sum_1_2&quot; &quot;t.mat&quot; ## [97] &quot;tb&quot; &quot;today&quot; &quot;trees&quot; ## [100] &quot;trees.2.3&quot; &quot;trees.fil&quot; &quot;True&quot; ## [103] &quot;uniq_d&quot; &quot;univ.libr&quot; &quot;v&quot; ## [106] &quot;v1&quot; &quot;v2&quot; &quot;v3&quot; ## [109] &quot;var.1&quot; &quot;var.2&quot; &quot;var.3&quot; ## [112] &quot;w&quot; &quot;w1&quot; &quot;w10&quot; ## [115] &quot;w2&quot; &quot;w3&quot; &quot;w4&quot; ## [118] &quot;w5&quot; &quot;w6&quot; &quot;w7&quot; ## [121] &quot;w8&quot; &quot;w9&quot; &quot;x&quot; ## [124] &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; ## [127] &quot;x4&quot; &quot;x5&quot; &quot;x6&quot; ## [130] &quot;x7&quot; &quot;y&quot; &quot;y1&quot; ## [133] &quot;y2&quot; &quot;y3&quot; &quot;y5&quot; ## [136] &quot;y6&quot; &quot;y7&quot; &quot;year_fct&quot; ## [139] &quot;z&quot; &quot;z1&quot; &quot;z2&quot; # 현재의 작업 환경에 있는 개체를 제거합니다. : rm() rm(list = ls()) # 현재의 작업 환경에 있는 모든 개체들을 제거합니다. # rm()에 의해 mydata 개체가 제거되어서, 다시 파일을 불러옵니다. mydata &lt;- read.table(&quot;data/University_Library_20201028.csv&quot;, head = TRUE, sep = &quot;,&quot;) # mydata에 있는 컬럼(변수)을 확인합니다. : names() names(mydata) ## [1] &quot;평가년도&quot; &quot;도서관구분&quot; &quot;도서관코드&quot; &quot;면적&quot; &quot;시군구&quot; ## [6] &quot;장서수&quot; &quot;사서수&quot; &quot;대출권수&quot; &quot;예산액&quot; # mydata의 구조를 확인합니다. : str() str(mydata) ## &#39;data.frame&#39;: 1834 obs. of 9 variables: ## $ 평가년도 : int 2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ... ## $ 도서관구분: chr &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; &quot;LIBTYPE008&quot; ... ## $ 도서관코드: int 227 25 269 290 311 340 363 387 408 43 ... ## $ 면적 : chr &quot;경북&quot; &quot;대전&quot; &quot;경기&quot; &quot;서울&quot; ... ## $ 시군구 : chr &quot;영천시&quot; &quot;서구&quot; &quot;여주시&quot; &quot;종로구&quot; ... ## $ 장서수 : int 20827 31054 114815 6326 756633 1306474 1611325 136147 4421 1379785 ... ## $ 사서수 : int 1 1 2 1 6 11 30 2 0 20 ... ## $ 대출권수 : int 2044 15745 10677 4647 53358 303522 187458 26534 495 123313 ... ## $ 예산액 : num 3.44e+07 0.00 3.80e+07 7.50e+06 1.05e+08 ... # mydata의 요인 컬럼의 요인 수준을 확인합니다. : levels() mydata$&quot;평가년도&quot; &lt;- as.factor(mydata$&quot;평가년도&quot;) # 평가년도 컬럼을 요인형으로 변환합니다. levels(mydata$&quot;평가년도&quot;) # 수준을 확인합니다. ## [1] &quot;2014&quot; &quot;2015&quot; &quot;2016&quot; &quot;2017&quot; # mydata의 차원을 확인합니다. : dim() dim(mydata) ## [1] 1834 9 # 개체의 클래스를 확인합니다. : class() class(mydata) ## [1] &quot;data.frame&quot; # mydata를 출력합니다. # mydata # 너무 데이터가 많아서 생략합니다. # mydata의 첫 10개 행을 출력합니다. : head() head(mydata, n = 10) ## 평가년도 도서관구분 도서관코드 면적 시군구 장서수 사서수 대출권수 예산액 ## 1 2014 LIBTYPE008 227 경북 영천시 20827 1 2044 34412000 ## 2 2014 LIBTYPE008 25 대전 서구 31054 1 15745 0 ## 3 2014 LIBTYPE008 269 경기 여주시 114815 2 10677 38000000 ## 4 2014 LIBTYPE008 290 서울 종로구 6326 1 4647 7500000 ## 5 2014 LIBTYPE008 311 경남 김해시 756633 6 53358 105000000 ## 6 2014 LIBTYPE008 340 서울 동작구 1306474 11 303522 740000000 ## 7 2014 LIBTYPE008 363 대전 유성구 1611325 30 187458 300000000 ## 8 2014 LIBTYPE008 387 경기 시흥시 136147 2 26534 35000000 ## 9 2014 LIBTYPE008 408 전북 김제시 4421 0 495 6500000 ## 10 2014 LIBTYPE008 43 경남 진주시 1379785 20 123313 320000000 # mydata의 마지막 5개 행을 출력합니다. : tail() tail(mydata, n=5) ## 평가년도 도서관구분 도서관코드 면적 시군구 장서수 사서수 대출권수 ## 1830 2017 LIBTYPE008 60 서울 성북구 2867238 28 429509 ## 1831 2017 LIBTYPE008 61 세종 누락 554001 3 42765 ## 1832 2017 LIBTYPE008 62 서울 종로구 48966 0 7408 ## 1833 2017 LIBTYPE008 63 부산 영도구 470566 4 36713 ## 1834 2017 LIBTYPE008 64 충북 청주시 217010 7 37760 ## 예산액 ## 1830 731938000 ## 1831 91473000 ## 1832 15000000 ## 1833 120700000 ## 1834 90000000 # mydata를 View화면에서 확인합니다 : View() View(mydata) 참고자료 https://www.statmethods.net/ https://www.datacamp.com/community/tutorials/r-data-import-tutorial https://learn.datacamp.com/courses/importing-data-in-r-part-1 "],["조건문.html", "Chapter 14 조건문", " Chapter 14 조건문 반복문(looping)은 R 식의 시퀀스를 구성하여 특정 다단계 프로세스를 자동화하는 수단이라는 점에서 함수 생성과 유사합니다. R은 목적이 다른 반복 코드 프로세스를 수행하고, 이러한 자동화된 표현이 데이터의 특징에 자연스럽게 응답할 수 있도록 하는 여러 루프 제어문으로 구성됩니다. 결과적으로 이러한 루프 제어 문을학습하면 코드의 중복을 줄이고, 보다 효율적인 데이터 관리자가 되는 데 많은 도움이 됩니다. 이번 장에서는 R에서 다루는 조건문들에 대하여 학습하겠습니다. "],["if-조건문.html", "14.1 if 조건문", " 14.1 if 조건문 if 조건문은 조건식을 테스트하는 데 사용됩니다. test_expression이TRUE이면statement가 실행됩니다. 하지만 FALSE이면 아무 일도 일어나지 않습니다. 여기서 test_expression은 논리형 벡터 또는 숫자형 벡터 일 수 있지만 첫 번째 요소 만 고려됩니다. 숫자형 벡터의 경우 0은 FALSE로, 나머지는 TRUE로 간주됩니다. if 조건문을 플로우 차트로 나타내면 다음과 같습니다. Flowchart of if in R Programming if 조건문의 형식은 다음과 같습니다. # if 조건문의 형식 if (test_expression) { statement } 다음은 벡터의 값이 음수인지 테스트하는 예입니다. 이if 문을 작성하는 방법에는 두 가지가 있습니다. 명령문의 본문은 한 줄이기 때문에 블럭을 나타내는 중괄호({})를 사용하거나 사용하지 않고 작성할 수 있습니다. 그러나 중괄호를 사용하는 습관을 들이는 것이 좋습니다. 이렇게하면 본문에 추가 함수가 있는 if 문을 작성하거나 나중에 else문을 추가하면 예기치 않은 코드 절차와 관련된 문제가 발생하지 않습니다. # 테스트할 벡터를 생성합니다. x &lt;- c(8, 3, -2, 5) # 명령문이 한 줄인 경우 중괄호 없이 if 조건문의 실행문을 작성할 수 있습니다. if(any(x &lt; 0)) print(&quot;x contains negative numbers&quot;) # x 요소 중 하나라도(any) 음수가 있다면 출력합니다. ## [1] &quot;x contains negative numbers&quot; # 중괄호를 사용해도 같은 결과를 가져옵니다. if(any(x &lt; 0)){ print(&quot;x contains negative numbers&quot;) } ## [1] &quot;x contains negative numbers&quot; # 만일 조건문이 FALSE인 경우에는 어떠한 결과도 반환하지 않습니다. y &lt;- c(8, 3, 2, 5) # y 요소가 모두 양수입니다. if(any(y &lt; 0)){ # any(y&lt;0) 이 FALSE 입니다. print(&quot;y contains negative numbers&quot;) # 이 명령문은 실행되지 않습니다. } "],["if-else-조건문.html", "14.2 if...else 조건문", " 14.2 if...else 조건문 if ... else 조건문은 if 조건문과 유사한 조건식을 테스트하는 데 사용됩니다. 그러나 if 조건문에서는 test_expression이FALSE이면 아무 일도 일어나지 않지만 if ... else 조건문에서는 else 부분이 평가됩니다. if...else 조건문의 플로우 차트는 다음과 같습니다. Flowchart of if…else in R Programming if … else 조건문의 형식은 다음과 같습니다. # if...else 조건문의 형식 if (test_expression) { # 조건식을 검사하고 조건이 TRUE 이면 실행될 블럭을 지정합니다. (TRUE 블럭) statement 1 } else { # 조건이 FALSE이면 실행될 블럭을 지정합니다. (FALSE 블럭) statement 2 } 다음은if 조건을 이용하여 벡터의 값에 음수 값이 있는지 확인하는 if 조건문을 설명한 앞의 예를 확장한 것입니다. if 조건문의 조건식 결과가 TRUE이면 TRUE 블럭을 실행하고, FALSE이면 else 이하의 FALSE 블럭을 실행하게 됩니다. # 다음의 if 조건문은 TRUE 블럭을 실행하는 예입니다. x &lt;- c(8, 3, -2, 5) if(any(x &lt; 0)){ print(&quot;x contains negative numbers&quot;) } else{ # FASLE 블럭은 실행되지 않습니다. print(&quot;x contains all positive numbers&quot;) } ## [1] &quot;x contains negative numbers&quot; # 다음의 if 조건문은 FALSE 블럭을 실행하는 예입니다. y &lt;- c(8, 3, 2, 5) if(any(y &lt; 0)){ # TRUE 블럭은 실행되지 않습니다. print(&quot;y contains negative numbers&quot;) } else{ print(&quot;y contains all positive numbers&quot;) } ## [1] &quot;y contains all positive numbers&quot; 앞에서 살펴본 예를 if … else조건문을 이용하여 한줄로도 간단히 표현할 수 있습니다. # 대체적 방법 if(any(x &lt; 0)) print(&quot;x contains negative numbers&quot;) else print(&quot;x contains all positive numbers&quot;) ## [1] &quot;x contains negative numbers&quot; "],["ifelse-함수.html", "14.3 ifelse() 함수", " 14.3 ifelse() 함수 위와 같이 명령문에서 한 줄의 코드만 실행되는 간단한if ... else 문은 간단한 대체적인 방식으로 작성될 수 있습니다. 다음 대안은 매우 짧은ifelse() 함수의 사용 예입니다. ifelse() 함수의 형식은 다음과 같습니다. ifelse(test, yes, no) test : 조건식입니다. yes : 조건식이 TRUE 일 때 실행되는 TRUE 블럭에 해당합니다. no : 조건식이 FALSE일때 실행되는 FALSE 블럭에 해당합니다. 여기서 test는 논리형 벡터 (또는 논리로 강제 변환 될 수있는 개체)여야 합니다. 반환 값은 test와 길이가 같은 벡터입니다. 이 ifelse() 함수에 의해 반환되는 벡터는 test의 값이 TRUE 인 경우 yes의 요소가 되고, test의 값이 FALSE 인 경우 no의 요소가 됩니다. 즉, test[i]가 TRUE이면 결과의 i 번째 요소는 yes[i]가 됩니다. FALSE이면 no[i]의 값을 반환하게 됩니다. 벡터 yes와 no는 필요할 때마다 자동 채우기(recycling)가 됩니다. ifelse() 함수의 사용에 대한 간단한 예를 들어 보겠습니다. # 벡터 a의 요소들이 짝수이면 &quot;even&quot;, 홀수 이면 &quot;odd&quot;를 반환합니다. a &lt;- c(5, 7, 2, 9) # 예제 벡터입니다. ifelse(a %% 2 == 0, &quot;even&quot;, &quot;odd&quot;) # a %% 2 == 0 벡터 나머지 연산을 하여 결과를 반환합니다. ## [1] &quot;odd&quot; &quot;odd&quot; &quot;even&quot; &quot;odd&quot; 위의 예에서 test에 해당하는 a %% 2 == 0의 반환결과는 논리형 벡터로 (FALSE, FALSE, TRUE, FALSE)가 됩니다. 마찬가지로 함수 인수의 다른 두 벡터인 yes와 no는 각각 ( \"even\", \"even\", \"even\", \"even\") 과 ( \"odd\", \"odd\", \"odd\", \"odd\")로 자동 채우기가 됩니다. 따라서 결과는 test가 반환하는 벡터의 요소 값에 따라 평가가 되어 최종 결과로 (“odd”, “odd”, “even”, “odd”)가 반환됩니다. 앞에서 살펴본 예를 ifelse() 함수를 이용하면 간단하게 작성할 수 있습니다. x &lt;- c(8, 3, 2, 5) # ifelse() 함수의 이용 방법 ifelse(any(x &lt; 0), &quot;x contains negative numbers&quot;, &quot;x contains all positive numbers&quot;) ## [1] &quot;x contains all positive numbers&quot; "],["중청된-if-else-조건문.html", "14.4 중청된 if … else 조건문", " 14.4 중청된 if … else 조건문 if ... else 조건문은 필요한 만큼 중첩 할 수도 있습니다. 중첩된 if … else 조건문은 다음과 같은 형식입니다. if ( test_expression1) { # 첫번째 조건문입니다. statement1 # 첫번째 조건의 TRUE 블럭입니다. } else if ( test_expression2) { # 두번째 조건문입니다. statement2 # 두번째 조건의 TRUE 블럭입니다. } else if ( test_expression3) { # 세번째 조건문입니다. statement3 # 세번째 조건의 TRUE 블럭입니다. } else { # 모든 조건의 FALSE 블럭입니다. statement4 } 예를 들면 : # 다음은 허용범위(0부터 10까지의 값)를 조건으로 하는 중첩 if ... else 조건문의 예입니다. x &lt;- 7 if(x &gt;= 10){ # 첫번째 조건의 TRUE 블럭입니다. print(&quot;x exceeds acceptable tolerance levels&quot;) } else if(x &gt;= 0 &amp; x &lt; 10){ # 두번째 조건의 TRUE 블럭입니다. print(&quot;x is within acceptable tolerance levels&quot;) } else { # 모든 조건의 FALSE 블럭입니다. print(&quot;x is negative&quot;) } ## [1] &quot;x is within acceptable tolerance levels&quot; "],["switch-함수.html", "14.5 switch() 함수", " 14.5 switch() 함수 R의switch ()함수는 list의 요소에 대해 조건식을 테스트합니다. 조건식에서 평가된 값이 list의 항목과 일치하면 해당 값이 반환됩니다. switch() 함수의 형식은 다음과 같습니다. switch (expression, list) Here, the expression is evaluated and based on this value, the corresponding item in the list is returned. If the value evaluated from the expression matches with more than one item of the list, switch() function returns the first matched item. 여기서 조건식인 expression이 평가되고, 이 값을 기반으로 list의 해당 항목이 반환됩니다. 조건식인 expression에서 평가된 값이 list의 두 개 이상의 항목과 일치하는 경우 switch()함수는 첫 번째 일치 항목을 반환합니다. switch() 함수의 예를 들어 보겠습니다. 평가된 값이 숫자이면 목록의 해당 항목이 반환됩니다. switch(2,&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;) # 2번째 요소가 반환됩니다. ## [1] &quot;green&quot; switch(1,&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;) # 1번째 요소가 반환됩니다. ## [1] &quot;red&quot; 이 예에서 \"red\",\"green\",\"blue\"가 세 개의 항목으로 된 리스트입니다. 이처럼 switch()함수는 평가된 숫자 값에 해당하는 항목을 반환합니다. 그런데 만일 해당하는 항목이 없으면 어떻게 될까요? 결론적으로 NA를 반환하게 됩니다. x &lt;- switch(4,&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;) # 4번째 항목이 없기 때문에 NA를 반환합니다. x ## NULL x &lt;- switch(0,&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;) # 0번째 항목이 없기 때문에 NA를 반환합니다. x ## NULL switch() 함수의 조건식에 문자열도 사용될 수 있습니다. 그러면 switch() 함수는 이 문자열으로 이름 붙여진 항목의 값을 반환하게 됩니다. switch(&quot;color&quot;, &quot;color&quot; = &quot;red&quot;, &quot;shape&quot; = &quot;square&quot;, &quot;length&quot; = 5) # &quot;color&quot; 요소를 반환합니다. ## [1] &quot;red&quot; # 따라서 &quot;red&quot;가 반환됩니다. switch(&quot;length&quot;, &quot;color&quot; = &quot;red&quot;, &quot;shape&quot; = &quot;square&quot;, &quot;length&quot; = 5) # &quot;length&quot; 요소를 반환합니다. ## [1] 5 # 따라서 5를 반환합니다. 다음은 switch() 함수를 이용한 간단한 계산기 프로그램입니다.15 # 사칙연산을 수행하는 함수로 구현된 단순한 계산기 프로그램입니다. add &lt;- function(x, y) { return(x + y) } subtract &lt;- function(x, y) { return(x - y) } multiply &lt;- function(x, y) { return(x * y) } divide &lt;- function(x, y) { return(x / y) } # 사용자로부터 자료를 입력받습니다. print(&quot;연산자를 선택하세요(1/2/3/4).&quot;) ## [1] &quot;연산자를 선택하세요(1/2/3/4).&quot; print(&quot;1. 더하기&quot;) ## [1] &quot;1. 더하기&quot; print(&quot;2. 빼기&quot;) ## [1] &quot;2. 빼기&quot; print(&quot;3. 곱하기&quot;) ## [1] &quot;3. 곱하기&quot; print(&quot;4. 나누기&quot;) ## [1] &quot;4. 나누기&quot; choice = as.integer(readline(prompt=&quot;[1/2/3/4] 중에서 선택하세요 : &quot;)) ## [1/2/3/4] 중에서 선택하세요 : num1 = as.integer(readline(prompt=&quot;첫 번째 수를 입력하세요 : &quot;)) ## 첫 번째 수를 입력하세요 : num2 = as.integer(readline(prompt=&quot;두 번째 수를 입력하세요 : &quot;)) ## 두 번째 수를 입력하세요 : # 연산자를 선택합니다. operator &lt;- switch(choice,&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;) # 각 연산자에 해당하는 함수를 선택하여 연산을 수행합니다. result &lt;- switch(choice, add(num1, num2), subtract(num1, num2), multiply(num1, num2), divide(num1, num2)) # 계산결과를 출력합니다. print(paste(num1, operator, num2, &quot;=&quot;, result)) ## [1] &quot;NA NA = &quot; 참고자료 http://uc-r.github.io/control_statements https://www.datamentor.io/r-programming/if-else-statement/ https://www.datamentor.io/r-programming/ifelse-function/ https://www.datamentor.io/r-programming/switch-function/ https://www.datamentor.io/r-programming/examples/simple-calculator/ https://www.datamentor.io/r-programming/examples/simple-calculator/를 참고하였습니다. "],["반복구문.html", "Chapter 15 반복구문", " Chapter 15 반복구문 R의 계산은 순차적으로 평가하는 명령문(statement)으로 구성됩니다. x &lt;- 1 : 10 또는 mean(y)와 같은 명령문은 세미콜론(;) 또는 새 줄(&lt;Enter&gt;)로 구분할 수 있습니다. 평가자에게 구문상 완전한 명령문이 표시될 때마다 해당 명령문이 평가되고 결과가 값으로 반환됩니다. 명령문을 평가한 결과는 그 명령문의 값이라고 할 수 있습니다. 값은 항상 하나의 기호(변수)에 할당 될 수 있습니다. 세미콜론(;)과 새 줄은 모두 명령문을 구분하는 데 사용할 수 있습니다. 세미콜론(;)은 항상 명령문의 끝을 나타내며, 새 줄은 명령문의 끝을 나타내지 못할 수도 있습니다. 이는 현재 명령문이 구문적으로 완전하지 않으면 평가자에 의해 새 줄은 명령문의 끝을 나타내지 못합니다. 이는 세션이 대화형일 떄 프롬프트가 ‘&gt;’ 에서 ‘+’ 로 변경되어 표시해 줍니다. x &lt;- 0; x + 5 ## [1] 5 y &lt;- 1:10 1:2 ## [1] 1 2 명령문들은 중괄호‘{’와 ‘}’를 사용하여 함께 그룹화할 수 있습니다. 명령문 그룹을 때때로 블록(block, body)이라고합니다. 구문 상 완전한 명령문 끝에 새 행을 입력하면 단일 명령문이 평가됩니다. 블록은 닫는 중괄호 다음에 새 줄을 입력할 때까지 평가되지 않습니다. 이 절의 나머지 부분에서 명령문은 단일 명령문 또는 블록 명령문을 나타냅니다. 이번 장과 다음 장에서는 이러한 명령문을 반복적으로 수행하게 하거나, 조건에 따라 다른 명령문을 수행하게 하는 방법에 대하여 학습하겠습니다. 먼저 명령문을 반복적으로 수행하게 하는 방법에 대하여 살펴 보겠습니다. R에는 명시적으로 명령문을 반복적으로 수행하게 하는 명령문에는 for, while, 그리고 repeat 등이 있습니다. 문법 의미 for (i in data) { i를 사용한 문장 } data에 들어 있는 각각의 값을 변수 i에 할당하면서 각각에 대해 블록 안의 문장을 수행합니다. while (cond) { 조건이 참일 때 수행할 문장 } 조건 cond가 참일 때 블록 안의 문장을 수행합니다. repeat { 반복해서 수행할 문장 } 블록 안의 문장을 반복해서 수행합니다. repeat는 다른 언어의 do-while에 해당합니다. 두 개의 R에 내장된 구조인 next와 break는 이러한 반복구문에 추가적인 제어를 제공합니다. 또한 R은 tapply() 함수, apply() 그리고 lapply() 함수와 같은 암시적 루프를 위한 다른 함수도 제공하고 있습니다. 또한 많은 연산에서 특히 벡터에 대한 학습에서 살펴본 바와 같이 산술 연산이 벡터화되므로 루프를 사용할 필요가 없습니다. 루프를 명시적으로 제어하는 데 사용할 수있는 두 가지 명령문이 있습니다. 그것은 break와 next 입니다. break 문은 현재 실행중인 가장 안쪽 루프에서 종료됩니다. next 문은 즉시 제어가 루프의 시작으로 돌아가도록 합니다. 그런 다음 루프의 다음 반복 (있는 경우)이 실행됩니다. 현재 루프에서 next 아래의 문은 평가되지 않습니다. 루프 문에서 반환된 값은 항상 NULL이며 보이지 않게 반환됩니다. "],["for-반복문.html", "15.1 for 반복문", " 15.1 for 반복문 for 반복구문은 특정 횟수 동안 반복적으로 코드 문을 실행하는데 사용됩니다. for 반복구문의 플로우 차트는 다음과 같습니다. r for loop flowchart for 반복구문의 형식은 다음과 같습니다. for (val in sequence) # val 값을 sequence의 첫번째 값부터 마지막까지 하나씩 할당합니다. { statement # 반복실행되는 명령문입니다. } for 구문의 일반적인 형식은 i 를 카운터로 하고 이 카원터가 순차적으로 증가하는 i번째 값에서 코드의 본체(body)가 실행되는 for 루프는 특정 횟수 동안 반복적인 명령문을 실행하는 데 사용됩니다. i가 카운터이고 i가 정의되어 있는 각 순차 값(이 예에서는 1부터 100까지)을 가정하므로 본문의 코드가 i 번째 값에 대해 수행되는 일반적인 구문은 다음과 같습니다. # for 반복구문의 형식 for(i in 1:100) { &lt;do stuff here with i&gt; } 예를 들어, 다음 ‘for’ 반복은 i가 가질 수 있는 값 (2010, 2011,…, 2016)의 범위인 2010에서 시작하여 2016의 값을 가질 때까지 중괄호 안에 있는 블럭의 ‘paste()’ 함수와 ‘print()’ 함수를 반복적으로 수행합니다. for (i in 2010:2016){ output &lt;- paste(&quot;The year is&quot;, i) print(output) } ## [1] &quot;The year is 2010&quot; ## [1] &quot;The year is 2011&quot; ## [1] &quot;The year is 2012&quot; ## [1] &quot;The year is 2013&quot; ## [1] &quot;The year is 2014&quot; ## [1] &quot;The year is 2015&quot; ## [1] &quot;The year is 2016&quot; 만일 for 루프를 수행하여 output을 벡터 또는 다른 데이터 구조로 결합시키려면 for 루프 이전에 output 데이터 구조를 지정할 수 있습니다. 예를 들어, 앞의 output출력 결과들을 하나의 벡터 x로 결합하고자 한다면 먼저 x를 for 루프 이전에 정의한 다음, for 루프 안에서 output 을 x에 추가하면 됩니다. 그 결과는 앞의 예에서 보았던 output 의 결과들이 벡터 x의 요소가 된다는 것입니다. # 블록 내의 output 결과를 하나의 벡터 x로 결합하기 x &lt;- NULL # x를 정의합니다. for (i in 2010:2016){ # for 반복구문의 시작입니다. output &lt;- paste(&quot;The year is&quot;, i) # paste() 결과를 output에 할당합니다. x &lt;- append(x, output) # x에 output을 추가합니다. } x # 최종적으로 하나의 벡터 x로 출력됩니다. ## [1] &quot;The year is 2010&quot; &quot;The year is 2011&quot; &quot;The year is 2012&quot; &quot;The year is 2013&quot; ## [5] &quot;The year is 2014&quot; &quot;The year is 2015&quot; &quot;The year is 2016&quot; 그러나 학습해야 할 중요한 교훈은 R이 데이터 개체를 증가(growing)시키는 데 효율적이지 않다는 것입니다. 결과적으로 빈 데이터 객체를 만들고for 루프 출력으로 채우는(filling) 것이 더 효율적입니다. 이전 예에서는 새 값을 추가하여 x를 증가시켰습니다. 보다 효율적인 방법은 적당한 길이의 벡터 (또는 기타 데이터 구조)를 미리 정의하고 그 요소를 채우는 것입니다. 다음 예에서는 올바른 크기의 벡터 x 를 만든 다음 for 루프 내에서 각 요소를 채우는 것을 보여 주고 있습니다. 이 작은 예제에서는 이러한 비효율성이 눈에 띄지 않지만 더 큰 반복을 수행하면 눈에 띄게 될 것이므로 증가보다는 채우기 습관을 갖는 것이 좋습니다. ## 적당한 길이의 벡터를 그 유형과 함께 정의합니다. x &lt;- vector(mode = &quot;numeric&quot;, length = 7) # 숫자형으로 길이가 7인 벡터 x를 정의합니다. counter &lt;- 1 # counter 변수의 초기값으로 1을 설정합니다. for (i in 2010:2016){ # for 반복구문의 시작입니다. output &lt;- paste(&quot;The year is&quot;, i) # paste() 결과를 output에 할당합니다. x[counter] &lt;- output # output 결과를 x 요소로 채워 넣습니다. counter &lt;- counter + 1 # counter를 1증가 시킵니다. } x ## [1] &quot;The year is 2010&quot; &quot;The year is 2011&quot; &quot;The year is 2012&quot; &quot;The year is 2013&quot; ## [5] &quot;The year is 2014&quot; &quot;The year is 2015&quot; &quot;The year is 2016&quot; 다음의 예는 5 개의 행과 5 개의 열로 된 빈 행렬 my.dat를 정의하여 채워가는 예입니다. my.dat 행렬을 미리 정의한 다음for 루프가 각 열에 대하여 반복적으로 (여기에서 i가my.mat 행렬의 열 번호 값 1을 어떻게 취하는지 주목하기 바랍니다.) i 컬럼에 있는 평균 i를 갖는 포아송 분포에서 추출된 5개의 난수를 가져와 각 열의 요소로 채우게 됩니다. : my.mat &lt;- matrix(NA, nrow = 5, ncol = 5) # my.dat 행렬을 미리 정의합니다. set.seed(1000) # 난수의 초기값을 지정합니다. for(i in 1:ncol(my.mat)){ # for 반복구문의 시작입니다. my.mat[, i] &lt;- rpois(5, lambda = i) # ㅑ 컬럼을 rpois() 함수 반환값으로 할당합니다. } my.mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 2 1 3 ## [2,] 2 3 4 4 7 ## [3,] 0 2 2 5 4 ## [4,] 1 1 5 1 2 ## [5,] 1 1 4 4 5 "],["while-반복구문.html", "15.2 while 반복구문", " 15.2 while 반복구문 While루프는 조건 테스트로 시작됩니다. TRUE이면 명령문을 실행합니다. 명령문이 실행되면 조건이 다시 테스트되고 조건이 FALSE가 될 때까지 계속해서 반복하다가 루프가 종료됩니다. while 내의 블록이 몇 번 반복되었는가를 확인하기 위한 counter 개체를 포함하는 것도 좋은 방법입니다. while 반복구문의 플로우 차트는 다음과 같습니다. Flowchart of while loop in R programming while 반복구문의 형식은 다음과 같습니다. # while 반복구문의 형식 counter &lt;- 1 # 반복횟수 확인을 위한 counter 입니다. while(test_expression) { # while 반복구문의 시작입니다. statement # 반복할 명령문을 기입합니다. counter &lt;- counter + 1 # counter를 1증가 시킵니다. } while 루프는 잘못 작성되면 잠재적으로 무한 루프가 발생할 수 있습니다. 따라서 주의해서 사용해야 합니다. for 반복구문과 while 반복구문이 얼마나 유사한 지 다음의 예에서 살펴보겠습니다. ## for 반복구문과 while 반복구문은 매우 유사합니다. # while 반복구문의 예입니다. counter &lt;- 1 # counter를 1로 설정합니다. while(counter &lt;= 10) { # while 반복구문의 시작입니다. print(counter) # counter를 출력합니다. counter &lt;- counter + 1 # counter를 1증가 시킵니다. } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 # 위와 같은 결과를 가져오는 for 반복구문입니다. counter &lt;- vector(mode = &quot;numeric&quot;, length = 10) # counter 변수를 정의합니다. for(i in 1:length(counter)) { # for 반복구문의 시작입니다. print(i) # i를 출력합니다. } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 for 루프와 while 루프의 주요 차이점은 다음과 같습니다. 코드가 실행되어야 하는 반복 횟수가 알려져있을 때 for 루프가 사용되며, 반복 횟수가 사전에 미리 정해져 있지 않은 경우에 while 루프가 사용됩니다. 예를 들어, 다음은 x 값을 취하고 x가 조건식에 있는 값 9를 초과할 때까지 x에서 임의로 1을 더하거나 뺍니다. output은 x의 값이 조건식의 임계값인 9를 초과 할 때까지 코드가 14 번 실행되었음을 보여줍니다. # for 반복구문과 while 반복구문의 차이를 비교합니다. counter &lt;- 1 # counter의 초기값으로 1로 설정합니다. x &lt;- 5 # x의 초기값으로 5을 설정합니다. set.seed(3) # 난수의 초기값을 지정합니다. while(x &gt;= 3 &amp;&amp; x &lt;= 8 ) { # while 반복구문의 시작입니다. coin &lt;- rbinom(1, 1, 0.5) # 이항분포인 난수를 발생하여 coin에 할당합니다. if(coin == 1) { ## random walk # coin 값이 1인지 확인합니다. # coin 값이 1이면 x &lt;- x + 1 # x에 1을 더합니다. } else { # coin 값이 1이 아니면 x &lt;- x - 1 # x에서 1을 뺍니다. } cat(&quot;On iteration&quot;, counter, &quot;, x =&quot;, x, &#39;\\n&#39;) # 블록 실행결과를 출력합니다. counter &lt;- counter + 1 # counter를 1증가 시킵니다. } ## On iteration 1 , x = 4 ## On iteration 2 , x = 5 ## On iteration 3 , x = 4 ## On iteration 4 , x = 3 ## On iteration 5 , x = 4 ## On iteration 6 , x = 5 ## On iteration 7 , x = 4 ## On iteration 8 , x = 3 ## On iteration 9 , x = 4 ## On iteration 10 , x = 5 ## On iteration 11 , x = 6 ## On iteration 12 , x = 7 ## On iteration 13 , x = 8 ## On iteration 14 , x = 9 "],["repeat-반복구문.html", "15.3 repeat 반복구문", " 15.3 repeat 반복구문 repeat 반복구문은 코드 블록을 여러 번 반복하는 데 사용됩니다. repeat 반복구문의 플로우 차트는 다음과 같습니다. Flowchart of repeat loop in R programming repeat 반복구문의 형식은 다음과 같습니다. repeat { statement } repeat 루프에서 루프를 종료하거나 빠져나가기 위해서는 명령문 블럭에 테스트 조건식을 입력해야 합니다. 한편, 루프 본문에 명시적으로 조건문을 넣고 루프를 종료하기 위해 break 함수를 사용하여 루프를 종료할 수도 있습니다. 그렇게하지 않으면 무한 루프가 발생하게 됩니다. # repeat 반복구문의 형식 counter &lt;- 1 # counter의 초기값으로 1을 설정합니다. repeat { # repeat 반복구문의 시작입니다. statement # 반복될 명령문입니다. if(test_expression){ # if() 조건문의 시작입니다. break # 조건문의 조건이 TRUE이면 break에 의해 반복이 종료됩니다. } counter &lt;- counter + 1 } 예를 들어, (min = ) 1과 (max = ) 25 사이의 균등 분포를 갖는 난수를 추출해 보고자 합니다. 이렇게 생성되는 샘플에 1과 25 사이의 각 정수 값들이 적어도 한번이라도 포함될 때까지 계속 무작위로 값을 추출할 것입니다. 그러나 특정 값이 여러 번 추출되어도 상관은 없습니다. 다음의 코드는 1에서 25 사이의 값을 (반올림하여) 무작위로 추출하는 것을 반복합니다. 그런 다음 if 문을 포함하여 1에서 25 사이의 모든 값이 샘플에 있는지 확인합니다. 그러한 조건이 만족되면 break 문을 사용하여 루프를 종료합니다. 그렇지 않은 경우에는 counter에 1을 추가하고 if 조건문이 참이 될 때까지 루프를 반복합니다. 그런 다음 counter 개체를 확인하여 조건부 요구 사항에 도달하기 까지의 반복 횟수 113을 확인할 수 있습니다. ## repeat 반복구문의 예입니다. counter &lt;- 1 # counter의 초기값으로 1을 설정합니다. x &lt;- NULL # x를 정의합니다. # 난수 발생을 반복합니다. set.seed(1234) # 난수의 초기값을 설정합니다. repeat { # repeat 반복구문의 시작입니다. x &lt;- c(x, round(runif(1, min = 1, max = 25))) # 난수를 발생시키고 x와 결합합니다. # 발생된 난수에 대한 조건문입니다. if(all(1:25 %in% x)){ # x에 1:25의 값이 있는지 확인합니다. break # 조건이 만족되면 반복을 종료하고 블럭 아래로 이동합니다. } counter &lt;- counter + 1 # counter를 1증가 시킵니다. } # 반복횟수를 학인합니다. counter # 최종 반복횟수를 출력합니다. ## [1] 113 "],["breaknext-arguments.html", "15.4 break/next arguments", " 15.4 break/next arguments break 인수는 루프가 어떤 반복에 있든 상관없이 즉시 루프를 종료하는 데 사용됩니다. break 인수는 일반적으로 조건이 평가되는if 문에 포함되며, TRUE이면 루프를 벗어나고 FALSE이면 다음 번 루프가 진행됩니다. 다른 루프 내부에 루프가 있는 중첩 루프 상황에서 이 break 문은 평가중인 루프에서 종료하는 역할을 수행하게 됩니다. break 명령문의 플로우 차트는 다음과 같습니다. 다음의 예에서for 루프는x의 각 요소에 대해 반복됩니다. 그러나 x의 값이 3 과 같으면 for 루프 프로세스가 중단되고 종료됩니다. # break의 예 x &lt;- 1:5 # x 벡터를 정의합니다. for (i in x) { # for 반복구문 : i를 x의 값 1에서부터 5가 될 때까지 반복 시행합니다. if (i == 3){ # if 조건문 : i 값이 3과 같은지 확인합니다. break # 조건이 TRUE 이면 break 합니다. } print(i) # i를 출력합니다. } ## [1] 1 ## [1] 2 next 인자는 루프를 종료하지 않고 현재 반복되는 루프를 건너 뛰고 싶을 때 유용합니다. next 명령문의 플로우 차트는 다음과 같습니다. next를 만나면 R은 추가 평가를 건너 뛰고 루프의 다음 반복을 시작합니다. 이 예에서for 루프는x의 각 요소에 대해 반복 시행됩니다. 그러나 3과 같은 값을 갖는 요소에 도달하면 요소를 print 하는 for 루프의 실행을 건너 뛰고 다음 반복을 실행하게 됩니다. 즉, next 이하의 블록을 실행하지 않고 for 로 올라가서 다음 번 반복 시행을 검사합니다. # next의 예 x &lt;- 1:5 # x 벡터를 정의합니다. for (i in x) { # for 반복구문 : i를 x의 값 1에서부터 5가 될 때까지 반복 시행합니다. if (i == 3){ # if 조건문 : i 값이 3과 같은지 확인합니다. next # 조건이 TRUE 이면 next에 의해 다음 반복을 시행합니다. } print(i) # i를 출력합니다. } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 앞의 break 구문 예에서는 x의 요소 값이 3이 되기 전까지의 print 구문이 2번 반복 실행되는 반면에, next 구문 예에서는 x의 요소 값이 3인 경우만 print를 하지 않고 print를 4번 반복 실행함을 알 수 있습니다. 참고자료 http://uc-r.github.io/control_statements https://www.datamentor.io/r-programming/for-loop/ https://www.datamentor.io/r-programming/while-loop/ https://www.datamentor.io/r-programming/break-next/ https://www.datamentor.io/r-programming/repeat-loop/ "],["사용자-정의-함수.html", "Chapter 16 사용자 정의 함수", " Chapter 16 사용자 정의 함수 이 장에서는 R 프로그래밍의 함수에 관련하여 사용자 정의 함수의 작성 방법와 그리고 활용 방법 등에 대하여 학습하겠습니다. 함수는 논리적으로 코드를 더 쉬운 부분으로 분할하여 코드의 유지보수하고 더 쉽게 이해할 수 있게 하기 위해 사용됩니다. R 프로그래밍에서 사용자 자신 만의 함수를 만드는 것이 매우 간단합니다. "],["함수-정의.html", "16.1 함수 정의", " 16.1 함수 정의 함수 작성의 기본 형식은 다음과 같습니다. func_name &lt;- function (argument) { statement } 함수를 선언하는 데 예약어 function을 사용합니다. function 예약어 다음에 이 함수에서 사용할 인수들을 나열합니다. 그리고 중괄호 안의 블럭은 함수의 본문을 형성합니다. 본문에 명령문이 하나만 포함된 경우에는 중괄호를 생략할 수 있습니다. 이렇게 생성된 함수는 함수 개체를 나타내는 변수 func_name에 할당하여 함수의 이름이 지정됩니다. x, y를 인수로 받아들여 x^y의 결과를 적당한 문자열로 반환하는 pow() 함수를 정의하고 이를 활용하는 예를 들어 보겠습니다. # x, y 인수로 하여 x의 y 제곱을 구하는 pow() 함수를 정의합니다. pow &lt;- function(x, y) { # 예약어 function으로 함수를 정의합니다. result &lt;- x^y # x^y를 result에 할당합니다. print(paste(x, &quot;의&quot;, y, &quot;제곱은&quot;, result, &quot;입니다.&quot;)) # pow 함수의 최종 결과로 반환합니다.(문자열) } # pow() 함수를 사용합니다. pow(3, 4) ## [1] &quot;3 의 4 제곱은 81 입니다.&quot; 여기에서 우리는 pow()라는 함수를 만들었습니다. 이 함수는 두 개의 인수 x, y를 받아들여, x의 y 제곱을 계산한 다음, 이를 적절한 형식으로 인쇄하는 함수입니다. 이 함수는 문자열을 결합하는 데 사용되는 paste()를 사용하고 있습니다. 여기서 함수 선언에 사용된 x와 y 인수를 형식 인수(formal arguments)라고 하고, 함수를 호출하는 동안 사용되는 인수를 실제 인수(actual argements)라고합니다. 16.1.1 명명된 인수 위의 함수 호출에서 형식 인수와 실제 인수의 대응은 인수의 위치 순서대로 이루어 지게 됩니다. 즉, ’pow(8,2)’호출에서 형식 인수 x와 y에 각각 8과 2가 할당되는 것입니다. 그런데, 명명된 인수(named arguments)를 사용하여 함수를 호출할 수도 있습니다. 이러한 명명된 인수로 함수를 호출할 때에는 실제 인수의 순서는 중요하지 않습니다. 예를 들어, 아래 주어진 모든 함수 호출은 동일합니다. # 인수의 순서대로 함수를 호출합니다. pow(8, 2) # pow() 함수를 호출할 때, 인수가 형식인수 순서대로 적용됩니다. ## [1] &quot;8 의 2 제곱은 64 입니다.&quot; # 명명된 인수를 이용하여 함수를 호출합니다. pow(x = 8, y = 2) # pow() 함수를 호출할 때, 형식인수 x, y에 그대로 적용이 됩니다. ## [1] &quot;8 의 2 제곱은 64 입니다.&quot; pow(y = 2, x = 8) # pow() 함수를 호출할 때, 형식인수 x, y에 그대로 적용이 됩니다. ## [1] &quot;8 의 2 제곱은 64 입니다.&quot; # 인수의 순서는 중요하지 않습니다. 또한 단일 함수의 호출에서 명명된 인수와 명명되지 않은 인수를 동시에 사용할 수도 있습니다. 이 경우 모든 명명된 인수를 형식 인수와 먼저 대응시킨다음, 명명되지 않은 인수를 형식 인수의 순서대로 대응시켜 적용시킵니다. ## 명명된 인수와 명명되지 않은 인수를 동시에 이용한 함수 호출입니다. pow(x=8, 2) # x에 8을 먼저 대응시키고, 2는 나머지 인수 y에 적용시킵니다. ## [1] &quot;8 의 2 제곱은 64 입니다.&quot; pow(2, x=8) # 앞의 예와 동일합니다. ## [1] &quot;8 의 2 제곱은 64 입니다.&quot; "],["인수에-기본-값-지정하기.html", "16.2 인수에 기본 값 지정하기", " 16.2 인수에 기본 값 지정하기 함수를 정의할 때, 인수에 기본값을 설정할 수도 있습니다. 이는 함수 선언에 있어서 형식 인수에 적절한 값을 제공함으로써 구현할 수 있습니다. 다음은 형식 인수 y에 기본값으로 2를 설정한 함수 정의입니다. # 형식 인수 y에 2를 기본값으로 설정합니다. pow &lt;- function(x, y = 2) { # x의 y 제곱을 구합니다. result &lt;- x^y print(paste(x,&quot;raised to the power&quot;, y, &quot;is&quot;, result)) } 형식 인수에 기본값을 설정하면, 함수를 호출 할 때 기본적인 선택 사항이 됩니다. # 인수를 한 개만 설정해서 호출합니다. pow(3) # 인수는 x에 대응이 되고, y는 기본 설정값 2를 적용하게 됩니다. ## [1] &quot;3 raised to the power 2 is 9&quot; # 인수를 모두 설정해서 호출합니다. pow(3,1) ## [1] &quot;3 raised to the power 1 is 3&quot; 연습문제 Find Sum, Mean and Product of Vector in R Programming Generate Random Number from Standard Distributions Sample from a Population "],["함수의-반환-값.html", "16.3 함수의 반환 값", " 16.3 함수의 반환 값 이 절에서는 R의 함수에서 값을 반환하는 방법을 학습하겠습니다. 또한 return() 함수없이 함수를 사용하는 방법도 알아 보겠습니다. 여러 번 처리를 수행하고 결과를 반환하려면 함수가 필요합니다. 이것은 R의 return ()함수로 수행됩니다. return() 함수의 형식은 다음과 같습니다. return(expression) 함수에서 반환되는 값은 유효한 개체가 될 수 있습니다. 16.3.1 return() 함수를 이용한 함수 값의 반환 return() 함수의 사용 예를 들면 다음과 같습니다. 주어진 숫자가 양수인지, 음수인지 또는 0인지를 반환하는 예를 살펴 보겠습니다. 아래와 같이 check() 함수를 정의해 보겠습니다. check &lt;- function(x) { # 함수를 정의합니다. if (x &gt; 0) { # 첫번째 조건으로 인수가 양수인지 학인합니다. result &lt;- &quot;Positive&quot; # 첫번째 조건의 TRUE 블럭입니다 } else if (x &lt; 0) { # 두번째 조건으로 음수인지 확인합니다. result &lt;- &quot;Negative&quot; # 두번째 조건의 TRUE 블럭입니다. } else { result &lt;- &quot;Zero&quot; # 모든 조건의 FALSE 블럽입니다. } return(result) # return() 함수로 result를 반환합니다. } 이제 정의된 check() 함수를 호출해 보겠습니다. check(1) ## [1] &quot;Positive&quot; check(-10) ## [1] &quot;Negative&quot; check(0) ## [1] &quot;Zero&quot; 16.3.2 return() 함수가 없는 함수 함수에서 명시적인 return() 함수가 없는 경우 마지막으로 평가된 식의 값이 자동으로 반환됩니다. 예를 들어 다음은 위의 기능과 동일합니다. check &lt;- function(x) { if (x &gt; 0) { result &lt;- &quot;Positive&quot; } else if (x &lt; 0) { result &lt;- &quot;Negative&quot; } else { result &lt;- &quot;Zero&quot; } result } 우리는 일반적으로 명시적인 return()함수를 사용하여 함수의 값을 반환합니다. 그러나 함수의 마지막 명령문이 return() 함수가 아니면 조건문이 호출된 곳의 결과로 함수가 조기에 종료됩니다. check &lt;- function(x) { if (x&gt;0) { return(&quot;Positive&quot;) } else if (x&lt;0) { return(&quot;Negative&quot;) } else { return(&quot;Zero&quot;) } } 위의 예에서x &gt; 0 인 경우 함수는 나머지 부분을 평가하지 않고 즉시\"Positive\"라는 문자열을 반환합니다. 16.3.3 다중값 반환 return() 함수는 단일 객체 만 반환할 수 있습니다. 다중 값을 반환하려면 복수 개의 요소로 구성되는 벡터나 리스트 등 (또는 다른 개체)을 사용하여 반환할 수 있습니다. 다음은 그 예입니다. # 다중 값을 반환하는 함수를 정의합니다. multi_return &lt;- function() { my_list &lt;- list(&quot;color&quot; = &quot;red&quot;, &quot;size&quot; = 20, &quot;shape&quot; = &quot;round&quot;) return(my_list) # my_list 개체를 반환합니다. } 여기에서 여러 요소로 구성되어 있는 리스트 구조의 my_list를 생성하고 이 리스트를 반환합니다. a &lt;- multi_return() a$color ## [1] &quot;red&quot; a$size ## [1] 20 a$shape ## [1] &quot;round&quot; 앞에서 살펴 본 간단한 계산기 프로그램을 참고하기 바랍니다. https://www.datamentor.io/r-programming/examples/simple-calculator "],["r-환경과-범위.html", "16.4 R 환경과 범위", " 16.4 R 환경과 범위 이 절에서는 R 프로그래밍의 환경 (전역 환경, 단계적 환경 등)에 대해 알아 보겠습니다. 또한 변수의 적용 범위에 대해 예제를 통해 살펴 보겠습니다. 함수를 적절하게 작성하고 비정상적인 오류를 방지하려면 R에서의 환경(environment)과 범위(range)의 개념을 알아야합니다. 16.4.1 R 프로그래밍 환경 환경(environment)은 객체(함수, 변수 등)의 모음으로 생각할 수 있습니다. R 인터프리터를 처음 시작할 때 하나의 환경이 생성됩니다. 우리가 정의하는 모든 변수는 이제 이 환경에 존재하게 됩니다. R 명령 프롬프트에서 사용할 수 있는 최상위 환경은R_GlobalEnv라는 전역 환경입니다. 전역 환경은 R 코드에서도.GlobalEnv로 참조될 수 있습니다. ls() 함수를 사용하여 현재 환경에서 정의된 변수와 함수를 표시할 수 있습니다. 또한environment() 함수를 사용하여 현재 환경을 가져올 수 있습니다. a &lt;- 2 # 개체 a에 2를 할당합니다. b &lt;- 5 # 개체 b에 5를 할당합니다. f &lt;- function(x) x &lt;- 0 # 함수 f를 정의합니다. ls() # 현재의 환경을 확인합니다. ## [1] &quot;a&quot; &quot;add&quot; &quot;b&quot; &quot;check&quot; &quot;choice&quot; ## [6] &quot;coin&quot; &quot;counter&quot; &quot;divide&quot; &quot;f&quot; &quot;i&quot; ## [11] &quot;multi_return&quot; &quot;multiply&quot; &quot;my.mat&quot; &quot;mydata&quot; &quot;num1&quot; ## [16] &quot;num2&quot; &quot;operator&quot; &quot;output&quot; &quot;pow&quot; &quot;result&quot; ## [21] &quot;subtract&quot; &quot;x&quot; &quot;y&quot; environment() ## &lt;environment: R_GlobalEnv&gt; .GlobalEnv ## &lt;environment: R_GlobalEnv&gt; 위의 예에서a,b,f가R_GlobalEnv 환경에 있음을 알 수 있습니다. 그런데 (f 함수의 형식 인수인) x 는 이 전역 환경에 존재하지 않습니다. 이는 함수를 정의하면 새로운 환경이 생성되기 때문입니다. 위의 예에서 함수f는 전역 환경 내에 새로운 환경을 만듭니다. 실제로 하나의 환경은 모든 정의된 개체를 담고 있는 프레임(frame)과 둘러싸고 있는 (상위) 환경에 대한 포인터(pointer)가 있습니다. 따라서x는 함수f에 의해 생성된 새로운 환경의 프레임 안에 있습니다. 이 환경은 이 환경의 상위 환경인 R_GlobalEnv에 대한 포인터를 가지고 있을 것입니다. 16.4.2 단계적 환경의 예 글로벌 환경 내에 상이한 환경이 어떻게 단계적으로 중첩될 수 있는지 다음의 예를 통해 확인해 보겠습니다. f &lt;- function(f_x){ # 함수 f를 정의합니다. g &lt;- function(g_x){ # 함수 f내에서 함수 g를 정의합니다. print(&quot;Inside g&quot;) print(environment()) # g 함수 내의 환경을 반환합니다. print(ls()) # g 함수 내의 개체를 반환합니다. } g(5) # f 환경에서 g함수를 호출합니다. print(&quot;Inside f&quot;) print(environment()) # f 함수 내의 환경을 반환합니다 print(ls()) # f 함수 내의 개체를 반환합니다. } 이제 명령 프롬프트에서 이 함수를 실행하면 다음과 같은 결과를 얻게 될 것입니다. f(6) # 함수 f를 호출합니다. # g 함수 내의 환경과 개체를 반환하고, # 또한 f 함수 내의 환경과 개쳬를 반환합니다. environment() # 최상위의 환경을 반환합니다. ## &lt;environment: R_GlobalEnv&gt; ls() # 최상위의 개체를 반환합니다. ## [1] &quot;a&quot; &quot;add&quot; &quot;b&quot; &quot;check&quot; &quot;choice&quot; ## [6] &quot;coin&quot; &quot;counter&quot; &quot;divide&quot; &quot;f&quot; &quot;i&quot; ## [11] &quot;multi_return&quot; &quot;multiply&quot; &quot;my.mat&quot; &quot;mydata&quot; &quot;num1&quot; ## [16] &quot;num2&quot; &quot;operator&quot; &quot;output&quot; &quot;pow&quot; &quot;result&quot; ## [21] &quot;subtract&quot; &quot;x&quot; &quot;y&quot; 여기에서 우리는 함수 f 안에서 함수 g를 정의하였다. 두 함수 모두 각각의 프레임 내에서 서로 다른 객체를 갖는 다른 환경을 가지고 있음을 분명히 알 수 있습니다. 16.4.3 R 프로그래밍 범위 변수가 프로그램 내에서 적용되는 범위에 대한 개념을 이해하기 위해서 다음 예를 살펴 보겠습니다. outer_func &lt;- function(){ b &lt;- 20 inner_func &lt;- function(){ c &lt;- 30 } } a &lt;- 10 16.4.3.1 전역 변수 전역 변수(global variables)는 프로그램이 실행되는 동안 계속 존재하고 있는 변수입니다. 이 전역 변수는 프로그램의 모든 부분에서 액세스할 수 있고 변경도 가능합니다. 그러나 전역 변수는 함수의 관점에 의존하기도 합니다. 예를 들어 위의 예에서inner_func()의 관점에서 보면a와b는 모두 전역 변수입니다. 그러나outer_func()의 관점에서 보면b는 지역 변수(local variables)이고a 만 전역 변수입니다. 변수c는outer_func()의 입장에서는 전혀 알 수 없습니다. 16.4.3.2 지역 변수 반면에 지역 변수(local variables)는 함수와 같은 프로그램의 특정 부분에만 존재하며 함수 호출이 종료되면 사라지는 변수입니다. 위의 프로그램에서 보면 변수 c는 지역 변수에 해당합니다. inner_func() 함수를 사용하여 변수에 값을 할당하면 변경 사항은 그 함수 내에서만 적용될 뿐이며 inner_func() 함수 외부에서는 이 변수에 접근할 수 없습니다. 이는 전역 변수와 지역 변수의 이름이 같더라도 마찬가지 입니다. 예를 들어 아래와 같은 함수가 있다면. outer_func &lt;- function(){ a &lt;- 20 inner_func &lt;- function(){ a &lt;- 30 print(a) } inner_func() print(a) } 이제 이 함수들을 호출해 보겠습니다. a &lt;- 10 # 전역 변수 a에 10을 할당합니다. outer_func() # outer_func() 함수를 호출합니다. ## [1] 30 ## [1] 20 print(a) # a를 출력합니다. ## [1] 10 변수 a는 outer_func() 함수와 inner_func() 함수 등의 각각의 환경 프레임 내에서 지역 변수로 생성이 되었으며, 글로벌 환경 프레임의 변수 a와는 다릅니다. 16.4.3.3 전역 변수 접근 지역의 환경에서 전역 변수의 값을 접근할 수 있지만, 그 전역 변수에 값을 할당하려고하면 새 지역 변수가 생성됩니다. 이럴 때 전역 변수에 값을 할당하고자 한다면 수퍼 할당 연산자 &lt;&lt;-를 사용합니다. 함수 내에서 이 연산자를 사용하면, 상위 환경 프레임에 있는 변수를 검색하고, 찾을 수 없는 경우 전역 환경에 도달할 때까지 상위의 레벨을 계속 검색하게 됩니다. 변수가 여전히 발견되지 않으면 글로벌 환경 수준에서 그 변수를 생성하고 할당하게 됩니다. outer_func &lt;- function(){ inner_func &lt;- function(){ a &lt;&lt;- 30 # 수퍼 할당 연산자(&lt;&lt;-)를 사용하여 &quot;전역 변수&quot;에 할당합니다. print(a) } inner_func() print(a) } 이 함수를 실행해 보면 다음과 같은 결과를 확인할 수 있습니다. outer_func() # inner_func() 함수 내의 a와 outer_func() 함수 내의 a가 출력됩니다. ## [1] 30 ## [1] 30 print(a) # 전역 변수 a 값이 출력됩니다. ## [1] 30 inner_func) 함수 내에 a &lt;&lt;- 30 할당문이 있기 때문에 상위의 환경인 outer_func() 환경에서 변수a를 찾습니다. 그러나 검색이 실패하여 다시 그 상위 환경인 전역 환경 즉, R_GlobalEnv에서 검색합니다. 이 전역 환경에서도a가 발견되지 않기 때문에 inner_func() 내에서 변수 a가 전역 변수로 생성되고 할당됩니다. 따라서 이 a 변수는 inner_func() 함수 내에서 뿐 아니라 out_func() 함수 내에서도 참조되어 출력이 되는 것입니다. "],["r-재귀-함수.html", "16.5 R 재귀 함수", " 16.5 R 재귀 함수 이 절에서는 R 프로그래밍에서 재귀 함수(recursive function, 자신을 호출하는 함수)를 생성하는 방법에 대해 살펴 보겠습니다. 자신을 호출하는 함수를 재귀 함수라고 하며, 이러한 기술을 재귀(recursion)라고합니다. 이 특수 프로그래밍 기술은 문제를 더 작고 간단한 하위 문제로 나누어 문제를 해결하는 데 사용할 수 있습니다. 다음의 예를 통하여 이 개념을 살펴보도록 하겠습니다. 숫자의 팩토리얼의 결과를 찾는 예를 들어 보겠습니다. 양의 정수의 팩토리얼은 1에서 해당 숫자까지의 모든 정수의 곱 즉 \\[ (n! = 1 \\times 2 \\times \\cdots \\times n) \\] 으로 정의됩니다. 예를 들어 5의 팩토리얼은 ( 5!로 표시)은 다음과 같습니다. 5! = 1*2*3*4*5 = 120 5의 팩토리얼을 찾는이 문제는 4의 계승과 5를 곱하는 하위 문제로 나눌 수 있습니다. 즉, 5! = 5*4! 이를 일반적인 식으로 표현하면 다음과 같습니다. n! = n*(n-1)! 이제 우리는1의 값을 갖는 0!에 도달할 때까지 이 연산을 계속할 수 있습니다. 이제 이러한 팩토리얼 연산을 구현하는 함수는 다음과 같이 작성할 수 있습니다. 16.5.1 재귀 함수 예 # 팩토리얼 연산을 위한 재귀함수를 정의합니다. recursive.factorial &lt;- function(x) { if (x == 0) return (1) else return (x * recursive.factorial(x-1)) } 여기에 자신을 호출하는 함수가 있습니다. recursive.factorial(x) 함수는 x가 0이 될 때까지 x * recursive.factorial(x)를 계속 실행합니다. x가 0이 되면 0 팩토리얼 값이 1이므로 1을 반환합니다. 이것은 종료 조건이며 매우 중요한 의미를 갖습니다. 이 조건이 없으면 재귀는 끝나지 않고 (이론상) 무한히 반복됩니다. 다음은 이 함수를 호출하는 몇 가지 예를 보여주고 있습니다. recursive.factorial(0) ## [1] 1 recursive.factorial(5) ## [1] 120 recursive.factorial(7) ## [1] 5040 재귀함수를 사용하면 종종 코드가 짧아지고 깔끔해 보입니다. 그러나 때때로 코드 로직을 따르기가 어렵습니다. 재귀적인 방식으로 문제를 생각하기 어려울 수 있기 때문입니다. 재귀 함수는 또한 많은 중첩 함수 호출로 이어질 수 있으므로 메모리를 많이 사용합니다. 이것은 큰 문제를 해결하기 위해 사용할 때 명심해야 하는 문제입니다. 연습문제 피보나치 수열을 생성하는 함수를 정의하고, 이 함수를 호출하는 예를 들어보시오. # 피보나치 수열을 생성하는 함수를 정의합니다. fibonacci &lt;- function(x) { if (x &lt; 0) print(&quot;양의 정수 값을 입력해 주세요.&quot;) else if (x &lt; 2) return(1) else return(fibonacci(x-1) + fibonacci(x-2)) } # fibonacci() 함수를 호출하여 0:10 까지의 피보나치 수를 생성합니다. for (i in 0:10) print(paste0(&quot;Fibonacci Number of &quot;, i, &quot; = &quot;, fibonacci(i))) ## [1] &quot;Fibonacci Number of 0 = 1&quot; ## [1] &quot;Fibonacci Number of 1 = 1&quot; ## [1] &quot;Fibonacci Number of 2 = 2&quot; ## [1] &quot;Fibonacci Number of 3 = 3&quot; ## [1] &quot;Fibonacci Number of 4 = 5&quot; ## [1] &quot;Fibonacci Number of 5 = 8&quot; ## [1] &quot;Fibonacci Number of 6 = 13&quot; ## [1] &quot;Fibonacci Number of 7 = 21&quot; ## [1] &quot;Fibonacci Number of 8 = 34&quot; ## [1] &quot;Fibonacci Number of 9 = 55&quot; ## [1] &quot;Fibonacci Number of 10 = 89&quot; 다음의 예제를 확인하기 바랍니다. Convert Decimal into Binary using Recursion in R Find the Factorial of a Number Using Recursion Fibonacci Sequence Using Recursion in R "],["r의-infix-연산자.html", "16.6 R의 Infix 연산자", " 16.6 R의 Infix 연산자 이 절에서는 infix 연산자에 대해 알아 보겠습니다. 이러한 연산자가 R에서 실제로 어떻게 작동하는지, 그리고 infix 연산자를 직접 만드는 방법 등에 대하여 알아 보겠습니다. 또한 R 프로그래밍에서 사용할 수 있는 사전에 정의된 다양한 infix 연산자에는 어떤 것이 있는지 알아 보겠습니다. R에서 사용하는 대부분의 연산자는 이항 연산자(두 개의 피연산자를 가짐)입니다. 따라서 이들은 피연산자와 피연산자 사이에 사용되는 infix 연산자라고 할 수 있습니다. 실제로 이러한 연산자는 백그라운드에서 함수를 호출합니다. 예를 들어 a + b 라는 수식은 실제로는 +(a, b)와 같이 인수 a와 b를 받아들여 ` + ` () 함수를 호출하는 것과 같습니다. 참고 : 백틱 (``) 기호를 주목하기 바랍니다. 함수 이름에서 +를 특수 기호로 인식하기 때문에 백틱으로 묶어 줘야 합니다. 다음은 백그라운드에서 호출되는 실제 함수와 함께 몇 가지 예제 수식입니다. 16.6.1 infix 연산자의 작동 예 5 + 3 ## [1] 8 `+`(5,3) # 5 + 3의 +연산자를 함수로 표현한 것입니다 ## [1] 8 5 - 3 ## [1] 2 `-`(5,3) ## [1] 2 5 * 3 - 1 ## [1] 14 `-`(`*`(5,3),1) ## [1] 14 앞의 예를 보면 이제 R에서 사용자 정의 infix 연산자를 만들 수도 있는 것입니다. 이러한 infix 연산사를 위한 함수의 이름은 %로 시작하고 끝나게 정의합니다. 다음은 숫자가 정확히 다른 숫자로 나누어 지는지를 확인하는 사용자 정의 infix 연산자를 정의하는 함수입니다. 16.6.2 사용자 정의 infix 연산자의 예 `%divisible%` &lt;- function(x,y) { if (x%%y ==0) return (TRUE) else return (FALSE) } This function can be used as infix operator a %divisible% b or as a function call `%divisible%(a, b)`. Both are the same. 이 함수는 infix 연산자a %divisible% b 또는 함수 호출`%divisible%(a, b)로 사용할 수 있습니다. x &lt;- c(4, 8, 6, 3) y &lt;- c(2, 3, 2, 2) x %divisible% y ## Warning in if (x%%y == 0) return(TRUE) else return(FALSE): length &gt; 1 이라는 조 ## 건이 있고, 첫번째 요소만이 사용될 것입니다 ## [1] TRUE `%divisible%`(x, y) ## Warning in if (x%%y == 0) return(TRUE) else return(FALSE): length &gt; 1 이라는 조 ## 건이 있고, 첫번째 요소만이 사용될 것입니다 ## [1] TRUE 참고로 2개의 벡터 x, y 를 인수로 받아 들여, 이 두 벡터의 요소 각각에 대한 %divisible% 연산자를 적용하는 함수를 생성해 보았습니다. ## 요소의 갯수가 적은 벡터를 자동 반복으로 채워주는 함수입니다. vec.cycle &lt;- function(x, j, k) { # x : 짧은 벡터이며, # j : 벡터 전체의 자동반복 횟수 # k : 마지막으로 채워 넣어야 할 요소의 수입니다. vec &lt;- x if (j&gt;=2) { # 벡터 전체를 자동 반복으로 복사합니다. for (t1 in 1:(j-1)) vec &lt;- c(vec, vec) } for (t2 in 1:k) # 남은 요소를 자동으로 채워 넣기 합니다. vec &lt;- c(vec, vec[t2]) return(vec) } ## infix 연산자를 정의합니다. `%divisible%` &lt;- function(x, y, na.rm = FALSE) { # if (na.rm == TRUE) { # x &lt;- x[!is.na(x)] # y &lt;- y[!is.na(y)] # } len.x &lt;- length(x) # x 벡터의 길이를 반환합니다. len.y &lt;- length(y) # y 벡터의 길이를 반환합니다. if (len.x &gt;= len.y) { # 벡터 x가 긴 경우입니다. j &lt;- len.x %/% len.y # 벡터 전체를 반복할 횟수를 계산합니다. k &lt;- len.x %% len.y # 부족한 벡터 요소 갯수를 계산합니다. y &lt;- vec.cycle(y, j, k) # y를 자동반복으로 채워줍니다. } else { j &lt;- len.y %/% len.x k &lt;- len.y %% len.x x &lt;- vec.cycle(x, j, k) } # result &lt;- NULL # for (i in 1:length(x)) { # 각 요소별로 %% 연산 결과를 저장합니다. # if (x[i] %% y[i] == 0) result[i] &lt;- TRUE # else result[i] &lt;- FALSE # } # return(result) # 최종 연산결과를 반환합니다. return(x %% y == 0) # x의 요소 각각을 y의 요소 각각으로 나누어지는지 결과를 반환한다. } # 데이터 벡터입니다. x &lt;- c(2, 3, 2) y &lt;- c(4, 8, 6, 2, 4, 3, 8, 7) # 두 벡터 데이터를 확인합니다. x %divisible% y ## [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE 자신만의 infix 연산자를 정의할 때 기억해야 할 점은 연산자의 이름은 %로 시작하고 %로 끝나야 한다는 것입니다. 함수를 정의할 때 함수 이름을 백틱(``)으로 묶어서 % 를 이스케이프 시켜 주어야 합니다. 16.6.3 R에 미리 정의되어 있는 infix 연산자 기호 설 명 %% 나머지 연산자 %/% 몫 연산자 %*% 행렬 곱하기 %o% 아웃터 곱하기 %x% Kronecker 곱하기 %in% 대응 연산자 "],["잘못된-인수-처리.html", "16.7 잘못된 인수 처리", " 16.7 잘못된 인수 처리 다시 사용할 함수, 특히 함수 작성자가 아닌 다른 사람이 사용할 수 있는 함수의 경우 함수 내 인수의 유효성을 확인하는 것이 좋습니다. 이를 수행하는 한 가지 방법은stop() 함수를 사용하는 것입니다. 다음은 if()문을 사용하여 각 인수의 클래스가 숫자인지 확인합니다. 하나 이상의 인수가 숫자가 아니면 stop() 함수가 작동하여 사용자에게 의미 메시지를 제공할 것입니다. # 미래 가치 벡터 : FV, 할인율 : r, 기간 : n을 인수로 현재 가치를 반환하는 PV 함수를 정의합니다. PV &lt;- function(FV, r, n) { if(!is.numeric(FV) | !is.numeric(r) | !is.numeric(n)){ stop(&#39;This function only works for numeric inputs!\\n&#39;, &#39;You have provided objects of the following classes:\\n&#39;, &#39;FV: &#39;, class(FV), &#39;\\n&#39;, &#39;r: &#39;, class(r), &#39;\\n&#39;, &#39;n: &#39;, class(n)) } PV &lt;- FV/(1+r)^n round(PV, 2) } # PV() 함수를 이용하여 현재 가치를 구합니다. PV(&quot;1000&quot;, 0.08, &quot;5&quot;) ## Error in PV(&quot;1000&quot;, 0.08, &quot;5&quot;): This function only works for numeric inputs! ## You have provided objects of the following classes: ## FV: character ## r: numeric ## n: character 또 다른 문제는 누락되거나 NA 값을 다루는 것입니다. 잠재적 미래 가치 벡터에 PV() 함수를 수행하고 싶다고 가정해 보겠습니다. 이 함수는 FV(future value, 미래 가치) 입력 벡터에서 누락된 값 대신 NA를 출력합니다. 누락된 값을 제거하려면 na.rm = TRUE인 경우 누락 된 값을 제거하기 위해 if문과 함께 함수 인수에 na.rm 인수를 통합 할 수 있습니다. # NA를 포함하고 있는 미래 가치 입력 벡터입니다. fv &lt;- c(800, 900, NA, 1100, NA) # PV 함수를 호출합니다. PV(fv, .08, 5) ## [1] 544.47 612.52 NA 748.64 NA # PV 함수를 정의합니다. PV &lt;- function(FV, r, n, na.rm = FALSE) { if(!is.numeric(FV) | !is.numeric(r) | !is.numeric(n)){ stop(&#39;This function only works for numeric inputs!\\n&#39;, &#39;You have provided objects of the following classes:\\n&#39;, &#39;FV: &#39;, class(FV), &#39;\\n&#39;, &#39;r: &#39;, class(r), &#39;\\n&#39;, &#39;n: &#39;, class(n)) } if(na.rm == TRUE) { # na.rm 인수를 처리합니다. FV &lt;- FV[!is.na(FV)] } PV &lt;- FV/(1+r)^n round(PV, 2) } PV(fv, 0.08, 5, na.rm = TRUE) ## [1] 544.47 612.52 748.64 "],["함수의-저장과-소싱.html", "16.8 함수의 저장과 소싱", " 16.8 함수의 저장과 소싱 나중에 그리고 다른 스크립트 내에서 사용하기 위해 함수를 저장할 수도 있습니다. 이러한 경우 두 가지 주요 방법이 있습니다. 한 가지 방법은 여기에서 자세히 설명하는 패키지를 구축하는 것입니다. 또 다른 방법은 함수를 R 스크립트로 저장하는 것입니다. 예를 들어 앞에서의PV()함수가 포함된 스크립트를 예를 들어 PV.R로 저장할 수 있습니다. 그리고 이 새 스크립트에 정의되어 있는 PV() 함수를 사용하려면source(\"PV.R\")를 사용하여 함수를 불러올 수 있습니다.그러면 전역 환경에 PV() 함수 생성되면, 이 함수를 정상적으로 사용할 수 있습니다. PV.R 파일이 저장되어 있는 것과 다른 디렉토리에서 작업하는 경우 관련 디렉토리에 액세스하려면 적절한 명령(또는 경로)을 포함해야 합니다. "],["추가-자료.html", "추가 자료", " 추가 자료 함수는 R의 기본 빌딩 블럭이며 함수 작성은 R 프로그래머의 핵심 활동입니다. 이는 단순한 “사용자”에서 R을 위한 새로운 함수를 개발하는 개발자로의 전환해 나가는 핵심 단계를 나타냅니다. 따라서 기존의 비공식적인 함수에 대한 지식을 함수가 무엇이며 어떻게 작동하는지에 대해 철저한 이해가 중요합니다. 함수를 이해하는 다음 단계로 나아가는데 도움이 되는 몇 가지 추가 자료를 소개하면 다음과 같습니다. Hadley Wickham’s Advanced R book Roger Peng’s R Programming for Data Science book DataCamp’s Intermediate R course Coursera’s R Programming course 참고자료 http://uc-r.github.io/functions https://www.statmethods.net/management/userfunctions.html https://www.datamentor.io/r-programming/function/ https://www.datamentor.io/r-programming/return-function/ https://www.datamentor.io/r-programming/environment-scope/ https://www.datamentor.io/r-programming/recursion/ https://www.datamentor.io/r-programming/infix-operator/ "],["개체와-클래스-2.html", "Chapter 17 개체와 클래스 ", " Chapter 17 개체와 클래스 "],["s3-클래스-1.html", "17.1 S3 클래스", " 17.1 S3 클래스 S3 클래스는 R 프로그래밍 언어에서 가장 널리 사용되는 클래스입니다. R에 미리 정의 된 대부분의 클래스는이 유형입니다. 이것이 간단하고 구현하기 쉽다는 사실이 그 이유입니다. 17.1.1 S3 클래스를 정의하고 S3 개체를 생성하는 방법 S3 클래스에는 사전 정의된 공식적인 정의가 없습니다. 기본적으로 클래스 속성이 일부 클래스 이름으로 설정된 리스트는 S3객체입니다. 리스트의 구성 요소는 개체의 멤버 변수가 됩니다. 다음은 student라는 의 S3 개체를 생성하는 간단한 예입니다. # 원하는 구성요소를 갖는 리스트를 생성합니다. s &lt;- list(name = &quot;John&quot;, age = 21, GPA = 3.5) # 클래스 이름을 지정합니다. class(s) &lt;- &quot;student&quot; # 이게 다입니다. 이제 &quot;student&quot; 클래스인 개체 s가 생성되었습니다. s ## $name ## [1] &quot;John&quot; ## ## $age ## [1] 21 ## ## $GPA ## [1] 3.5 ## ## attr(,&quot;class&quot;) ## [1] &quot;student&quot; 이것은 공식적인 클래스 정의가 있고 개체에 속성과 메서드가 적절하게 정의되어 있는 C ++, Python 등을 사용해 본 프로그래머들에게 어색해 보일 수 있습니다. R의 S3 시스템은 매우 임기응변적입니다. 같은 클래스의 객체가 여러분의 의지에 따라 완전히 다르게 보이는 객체의 클래스로 변환시킬 수 있습니다. 모든 것이 당신에게 달려 있습니다. 17.1.2 생성자를 사용하여 개체를 만드는 방법 클래스와 같은 이름을 갖는 함수(필수 아님)를 사용하여 개체를 만드는 것이 좋습니다. 이것은 개체 생성에 약간의 일관성(uniformity)을 가져와 유사하게 보이게 합니다. 멤버 속성에 대한 무결성 검사(integrity test)를 추가할 수도 있습니다. 여기에 예가 있습니다. 이 예제에서는 개체의 클래스 속성을 설정하기 위해 attr() 함수를 사용하고 있음을 주목하기 바랍니다. 다음은 student 클래스의 개체를 만들 수 있는 student() 함수를 정의하는 것을 보여주고 있습니다. # &quot;student&quot; 클래스 생성 함수 정의 : student(n, a, g) student &lt;- function(n, a, g) { # (데이터 입력 오류 방지를 위한) 무결성 테스트 조건을 추가핳 수 있습니다. if(g &gt; 4 || g &lt; 0) stop(&quot;GPA must be between 0 and 4&quot;) value &lt;- list(name = n, age = a, GPA = g) # class() 함수 또는 attr() 함수를 이용하여 클래스가 설정될 수 있습니다. attr(value, &quot;class&quot;) &lt;- &quot;student&quot; value } student 클래스의 개체를 만들 수 있는 student() 함수가 만들어 졌습니다. 다음은 이 student() 함수를 사용하여 student 클래스의 s3.s1 개체를 만드는 예를 보여 주고 있습니다. # student() 함수를 이용하여 student 클래스의 s3.s1 개체를 생성합니다. s3.s1 &lt;- student(&quot;Paul&quot;, 26, 3.7) # s 개체의 요소들과 클래스를 확인합니다. s3.s1 ## $name ## [1] &quot;Paul&quot; ## ## $age ## [1] 26 ## ## $GPA ## [1] 3.7 ## ## attr(,&quot;class&quot;) ## [1] &quot;student&quot; class(s3.s1) ## [1] &quot;student&quot; # 새로운 s3.s1 개체를 생성합니다. 이때, 3번째 요소 값이 student() 함수의 무결성 검사에 걸립니다 s3.s1 &lt;- student(&quot;Paul&quot;, 26, 5) ## Error in student(&quot;Paul&quot;, 26, 5): GPA must be between 0 and 4 # student() 함수를 이용하여 개체를 만들 때 무결성 검사를 통과해야 개체가 생성됩니다. s3.s2 &lt;- student(&quot;Paul&quot;, 26, 2.5) # 만일 무결성 검사와 상관없이 요소의 값을 수정할 수 있습니다.(꼭 그렇게 해야 한다면) s3.s2$GPA &lt;- 5 17.1.3 메소드와 일반 함수 위의 예에서는 단순히 개체의 이름 s를 입력하면 내부 요소들이 출력되었습니다. 대화형 모드에서 개체 이름만 입력하면 print() 함수가 작동되어 출력됩니다. s3.s1 ## $name ## [1] &quot;Paul&quot; ## ## $age ## [1] 26 ## ## $GPA ## [1] 3.7 ## ## attr(,&quot;class&quot;) ## [1] &quot;student&quot; 또한 벡터, 행렬, 데이터 프레임, factor 등과 함께 print()를 사용할 수 있으며 이들이 속한 클래스에 따라 그 결과는 다르게 인쇄됩니다. print() 함수는 이처럼 다양한 모양의 개체를 인쇄하는 방법을 어떻게 알까요? 대답은 print() 함수가 일반 함수(generic function)라는 것입니다. 실제로 여러 메서드 모음이 있습니다. 이러한 모든 방법은 method(print) 로 확인할 수 있습니다. head(methods(print), 10) # 앞의 10개만 확인합니다. ## [1] &quot;print,ANY-method&quot; &quot;print,diagonalMatrix-method&quot; ## [3] &quot;print,sparseMatrix-method&quot; &quot;print.aareg&quot; ## [5] &quot;print.abs.error.pred&quot; &quot;print.acf&quot; ## [7] &quot;print.AES&quot; &quot;print.agnes&quot; ## [9] &quot;print.all_vars&quot; &quot;print.anova&quot; 위 목록에서 print.data.frame 과 print.factor 등과 같은 메소드를 볼 수 있습니다. 데이터 프레임에서 print() 함수를 호출하면 print.data.frame()함수로 전달됩니다. factor 로 동일한 작업을 수행했다면 호출은 print.factor() 함수로 전달됩니다. 여기서 메소드 이름이 generic_name.class_name() 형식임을 알 수 있습니다. 이것이 R이 클래스에 따라 어떤 메소드를 호출할지 알아낼 수있는 방법입니다. \"student\"클래스의 개체를 인쇄하면 print.student() 형식의 메소드를 찾지만 이 형식의 메소드는 없습니다. 그렇다면 \"student\" 클래스의 개체는 어떤 메소드를 호출했을까요? print.default() 함수를 호출한 것입니다. 이것은 일치하는 메소드를 찾을 수 없을 때 호출되는 대체 메소드입니다. 일반 함수에는 기본 매소드를 가지고 있습니다. print() 함수와 같은 많은 일반 함수가 있습니다. 이러한 일반 함수들은 method(class = \"default\") 를 이용하여 모두 나열할 수 있습니다. head(methods(class=&quot;default&quot;), 10) # 앞의 10개만 확인하겠습니다. ## [1] &quot;add1.default&quot; &quot;aggregate.default&quot; &quot;AIC.default&quot; ## [4] &quot;all.equal.default&quot; &quot;ansari.test.default&quot; &quot;anyDuplicated.default&quot; ## [7] &quot;aperm.default&quot; &quot;ar.burg.default&quot; &quot;ar.yw.default&quot; ## [10] &quot;arrange.default&quot; 17.1.4 자신의 메소드를 작성하는 방법 이제 student 클래스를 출력할 수 있는 print.student()메소들 만들어 보겠습니다. print.student &lt;- function(obj) { cat(obj$name, &quot;\\n&quot;) cat(obj$age, &quot;years old\\n&quot;) cat(&quot;GPA:&quot;, obj$GPA, &quot;\\n&quot;) } 이제 이 print.student() 메서드는 \"student\" 클래스의 객체를 print() 할 때마다 호출됩니다. S3 시스템에서 메서드는 개체나 클래스에 속하지 않고 일반 함수에 속합니다. 이것은 개체의 클래스가 설정되어 있는 한 작동합니다. # 이제 s 개체를 출력해 보겠습니다. 이때 앞에서 정의한 print.student() 메소드가 호출되어 출력합니다. s3.s1 ## Paul ## 26 years old ## GPA: 3.7 # s 개체의 student 클래스 속성을 없앨 수도 있습니다. unclass(s3.s1) ## $name ## [1] &quot;Paul&quot; ## ## $age ## [1] 26 ## ## $GPA ## [1] 3.7 class(s3.s1) # student 클래스가 아닌 list 클래스로 출력이 됩니다. ## [1] &quot;student&quot; 17.1.5 자신 만의 일반 함수 작성 print() 함수 또는 plot() 함수 등과 같은 고유한 일반 함수를 만들 수도 있습니다. 먼저 이러한 기능이 어떻게 구현되는지 살펴 보겠습니다. print ## function (x, ...) ## UseMethod(&quot;print&quot;) ## &lt;bytecode: 0x0000000016999388&gt; ## &lt;environment: namespace:base&gt; plot ## function (x, y, ...) ## UseMethod(&quot;plot&quot;) ## &lt;bytecode: 0x000000002375d9d8&gt; ## &lt;environment: namespace:base&gt; UseMethod() 함수에 전달된 일반 함수의 이름으로 단일 호출이 있음을 알 수 있습니다. 이것은 모든 배경이 되는 세부 정보를 처리 하게 될 디스패처(dispatcher) 함수입니다. 이것을 이용한다면 일반 함수를 구현하는 것은 간단합니다. 예를 들어 grade라는 새로운 일반 함수를 만들어 보겠습니다. grade &lt;- function(obj) { UseMethod(&quot;grade&quot;) } 일반 함수는 메소드 없이는 쓸모가 없습니다. 따라서 기본 메소드를 구현해 보겠습니다. grade.default &lt;- function(obj) { cat(&quot;This is a generic function.\\n&quot;) } 이 기본 메소드로 s개체를 출력해 보겠습니다. grade(s3.s1) ## This is a generic function. grade() 함수를 이용하여 s 개체를 출력해 보니, grade.default() 메소드가 작동됨을 알 수 있습니다. 이제 \"student\" 클래스를 위한 grade.student() 메소드를 만들어 보겠습니다. grade.student &lt;- function(obj) { cat(&quot;Your grade is&quot;, obj$GPA, &quot;\\n&quot;) } 이제 이 student 클래스의 s 개체를 출력해 보겠습니다. 아까와 달리 grade() 함수의 인수인 s개체가 student 클래스이기 때문에 grade.student() 메소드가 적용되어 출력됨을 알 수 있습니다. grade(s3.s1) ## Your grade is 3.7 이런 식으로 우리는 grade() 이라는 일반 함수를 구현하고 이를 우리가 만든 클래스를 위한 메소드로 구현해 보았습니다. 참고 자료 : https://www.datamentor.io/r-programming/s3-class/ "],["s4-클래스-1.html", "17.2 S4 클래스", " 17.2 S4 클래스 이 절에서는 R의 S4 클래스에 대한 모든 것을 학습합니다. 클래스를 정의하고, 생성하고, 슬롯에 액세스하고, 프로그램에서 효율적으로 사용하는 방법 등에 대하여 살펴 보겠습니다. S3클래스와 개체가 형식적 정의가 없는 것과 달리, 개체를 공식적으로 정의해야 하고 개체를 만드는데 독특한 방법을 가지고 있다는 점에서 더 엄격한 S4 클래스를 살펴 보겠습니다. 이것은 우리 코드를 안전하게 만들어 주어, 우연하게도 저지를 수 있는 순진한 실수를 막아 줍니다. 17.2.1 S4 클래스를 정의하는 방법 S4 클래스는 setClass() 함수를 사용하여 정의합니다. R 용어에서 멤버 변수를 슬롯(slot)이라고합니다. 클래스를 정의하는 동안 클래스의 이름과 (슬롯의 클래스와 함께) 클래스에 포함될 멤버인 슬롯을 설정해야 합니다. S4 클래스 정의의 예 setClass(Class = &quot;student&quot;, slots = list(name=&quot;character&quot;, age=&quot;numeric&quot;, GPA=&quot;numeric&quot;)) getClass(&quot;student&quot;) ## Class &quot;student&quot; [in &quot;.GlobalEnv&quot;] ## ## Slots: ## ## Name: name age GPA ## Class: character numeric numeric # initialize method during object instantiation setMethod(f = &quot;initialize&quot;, signature = &quot;student&quot;, definition = function( .Object, Aname, Aage, AGPA) { .Object@name &lt;- Aname .Object@age &lt;- Aage .Object@GPA &lt;- AGPA return( .Object ) } ) 17.2.2 S4 객체를 생성하는 방법 S4 객체는 new() 함수로 생성할 수 있습니다. S4 객체 생성 예 # new() 함수를 이용한 개체 생성 # 클래스 이름과 슬롯의 값을 제공 # create new instance of the class &#39;Person&#39; using new() mystu &lt;- new(Class = &quot;student&quot;, Aname = &quot;John&quot;, Aage = 21, AGPA = 3.5) mystu ## An object of class &quot;student&quot; ## Slot &quot;name&quot;: ## [1] &quot;John&quot; ## ## Slot &quot;age&quot;: ## [1] 21 ## ## Slot &quot;GPA&quot;: ## [1] 3.5 isS4() 함수를 이용해 개체가 S4 개체인지 확인할 수 있습니다. isS4(mystu) ## [1] TRUE 17.2.3 슬롯에 액세스하고 수정하는 방법 $를 사용하여 리스트의 구성 요소에 액세스하는 것처럼 개체의 슬롯은 @를 사용하여 액세스합니다. 17.2.3.1 슬롯 접근 mystu@name ## [1] &quot;John&quot; mystu@GPA ## [1] 3.5 mystu@age ## [1] 21 17.2.3.2 슬롯 직접 수정 재할당을 통해 슬롯을 수정할 수 있습니다. # GPA 수정 mystu@GPA &lt;- 3.7 mystu ## An object of class &quot;student&quot; ## Slot &quot;name&quot;: ## [1] &quot;John&quot; ## ## Slot &quot;age&quot;: ## [1] 21 ## ## Slot &quot;GPA&quot;: ## [1] 3.7 17.2.3.3 slot() 함수를 사용한 슬롯 수정 마찬가지로 slot() 함수를 사용하여 슬롯에 액세스하거나 수정할 수 있습니다. slot(mystu,&quot;name&quot;) ## [1] &quot;John&quot; slot(mystu,&quot;name&quot;) &lt;- &quot;Paul&quot; slot(mystu,&quot;name&quot;) ## [1] &quot;Paul&quot; 17.2.4 메소드와 일반 함수 S3 클래스의 경우와 마찬가지로 S4 클래스의 메소드도 클래스 자체가 아닌 일반 함수에 속합니다. S4 의 일반 함수 작업은 S3의 일반 함수와 매우 유사합니다. showMethods() 함수를 사용하여 사용 가능한 모든 S4 일반 함수와 메소드를 나열할 수 있습니다. 모든 일반 함수 목록 showMethods() # 목록이 너무 많아서 출력은 생략합니다. 대화형 모드에서 개체 이름을 쓰면 그 내용이 출력됩니다. 이는 S4 일반 함수 show() 함수를 사용하여 수행됩니다. 위 목록에서 이 기능을 볼 수 있습니다. 이 함수는 S3 클래스의 print() 함수에 대응대는 S4 함수 입니다. 함수가 일반 함수인지 테스트하기 isS4(print) ## [1] FALSE isS4(show) ## [1] TRUE showMethods(show)를 사용하여 show 일반 함수의 모든 메소드를 확인할 수 있습니다. 예 6 : 일반 함수의 모든 메소드 나열 showMethods(show) # 목록이 너무 많아서 출력은 생략합니다. 17.2.5 메소드 작성 방법 setMethod() 도우미 함수를 사용하여 자체 메소드를 작성할 수 있습니다. 예를 들어 다음과 같이 show() 일반 함수의 메소드를 구현할 수 있습니다. setMethod(&quot;show&quot;, &quot;student&quot;, function(object) { cat(object@name, &quot;\\n&quot;) cat(object@age, &quot;years old\\n&quot;) cat(&quot;GPA:&quot;, object@GPA, &quot;\\n&quot;) } ) 이제 이전과 같이 대화형 모드에서 개체의 이름을 쓰면 위의 코드가 실행됩니다. s4.s &lt;- new(&quot;student&quot;, Aname=&quot;John&quot;, Aage=21, AGPA=3.5) s4.s # 이는 show(s)와 같습니다. ## John ## 21 years old ## GPA: 3.5 이런 식으로 일반 함수에 대한 자체 S4 클래스 메소드를 작성할 수 있습니다. 참고 자료 : https://www.datamentor.io/r-programming/s4-class/ "],["참조reference-클래스.html", "17.3 참조(reference) 클래스", " 17.3 참조(reference) 클래스 이 절에서는 세 가지 클래스 시스템 중 하나인 R 프로그래밍에서 참조(reference) 클래스로 작업하는 방법을 학습하겠습니다. R 프로그래밍의 참조 클래스는 C ++, Java, Python 등과 같은 공통 언어에서 사용되는 개체 지향 프로그래밍과 유사합니다. 참조 클래스에서는 S3와 S4 클래스와 달리 메소드는 일반 함수가 아닌 클래스에 속합니다. 참조 클래스는 환경이 추가된 S4 클래스로 내부적으로 구현됩니다. 17.3.1 참조 클래스를 정의하는 방법 참조 클래스를 정의하는 것은 S4 클래스를 정의하는 것과 유사합니다. 다만, setClass() 대신에 setRefClass() 함수를 사용하는 것입니다. setRefClass(&quot;student&quot;) 클래스의 멤버 변수가 정의된 경우 클래스 정의에 포함되어야 합니다. 참조 클래스의 멤버 변수를 필드라고합니다 (S4 클래스의 슬롯과 유사함). 다음은 이름(name), 나이(age) 그리고 GPA의 3 개 필드가 있는 st라는 클래스를 정의하는 예입니다. setRefClass(&quot;st&quot;, fields = list(name = &quot;character&quot;, age = &quot;numeric&quot;, GPA = &quot;numeric&quot;)) 17.3.2 참조 개체를 만드는 방법 setRefClass() 함수는 해당 클래스의 개체를 생성하는 데 사용되는 생성 함수를 반환합니다. st &lt;- setRefClass(&quot;st&quot;, fields = list(name = &quot;character&quot;, age = &quot;numeric&quot;, GPA = &quot;numeric&quot;)) # 이제 student() 함수는 새로운 개체를 생성하는 데 사용될 수 있는 생성 함수입니다. ref.s &lt;- st(name = &quot;John&quot;, age = 21, GPA = 3.5) ref.s ## Reference class object of class &quot;st&quot; ## Field &quot;name&quot;: ## [1] &quot;John&quot; ## Field &quot;age&quot;: ## [1] 21 ## Field &quot;GPA&quot;: ## [1] 3.5 17.3.3 필드에 액세스하고 수정하는 방법 $ 연산자를 사용하여 개체의 필드에 액세스할 수 있습니다. ref.s$name ## [1] &quot;John&quot; ref.s$age ## [1] 21 ref.s$GPA ## [1] 3.5 마찬가지로 재할당을 통해 수정됩니다. ref.s$name &lt;- &quot;Paul&quot; ref.s ## Reference class object of class &quot;st&quot; ## Field &quot;name&quot;: ## [1] &quot;Paul&quot; ## Field &quot;age&quot;: ## [1] 21 ## Field &quot;GPA&quot;: ## [1] 3.5 17.3.3.1 경고 참고 R 프로그래밍에서 개체는 새 변수에 할당되거나 (값으로) 함수에 전달될 때 복사됩니다. 예를 들면. # 리스트 a를 생성하고 b에 할당합니다. a &lt;- list(&quot;x&quot; = 1, &quot;y&quot; = 2) b &lt;- a # b를 수정합니다. b$y = 3 # a에게는 아무런 영향이 미치지 않습니다. a ## $x ## [1] 1 ## ## $y ## [1] 2 # b만 수정됩니다. b ## $x ## [1] 1 ## ## $y ## [1] 3 그러나 참조 객체의 경우가 이렇지 않습니다. 단지 사본만이 존재하고 모든 변수가 동일한 사본을 참조합니다. 따라서 다음의 내용을 확인해 보겠습니다. # 참조 개체 a를 생성하고, b에 할당합니다. a &lt;- st(name = &quot;John&quot;, age = 21, GPA = 3.5) b &lt;- a # b를 수정합니다. b$name &lt;- &quot;Paul&quot; # 그러면 a와 b 모두 수정됩니다. a ## Reference class object of class &quot;st&quot; ## Field &quot;name&quot;: ## [1] &quot;Paul&quot; ## Field &quot;age&quot;: ## [1] 21 ## Field &quot;GPA&quot;: ## [1] 3.5 b ## Reference class object of class &quot;st&quot; ## Field &quot;name&quot;: ## [1] &quot;Paul&quot; ## Field &quot;age&quot;: ## [1] 21 ## Field &quot;GPA&quot;: ## [1] 3.5 이로 인해 원치 않는 값의 변경이 발생할 수 있으며, 이상한 버그의 원인이 될 수 있습니다. 참조 개체로 작업하는 동안 이를 염두에 두어야 합니다. 복사본을 만들기 위해, copy() 메소드를 사용할 수 있습니다. # 참조 개체 a를 생성하고, a의 copy를 b에 할당합니다. a &lt;- st(name = &quot;John&quot;, age = 21, GPA = 3.5) b &lt;- a$copy() # b를 수정합니다. b$name &lt;- &quot;Paul&quot; # a는 아무런 영향이 없습니다. a ## Reference class object of class &quot;st&quot; ## Field &quot;name&quot;: ## [1] &quot;John&quot; ## Field &quot;age&quot;: ## [1] 21 ## Field &quot;GPA&quot;: ## [1] 3.5 # b만 수정됩니다. b ## Reference class object of class &quot;st&quot; ## Field &quot;name&quot;: ## [1] &quot;Paul&quot; ## Field &quot;age&quot;: ## [1] 21 ## Field &quot;GPA&quot;: ## [1] 3.5 17.3.4 참조 메소드 메소드는 참조 클래스에 대해 정의되며, S3와 S4 클래스에서 처럼 일반 함수에는 속하지 않습니다. 모든 참조 클래스는 사전에 정의된 메소드를 가지고 있습니다. 이 메소들은 수퍼 클래스 envRefClass에서 상속되기 때문입니다. st ## Generator for class &quot;st&quot;: ## ## Class fields: ## ## Name: name age GPA ## Class: character numeric numeric ## ## Class Methods: ## &quot;field&quot;, &quot;trace&quot;, &quot;getRefClass&quot;, &quot;initFields&quot;, &quot;copy&quot;, &quot;callSuper&quot;, ## &quot;.objectPackage&quot;, &quot;export&quot;, &quot;untrace&quot;, &quot;getClass&quot;, &quot;show&quot;, &quot;usingMethods&quot;, ## &quot;.objectParent&quot;, &quot;import&quot; ## ## Reference Superclasses: ## &quot;envRefClass&quot; 위 목록에서 copy(), field() 그리고 show()와 같은 클래스 메소드를 볼 수 있습니다. 이 클래스에 대한 자체 메소드도 만들 수 있습니다. 이것은 함수 정의 목록을 setRefClass()의 메소드 인수에 전달하여 클래스 정의 중에 수행할 수 있습니다. st &lt;- setRefClass(&quot;st&quot;, fields = list(name = &quot;character&quot;, age = &quot;numeric&quot;, GPA = &quot;numeric&quot;), methods = list( inc_age = function(x) { age &lt;&lt;- age + x }, dec_age = function(x) { age &lt;&lt;- age - x } ) ) 위의 코드 섹션에서 inc_age()와 dec_age/ ()라는 두 가지 메소드를 정의했습니다. 이 두 가지 메소드는 age 필드를 수정합니다. age가 메소드의 로컬 환경에 없기 때문에 로컬이 아닌 할당 연산자 &lt;&lt;-를 사용해야 합니다. 이것은 중요합니다. 간단한 할당 연산자 &lt;-를 사용하면 우리가 원하는 것이 아닌 age라는 지역 변수가 생성되었을 것입니다. 이러한 경우 R은 경고를 발하게 됩니다. 다음은 위에 정의된 메소드를 사용하는 실행의 예를 보겠습니다. ref.s3 &lt;- st(name = &quot;John&quot;, age = 21, GPA = 3.5) ref.s3$inc_age(5) ref.s3$age ## [1] 26 ref.s3$dec_age(10) ref.s3$age ## [1] 16 참고 자료 : https://www.datamentor.io/r-programming/reference-class/ "],["상속.html", "17.4 상속", " 17.4 상속 이 절에서는 R의 상속에 대한 모든 것을 살펴 보겠습니다. 보다 구체적으로는 S3, S4 그리고 참조 클래스에서 상속을 생성하고이를 프로그램에서 효율적으로 사용하는 방법을 알아 보겠습니다. 상속(inheritance)은 기존 클래스에서 새 클래스를 정의할 수있는 개체 지향 프로그래밍의 주요 기능 중 하나입니다. 즉, 기존 기본 클래스에서 새 클래스를 파생시키고 새 기능을 추가할 수 있습니다. 처음부터 쓸 필요가 없습니다. 따라서 상속은 코드의 재사용성(reusability)을 제공합니다. 상속은 가계도처럼 클래스의 계층을 형성합니다. 중요한 점은 기본 클래스에 대해 정의된 특성이 파생 클래스에 자동으로 존재한다는 것입니다. 또한 기본 클래스의 메소드는 파생된 클래스에서도 작동합니다. 아래에서는 R 프로그래밍 언어의 세 가지 클래스 시스템에 대해 상속이 수행되는 방법에 대해 설명합니다. 17.4.1 S3 클래스의 상속 S3 클래스에는 고정된 정의가 없습니다. 따라서 S3 객체의 속성은 임의적일 수 있습니다. 그러나 파생된 클래스는 기본 클래스에 대해 정의된 메소드를 상속합니다. 다음과 같이 stu 클래스의 새로운 개체를 생성하는 함수가 있다고 가정해 봅니다. stu &lt;- function(n,a,g) { value &lt;- list(name=n, age=a, GPA=g) attr(value, &quot;class&quot;) &lt;- &quot;stu&quot; value } 또한 다음과 같이 일반 함수 print()에 대해 정의된 메소드가 있습니다. print.stu &lt;- function(obj) { cat(obj$name, &quot;\\n&quot;) cat(obj$age, &quot;years old\\n&quot;) cat(&quot;GPA:&quot;, obj$GPA, &quot;\\n&quot;) } print.stu(s3.s1) ## Paul ## 26 years old ## GPA: 3.7 s3.s1 ## Paul ## 26 years old ## GPA: 3.7 이제 stu에서 상속하는InternationalStudent 클래스의 개체를 만들고 싶습니다. 이것은 class(obj) &lt;- c(child, parent)와 같은 클래스 이름의 문자형 벡터를 할당하여 수행됩니다. # 리스트를 생성합니다. s3.s2 &lt;- list(name=&quot;John&quot;, age=21, GPA=3.5, country=&quot;France&quot;) s3.s2 ## $name ## [1] &quot;John&quot; ## ## $age ## [1] 21 ## ## $GPA ## [1] 3.5 ## ## $country ## [1] &quot;France&quot; class(s3.s2) ## [1] &quot;list&quot; # stu 클래스에서 파생된 InternationalStudent 클래스를 만듭니다. class(s3.s2) &lt;- c(&quot;InternationalStudent&quot;, &quot;stu&quot;) class(s3.s2) ## [1] &quot;InternationalStudent&quot; &quot;stu&quot; # 개체를 출력합니다. print.stu(s3.s2) ## John ## 21 years old ## GPA: 3.5 s3.s2 ## John ## 21 years old ## GPA: 3.5 print.InternationalStudent() 형식의 메소드를 정의하지 않았으므로 print.stu() 메서드가 호출되었음을 위에서 볼 수 있습니다. 이 class 메소드는 상속된 것입니다. 이제 print.InternationalStudent()를 정의하겠습니다. print.InternationalStudent &lt;- function(obj) { cat(obj$name, &quot;is from&quot;, obj$country, &quot;\\n&quot;) } 아래와 같이 stu 클래스에 대해 정의된 메소드를 덮어 씁니다. s3.s2 ## John is from France inherits() 함수 또는 is() 함수와 같은 함수들을 이용하여 상속 여부를 확인할 수 있습니다. inherits(s3.s2,&quot;stu&quot;) ## [1] TRUE is(s3.s2,&quot;stu&quot;) ## [1] TRUE 17.4.2 S4 클래스의 상속 S4 클래스에는 적절한 정의가 있으므로 파생 클래스는 부모 클래스의 특성과 메소드를 모두 상속합니다. 일반 함수 show()에 대한 메소드로 student1 클래스를 정의해 보겠습니다. # student1라 불리는 클래스를 정의합니다. setClass(&quot;student1&quot;, slots=list(name=&quot;character&quot;, age=&quot;numeric&quot;, GPA=&quot;numeric&quot;)) # show() 일반 함수를 위한 클래스 메소드를 정의합니다. setMethod(&quot;show&quot;, &quot;student1&quot;, function(object) { cat(object@name, &quot;\\n&quot;) cat(object@age, &quot;years old\\n&quot;) cat(&quot;GPA:&quot;, object@GPA, &quot;\\n&quot;) } ) 상속은 다음과 같이 인수가 포함된 파생 클래스 정의 중에 수행됩니다. # student1에서 상속됩니다. setClass(&quot;InternationalStudent&quot;, slots=list(country=&quot;character&quot;), contains=&quot;student1&quot; ) 여기에 country 속성을 추가했으며 나머지는 부모로부터 상속됩니다. s3 &lt;- new(&quot;InternationalStudent&quot;, name=&quot;John&quot;, age=21, GPA=3.5, country=&quot;France&quot;) s3 ## John ## 21 years old ## GPA: 3.5 show(s3) ## John ## 21 years old ## GPA: 3.5 우리가 show(s)를 했을 때 student 클래스에 대한 정의가 호출된 것을 볼 수 있습니다. S3 시스템의 경우처럼 기본 클래스의 메소드를 덮어 쓰는 파생 클래스에 대한 메소드를 정의 할 수 있습니다. 17.4.3 참조 클래스의 상속 참조 클래스의 상속은S4 클래스의 상속과 매우 유사합니다. 파생할 기본 클래스를 contains 인수에서 정의합니다. 다음은 inc_age()와 dec_age() 두 가지 메소드가 있는 st1 참조 클래스의 예입니다. ref.st &lt;- setRefClass(&quot;ref.st&quot;, fields=list(name=&quot;character&quot;, age=&quot;numeric&quot;, GPA=&quot;numeric&quot;), methods=list( inc_age = function(x) { age &lt;&lt;- age + x }, dec_age = function(x) { age &lt;&lt;- age - x } ) ) 이제 이 클래스에서 상속합니다. 또한dec_age()메소드를 덮어 써서 age가 음수가 되지 않도록 무결성 검사를 추가합니다. IntStu &lt;- setRefClass(&quot;IntStu&quot;, fields=list(country=&quot;character&quot;), contains=&quot;ref.st&quot;, methods=list( dec_age = function(x) { if((age - x) &lt; 0) stop(&quot;Age cannot be negative&quot;) age &lt;&lt;- age - x } ) ) 테스트 해 보겠습니다. ref.s4 &lt;- ref.st(name=&quot;Paul&quot;, age = 18, GPA = 3.8) ref.s4$age ## [1] 18 ref.s4$dec_age(5) ref.s4$age ## [1] 13 ref.s5 &lt;- IntStu(name=&quot;John&quot;, age=21, GPA=3.5, country=&quot;France&quot;) ref.s5$age ## [1] 21 ref.s5$inc_age(5) ref.s5$age ## [1] 26 ref.s5$dec_age(5) ref.s5$age ## [1] 21 이런 식으로 부모 클래스에서 상속할 수 있습니다. 참고자료 : https://www.datamentor.io/r-programming/inheritance/ "],["apply-류의-함수를.html", "Chapter 18 apply 류의 함수를", " Chapter 18 apply 류의 함수를 apply() 함수 패밀리는 루프를 명시적으로 생성하는 필요성을 최소화하는 벡터화된 함수로 구성됩니다. 이러한 함수는 지정된 함수를 데이터 개체에 적용하며 함수 간의 주요 차이점은 함수가 적용되는 개체 클래스(리스트, 행렬 등)와 함수에서 반환하는 개체 클래스에 있습니다. 다음은 데이터 분석에 사용하는 가장 일반적인 형태의 appy() 함수 패밀리이지만, 여기에서 다루지 않는 추가적인 함수(mapply,rapply,vapply 등)들도 있다는 것을 알고 있어야 합니다. apply() : 행렬과 데이터 프레임에 적용 lapply() : 리스트에 적용. 리스트 반환 sapply() : 리스트에 적용…단순화된 출력 tapply() : 벡터에 적용 그 밖에도 유용한 apply 류의 함수들 "],["apply-함수.html", "18.1 apply() 함수", " 18.1 apply() 함수 apply()함수는 행렬이나 데이터 프레임의 행이나 열(이를 margin이라고 합니다)에 함수를 적용하는 데 가장 자주 사용됩니다. 그러나 예를 들어 행렬과 배열의 평균을 구하기 위해 일반 배열과 함께 사용할 수 있습니다. apply() 함수를 사용하는 것이 루프 함수를 사용하는 것보다 빠르지는 않지만 매우 간결하고 한 줄로 작성할 수 있습니다. apply() 함수의 형식은 다음과 같습니다. apply(X, MARGIN, FUN, ...) x : 행렬, 데이터 프레임 또는 배열입니다. MARGIN : 함수가 적용될 첨자를 제공하는 벡터입니다. 예를 들어, 배열에서 1은 1차원(행)을, 2는 2차원(열)을, c(1, 2)는 3차원 배열에서 행과 열을 나타냅니다. FUN : 적용할 함수입니다. ... : 함수에 전달되는 다른 인수를 위한 것입니다. R에서 제공하는 mtcars 데이터 세트를 사용하여 예를 들어 보겠습니다. # mtcars 데이터 세트의 첫 6개 행을 확인합니다. head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # 각 열(2차원)의 평균을 구합니다. apply(mtcars, 2, mean) ## mpg cyl disp hp drat wt qsec ## 20.090625 6.187500 230.721875 146.687500 3.596563 3.217250 17.848750 ## vs am gear carb ## 0.437500 0.406250 3.687500 2.812500 # 각 행(1차원)의 합계를 구합니다. (이 데이터 세트에서 행의 합이 갖는 의미는 없지만, # 행의 합을 구할 수 있음을 보여주기 위해 실행해 봅니다.) apply(mtcars, 1, sum) ## Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive ## 328.980 329.795 259.580 426.135 ## Hornet Sportabout Valiant Duster 360 Merc 240D ## 590.310 385.540 656.920 270.980 ## Merc 230 Merc 280 Merc 280C Merc 450SE ## 299.570 350.460 349.660 510.740 ## Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental ## 511.500 509.850 728.560 726.644 ## Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla ## 725.695 213.850 195.165 206.955 ## Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 ## 273.775 519.650 506.085 646.280 ## Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa ## 631.175 208.215 272.570 273.683 ## Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E ## 670.690 379.590 694.710 288.890 # 각 열(2차원)의 백분위수를 구합니다. apply(mtcars, 2, quantile, probs = c(0.10, 0.25, 0.50, 0.75, 0.90)) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 10% 14.340 4 80.610 66.0 3.007 1.95550 15.5340 0 0 3 1 ## 25% 15.425 4 120.825 96.5 3.080 2.58125 16.8925 0 0 3 2 ## 50% 19.200 6 196.300 123.0 3.695 3.32500 17.7100 0 0 4 2 ## 75% 22.800 8 326.000 180.0 3.920 3.61000 18.9000 1 1 4 4 ## 90% 30.090 8 396.000 243.5 4.209 4.04750 19.9900 1 1 5 4 "],["lapply-함수.html", "18.2 lapply() 함수", " 18.2 lapply() 함수 lapply() 함수는 다음과 같은 간단한 일련의 작업을 수행합니다. 리스틀 반복하며 해당 리스트의 각 요소에 반복적으로 적용합니다. 리스트의 각 요소에 함수를 적용합니다(사용자가 지정한 함수). 결과로 리스트를 반환합니다 (lapply() 함수의 l은 “list”를 나타냅니다). lapply() 함수의 형식은 다음과 같습니다. lapply(X, FUN, ...) x : 리스트 개체입니다. FUN : 적용하는 함수입니다. ... : 함수에 전달되는 다른 인수를 위한 것입니다. 예를 들기 위해 4 개의 요소로 구성되는 리스트를 먼저 생성하겠습니다. 그리고 이 리스트의 요소별 평균을 구해 보겠습니다. # 4 개의 요소로 구성되는 리스트를 생성합니다. data &lt;- list(item1 = 1:4, item2 = rnorm(10), item3 = rnorm(20, 1), item4 = rnorm(100, 5)) # 리스트의 각 요소의 평균을 구합니다. lapply(data, mean) ## $item1 ## [1] 2.5 ## ## $item2 ## [1] 0.2699883 ## ## $item3 ## [1] 1.383788 ## ## $item4 ## [1] 5.090595 위는 각 리스트 항목이 단순히 숫자형의 벡터인 간단한 예를 들고 있습니다. 그러나 데이터 프레임이 포함된 리스트를 생각해 볼 수 있습니다. 각 리스트의 항목에 반복적으로 적용하여 데이터 프레임에 대한 항수를 수행해 보겠습니다. 이 경우 lapply() 함수 내에 apply 함수를 삽입할 수도 있습니다. 예를 들어, 다음은 R의 내장 beaver 데이터 세트에 대한 리스트를 만듭니다. lapply() 함수는 두 리스트 항목을 각각 반복하고 apply() 함수를 사용하여 두 리스트 항목의 열 평균을 계산하겠습니다. 더 쉽게 읽을 수있는 출력을 제공하기 위해 apply() 함수를 round() 함수로 묶어 주었습니다. # R에 내장된 beaver 데이터 세트를 리스트로 변형합니다. beaver_data &lt;- list(beaver1 = beaver1, beaver2 = beaver2) # 각 리스트 항목의 평균을 구하여 리스트로 반환합니다. lapply(beaver_data, function(x) round(apply(x, 2, mean), 2)) ## $beaver1 ## day time temp activ ## 346.20 1312.02 36.86 0.05 ## ## $beaver2 ## day time temp activ ## 307.13 1446.20 37.60 0.62 "],["sapply-함수.html", "18.3 sapply() 함수", " 18.3 sapply() 함수 sapply() 함수는lapply()와 유사하게 작동합니다. 유일한 실제적인 차이점은 함수가 반환하는 값입니다. sapply() 함수는 가능하면 lapply () 함수의 결과를 단순화하려고 합니다. 기본적으로sapply() 함수는 입력에서lapply()를 호출하고 다음의 알고리즘을 적용합니다. 모든 요소의 길이가 1 인 리스트로 결과가 나오면 벡터를 반환합니다. 모든 요소가 동일한 길이 (&gt; 1)의 벡터인 리스트로 결과가 나오면 행렬을 반환합니다. 위와 같은 단순화를 수행할 수 없는 경우에는 리스트를 반환합니다. lapply() 함수와 sapply() 함수의 차이점을 설명하기 위해 beaver 데이터가 있는 리스트를 사용하는 앞의 예를 사용하여 살펴 보겠습니다. # R에 내장된 beaver 데이터 세트를 리스트로 변형합니다. beaver_data &lt;- list(beaver1 = beaver1, beaver2 = beaver2) # 각 리스트 항목의 평균을 구하여 리스트로 반환합니다. lapply(beaver_data, function(x) round(apply(x, 2, mean), 2)) ## $beaver1 ## day time temp activ ## 346.20 1312.02 36.86 0.05 ## ## $beaver2 ## day time temp activ ## 307.13 1446.20 37.60 0.62 # 각 리스트 항목의 평균을 구하여 결과를 단순화합니다. bea.result &lt;- sapply(beaver_data, function(x) round(apply(x, 2, mean), 2)) class(bea.result) # 행렬을 반환합니다. ## [1] &quot;matrix&quot; &quot;array&quot; "],["tapply-함수.html", "18.4 tapply() 함수", " 18.4 tapply() 함수 tapply() 함수는 벡터의 하위 집합에 함수를 적용하는 데 사용됩니다. 주로 다음과 같은 상황에서 사용됩니다. (범주형 변수 즉, 일명 요인을 통해) 그룹으로 나누어 질 수있는 데이터 세트의 경우입니다. 데이터 세트를 그룹으로 나누고 싶은 경우 입니다. 각 그룹 내에서 함수를 적용하고 싶습니다. tapply() 함수의 형식은 다음과 같습니다. tapply(X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE) x : 벡터입니다. INDEX : 요인 또는 요인의 리스트(또는 강제 변환된 요인)입니다. FUN : 적용할 함수입니다. ... : FUN에 전달될 다른 인수가 포함되어 있습니다. simplify : 결과의 단순화 여부를 설정합니다. R에 내장된 mtcars 데이터 세트를 사용하고 cyl 변수로 그룹화된 mpg 변수의 평균을 계산하는 것을 예로 들어 보겠습니다. # mtcars 데이터 세트의 앞의 6개 행을 확인합니다. head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 # cylinders를 그룹화하여 mpg 컬럼의 평균을 구합니다. tapply(mtcars$mpg, mtcars$cyl, mean) ## 4 6 8 ## 26.66364 19.74286 15.10000 이제 cylinder 범주형 변수로 그룹화된 mtcars 데이터 세트의 각 열에 대한 평균을 계산해 보겠습니다. 이를 위해 apply 함수 내에 tapply 함수를 포함할 수 있습니다. # cylinders를 그룹화하여 모든 컬럼의 평균을 구합니다. apply(mtcars, 2, function(x) tapply(x, mtcars$cyl, mean)) ## mpg cyl disp hp drat wt qsec vs ## 4 26.66364 4 105.1364 82.63636 4.070909 2.285727 19.13727 0.9090909 ## 6 19.74286 6 183.3143 122.28571 3.585714 3.117143 17.97714 0.5714286 ## 8 15.10000 8 353.1000 209.21429 3.229286 3.999214 16.77214 0.0000000 ## am gear carb ## 4 0.7272727 4.090909 1.545455 ## 6 0.4285714 3.857143 3.428571 ## 8 0.1428571 3.285714 3.500000 "],["그-밖의-유용한-apply-류-함수들.html", "18.5 그 밖의 유용한 apply-류 함수들", " 18.5 그 밖의 유용한 apply-류 함수들 루프를 명시적으로 생성해야 하는 필요성을 최소화하는 벡터화된 함수를 제공하는 [apply 함수군] (http://uc-r.github.io/apply_family#apply_family) 외에도 일반적으로 적용할 수 있는 더욱 단순화된 apply류의 몇 가지 함수가 있습니다. 여기에는 전체 데이터 세트에 대한 열과 행의 합계, 평균, 중앙값, 표준 편차, 분산 그리고 요약 백분위수 계산 등이 포함됩니다. 가장 일반적인 apply 함수에는 열과 행의 합계와 평균 계산이 포함됩니다. 예를 들어 데이터 프레임 또는 행렬에서 열의 합계를 계산하려면 다음과 같이 실행할 수 있습니다. # mtcars 데이터 세트를 예로 들겠습니다. head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 apply(mtcars, 2, sum) ## mpg cyl disp hp drat wt qsec vs ## 642.900 198.000 7383.100 4694.000 115.090 102.952 571.160 14.000 ## am gear carb ## 13.000 118.000 90.000 그러나 더 간결한 colSums()함수로 동일한 기능을 수행할 수 있으며 실행속도도 더 빠릅니다. colSums(mtcars) ## mpg cyl disp hp drat wt qsec vs ## 642.900 198.000 7383.100 4694.000 115.090 102.952 571.160 14.000 ## am gear carb ## 13.000 118.000 90.000 To illustrate the speed difference we can compare the performance of using the apply() function versus the colSums() function on a matrix with 100 million values (10K x 10K). You can see that the speed of colSums() is significantly faster. 속도 차이를 확인하기 위해 1 억 개의 값(10K x 10K)이 있는 행렬에 apply() 함수와 colSums() 함수를 적용하여 성능을 비교해 보겠습니다. 그 결과로 colSums()의 속도가 훨씬 빠르다는 것을 알 수 있습니다. # 10,000 x 10,000 행렬을 생성합니다. mat &lt;- matrix(sample(1:10, size=100000000, replace=TRUE), nrow=10000) system.time(apply(mat, 2, sum)) ## user system elapsed ## 1.45 0.19 1.64 system.time(colSums(mat)) ## user system elapsed ## 0.09 0.00 0.09 Base R은 다음과 같은 단순화된 apply 함수를 제공합니다. colSums (x, na.rm = FALSE) rowSums (x, na.rm = FALSE) colMeans(x, na.rm = FALSE) rowMeans(x, na.rm = FALSE) 또한 다음의 패키지들도 다음의 함수를 제공합니다. miscTools 패키지 (다음의 함수들은 데이터 프레임에서 작동될 것입니다) colMedians() rowMedians() matrixStats 패키지 (다음의 함수들은 행렬에서만 작동될 것입니다) colMedians() &amp; rowMedians() colSds() &amp; rowSds() colVar() &amp; rowVar() colRanges() &amp; rowRanges() colQuantiles() &amp; rowQuantiles() 그 밖에도 여러 개의 추가적인 요약 통계 함수들이 있습니다. 또한 summary () 함수는 데이터 프레임과 행렬의 각 열에 대한 관련 요약 통계를 제공합니다. 다음의 예는 iris 데이터 세트의 처음 4 개 열에 대한 요약 통계로 최솟값, 중앙값, 평균, 최댓값, 1사분위수 그리고 3사분위수 등이 포함됩니다. 마지막 열(species)은 요인 변수이기 때문에 각 수준별 빈도수를 제공하고 있습니다. summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## 참고 자료 http://uc-r.github.io/apply_family "],["r의-plotting-system.html", "Chapter 19 R의 Plotting System", " Chapter 19 R의 Plotting System R의 plotting system에는 크게 (1) Base Graphics, (2) Lattice, (3) ggplot2 의 3가지가 있습니다. 이 파트에서는 쉽고 빠르게, 대화형으로 직관적으로 그래프를 단계적으로 그려나갈 수 있는 Base Graphics plotting system에 대해서 알아보겠습니다. Base Graphics system 은 기본 뼈대에 해당하는 (1) 높은 수준의 그래프 함수 (High Level Graphics facilities)를 이용하여 기본적인 그래프를 작성하고, 여기에 살을 하나, 둘씩 차근 차근 더해가는 (2) 낮은 수준의 그래프 함수 (Low Level Graphics facilities)를 적용합니다. 또한, 색깔이나 모양, 선 형태, 마진 등의 다양한 옵션을 적용하여 설정하는 (3) 그래픽 모수 (Graphic Parameters) 를 다양하게 조합하여 단계적으로 그래프를 작성하여 나가게 됩니다. 지금까지 설명한 내용을 구체적인 예로 산점도(scatter plot)을 이용하여 간단히 앞서 소개한 용어들이 의미하는 바를 살펴 보겠습니다. MASS 패키지에서 제공하는 Cars93 데이터 세트를 이용하겠습니다. # 데이터 세트를 불러옵니다. # install.packages(MASS) library(MASS) ## ## Attaching package: &#39;MASS&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## select attach(Cars93) # Cars93을 공통으로 사용하는 데이터 프레임으로 지정합니다. # 높은 수준의 그래프 함수 plot()를 이용하여 기본 그래프를 작성합니다. # 그래픽 인수를 설정합니다. : type, pch, col, etc. (그래프의 유형, 모양, 그리고 색깔 등) plot(MPG.highway ~ Weight, type = &quot;p&quot;, pch = 19, col = &quot;black&quot;) # 낮은 수준의 그래프 함수 abline(), title(), text() 등을 이용하여 그래프를 치장합니다. # 그래픽 인수를 설정합니다. : labels, cex, pos, col, etc. (레이블, 글자크기, 위치, 색깔 등) abline(lm(MPG.highway ~ Weight)) text(Weight, MPG.highway, labels = abbreviate(Manufacturer, minlength = 5), cex = 0.6, pos = 2, col = &quot;blue&quot;) detach(Cars93) # 활성화된 데이터 프레임을 해제합니다. 이처럼 base plotting system의 그래프에서는 높은 수준의 그래프 함수, 낮은 수준의 그래프 함수, 그리고 그래프 모수 등으로 구성하여 그래프를 작성하게 됩니다. 높은 수준의 그래프 함수 : plot() 함수를 먼저 그래프를 작성합니다. 낮은 수준의 그래프 함수 : abline() 함수로 차의 무게(Weight)와 고속도로연비(MPG.highway) 간의 회귀선을 적합시키는 회귀선을 추가합니다. 그리고 text() 함수로 차 제조사 이름(Manufacturer)을 명기합니다. 그리고 그래프 모수(parameters)로 그래프의 형태(type), 점의 형태(pch), 색깔(col), 레이블(labels), default 대비 확대 배수(cex), 다른 축과 교차되는 좌표(pos) 등의 추가적인 사항들을 옵션으로 설정합니다. "],["높은-수준의-그래프-함수.html", "Chapter 20 높은 수준의 그래프 함수", " Chapter 20 높은 수준의 그래프 함수 높은 수준의 그래프 함수 (High Level Graphics facilities) 들을 표로 정리해보면 아래와 같습니다. 그래프 종류 높은 수준의 그래프 함수 히스토그램(histogram) hist() 박스 플롯(box and whisker plot) boxplot() 줄기 잎 플롯(stem and leaf plot) stem() 막대 그래프 barplot() Cleveland Dot Plot dotchart() 파이 차트 pie() 산점도 plot(x, y) 산점도 행렬 plot(dataframe)cf) other package: scatterplotMatrx() 선 그래프 plot(x, y, type=“l”) High Density Needle Plot plot(x, y, type=“h”) Both Dot and Line Plot plot(x, y, type=“b”) Overlapped Dot and Line Plot plot(x, y, type=“o”) Step Plot plot(x, y, type=“s”) Empty Plot plot(x, y, type=“n”) 그런데 이러한 높은 수준의 함수 그래프는 각 함수에 서 사용하고 있는 데이터 인수의 갯수와 x, y의 데이터 유형에 따라 분류할 수 있습니다. 변수의 갯수데이터 유형 1개 2개 이상 연속형 데이터 1변량 연속형 그래프 2(다)변량 연속형 그래프 범주형 데이터 1변량 연속형 그래프 2(다)변량 연속형 그래프 "],["일변량-연속형-데이터-그래프.html", "20.1 일변량 연속형 데이터 그래프", " 20.1 일변량 연속형 데이터 그래프 플롯 함수의 데이터 인수가 1개 이며, 그 데이터가 연속형(정수형, 실수형 등)인 경우의 그래프입니다. 이러한 유형의 변수의 시각화를 위한 다양한 그래프 함수가 있는데 이 절에서는 다음과 같은 유형의 그래프에 대하여 살펴보겠습니다. 히스토그램(Histogram) 박스 플롯(Box and whisker plot) 줄기 잎 플롯(Stem and leaf plot) 20.1.1 히스토그램 연속형 데이터 x를 단계(또는 구간, bins)로 분할하여 각 구간별 데이터의 빈도수(또는 합계, 평균 등)을 시각화하는 것입니다. base 의 hist() 함수를 사용합니다. 다음의 예는 Cars93 데이터 세트의 MPG.highway 변수를 히스토그램으로 작성하는 것입니다. # hist() 함수를 이용하여 히스토그램을 작성합니다. library(MASS) class(Cars93$MPG.highway) # Cars93$MPG.highway 컬럼의 클래스를 확인합니다. ## [1] &quot;integer&quot; hist(Cars93$MPG.highway, main = &quot; 히스토그램 : hist()&quot;) ? hist()를 이용하여 자세한 도움말을 참고하기 바랍니다. 20.1.2 박스 플롯 박스 플롯은 연속형 데이터 x에 대한 통계적 요약 정보인 summary()의 결과를 시각화하는 것입니다. base의 boxplot() 함수를 사용합니다. 다음의 예는 Cars93 데이터 세트의 MPG.highway 변수를 박스 플롯으로 작성하는 것입니다. # Cars93$MPG.highway의 통계적 요약 정보를 확인합니다. library(MASS) summary(Cars93$MPG.highway) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 20.00 26.00 28.00 29.09 31.00 50.00 # boxplot() 함수를 이용하여 박스 플롯을 작성합니다. boxplot(Cars93$MPG.highway, main = &quot;박스 플롯 : boxplot()&quot;) ? boxplot()을 이용하여 자세한 도움말을 참고하기 바랍니다. 20.1.3 줄기 잎 플롯 줄기 잎 플롯은 연속형 데이터 x를 표 형태와 그래프 형태의 혼합된 방법으로 시각화하는 것입니다. # 줄기 잎 플롯 : stem() library(MASS) stem(Cars93$MPG.highway) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 2 | 00112233334444 ## 2 | 55555555666666666667777778888888888999999 ## 3 | 000000000111111123333333444 ## 3 | 6667778 ## 4 | 13 ## 4 | 6 ## 5 | 0 ? stem()을 이용하여 자세한 도움말을 참고하기 바랍니다. "],["일변량-범주형-자료-그래프.html", "20.2 일변량 범주형 자료 그래프", " 20.2 일변량 범주형 자료 그래프 플롯 함수의 데이터 인수가 1개 이며, 그 데이터가 범주형(명목형, 요인 변수)인 경우의 그래프입니다. 이러한 유형의 변수의 시각화를 위한 다양한 그래프 함수가 있는데 이 절에서는 다음과 같은 유형의 그래프에 대하여 살펴보겠습니다. 막대 그래프(Bar plot) 클리블랜드 점 플롯(Cleveland dot plot) 파이 차트(Pie chart) 일반적으로 범주형 데이터의 경우는 그 변수에 대한 도수 분포표 또는 도수 분포도로 그 변수에 대한 통계적 정보를 파악하게 됩니다. 여기서 도수 분포도가 바로 범주형 변수의 시각화 방법의 대상입니다. 참고적으로 도수 분포표(frequency table)는 table() 함수로 구할 수 있습니다. 다음의 예는 Cars93 데이터 세트의 Cylinders 에 대한 도수 분포표(freq.table.cyl)를 구하는 예입니다. # Cars93$Cylinders의 클래스를 확인합니다. library(MASS) class(Cars93$Cylinders) # factor 형입을 확인할 수 있습니다. ## [1] &quot;factor&quot; # Cars93$Cylinders의 도수분포표를 구합니다. freq.table.cyl &lt;- table(Cars93$Cylinders) freq.table.cyl ## ## 3 4 5 6 8 rotary ## 3 49 2 31 7 1 # 이렇게 구한 도수분포표의 상대 도수분포표를 구합니다. rel.freq.table.cyl &lt;- prop.table(freq.table.cyl) rel.freq.table.cyl ## ## 3 4 5 6 8 rotary ## 0.03225806 0.52688172 0.02150538 0.33333333 0.07526882 0.01075269 이제 위의 예에서 구한 도수분포표를 시각화해 보겠습니다. 20.2.1 막대 그래프(bar plot) 막대 그래프는 앞의 도수 분포표를 시각화하는 방법 중의 하나입니다. x축에 범주형 데이터의 수준을 표시하고, y축에 그 빈도를 표시하는 그래프가 막대 그래프입니다. 막대 그래프는 barplot() 함수로 작성됩니다. 다음의 예는 Cars93 데이터 세트의 Cylinders 에 대한 도수 분포표(freq.table.cyl)를 막대 그래프로 시각화하는 예입니다. ## 일변량 범주형 데이터의 시각화입니다. # barplot() 함수를 이용하여 막대그래프를 작성합니다. library(MASS) # 먼저 Cars93$Cylinders의 도수분포표를 구합니다. freq.table.cyl &lt;- table(Cars93$Cylinders) # 도수분포표를 데이터 인수로 하여 막대 그래프를 작성합니다. barplot(freq.table.cyl, main = &quot; 막대 그래프 : barplot()&quot;) ? barplot()을 이용하여 자세한 도움말을 참고하기 바랍니다. 20.2.2 클리블랜드 점 플롯(Cleveland dot plot ) 이 시각화 방법은 Cleveland and McGill (1984) 이 “Graphical Methods for Data Presentation: Full Scale Breaks, Dot Charts, and Multibased Logging.” 이라는 논문을 통해, 막대 그래프에 비해 점 그래프가 데이터의 해석, 가독성 등에서 우수한 점을 소개하면서 Cleveland Dot Plot 이라고 명명이 된 그래프입니다. 클리블랜드 점 플롯은 dotchart() 함수로 작성됩니다. 다음의 예는 Cars93 데이터 세트의 Cylinders 에 대한 도수 분포표(freq.table.cyl)를 클리블랜드 점 플롯으로 시각화하는 예입니다. # dotchart() 함수를 이용하여 클리블랜드 점 플롯을 작성합니다 library(MASS) # 먼저 Cars93$Cylinders의 도수분포표를 구합니다. freq.table.cyl &lt;- sort(table(Cars93$Cylinders)) # 빈도수로 sort 합니다. # Cars93$Cylinders의 수준이름을 추출합니다. Cylinders &lt;- names(freq.table.cyl) # y축에 표시될 수준 데이터 레이블입니다. # names for label dotchart(as.numeric(freq.table.cyl), # 도수 분포표를 숫자형으로 변환합니다. labels = Cylinders, # y축에 Cylinders 의 값을 표시합니다. main = &quot; 클리블랜드 점 플롯&quot;) 그런데, 클리블랜드 점 플롯은 막대 그래프와 달리 범주형 데이터의 수준을 y축에 표시합니다. 그리고 빈도수는 x축에 표시합니다. ? dotchart()를 이용하여 자세한 도움말을 참고하기 바랍니다. 한편 위의 클리블랜드 점 플롯을 자동차 종류(Type)별로 그룹화하여 시각화해 보겠습니다. https://nittaku.tistory.com/367 20.2.3 파이 차트 파이 차트는 (상대) 도수 분포표(Relative frequency table)를 시각화하는 방법 중의 하나입니다. 범주형 데이터 x에 대하여 각 수준별 발생 빈도(의 비율)에 비례하여 중심각을 나누어 마치 파이를 조작으로 나눈 것과 같은 형태로 시각화한 것입니다. 파이 차트는 pie() 함수로 작성됩니다. 다음의 예는 Cars93 데이터 세트의 Cylinders 에 대한 상대도수 분포표(rel.freq.table.cyl)를 파이 차트로 시각화하는 예입니다. # Cylinders 의 도수분포표와 상대도수분포표를 구합니다. library(MASS) # 도수 분포표를 구합니다. freq.table.cyl &lt;- table(Cars93$Cylinders) freq.table.cyl ## ## 3 4 5 6 8 rotary ## 3 49 2 31 7 1 # 도수 분포표를 이용하여 상대 도수 분포표를 구합니다. rel.freq.table.cyl &lt;- round(prop.table(freq.table.cyl) * 10000) / 100 rel.freq.table.cyl ## ## 3 4 5 6 8 rotary ## 3.23 52.69 2.15 33.33 7.53 1.08 # Cylinders의 수준 이름을 추출합니다. 이를 파이 조작의 레이블로 사용합니다. Cylinders &lt;- names(rel.freq.table.cyl) label1 &lt;- paste0(Cylinders, &quot; : &quot;, rel.freq.table.cyl, &quot; %&quot; ) # 상대 도수 분포표를 파이 차트로 시각화합니다. pie(rel.freq.table.cyl, labels = label1, main = &quot;파이 차트 : 상대 도수&quot;, cex = 0.7) ? pie() 를 이용하여 자세한 도움말을 참고하기 바랍니다. "],["이변량-연속형-변수-그래프.html", "20.3 이변량 연속형 변수 그래프", " 20.3 이변량 연속형 변수 그래프 플롯 함수의 데이터 인수가 2개 이며, 그 데이터가 연속형(정수형, 실수형) 인 경우의 그래프입니다. 이러한 유형의 변수의 시각화를 위한 다양한 그래프 함수가 있는데 이 절에서는 다음과 같은 유형의 그래프에 대하여 살펴보겠습니다. 산점도(Scatter plot) 산점도 행렬(Scatter plot matrix) 20.3.1 산점도 (scatter plot) 산점도는 2개의 연속형 변수 간의 관계를 보기 위하여 직교좌표의 평면에 관측점을 찍어 만든 통계 그래프입니다. 산포도에 표시되는 각 점들은 자료의 관측 값을 나타내며 산점도에서 각 점의 위치는 각 관측값이 가지는 X축, Y축 변수의 값으로 결정되게 됩니다. 산점도는 plot() 함수로 작성됩니다. 다음의 예는 Cars93 데이터 세트의 차량의 무게(Weight)와 고속도로의 연비(MPG.highwat) 간의 관계를 시각화로 표현하는 예입니다. ## 이변량 연속형 변수의 그래프를 그립니다. # plot(x, y) 함수를 이용하여 시각화할 수 있습니다. library(MASS) attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders plot(Weight, MPG.highway, main = &quot;산점도 : plot(x, y)&quot;) detach(Cars93) 이 산점도를 통해 x 축의 차량의 무게(Weight)가 커질 수록 y 축의 고속도로의 연비(MPG.highwat)가 떨어지는 것을 시각적으로 확인할 수 있습니다. ? plot() 를 이용하여 자세한 도움말을 참고하기 바랍니다. 20.3.2 산점도 행렬 : plot(dataframe), pairs(), scatterplotMatrix(dataframe) 산점도 행렬는 산포도 그래프를 여러 개의 변수 조합별로 그린 행렬 형태의 그래프입니다. 이 그래프를 이용하면 변수들끼리의 선형성을 파악하기 용이하기 때문에 탐색적 데이터 분석을 수행할 때, 거의 빠지지 않고 살펴보는 과정 중 하나라고 할 수 있습니다. 이 절에서는 R로 어떻게 산점도 행렬을 어떻게 그릴 수 있는지 확인해 보겠습니다. 참고자료 : https://m.blog.naver.com/PostView.nhn?blogId=pmw9440&amp;logNo=221531227924&amp;proxyReferer=https:%2F%2Fwww.google.com%2F 20.3.2.1 plot() 함수 이용 다음의 예에서는 차량의 무게(Weight), 마력(Horsepower), 고속도록 연비(MPG.highway) 그리고 시내 연비(MPG.city) 등의 4 개의 변수 간의 관계를 산점도 행렬로 시각화하는 예입니다. # plot(dataframe) 함수를 이용하여 산점도 행렬을 작성합니다. library(MASS) # Cars93 데이터 세트에서 4 개의 컬럼을 서브 세팅합니다. Cars93_subset &lt;- Cars93[ ,c(&quot;Weight&quot;, &quot;Horsepower&quot;, &quot;MPG.highway&quot;, &quot;MPG.city&quot;)] # 서브세팅한 데이터 세트를 plot() 함수로 시각화합니다. plot(Cars93_subset, main = &quot;산점도 행렬 : plot(dataframe)&quot;) 20.3.2.2 pairs() 함수 이용 pairs() 함수를 이용해서도 여러 변수들 간의 관계를 시각화할 수 있습니다. pairs() 함수의 형식은 다음과 같습니다. S3 method for class ‘formula’ pairs(formula, data = NULL, ..., subset, na.action = stats::na.pass) Default S3 method: pairs(x, labels, panel = points, ..., horInd = 1:nc, verInd = 1:nc, lower.panel = panel, upper.panel = panel, diag.panel = NULL, text.panel = textPanel, label.pos = 0.5 + has.diag/3, line.main = 3, cex.labels = NULL, font.labels = 1, row1attop = TRUE, gap = 1, log = \"\", horOdd = !row1attop, verOdd = !row1attop) pairs() 함수를 이용하여 앞의 예를 시각화해 보겠습니다. pairs() 함수를 이용하는 경우 분석하고자 하는 변수들을 모형식(formula)으로 설정해 주어야 합니다. 우리가 시각화하고자 하는 것은 차량의 무게(Weight), 마력(Horsepower), 고속도록 연비(MPG.highway) 그리고 시내 연비(MPG.city) 등의 4 개의 변수 간의 관계이기 때문에, 이를 모형식으로 표현하면 다음과 같습니다. \\[ \\sim Weight + Horesepower + MPG.highway + MPG.city \\] library(MASS) # pairs() 함수를 이용하여 산점도 행렬을 작성합니다. pairs(~ Weight + Horsepower + MPG.highway + MPG.city, data=Cars93) pairs() 함수는 모수(parameters)를 활용하면 산점도 행렬을 다양하게 표현할 수 있습니다. 다음의 예는 대각선 아래의 행렬에 LOWESS ^[LOWESS는 데이터를 설명하는 일종의 추세선을 찾는 방법입니다. LOWESS는 데이터의 각 점을 y, 각 점의 주변에 위치한 점들을 x라고 할 때 했을 때, y를 x로부터 추정하는 다항식을 찾습니다. LOWESS가 찾는 다항식은 y = ax +b 또는 y = ax^2 + bx + c와 같은 형태의 저차 다항식low degree polynomial입니다. 다항식을 찾을 때는 추정하고자 하는 y에 가까운 x일수록 더 큰 가중치를 줍니다. 이런 이유로 LOWESS는 지역 가중 다항식 회귀3 Locally Weighted Polynomial Regression라고도 부르며, 그 결과는 각 점을 그 주변 점들로 설명하는 다항식들이 연결된 모양이 됩니다. 이렇게 각 점에서 찾아진 다항식들을 부드럽게 연결하면 데이터의 추세를 보여주는 선이 됩니다. 자세한 내용은 참고자료 [1]을 보기 바랍니다.]를 적용한 예입니다. # pairs() 함수의 모수를 설정히여 산점도 행렬을 시각화합니다. pairs(~ Weight + Horsepower + MPG.highway + MPG.city, data=Cars93, # lower.panel=panel.smooth, # lowess smooth(기본값) 곡선을 대각선 아래 행렬에 표시합니다. pch = 21, # 속이 빈 동그란 점입니다. bg = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), # 동그란 점 안의 색을 지정합니다. main=&quot;Cars93 산점도 행렬&quot;) 이를 좀 더 발전시켜서 대각선 아래에는 선형회귀선, 대각선 위에는 상관계수 값을 그리고 대각선에는 각 변수의 히스토그램 등으로 시각화해 보겠습니다. 이를 위해 선형회귀선을 구하는 panel.lm() 함수, 상관계수 값을 구하는 panel.cor() 함수 그리고 히스토그램을 그리는 panel.hist() 함수를 정의하였습니다. 이 함수들은 그대로 사용하면 됩니다. library(MASS) ## 산점도 행렬에 다양한 요소들을 추가하는 예입니다. # 선형 회귀선을 구하는 함수를 정의합니다 panel.lm &lt;- function (x, y, col = par(&quot;col&quot;), bg = NA, pch = par(&quot;pch&quot;), cex = 1, col.smooth = &quot;black&quot;, ...) { points(x, y, pch = pch, col = col, bg = bg, cex = cex) abline(stats::lm(y ~ x), col = col.smooth, ...) } # 상관계수 값을 구하는 함수를 정의합니다. panel.cor &lt;- function(x, y, digits=2, prefix=&quot;&quot;, cex.cor, ...) { usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) # on.exit() par()함수 인자가 있으면 실행 par(usr = c(0, 1, 0, 1)) r &lt;- abs(cor(x, y)) #상관계수 절대값 txt &lt;- format(c(r, 0.123456789), digits=digits)[1] # 상관계수 자릿수 지정 txt &lt;- paste(prefix, txt, sep=&quot;&quot;) if(missing(cex.cor)) cex.cor &lt;- 0.8/strwidth(txt) text(0.5, 0.5, txt, cex = cex.cor * r) #상관계수 크기에 비례하게 글자지정 } # 히스토그램 생성하는 함수를 정의합니다. panel.hist &lt;- function(x, ...) { usr &lt;- par(&quot;usr&quot;) on.exit(par(usr)) par(usr = c(usr[1:2], 0, 1.5) ) h &lt;- hist(x, plot = FALSE) breaks &lt;- h$breaks nB &lt;- length(breaks) y &lt;- h$counts y &lt;- y/max(y) rect(breaks[-nB], 0, breaks[-1], y, col=&quot;white&quot;, ...) } # 선형 회귀선과 상관계수를 표시하는 산점도 행렬을 그립니다. pairs(~ Weight + Horsepower + MPG.highway + MPG.city, data=Cars93, # lower.panel=panel.smooth, lower.panel = panel.lm, # 대각선 아래의 그림에 선형회귀선을 표시합니다. upper.panel = panel.cor, # 대각선 위에 상관계수를 표시합니다. diag.panel = panel.hist, # 대각선에 히스토그램을 표시합니다. pch=21, # 속이 빈 동그란 점으로 표시합니다. bg = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), # 동그란 점 안의 색을 지정합니다. main=&quot;Cars93 산점도 행렬&quot;) # 점의 모양과 그림 제목을 표시합니다. ? pairs() 를 이용하여 자세한 도움말을 참고하기 바랍니다. 20.3.2.3 car 패키지의 scatterplotMatrix() 함수 이용 # scatter plot matrix : scatterplotMatrix(dataframe) library(car) ## Loading required package: carData ## ## Attaching package: &#39;car&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## recode ## The following object is masked from &#39;package:purrr&#39;: ## ## some scatterplotMatrix(Cars93_subset, main = &quot;산점도 행렬 : scatterplotMatrx(dataframe)&quot;) ? car::scatterplotMatrix() 를 이용하여 자세한 도움말을 참고하기 바랍니다. 20.3.2.4 psych 패키지의 pairs.panel() 함수 이용 # psych 패키지의 pairs.panels() 함수로 산점도 행렬을 그립니다. # 패키지를 불러옵니다. # install.packages(&quot;psych&quot;) library(psych) ## ## Attaching package: &#39;psych&#39; ## The following object is masked from &#39;package:car&#39;: ## ## logit ## The following object is masked from &#39;package:Hmisc&#39;: ## ## describe ## The following objects are masked from &#39;package:ggplot2&#39;: ## ## %+%, alpha # Cars93 데이터 세트에서 4 개의 컬럼을 서브 세팅합니다. Cars93_subset &lt;- Cars93[ ,c(&quot;Weight&quot;, &quot;Horsepower&quot;, &quot;MPG.highway&quot;, &quot;MPG.city&quot;)] # 서브세팅한 데이터 세트를 pairs.panels() 함수로 시각화합니다. pairs.panels(Cars93_subset, stars = TRUE, lm =TRUE) pairs() 함수와 비교하면 많은 옵션들이 그래프에 추가된 것을 확인할 수 있습니다. ? psych::pairs.panel() 를 이용하여 자세한 도움말을 참고하기 바랍니다. GGally 패키지의 ggpairs() 산점도 행렬을 더 하려하게 그릴 수 있게 해 주는 것이 GGally 패키지의 ggpairs() 함수입니다. # 패키지를 불러옵니다. # install.packages(&quot;GGally&quot;) library(GGally) ## Registered S3 method overwritten by &#39;GGally&#39;: ## method from ## +.gg ggplot2 # Cars93 데이터 세트에서 4 개의 컬럼을 서브 세팅합니다. Cars93_subset1 &lt;- Cars93[ ,c(&quot;Weight&quot;, &quot;Horsepower&quot;, &quot;MPG.highway&quot;, &quot;MPG.city&quot;)] # 산점도 행렬을 ggpairs() 함수로 시각화 합니다. ggpairs(Cars93_subset1) ### 범주형 변수 Type의 이용 # Cars93 데이터 세트에서 4개의 컬럼과 범주형 컬럼인 Type을 서브 세팅합니다. Cars93_subset2 &lt;- Cars93[ ,c(&quot;Weight&quot;, &quot;Horsepower&quot;, &quot;MPG.highway&quot;, &quot;MPG.city&quot;, &quot;Type&quot;)] # 서브세팅한 데이터 세트를 범주형 Type 별로 색을 달리해서 # **`GGally` 패키지의 `ggpairs()` 함수로 시각화합니다. ggpairs(Cars93_subset2, # 데이터 프레임을 지정해 줍니다. aes(colour = Type, alpha = 0.4)) # Type 컬럼의 값 별로 색깔을 달리합니다. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggpairs() 함수를 사용하니 산점도 행렬이 더욱 화려해진 것을 확인할 수 있습니다. 눈에 띄는 것은 범주형 데이터 Type를 넣어서, 범주형별로 상관계수(Correlation coefficien)와 박스 플롯을 그릴 수 있다은 것입니다. ? GGally::ggpairs() 를 이용하여 자세한 도움말을 참고하기 바랍니다. 20.3.2.5 참고자료 https://m.blog.naver.com/PostView.nhn?blogId=pmw9440&amp;logNo=221531227924&amp;proxyReferer=https:%2F%2Fwww.google.com%2F https://m.blog.naver.com/PostView.nhn?blogId=edgelab&amp;logNo=150187105234&amp;proxyReferer=https:%2F%2Fwww.google.com%2F https://m.blog.naver.com/PostView.nhn?blogId=padosori60&amp;logNo=220935469036&amp;proxyReferer=https:%2F%2Fwww.google.com%2F "],["이변량-범주형-변수-그래프.html", "20.4 이변량 범주형 변수 그래프", " 20.4 이변량 범주형 변수 그래프 2개의 범주형 변수에 대한 분석은 두 변수 값에 대한 도수 분포표를 작성하는 것입니다. 이러한 도수 분포표를 분할표(Contingency table)이라고도 합니다. 이러한 분할표는 table(x, y) 함수 또는 xtabs(~formula) 함수로 구할 수 있습니다. Cars93 데이터 세트에서 범주형 변수인 자동차 유형별 (Type) 실린더 수(Cylinders) 에 대한 분할표를 작성해 보겠습니다. library(MASS) # table() 함수를 이용하여 분할표를 작성합니다. tab.T.C &lt;- with(Cars93, table(Type, Cylinders)) tab.T.C ## Cylinders ## Type 3 4 5 6 8 rotary ## Compact 0 15 0 1 0 0 ## Large 0 0 0 7 4 0 ## Midsize 0 7 1 12 2 0 ## Small 3 18 0 0 0 0 ## Sporty 0 8 0 4 1 1 ## Van 0 1 1 7 0 0 # xtabs() 함수를 이용하여 분할표를 작성합니다. xtabs( ~ Type + Cylinders, data = Cars93) ## Cylinders ## Type 3 4 5 6 8 rotary ## Compact 0 15 0 1 0 0 ## Large 0 0 0 7 4 0 ## Midsize 0 7 1 12 2 0 ## Small 3 18 0 0 0 0 ## Sporty 0 8 0 4 1 1 ## Van 0 1 1 7 0 0 이렇게 구한 분할표를 시각화하는 것이 모자이크 플롯입니다. 모자이크 플롯은 분할표에서 구한 빈도수를 사각형 모양의 그래프로 나열합니다. 이때 각 사각형의 넓이가 각 범주에 속한 데이터의 상대적 빈도 수를 나타내는 것입니다. 앞의 예를 모자이크 플롯으로 시각화 해보겠습니다. library(MASS) # mosiacplot() 함수를 이용하여 모자이크 플롯을 작성합니다. mosaicplot(~ Cylinders + Type, data = Cars93) ### vcd 패키지의 mosaic() 함수를 이용하여 모자이크 플롯을 작성합니다. # install.packages(&quot;vcd&quot;) library(vcd) ## Loading required package: grid # table() 함수를 이용하여 분할표를 작성합니다. tab.T.C &lt;- with(Cars93, table(Type, Cylinders)) # mosaic() 함수를 이용하여 모자이크 플롯을 작성합니다. mosaic(tab.T.C, gp = gpar(fill = c(&quot;red&quot;, &quot;blue&quot;)), direction = &quot;v&quot;, main = &quot;Type별 Cylinders의 분할도 : mosaicplot()&quot;) ? mosaicplot() 를 이용하거나 ? vcd::mosaic()을 이용하여 자세한 도움말을 참고하기 바랍니다. 위의 그래프들은 높은 수준의 그래프 함수에 대해서 간략하게 소개하기 위해서 모수를 거의 손대지 않고 그린 그래프들입니다. 낮은 수준의 그래프 함수와 plot() 함수의 주요 모수 (parameter)를 설정하는 방법에 대해서는 다음 장에서 소개하도록 하겠습니다. 참고자료 https://rfriend.tistory.com/147?category=605866 "],["그래프-모수-graphical-parameters.html", "Chapter 21 그래프 모수 (Graphical Parameters) ", " Chapter 21 그래프 모수 (Graphical Parameters) "],["그래프-모수-설정하는-2가지-방법.html", "21.1 그래프 모수 설정하는 2가지 방법", " 21.1 그래프 모수 설정하는 2가지 방법 출처: https://rfriend.tistory.com/148 이전 포스팅에서 Base Graphics plotting system에서 그래프의 기본 골격을 생성하는 높은 수준의 그래프 함수 (High Level Graphics Function)에 대해서 알아보았습니다. 이번 포스팅에서는 그래프의 기호, 선, 색깔, 마진, 영역 분할 등 그래프의 세부적인 옵션들을 설정하는 방법으로 ‘그래프 모수 (Graphical Parameters)’ 에 대해서 소개하겠습니다. 그래프 모수에는 약 70여가지가 있는데요, 포스팅에서 전부 다루기에는 무리가 있어서 활용 빈도가 높다고 생각하는 항목들만을 선별해서 소개하겠습니다. R의 콘솔 창에 ‘**?par**’ 라고 입력하면 graphical parameter setting 관련한 도움말을 참고할 수 있습니다. 그래프 모수를 설정하는 방법에는 2가지가 있습니다. 첫번째 방법은 par() 함수를 이용해서 이후에 생성하는 그래프 전체에 일괄적으로 동일하게 모수를 적용하는 방법입니다 (전역 환경 설정). 동일한 모수 설정치로 다수의 그래프를 그려야 하는 상황이라면 편리하게 사용할 수 있는 방법입니다. 일부 그래프 모수는 이 첫 번째 방법으로만 설정할 수 있습니다. (예: 영역분할을 위한 mfrow() 함수) 두번째 방법은 그래프를 그릴 때마다 매번 사용하는 함수 내에서 그래프 모수를 일일이 지정해 주는 방법입니다. 그래프를 한 두 개만 그리거나, 다수의 그래프를 그려야 하는데 모수 설정치가 매번 다르다면 두번째 방법을 사용하는게 편하겠습니다. 21.1.1 par() 함수 설정 par() 함수는 그래프의 모양을 다양하게 조절할 수 있는 그래프 모수들을 설정하고 조회하는 함수입니다. 모수 값 설 명 mfrow / mfcol mfrow : 그래프를 행 우선 배치합니다. 기본값은 c(1,1) 입니다. mfcol : 그래프를 열 우선 배치합니다. 기본값은 c(1,1) 입니다. 한 화면에서 여러 그래프를 비교할 때 사용합니다. figure region을 나누어 plot region을 만들고 배치 순서를 정하는 인수. fig 기본값은 c(0, 1, 0, 1) 입니다. 분할된 영역의 크기와 위치를 지정합니다. 복잡하게 분할할 경우 네 개의 인수를 일일이 계산해야 하므로 layout() 등 타 함수를 쓰는 게 좋습니다. new 기본 값은 FALSE 입니다. 이는 현재 figure region을 초기화하고 새로운 그래프를 그립니다. TRUE로 설정하면 화면 분할 없이 그래프 하나만 쓸 때, 이전 결과에 겹쳐서 새 결과를 출력합니다. 새로운 그래픽 함수 호출 시, figure region을 초기화할 것인지를 설정합니다. 두 개 이상의 그래픽 함수를 한 figure region에 나타낼 때 주로 사용합니다. type “p” - points. 점 “l” - line. 선 “b” - both points and lines. 점과 선“c” - empty points joind by lines. 점이 빠진 선“o” - overplotted p 와 l. 겹친 점과 선 “s”나“S” - stair steps. 계단 모양 “h” - histogram-like vertical lines. 수직선 좌표 영역에 데이터를 출력하는 형태를 지정합니다. mar 기본 값은 c(5,4,4,2) + 0.1 plot margin. 여백을 지정합니다. oma outer margin. 외부 여백을 지정합니다. pty “s”(square, x축과 y축 스케일(비율)이 동일하게)“m”(maximal, 최대 크기로) plot type. plot region의 모양을 지정합니다. bty “o” (기본 값)“l”“7”“c”“u”“]” 글자와 닮은 형태.. box type. plot region 둘레의 상자 모양을 지정합니다. pch 기본 값은 1 point character. 점의 모양을 지정합니다. cex 기본 값은 1 character expansion. 문자나 점의 크기를 지정합니다. lty 기본 값은 “solid”(1) line type. 선의 모양을 지정합니다. col 1~8까지 정해진 색깔이 있습니다. “#RRGGBB” 형식으로 색상을 지정할 수 있습니다. “beige,” “aquamarine” 등 이름으로 색상을 지정할 수 있습니다. color. 색상을 지정합니다. str 기본 값은 0. (단위 degree, 음수도 사용 가능.)text() 함수에서 사용가능합니다. string rotation. 문자열을 회전합니다. family “sans,”“serif,”“mono” 등 문자의 폰트 종류를 지정합니다. font “plain”=1, “bold”=2, “italic”=3, “bold italic”=4, “symbol”=5 폰트 체를 지정합니다. fg 기본 값은 “black”입니다. 그래프의 테두리 색을 지정합니다. bg 기본 값은 “transparent”(투명)입니다. 그래프 기호의 배경색을 지정합니다. tck tick marks. 좌표 눈금선의 길이를 지정합니다.plot region의 크기를 기준으로 값이 계산됩니다. tcl cex=1일 때 문자의 길이를 tcl=1로 하여 값이 계산됩니다. tick length. 좌표 눈금선의 길이를 지정합니다. 아래에 첫번째 방법으로 par() 함수를 이용해서 그래프 모수를 설정하는 예를 살펴보겠습니다. MASS 패키지에 내장되어 있는 Cars93 데이터프레임의 차 무게(Weight)와 마력(Horsepower)과 고속도로연비(MPG.highway) 간의 관계를 알아보기 위해 산점도를 그려본 예제입니다. ## par() 함수를 이용하여 그래프 함수의 모수를 지정할 수 있습니다. # help on par() function : ? par() library(MASS) # to use Cars93 dataframe # method 1 : par() # 원래의 그래프 모수 설정을 저장합니다. par_origin &lt;- par(no.readonly = TRUE) # 새로운 그래프 모수를 설정합니다. par(pch = 15, col = &quot;blue&quot;) # 산점도를 작성합니다. plot(MPG.highway ~ Weight, type = &quot;p&quot;, Cars93) plot(MPG.highway ~ Horsepower, type = &quot;p&quot;, Cars93) # 원래의 그래프 모수 설정으로 돌아갑니다. par(par_origin) plot(MPG.highway ~ Weight, Cars93) # plot() 함수의 모수들에 기본값이 적용됩니다. par() 함수를 사용해서 전역 환경에 그래프 모수를 설정할 때는 나중에 디폴트 그래프 모수로 돌아와야 하는 상황에서 편리하게 사용할 수 있도록 par(no.readonly = TRUE) 를 par_origin 이라는 개체에 할당해서 저장해 두었다가, 그래프를 다 작서한 다음 제일 마지막에 par(par_origin)로 원래의 그래프 모수로 돌아 왔습니다. 21.1.2 행/열 별로 표시할 그래프 수 지정 mfrow,mfcol모수는 그래픽 장치에 영역을 분할하여 플롯의 배치 순서를 정합니다. 한 화면에 여러 개의 그래프를 그려서 그래프들을 비교하는 경우에 유용하게 이용할 수 있다. 앞의 예를 mfrow 모수를 이용하여 1줄에 2개의 그래프를 그려 보겠습니다. library(MASS) # par() 함수에 mfrow = c(1,2) 값을 모수로 지정하여 화면을 분할합니다. (1행, 2열로 그래프 표시) par(mfrow = c(1,2)) # 원래의 그래프 모수 설정을 저장합니다. par_origin &lt;- par(no.readonly = TRUE) # 새로운 그래프 모수를 설정합니다. par(pch = 15, col = &quot;blue&quot;) # 산점도를 작성합니다. plot(MPG.highway ~ Weight, type = &quot;p&quot;, Cars93) plot(MPG.highway ~ Horsepower, type = &quot;p&quot;, Cars93) # 원래의 그래프 모수 설정으로 돌아갑니다. par(par_origin) # 분할된 화면을 원상 복구합니다. par(mfrow = c(1,1)) # 산점도를 작성합니다. plot(MPG.highway ~ Weight, type = &quot;p&quot;, Cars93) plot(MPG.highway ~ Horsepower, type = &quot;p&quot;, Cars93) 21.1.3 개별 그래프 함수마다 그래프 모수를 설정하는 방법 두번째로 개별 그래프마다 그래프 모수를 설정하는 방법을 예로 들어보겠습니다. 그래프 결과는 위에서 par()로 그래프 모수 설정했을 때와 동일함을 알 수 있습니다. 그래프를 그려야 하는 상황에 가장 편리한 방법을 선택해서 사용하면 되겠습니다. ## 그래프 모수를 그래프 함수별로 개별적으로 설정할 수 있습니다. plot(MPG.highway ~ Horsepower, type = &quot;p&quot;, # 데이터를 점(p)로 출력합니다. pch = 15, # 점의 모양입니다. col = &quot;blue&quot;, # 점의 색을 지정합니다. data = Cars93) # 데이터를 지정합니다. plot(MPG.highway ~ Weight, type = &quot;p&quot;, # 데이터를 점(p)로 출력합니다. pch = 21, # 점의 모양(21:속이 빈 동그란 점)으로 지정합니다. col = &quot;blue&quot;, # 동그란 점의 테두리를 파랑색으로 채웁니다. data = Cars93) # 데이터를 지정합니다. 21.1.4 현재 그래프 모수 확인 (checking current graphical parameter settings) : par() 참고로, par() 함수를 쓰면 현재의 그래프 모수를 확인해볼 수 있습니다. 갯수를 세어보니 총 72개 graphical parameter 가 있네요. # 현재 설정되어 있는 그래프의 모수는 par() 함수로 확인할 수 있습니다. par() ## $xlog ## [1] FALSE ## ## $ylog ## [1] FALSE ## ## $adj ## [1] 0.5 ## ## $ann ## [1] TRUE ## ## $ask ## [1] FALSE ## ## $bg ## [1] &quot;white&quot; ## ## $bty ## [1] &quot;o&quot; ## ## $cex ## [1] 1 ## ## $cex.axis ## [1] 1 ## ## $cex.lab ## [1] 1 ## ## $cex.main ## [1] 1.2 ## ## $cex.sub ## [1] 1 ## ## $cin ## [1] 0.15 0.20 ## ## $col ## [1] &quot;black&quot; ## ## $col.axis ## [1] &quot;black&quot; ## ## $col.lab ## [1] &quot;black&quot; ## ## $col.main ## [1] &quot;black&quot; ## ## $col.sub ## [1] &quot;black&quot; ## ## $cra ## [1] 28.8 38.4 ## ## $crt ## [1] 0 ## ## $csi ## [1] 0.2 ## ## $cxy ## [1] 0.02604167 0.06329115 ## ## $din ## [1] 6.999999 4.999999 ## ## $err ## [1] 0 ## ## $family ## [1] &quot;&quot; ## ## $fg ## [1] &quot;black&quot; ## ## $fig ## [1] 0 1 0 1 ## ## $fin ## [1] 6.999999 4.999999 ## ## $font ## [1] 1 ## ## $font.axis ## [1] 1 ## ## $font.lab ## [1] 1 ## ## $font.main ## [1] 2 ## ## $font.sub ## [1] 1 ## ## $lab ## [1] 5 5 7 ## ## $las ## [1] 0 ## ## $lend ## [1] &quot;round&quot; ## ## $lheight ## [1] 1 ## ## $ljoin ## [1] &quot;round&quot; ## ## $lmitre ## [1] 10 ## ## $lty ## [1] &quot;solid&quot; ## ## $lwd ## [1] 1 ## ## $mai ## [1] 1.02 0.82 0.82 0.42 ## ## $mar ## [1] 5.1 4.1 4.1 2.1 ## ## $mex ## [1] 1 ## ## $mfcol ## [1] 1 1 ## ## $mfg ## [1] 1 1 1 1 ## ## $mfrow ## [1] 1 1 ## ## $mgp ## [1] 3 1 0 ## ## $mkh ## [1] 0.001 ## ## $new ## [1] FALSE ## ## $oma ## [1] 0 0 0 0 ## ## $omd ## [1] 0 1 0 1 ## ## $omi ## [1] 0 0 0 0 ## ## $page ## [1] TRUE ## ## $pch ## [1] 1 ## ## $pin ## [1] 5.759999 3.159999 ## ## $plt ## [1] 0.1171429 0.9400000 0.2040000 0.8360000 ## ## $ps ## [1] 12 ## ## $pty ## [1] &quot;m&quot; ## ## $smo ## [1] 1 ## ## $srt ## [1] 0 ## ## $tck ## [1] NA ## ## $tcl ## [1] -0.5 ## ## $usr ## [1] 0 1 0 1 ## ## $xaxp ## [1] 0 1 5 ## ## $xaxs ## [1] &quot;r&quot; ## ## $xaxt ## [1] &quot;s&quot; ## ## $xpd ## [1] FALSE ## ## $yaxp ## [1] 0 1 5 ## ## $yaxs ## [1] &quot;r&quot; ## ## $yaxt ## [1] &quot;s&quot; ## ## $ylbias ## [1] 0.2 "],["그래프-유형-type-기호-모양-pch-크기-cex-선-유형-lty-선-두께-lwd.html", "21.2 그래프 유형 type, 기호 모양 pch, 크기 cex, 선 유형 lty, 선 두께 lwd", " 21.2 그래프 유형 type, 기호 모양 pch, 크기 cex, 선 유형 lty, 선 두께 lwd 출처: https://rfriend.tistory.com/149?category=605866 지난번 포스팅에서 R 그래프 모수 (Graphical Parameters)를 설정하는 2가지 방법(par(), arguments)에 대해서 소개하였습니다. 이번 절에서는 그래프 모수의 유형(type), 기호(pch), 선(lty, lwd) 등의 모수 설정에 대해서 하나씩 예를 들어보면서 자세히 살펴 보겠습니다. 그래프 모수가 70여 가지가 되기 때문에, 자주 사용하는 것들을 위주로 살펴 보겠습니다. 자세한 것은 ? par 의 도움말을 보면 모든 그래프 모수에 대한 도움말을 검색할 수 있습니다. 21.2.1 그래프 유형 (type) 그래프의 유형으로 type = 의 값은 l, h, b, o, s, n등을 가질 수 있습니다. library(MASS) ##-------- # 다양한 그래프 유형을 선택할 수 있습니다. type = l, h, b, o, s, n # 자동차의 무게 Weight 별로 정렬합니다. Cars93_1 &lt;- Cars93[order(Cars93$Weight),] # 그래프를 표시할 윈도우 프레임을 분할합니다. par(mfrow = c(3, 2)) # 3행 2열로 그래프를 그립니다. # type 별로 그래프를 작성합니다. attach(Cars93_1) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders # type = &quot;l&quot; : line plot plot(MPG.highway ~ Weight, type = &quot;l&quot;, main = &quot;type = l&quot;) # type = &quot;h&quot; : high density needle plot plot(MPG.highway ~ Weight, type = &quot;h&quot;, main = &quot;type = h&quot;) # type = &quot;b&quot; : both dot and line plot plot(MPG.highway ~ Weight, type = &quot;b&quot;, main = &quot;type = b&quot;) # type = &quot;o&quot; : overlapped dot and line plot plot(MPG.highway ~ Weight, type = &quot;o&quot;, main = &quot;type = o&quot;) # type = &quot;s&quot; : step plot plot(MPG.highway ~ Weight, type = &quot;s&quot;, main = &quot;type = s&quot;) # type = &quot;n&quot; : empty plot plot(MPG.highway ~ Weight, type = &quot;n&quot;, main = &quot;type = n&quot;) detach(Cars93_1) 21.2.2 기호 (plotting symbols, characters) : pch = 21.2.2.1 기호를 번호로 지정하기 그래픽 모수 pch = 를 사용해서 다양한 모양의 기호, 상징으로 데이터의 각 점을 표시할 수 있습니다. 기본 값은 pch = 1 로서 속이 빈 원 모양이며, 아래의 pch 그래픽 모수의 숫자별 모양을 참고해서 원하는 모양의 숫자를 pch = '숫자' 로 입력하면 됩니다. Cars93 데이터 프레임의 차 무게(Weight)와 마력(Horsepower)과 고속도로연비(MPG.highway) 간의 관계를 알아보기 위해 산점도를 pch=1 ~ pch=6 까지 6개만 예로 다음과 같이 그려 보았습니다. library(MASS) ## symbol and character of plotting : pch= # 그래프를 표시할 윈도우 프레임을 분할합니다. par(mfrow = c(3,2)) # pch = 2, 4, 6, 8, 10, 12 plot(MPG.highway ~ Weight, data = Cars93, pch = 2, main = &quot;pch = 2&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 4, main = &quot;pch = 4&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 6, main = &quot;pch = 6&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 8, main = &quot;pch = 8&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 10, main = &quot;pch = 10&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 12, main = &quot;pch = 12&quot;) par(mfrow = c(1,1)) 21.2.2.2 기호를 직접 입력하기 pch = 1 처럼 숫자를 입력하는 방법 말고도 pch = '$', pch = '%', pch = '*'처럼 기호를 직접 pch 다음에 직접 입력해도 됩니다. library(MASS) ## 기호를 직접 입력하기 par(mfrow = c(1,3)) plot(MPG.highway ~ Weight, data = Cars93, pch = &#39;$&#39;, main = &quot;pch = &#39;$&#39; &quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = &#39;%&#39;, main = &quot;pch = &#39;%&#39; &quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = &#39;*&#39;, main = &quot;pch = &#39;*&#39; &quot;) par(mfrow = c(1,1)) 21.2.3 기호의 크기 : cex cex는 기호의 크기를 지정할 때 사용합니다. cex = 1 이 기본 값 크기이며, cex 다음에 입력하는 숫자는 디폴트 대비 상대적인 크기를 나타냅니다. 1 값을 기준으로 1보다 크면 글자가 커지고, 1보다 작으면 글자가 작아 집니다. library(MASS) ## 기호의 크기 : cex par(mfrow = c(2, 3)) # plot display by 2 row and 3 column plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 0.5, main = &quot;cex = 0.5&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 0.8, main = &quot;cex = 0.8&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 1, main = &quot;cex = 1 (default)&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 1.2, main = &quot;cex = 1.2&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 1.5, main = &quot;cex = 1.5&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 2, main = &quot;cex = 2&quot;) par(mfrow = c(1,1)) 21.2.4 선 스타일 지정하기 21.2.4.1 선의 유형 (line types) : lty 선의 유형을 쓰기 위해서는 type =이 l , b 또는 o로 지정이 되어 있어야 합니다. R 그래프 모수에서 제공하는 선 유형 인 lty =에는 아래과 같이 숫자로 1~6까지의 6 가지가 있습니다. library(MASS) ## 선의 유형 : lty # 자동차의 무게 Weight 별로 Cars93을 정렬합니다. Cars93_order &lt;- Cars93[order(Cars93$Weight), ] par(mfrow = c(2, 3)) # plot layout by 2 row and 3 column plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lty = 1, main = &quot;lty = 1&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;b&quot;, lty = 2, main = &quot;lty = 2&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;o&quot;, lty = 3, main = &quot;lty = 3&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lty = 4, main = &quot;lty = 4&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;b&quot;, lty = 5, main = &quot;lty = 5&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;o&quot;, lty = 6, main = &quot;lty = 6&quot;) par(mfrow = c(1,1)) 21.2.4.2 선 두께 (line width) : lwd 선의 유형을 쓰기 위해서는 type =이 l , b 또는 o로 지정이 되어 있어야 합니다. 선 두께를 조절하는 그래프 모수는 lwd 입니다. lwd = 1 이 기본 값이며, 이 기본 값을 기준으로 숫자 만큼 선의 두께가 정해집니다. 아래에 lwd = 0.5, 1, 2, 3 별로 선 두께가 어떻게 변화하는지 예를 보겠습니다. library(MASS) ## 선 두께 : lwd # 자동차의 무게 Weight 별로 Cars93을 정렬합니다. Cars93_order &lt;- Cars93[order(Cars93$Weight), ] # 화면을 2행 2열로 분할합니다. par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lwd = 0.5, main = &quot;lwd = 0.5&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;b&quot;, lwd = 1, main = &quot;lwd = 1 (default)&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;o&quot;, lwd = 2, main = &quot;lwd = 2&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lwd = 3, main = &quot;lwd = 3&quot;) par(mfrow = c(1,1)) "],["색깔-colors-col-col-axis-col-lab-col-main-col-sub-fg-bg.html", "21.3 색깔 (colors) : col, col.axis, col.lab, col.main, col.sub, fg, bg", " 21.3 색깔 (colors) : col, col.axis, col.lab, col.main, col.sub, fg, bg 이번 절에서는 그래프 모수 중에서 색깔(col)을 설정하는 방법에 대해서 알아보겠습니다. [ 색 관련 모수 별 기능 설명 ] 색 관련 모수(parameters of color) 설명 col 기호, 선, 문자 등의 색깔을 디폴트로 지정 (default plotting color) col.axis 축의 색 지정 (color for axis annotation) col.lab x축과 y축의 레이블 색 지정 (color for x and y labels) col.main 제목 색 지정 (color for main title) col.sub 부제목의 색 지정 (color for sub titles) fg 그래프 테두리 색 지정 (color for foreground) bg 그래프 기호의 배경 색 지정 (color for background) 아마도 대부분은 col 모수를 주로 사용하고 나머지 색상 관련 모수는 거의 사용하지 않을 듯 합니다만, R에서는 사용자가 원하면 거의 모든 부분의 색상을 원하는대로 설정할 수 있는 극강의 자유도를 제공합니다. 21.3.1 기호, 선, 문자 등의 디폴트 색 지정 (default plotting color) : col R에서 지원하는 색의 종류에는 657개가 있습니다. colors() 함수를 사용하면 657개 전체 색 리스트를 볼 수 가 있습니다. ##------------------------------- ## Graphical parameters : color ##------------------------------- length(colors()) ## [1] 657 colors() ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; ## [4] &quot;antiquewhite1&quot; &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; ## [7] &quot;antiquewhite4&quot; &quot;aquamarine&quot; &quot;aquamarine1&quot; ## [10] &quot;aquamarine2&quot; &quot;aquamarine3&quot; &quot;aquamarine4&quot; ## [13] &quot;azure&quot; &quot;azure1&quot; &quot;azure2&quot; ## [16] &quot;azure3&quot; &quot;azure4&quot; &quot;beige&quot; ## [19] &quot;bisque&quot; &quot;bisque1&quot; &quot;bisque2&quot; ## [22] &quot;bisque3&quot; &quot;bisque4&quot; &quot;black&quot; ## [25] &quot;blanchedalmond&quot; &quot;blue&quot; &quot;blue1&quot; ## [28] &quot;blue2&quot; &quot;blue3&quot; &quot;blue4&quot; ## [31] &quot;blueviolet&quot; &quot;brown&quot; &quot;brown1&quot; ## [34] &quot;brown2&quot; &quot;brown3&quot; &quot;brown4&quot; ## [37] &quot;burlywood&quot; &quot;burlywood1&quot; &quot;burlywood2&quot; ## [40] &quot;burlywood3&quot; &quot;burlywood4&quot; &quot;cadetblue&quot; ## [43] &quot;cadetblue1&quot; &quot;cadetblue2&quot; &quot;cadetblue3&quot; ## [46] &quot;cadetblue4&quot; &quot;chartreuse&quot; &quot;chartreuse1&quot; ## [49] &quot;chartreuse2&quot; &quot;chartreuse3&quot; &quot;chartreuse4&quot; ## [52] &quot;chocolate&quot; &quot;chocolate1&quot; &quot;chocolate2&quot; ## [55] &quot;chocolate3&quot; &quot;chocolate4&quot; &quot;coral&quot; ## [58] &quot;coral1&quot; &quot;coral2&quot; &quot;coral3&quot; ## [61] &quot;coral4&quot; &quot;cornflowerblue&quot; &quot;cornsilk&quot; ## [64] &quot;cornsilk1&quot; &quot;cornsilk2&quot; &quot;cornsilk3&quot; ## [67] &quot;cornsilk4&quot; &quot;cyan&quot; &quot;cyan1&quot; ## [70] &quot;cyan2&quot; &quot;cyan3&quot; &quot;cyan4&quot; ## [73] &quot;darkblue&quot; &quot;darkcyan&quot; &quot;darkgoldenrod&quot; ## [76] &quot;darkgoldenrod1&quot; &quot;darkgoldenrod2&quot; &quot;darkgoldenrod3&quot; ## [79] &quot;darkgoldenrod4&quot; &quot;darkgray&quot; &quot;darkgreen&quot; ## [82] &quot;darkgrey&quot; &quot;darkkhaki&quot; &quot;darkmagenta&quot; ## [85] &quot;darkolivegreen&quot; &quot;darkolivegreen1&quot; &quot;darkolivegreen2&quot; ## [88] &quot;darkolivegreen3&quot; &quot;darkolivegreen4&quot; &quot;darkorange&quot; ## [91] &quot;darkorange1&quot; &quot;darkorange2&quot; &quot;darkorange3&quot; ## [94] &quot;darkorange4&quot; &quot;darkorchid&quot; &quot;darkorchid1&quot; ## [97] &quot;darkorchid2&quot; &quot;darkorchid3&quot; &quot;darkorchid4&quot; ## [100] &quot;darkred&quot; &quot;darksalmon&quot; &quot;darkseagreen&quot; ## [103] &quot;darkseagreen1&quot; &quot;darkseagreen2&quot; &quot;darkseagreen3&quot; ## [106] &quot;darkseagreen4&quot; &quot;darkslateblue&quot; &quot;darkslategray&quot; ## [109] &quot;darkslategray1&quot; &quot;darkslategray2&quot; &quot;darkslategray3&quot; ## [112] &quot;darkslategray4&quot; &quot;darkslategrey&quot; &quot;darkturquoise&quot; ## [115] &quot;darkviolet&quot; &quot;deeppink&quot; &quot;deeppink1&quot; ## [118] &quot;deeppink2&quot; &quot;deeppink3&quot; &quot;deeppink4&quot; ## [121] &quot;deepskyblue&quot; &quot;deepskyblue1&quot; &quot;deepskyblue2&quot; ## [124] &quot;deepskyblue3&quot; &quot;deepskyblue4&quot; &quot;dimgray&quot; ## [127] &quot;dimgrey&quot; &quot;dodgerblue&quot; &quot;dodgerblue1&quot; ## [130] &quot;dodgerblue2&quot; &quot;dodgerblue3&quot; &quot;dodgerblue4&quot; ## [133] &quot;firebrick&quot; &quot;firebrick1&quot; &quot;firebrick2&quot; ## [136] &quot;firebrick3&quot; &quot;firebrick4&quot; &quot;floralwhite&quot; ## [139] &quot;forestgreen&quot; &quot;gainsboro&quot; &quot;ghostwhite&quot; ## [142] &quot;gold&quot; &quot;gold1&quot; &quot;gold2&quot; ## [145] &quot;gold3&quot; &quot;gold4&quot; &quot;goldenrod&quot; ## [148] &quot;goldenrod1&quot; &quot;goldenrod2&quot; &quot;goldenrod3&quot; ## [151] &quot;goldenrod4&quot; &quot;gray&quot; &quot;gray0&quot; ## [154] &quot;gray1&quot; &quot;gray2&quot; &quot;gray3&quot; ## [157] &quot;gray4&quot; &quot;gray5&quot; &quot;gray6&quot; ## [160] &quot;gray7&quot; &quot;gray8&quot; &quot;gray9&quot; ## [163] &quot;gray10&quot; &quot;gray11&quot; &quot;gray12&quot; ## [166] &quot;gray13&quot; &quot;gray14&quot; &quot;gray15&quot; ## [169] &quot;gray16&quot; &quot;gray17&quot; &quot;gray18&quot; ## [172] &quot;gray19&quot; &quot;gray20&quot; &quot;gray21&quot; ## [175] &quot;gray22&quot; &quot;gray23&quot; &quot;gray24&quot; ## [178] &quot;gray25&quot; &quot;gray26&quot; &quot;gray27&quot; ## [181] &quot;gray28&quot; &quot;gray29&quot; &quot;gray30&quot; ## [184] &quot;gray31&quot; &quot;gray32&quot; &quot;gray33&quot; ## [187] &quot;gray34&quot; &quot;gray35&quot; &quot;gray36&quot; ## [190] &quot;gray37&quot; &quot;gray38&quot; &quot;gray39&quot; ## [193] &quot;gray40&quot; &quot;gray41&quot; &quot;gray42&quot; ## [196] &quot;gray43&quot; &quot;gray44&quot; &quot;gray45&quot; ## [199] &quot;gray46&quot; &quot;gray47&quot; &quot;gray48&quot; ## [202] &quot;gray49&quot; &quot;gray50&quot; &quot;gray51&quot; ## [205] &quot;gray52&quot; &quot;gray53&quot; &quot;gray54&quot; ## [208] &quot;gray55&quot; &quot;gray56&quot; &quot;gray57&quot; ## [211] &quot;gray58&quot; &quot;gray59&quot; &quot;gray60&quot; ## [214] &quot;gray61&quot; &quot;gray62&quot; &quot;gray63&quot; ## [217] &quot;gray64&quot; &quot;gray65&quot; &quot;gray66&quot; ## [220] &quot;gray67&quot; &quot;gray68&quot; &quot;gray69&quot; ## [223] &quot;gray70&quot; &quot;gray71&quot; &quot;gray72&quot; ## [226] &quot;gray73&quot; &quot;gray74&quot; &quot;gray75&quot; ## [229] &quot;gray76&quot; &quot;gray77&quot; &quot;gray78&quot; ## [232] &quot;gray79&quot; &quot;gray80&quot; &quot;gray81&quot; ## [235] &quot;gray82&quot; &quot;gray83&quot; &quot;gray84&quot; ## [238] &quot;gray85&quot; &quot;gray86&quot; &quot;gray87&quot; ## [241] &quot;gray88&quot; &quot;gray89&quot; &quot;gray90&quot; ## [244] &quot;gray91&quot; &quot;gray92&quot; &quot;gray93&quot; ## [247] &quot;gray94&quot; &quot;gray95&quot; &quot;gray96&quot; ## [250] &quot;gray97&quot; &quot;gray98&quot; &quot;gray99&quot; ## [253] &quot;gray100&quot; &quot;green&quot; &quot;green1&quot; ## [256] &quot;green2&quot; &quot;green3&quot; &quot;green4&quot; ## [259] &quot;greenyellow&quot; &quot;grey&quot; &quot;grey0&quot; ## [262] &quot;grey1&quot; &quot;grey2&quot; &quot;grey3&quot; ## [265] &quot;grey4&quot; &quot;grey5&quot; &quot;grey6&quot; ## [268] &quot;grey7&quot; &quot;grey8&quot; &quot;grey9&quot; ## [271] &quot;grey10&quot; &quot;grey11&quot; &quot;grey12&quot; ## [274] &quot;grey13&quot; &quot;grey14&quot; &quot;grey15&quot; ## [277] &quot;grey16&quot; &quot;grey17&quot; &quot;grey18&quot; ## [280] &quot;grey19&quot; &quot;grey20&quot; &quot;grey21&quot; ## [283] &quot;grey22&quot; &quot;grey23&quot; &quot;grey24&quot; ## [286] &quot;grey25&quot; &quot;grey26&quot; &quot;grey27&quot; ## [289] &quot;grey28&quot; &quot;grey29&quot; &quot;grey30&quot; ## [292] &quot;grey31&quot; &quot;grey32&quot; &quot;grey33&quot; ## [295] &quot;grey34&quot; &quot;grey35&quot; &quot;grey36&quot; ## [298] &quot;grey37&quot; &quot;grey38&quot; &quot;grey39&quot; ## [301] &quot;grey40&quot; &quot;grey41&quot; &quot;grey42&quot; ## [304] &quot;grey43&quot; &quot;grey44&quot; &quot;grey45&quot; ## [307] &quot;grey46&quot; &quot;grey47&quot; &quot;grey48&quot; ## [310] &quot;grey49&quot; &quot;grey50&quot; &quot;grey51&quot; ## [313] &quot;grey52&quot; &quot;grey53&quot; &quot;grey54&quot; ## [316] &quot;grey55&quot; &quot;grey56&quot; &quot;grey57&quot; ## [319] &quot;grey58&quot; &quot;grey59&quot; &quot;grey60&quot; ## [322] &quot;grey61&quot; &quot;grey62&quot; &quot;grey63&quot; ## [325] &quot;grey64&quot; &quot;grey65&quot; &quot;grey66&quot; ## [328] &quot;grey67&quot; &quot;grey68&quot; &quot;grey69&quot; ## [331] &quot;grey70&quot; &quot;grey71&quot; &quot;grey72&quot; ## [334] &quot;grey73&quot; &quot;grey74&quot; &quot;grey75&quot; ## [337] &quot;grey76&quot; &quot;grey77&quot; &quot;grey78&quot; ## [340] &quot;grey79&quot; &quot;grey80&quot; &quot;grey81&quot; ## [343] &quot;grey82&quot; &quot;grey83&quot; &quot;grey84&quot; ## [346] &quot;grey85&quot; &quot;grey86&quot; &quot;grey87&quot; ## [349] &quot;grey88&quot; &quot;grey89&quot; &quot;grey90&quot; ## [352] &quot;grey91&quot; &quot;grey92&quot; &quot;grey93&quot; ## [355] &quot;grey94&quot; &quot;grey95&quot; &quot;grey96&quot; ## [358] &quot;grey97&quot; &quot;grey98&quot; &quot;grey99&quot; ## [361] &quot;grey100&quot; &quot;honeydew&quot; &quot;honeydew1&quot; ## [364] &quot;honeydew2&quot; &quot;honeydew3&quot; &quot;honeydew4&quot; ## [367] &quot;hotpink&quot; &quot;hotpink1&quot; &quot;hotpink2&quot; ## [370] &quot;hotpink3&quot; &quot;hotpink4&quot; &quot;indianred&quot; ## [373] &quot;indianred1&quot; &quot;indianred2&quot; &quot;indianred3&quot; ## [376] &quot;indianred4&quot; &quot;ivory&quot; &quot;ivory1&quot; ## [379] &quot;ivory2&quot; &quot;ivory3&quot; &quot;ivory4&quot; ## [382] &quot;khaki&quot; &quot;khaki1&quot; &quot;khaki2&quot; ## [385] &quot;khaki3&quot; &quot;khaki4&quot; &quot;lavender&quot; ## [388] &quot;lavenderblush&quot; &quot;lavenderblush1&quot; &quot;lavenderblush2&quot; ## [391] &quot;lavenderblush3&quot; &quot;lavenderblush4&quot; &quot;lawngreen&quot; ## [394] &quot;lemonchiffon&quot; &quot;lemonchiffon1&quot; &quot;lemonchiffon2&quot; ## [397] &quot;lemonchiffon3&quot; &quot;lemonchiffon4&quot; &quot;lightblue&quot; ## [400] &quot;lightblue1&quot; &quot;lightblue2&quot; &quot;lightblue3&quot; ## [403] &quot;lightblue4&quot; &quot;lightcoral&quot; &quot;lightcyan&quot; ## [406] &quot;lightcyan1&quot; &quot;lightcyan2&quot; &quot;lightcyan3&quot; ## [409] &quot;lightcyan4&quot; &quot;lightgoldenrod&quot; &quot;lightgoldenrod1&quot; ## [412] &quot;lightgoldenrod2&quot; &quot;lightgoldenrod3&quot; &quot;lightgoldenrod4&quot; ## [415] &quot;lightgoldenrodyellow&quot; &quot;lightgray&quot; &quot;lightgreen&quot; ## [418] &quot;lightgrey&quot; &quot;lightpink&quot; &quot;lightpink1&quot; ## [421] &quot;lightpink2&quot; &quot;lightpink3&quot; &quot;lightpink4&quot; ## [424] &quot;lightsalmon&quot; &quot;lightsalmon1&quot; &quot;lightsalmon2&quot; ## [427] &quot;lightsalmon3&quot; &quot;lightsalmon4&quot; &quot;lightseagreen&quot; ## [430] &quot;lightskyblue&quot; &quot;lightskyblue1&quot; &quot;lightskyblue2&quot; ## [433] &quot;lightskyblue3&quot; &quot;lightskyblue4&quot; &quot;lightslateblue&quot; ## [436] &quot;lightslategray&quot; &quot;lightslategrey&quot; &quot;lightsteelblue&quot; ## [439] &quot;lightsteelblue1&quot; &quot;lightsteelblue2&quot; &quot;lightsteelblue3&quot; ## [442] &quot;lightsteelblue4&quot; &quot;lightyellow&quot; &quot;lightyellow1&quot; ## [445] &quot;lightyellow2&quot; &quot;lightyellow3&quot; &quot;lightyellow4&quot; ## [448] &quot;limegreen&quot; &quot;linen&quot; &quot;magenta&quot; ## [451] &quot;magenta1&quot; &quot;magenta2&quot; &quot;magenta3&quot; ## [454] &quot;magenta4&quot; &quot;maroon&quot; &quot;maroon1&quot; ## [457] &quot;maroon2&quot; &quot;maroon3&quot; &quot;maroon4&quot; ## [460] &quot;mediumaquamarine&quot; &quot;mediumblue&quot; &quot;mediumorchid&quot; ## [463] &quot;mediumorchid1&quot; &quot;mediumorchid2&quot; &quot;mediumorchid3&quot; ## [466] &quot;mediumorchid4&quot; &quot;mediumpurple&quot; &quot;mediumpurple1&quot; ## [469] &quot;mediumpurple2&quot; &quot;mediumpurple3&quot; &quot;mediumpurple4&quot; ## [472] &quot;mediumseagreen&quot; &quot;mediumslateblue&quot; &quot;mediumspringgreen&quot; ## [475] &quot;mediumturquoise&quot; &quot;mediumvioletred&quot; &quot;midnightblue&quot; ## [478] &quot;mintcream&quot; &quot;mistyrose&quot; &quot;mistyrose1&quot; ## [481] &quot;mistyrose2&quot; &quot;mistyrose3&quot; &quot;mistyrose4&quot; ## [484] &quot;moccasin&quot; &quot;navajowhite&quot; &quot;navajowhite1&quot; ## [487] &quot;navajowhite2&quot; &quot;navajowhite3&quot; &quot;navajowhite4&quot; ## [490] &quot;navy&quot; &quot;navyblue&quot; &quot;oldlace&quot; ## [493] &quot;olivedrab&quot; &quot;olivedrab1&quot; &quot;olivedrab2&quot; ## [496] &quot;olivedrab3&quot; &quot;olivedrab4&quot; &quot;orange&quot; ## [499] &quot;orange1&quot; &quot;orange2&quot; &quot;orange3&quot; ## [502] &quot;orange4&quot; &quot;orangered&quot; &quot;orangered1&quot; ## [505] &quot;orangered2&quot; &quot;orangered3&quot; &quot;orangered4&quot; ## [508] &quot;orchid&quot; &quot;orchid1&quot; &quot;orchid2&quot; ## [511] &quot;orchid3&quot; &quot;orchid4&quot; &quot;palegoldenrod&quot; ## [514] &quot;palegreen&quot; &quot;palegreen1&quot; &quot;palegreen2&quot; ## [517] &quot;palegreen3&quot; &quot;palegreen4&quot; &quot;paleturquoise&quot; ## [520] &quot;paleturquoise1&quot; &quot;paleturquoise2&quot; &quot;paleturquoise3&quot; ## [523] &quot;paleturquoise4&quot; &quot;palevioletred&quot; &quot;palevioletred1&quot; ## [526] &quot;palevioletred2&quot; &quot;palevioletred3&quot; &quot;palevioletred4&quot; ## [529] &quot;papayawhip&quot; &quot;peachpuff&quot; &quot;peachpuff1&quot; ## [532] &quot;peachpuff2&quot; &quot;peachpuff3&quot; &quot;peachpuff4&quot; ## [535] &quot;peru&quot; &quot;pink&quot; &quot;pink1&quot; ## [538] &quot;pink2&quot; &quot;pink3&quot; &quot;pink4&quot; ## [541] &quot;plum&quot; &quot;plum1&quot; &quot;plum2&quot; ## [544] &quot;plum3&quot; &quot;plum4&quot; &quot;powderblue&quot; ## [547] &quot;purple&quot; &quot;purple1&quot; &quot;purple2&quot; ## [550] &quot;purple3&quot; &quot;purple4&quot; &quot;red&quot; ## [553] &quot;red1&quot; &quot;red2&quot; &quot;red3&quot; ## [556] &quot;red4&quot; &quot;rosybrown&quot; &quot;rosybrown1&quot; ## [559] &quot;rosybrown2&quot; &quot;rosybrown3&quot; &quot;rosybrown4&quot; ## [562] &quot;royalblue&quot; &quot;royalblue1&quot; &quot;royalblue2&quot; ## [565] &quot;royalblue3&quot; &quot;royalblue4&quot; &quot;saddlebrown&quot; ## [568] &quot;salmon&quot; &quot;salmon1&quot; &quot;salmon2&quot; ## [571] &quot;salmon3&quot; &quot;salmon4&quot; &quot;sandybrown&quot; ## [574] &quot;seagreen&quot; &quot;seagreen1&quot; &quot;seagreen2&quot; ## [577] &quot;seagreen3&quot; &quot;seagreen4&quot; &quot;seashell&quot; ## [580] &quot;seashell1&quot; &quot;seashell2&quot; &quot;seashell3&quot; ## [583] &quot;seashell4&quot; &quot;sienna&quot; &quot;sienna1&quot; ## [586] &quot;sienna2&quot; &quot;sienna3&quot; &quot;sienna4&quot; ## [589] &quot;skyblue&quot; &quot;skyblue1&quot; &quot;skyblue2&quot; ## [592] &quot;skyblue3&quot; &quot;skyblue4&quot; &quot;slateblue&quot; ## [595] &quot;slateblue1&quot; &quot;slateblue2&quot; &quot;slateblue3&quot; ## [598] &quot;slateblue4&quot; &quot;slategray&quot; &quot;slategray1&quot; ## [601] &quot;slategray2&quot; &quot;slategray3&quot; &quot;slategray4&quot; ## [604] &quot;slategrey&quot; &quot;snow&quot; &quot;snow1&quot; ## [607] &quot;snow2&quot; &quot;snow3&quot; &quot;snow4&quot; ## [610] &quot;springgreen&quot; &quot;springgreen1&quot; &quot;springgreen2&quot; ## [613] &quot;springgreen3&quot; &quot;springgreen4&quot; &quot;steelblue&quot; ## [616] &quot;steelblue1&quot; &quot;steelblue2&quot; &quot;steelblue3&quot; ## [619] &quot;steelblue4&quot; &quot;tan&quot; &quot;tan1&quot; ## [622] &quot;tan2&quot; &quot;tan3&quot; &quot;tan4&quot; ## [625] &quot;thistle&quot; &quot;thistle1&quot; &quot;thistle2&quot; ## [628] &quot;thistle3&quot; &quot;thistle4&quot; &quot;tomato&quot; ## [631] &quot;tomato1&quot; &quot;tomato2&quot; &quot;tomato3&quot; ## [634] &quot;tomato4&quot; &quot;turquoise&quot; &quot;turquoise1&quot; ## [637] &quot;turquoise2&quot; &quot;turquoise3&quot; &quot;turquoise4&quot; ## [640] &quot;violet&quot; &quot;violetred&quot; &quot;violetred1&quot; ## [643] &quot;violetred2&quot; &quot;violetred3&quot; &quot;violetred4&quot; ## [646] &quot;wheat&quot; &quot;wheat1&quot; &quot;wheat2&quot; ## [649] &quot;wheat3&quot; &quot;wheat4&quot; &quot;whitesmoke&quot; ## [652] &quot;yellow&quot; &quot;yellow1&quot; &quot;yellow2&quot; ## [655] &quot;yellow3&quot; &quot;yellow4&quot; &quot;yellowgreen&quot; 위처럼 text로 색깔 이름만 있으면 알기 어려울 수도 있는데요, Earl F. Glynn 가 657개 색을 각 숫자별로 그리드에 보기 좋게 정리를 해놓았습니다. [ Color Chart by Earl F. Glynn, Stowers Institute for Medical Research, 24 May 2005 ] * 출처 : http://research.stowers-institute.org/efg/R/Color/Chart/index.htm R에서 색을 지정하는 방법에는 (1) 숫자(index) 지정방법, (2) 색 이름 (color name) 지정 방법, (3) 16진수 (hexadecimal) 지정 방법, 그리고 (4) RGB 색상표 지정 방법 등의 4가지 방법이 있습니다. 숫자 (index) 색 이름 (color name) 16진수 (hexadecimal) RGB triple 4 (26번) blue #0000FF 0 0 255 NA (62번) comflowerblue #6495ED 100 149 237 NA (73번) darkblue #00008B 0 0 139 21.3.1.1 숫자(index)로 지정하는 방법 먼저 숫자(index)로 지정하는 방법은 편하긴 합니다. 그러나, 선택할 수 있는 색은 아래와 같이 8가지로 매우 제한적입니다. index 0 1 2 3 4 5 6 7 8 color 흰색(white) 검정색(black) 빨강색(red) 초록색(green) 파랑색(blue) 청록색 (turquoise) 자홍색(magenta) 노란색(yellow) 회색(gray) 8조각의 파이 차트를 예로 살펴 보겠습니다. # color by index 1~8 par(mfrow=c(1,2)) pie(rep(1, 8), col = 1:8) pie(rep(1, 16), col = 1:16) par(mfrow=c(1,1)) 21.3.1.2 기타 방법 반면, (2) 이름(color name), (3) 16진법 표기 (hexadecimal), (4) RGB 색상표 (RGB triple) 은 매우 다양한 색상을 선택할 수 있는 장점이 있습니다. 아래는 Earl F. Glynn가 작성한 색상표에서 일부를 화면캡쳐한 내용인데요, 모든 색상표는 아래의 출처에 있는 pdf url에 있습니다. img * 출처 : http://research.stowers-institute.org/efg/R/Color/Chart/ColorChart.pdf 파란색(blue)에 대해서 위의 4가지 방법, 즉 (1) 숫자 (index), (2) 색 이름 (color name), (3) 16진수 (hexadecimal), (4) RGB 색상표를 사용해서 R 함수 예를 들어보겠습니다. 파란색(blue)으로 모두 똑같은 결과가 나았습니다. library(MASS) ## 파란색(blue)을 선택하는 4가지 방법 par(mfrow = c(2,2)) # 방법 1 : index plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 19, col = 4, main = &quot;col = 4 (index)&quot;) # 방법 2 : color name plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 19, col = &quot;blue&quot;, main = &quot;col = blue (name)&quot;) # 방법 3 : hexadecimal plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 19, col = &quot;#0000FF&quot;, main = &quot;col = #0000FF (hexadecimal)&quot;) # 방법 4 : RGB triple rgb_1 &lt;- rgb(0, 0, 255, maxColorValue=255) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 19, col = rgb_1, main = &quot;col = RGB(0, 0, 255)(RGB triple)&quot;) par(mfrow = c(1, 1)) R에서는 색상 관련해서 서로 보완(complementing)되거나 대조를 이루는(contrasting) 색상들을 미리 팔레트 형식으로 정의(defined palettes of colors)해 놓은 것이 있습니다. 예를 들면, rainbow(n), heat.colors(n), terrain.colors(n), topo.colors(n), cm.colors(n) 등이 있습니다. example(rainbow) 함수를 이용해서 이들 색상표 palettes 를 살펴보겠습니다. 계속 Enter 치면 다음 화면으로 넘어갑니다. example(rainbow) colorspace 패키지는 팔레트의 선택을 위한 GUI를 제공하고 있습니다. choose_palette() 함수를 호출하면 다음과 같은 윈도우 팝업 창이 나타납니다. # install.packages(&quot;colorspace&quot;) library(colorspace) choose_palette() 21.3.2 축의 색 지정 x축과 y축의 척도 표기 색상을 지정할 때 col.axis 모수 옵션을 사용합니다. 아래에 x축과 y축 척도 표기 색상으로 파랑색, 빨강색, 노랑색, 회색 등으로 바꿔가면서 그래프를 그려보았습니다. library(MASS) ## 축의 색 지정 : col.axis par(mfrow = c(2,2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.axis = &quot;blue&quot;, main = &quot;col.axis = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.axis = &quot;red&quot;, main = &quot;col.axis = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.axis = &quot;yellow&quot;, main = &quot;col.axis = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.axis = &quot;gray&quot;, main = &quot;col.axis = gray&quot;) par(mfrow = c(1,1)) 21.3.3 x축과 y축 레이블 색 지정 이번에는 x축과 y의 레이블 색을 지정하는 방법으로 col.lab 모수 옵션을 사용하면 됩니다. 파랑색, 빨강색, 노랑색, 회색으로 x축과 y축의 레이블 색을 설정하는 예를 들어보겠습니다. library(MASS) ## x축과 y축 레이블 색 지정 : col.lab par(mfrow = c(2,2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.lab = &quot;blue&quot;, main = &quot;col.lab = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.lab = &quot;red&quot;, main = &quot;col.lab = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.lab = &quot;yellow&quot;, main = &quot;col.lab = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.lab = &quot;gray&quot;, main = &quot;col.lab = gray&quot;) par(mfrow = c(1,1)) 21.3.4 제목 색 지정 그래프 제목의 색은 col.main 모수를 이용하여 색을 지정할 수 있습니다. 파랑색, 빨강색, 노랑색, 회색으로 그래프 제목의 색을 설정하는 예를 보겠습니다. library(MASS) ## 제목 색 지정 : col.main par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.main = &quot;blue&quot;, main = &quot;col.main = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.main = &quot;red&quot;, main = &quot;col.main = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.main = &quot;yellow&quot;, main = &quot;col.main = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.main = &quot;gray&quot;, main = &quot;col.main = gray&quot;) par(mfrow = c(1,1)) 21.3.5 부 제목 색 지정 그래프 부 제목의 색은 col.sub 모수를 이용하여 색을 지정할 수 있습니다. 파랑색, 빨강색, 노랑색, 회색으로 그래프 부 제목의 색을 설정하는 예를 보겠습니다. library(MASS) ## 부 제목 색 지정 : col.sub par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.sub = &quot;blue&quot;, sub = &quot;col.sub = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.sub = &quot;red&quot;, sub = &quot;col.sub = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.sub = &quot;yellow&quot;, sub = &quot;col.sub = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.sub = &quot;gray&quot;, sub = &quot;col.sub = gray&quot;) par(mfrow = c(1,1)) 21.3.6 그래프 테두리 색 지정 그래프의 전경 색은 fg = 모수를 이용하여 지정할 수 있습니다. 파랑색, 빨강색, 노랑색, 회색으로 그래프의 전경 색을 설정하는 예를 보겠습니다. library(MASS) ## 그래프 전경 색 지정 : fg par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, fg = &quot;blue&quot;, main = &quot;fg (foreground) = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, fg = &quot;red&quot;, main = &quot;fg (foreground) = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, fg = &quot;yellow&quot;, main = &quot;fg (foreground) = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, fg = &quot;gray&quot;, main = &quot;fg(foreground) = gray&quot;) par(mfrow = c(1,1)) 21.3.7 그래프 기호의 배경 색 지정 bg는 그래프 기호의 배경색을 채울 때 사용합니다. 아래에 기호 모양 21번 (원)에 파랑색, 빨강색, 노랑색, 회색을 채워보았습니다. library(MASS) ## 그래프 기호의 배경 색 지정 :bg par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;blue&quot;, main = &quot;bg (background) = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;red&quot;, main = &quot;bg (background) = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;yellow&quot;, main = &quot;bg (background) = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;gray&quot;, main = &quot;bg (background) = gray&quot;) par(mfrow = c(1, 1)) bg (background color)는 속이 비어있는 pch 21번부터 25번 까지만 사용가능하며, 그 외에는 적용이 안됩니다. "],["그래프-영역-mar-oma-mfrow-mfcol-layout.html", "21.4 그래프 영역 (mar, oma, , mfrow, mfcol, layout)", " 21.4 그래프 영역 (mar, oma, , mfrow, mfcol, layout) 그래프 영역은 크게 (1) 플롯 영역 (plot area), (2) 내부 마진 영역 (inner margin area), (3) 외부 마진 영역(outer margin area) 로 구분할 수 있습니다. 아래의 예시 그래프에 각 영역의 위치에 text 로 표기를 해보았습니다. 21.4.1 플롯 영역 (plot area), 내부 마진 영역 (inner margin area) 플롯 영역 (plot area)은 점이든 선이든 기호가 그려지는 영역입니다. 내부 마진 영역 (inner margin area)는 플롯 영역을 감싸고 있는 4개 모서리 부분의 마진입니다. 하단 부분이 1번, 왼쪽 부분이 2번, 상단부분이 3번, 오른쪽 부분이 4번이며, 순서대로 내부 마진 영역의 디폴트 값은 c(5.1, 4.1, 4.1, 2.1) 입니다. 하단은 x축 레이블, 왼쪽은 y축 레이블, 상단은 제목이 들어가는 영역입니다. 그래서 기본 값의 마진 숫자가 큰 반면에, 오른쪽은 보통은 레이블이 없으므로 디폴트 마진 값이 타 영역의 반밖에 되지 않습니다. ##------------------------------------------- ## 그래프 영역과 내부/외부 마진 ##------------------------------------------- library(MASS) # to use Cars93 dataframe # 플롯 영역과 내부 마진 영역의 기본값으로 설정되어 있는대로 그래프를 작성합니다. # 기본 값 내부 마진 영역 : c(5.1, 4.1, 4.1, 2.1) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, xlab = &quot;Inner Margin Area 1&quot;, ylab = &quot;Inner Margin Area 2&quot;, main = &quot;Inner Margin Area 3&quot;) # 저수준 함수들을 이용하여 영역을 표시해 줍니다. mtext(&quot;내부 마진 영역 4&quot;, side = 4, col = &quot;blue&quot;) text(3000, 35, cex = 3, labels = &quot;플롯 영역&quot;, pos = 3, col = &quot;blue&quot;) 21.4.2 외부 마진 영역 (outer margin area) 외부 마진 영역은 내부 마진 영역의 바깥 쪽을 둘러싸는 마진 영역입니다. 내부 마진 영역과 위치 순서는 똑같이 하단 부분이 1번, 왼쪽 부분이 2번, 상단 부분이 3번, 오른쪽 부분이 4번입니다. 1번, 2번, 3번, 4번 별로 디폴트 마진 값은 c(0, 0, 0, 0) 입니다. 즉 위의 예의 경우 외부 마진(outer margin) 을 별도로 지정해주지 않았으므로 디폴트 값이 적용되어 외부 마진(outer margin)은 모두 ‘0’ 으로 없는 셈입니다. 외부 마진 영역은 위의 예처럼 1개짜리 그래프에서는 별 쓸모가 없습니다만 (그냥 내부 마진 영역으로 cover 되기 때문입니다), 그래프 영역을 분할해서 2개 이상의 그래프를 하나의 그래프에 결합할 경우 유용하게 사용할 수 있습니다. 개별 그래프에서는 내부 마진 영역에 제목, x축 레이블, y축 레이블을 적고, 2개 이상의 개별 그래프들을 모두 포괄하는 대제목 (mega title)을 적고자 할 때 외부 마진 영역에 적으면 딱 좋습니다. 아래에 1개의 행, 2개의 열로 영역을 분할(mfrow = )한 경우 외부 마진 영역 설정(oma = ), 내부 마진 영역 설정(mar = ) 함수의 예를 들어보겠습니다. 외부 마진 부분은 파란색으로 알아보기 쉽게 위치 표시를 했습니다. 참고로, op &lt;- par(no.readonly = TRUE)로 디폴트 par 값을 미리 할당해 두면, 나중에 par값 조정 다 끝나고 원래의 디폴트 값으로 되돌아오고자 할 때 par(op)를 실행시키면 되므로 매우 편리합니다. library(MASS) ## 내부 마진 영역과 외부 마진 영역 # par의 기본 설정 값을 저장합니다. op &lt;- par(no.readonly = TRUE) # par() 함수 옵션을 변경합니다. par(mfrow = c(1,2), # 1행 2열로 프레임을 분할합니다. mar = c(4, 3, 3, 1), # 내부 마진을 설정합니다. oma = c(0.5, 0.5, 2, 0.5)) # 외부 마진을 설정합니다. # 플롯 영역, 내부 마진 영역, 외부 마진 영역 plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, xlab = &quot;Inner Margin Area&quot;, main = &quot;Inner Margin Area&quot;) plot(MPG.highway ~ Horsepower, Cars93, type=&quot;p&quot;, xlab = &quot;Inner Margin Area&quot;, main = &quot;Inner Margin Area&quot;) # 저수준 함수로 텍스트를 표시합니다. mtext(&quot;Outer Margin Area&quot;, outer = TRUE, cex = 2, col = &quot;blue&quot;) # outer = TRUE : 외부 마진 영역 # par를 초기 설정값으로 환원합니다. par(op) 21.4.3 영역 분할/결합 방법 1 2개 이상의 다수의 그래프를 결합하는 방법에는 par() 함수와 layout() 함수의 2가지 방법이 있습니다. 먼저 par() 방법을 살펴보면, par(mfrow = ), par(mfcol = ) 의 2가지 모수 설정 방법이 있습니다. mfrow와 mfcol 은 아래의 말을 줄여 쓴 말입니다. mfrow : 행 우선의 복수 플롯의 수 mfcol : 열 우선의 복수 플롯의 수 par(mfrow = c(4, 2)) 은 복수의 플롯 작성할 때 프레임을 4행 2열로 분할하여 한 프레임에 표시하라는 의미입니다. 그래프가 그려지는 순서를 화살표로 표시를 해두었는데요, 상단 왼쪽에서 시작해서 오른쪽으로 지그재그로 하단으로 내려가면서 그래프가 순차적으로 그려집니다. library(MASS) # par의 기본 설정 값을 저장합니다. op &lt;- par(no.readonly = TRUE) ##-- par(mfrow = ): 행 우선의 복수 플롯의 수 par(mfrow = c(4, 2), # 4행 2열로 프레임을 분할합니다 mar = c(4, 3, 3, 1), # 내부 마진을 설정합니다. oma = c(0.5, 0.5, 2, 0.5)) # 외부 마진을 설정합니다. plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 2&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 3&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 4&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 5&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 6&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 7&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 8&quot;) mtext(&quot;par(mfrow = c(4, 2)&quot;, outer = TRUE, cex = 2, col = &quot;blue&quot;) # par를 초기 설정값으로 환원합니다. par(op) 한편, par(mfcol = c(4, 2)) 은 프레임을 4행 2열로 분할하되, 플롯은 열 우선 순서로 표시가 되는 것입니다. 다음의 예에서 플롯이 그려지는 순서를 잘 살펴보기 바랍니다. library(MASS) # par의 기본 설정 값을 저장합니다. op &lt;- par(no.readonly = TRUE) ##-- par(mfcol = ) : 열 우선의 복수 플롯의 수 par(mfcol = c(4, 2), # 프레임을 4행 2열로 분할합니다. mar = c(4, 3, 3, 1), # 내부 마진을 설정합니다. oma = c(0.5, 0.5, 2, 0.5)) # 외부 마진을 설정합니다. plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 2&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 3&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 4&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 5&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 6&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 7&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 8&quot;) mtext(&quot;par(mfcol = c(4, 2)&quot;, outer = TRUE, cex = 2, col = &quot;blue&quot;) # par를 초기 설정값으로 환원합니다. par(op) 21.4.4 영역 분할/결합 방법 2 : layout() layout() 함수를 사용하면 행렬 형태로 분할하려는 그래프 영역의 순서(sequence)와 열의 폭과 행의 높이(widths of column, heights of row), 영역 나누기/합치기(divide/combine)를 자유롭게 조절할 수 있습니다. layout() 함수는 par(mfrow = )나 par(mfcol = ) 함수와는 병행해서 사용할 수 없으므로 그래프 분석을 시작하기 전에 무슨 함수를 사용할 것인지 결정을 하고 하나를 선택해야만 합니다. layout.show(n)은 현재의 레이 아웃에 대한 외곽선을 n 만큼의 그래프 갯수만큼 볼 수 있게 해주는 함수입니다. 아래에 layout()과 layout.show(n) 함수 예를 하나 들어보겠습니다. matrix() 인수 안의 숫자가 그래프가 그려지는 순서입니다. byrow=TRUE 로 설정했으므로 행 우선 순서로 4개의 그래프를 그릴 수 있는 영역에 플롯이 채워지게 됩니다. byrow= FALSE 로 지정하면 열 우선 순서로 그래프가 생성됩니다. library(MASS) ##----------------------------------- ## layout ##----------------------------------- # par의 기본 설정 값을 저장합니다. op &lt;- par(no.readonly = TRUE) # 프레임을 2행 2열로 분할합니다. # 행 우선 순서로 1, 2, 3, 4가 왼쪽으로 오른쪽 하단으로 할당됩니다. layout(matrix(c(1, 2, 3, 4), 2, 2, byrow = TRUE)) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 2&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 3&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 4&quot;) # show the current layout layout.show(4) layout() 함수를 활용하면 그래프 영역을 합칠 수도 있습니다. 이러한 기능은 par(mfrow = )나 par(mfcol = ) 와 비교해서 매우 유용한 기능 중의 하나입니다. 2행 2열로 나눈 영역에서 1행 1열에만 그래프 영역 1개를 남겨놓고, 2행의 1열과 2행의 2열을합쳐보겠습니다. 숫자 ’0’은 비어있는 그래프 영역이 되며, 동일한 숫자를 행렬(matrix) 안에 나란히 입력하면 그 영역을 합쳐지게 됩니다. 아래 예에서는 1행2열에 ‘0’이 입력되었으므로 비어 있고, 2행1열과 2행 2열에는’2’가 입력되어 있으므로, 2행은 1개의 그래프 영역으로 표시가 되게 됩니다. library(MASS) ## 2행 2열 영역으로 분할합니다. ## 1행 1열의 요소로 그림 1을 할당합니다. ## 그림 2은 2행 전체에 할당합니다. layout(matrix(c(1, 0, 2, 2), 2, 2, byrow = TRUE)) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 2&quot;) ## show the current layout layout.show(2) 이해를 돕기위해서 이번에는 1행 1열과 1행 2열을 하나로 합치고, 2행 1열은 비워놓고 2행2열만 남겨놓는 layout을 만들어보는 예제를 아래에 들어보겠습니다. ## 2행 2열 영역으로 분할합니다. ## 그림 1을 1행 전체에 할당합니다. ## 그림 2은 2행의 2열에 할당합니다. layout(matrix(c(1, 1, 0, 2), 2, 2, byrow = TRUE)) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 2&quot;) ## show the current layout layout.show(2) 이번에는 10cm x 10cm 정사각형 모양의 그래프 영역을 생성해 보겠습니다. 폭은 widths = lcm() 으로, 높이는 heights = lcm() 으로 설정을 해주면 됩니다. ## 10 cm x 10 cm 넓이의 그래프를 작성합니다. layout.1 &lt;- layout(matrix(1), # 요소가 1개인 행렬입니다. widths = lcm(10), # 폭이 10cm heights = lcm(10)) # 높이가 10cm plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) layout.show(layout.1) 이번에는 그래프 생성 순서(sequence)의 위, 아래를 바꾸어 보고, 그래프의 넓이(widths)와 높이(heights)를 서로 다르게 하는 그래프 영역을 만들어보겠습니다. 가운데에 산점도를 그려놓고 상단과 우측에 작은 크기의 히스토그램이나 박스플롯을 병행해서 그릴 때 유용하게 사용할 수 있습니다. 참고로, respect = TRUE 는 가로 넓이와 세로 높이의 비율을 고려해서 그래프 영역을 설정하라는 옵션입니다. # 다음의 행렬에 있는 요소가 표시되는 그림의 번호입니다. l &lt;- matrix(c(2, 0, 1, 3), 2, 2,byrow = TRUE); l ## [,1] [,2] ## [1,] 2 0 ## [2,] 1 3 layout.2 &lt;- layout(matrix(c(2, 0, 1, 3), 2, 2,byrow = TRUE), # 그림의 위치를 지정합니다. widths = lcm(c(6, 4)), # 두 열의 넓이가 각각 6Cm와 4Cm로 설정됩니다. heights = lcm(c(4, 6)), # 두 행의 높이가 각각 4Cm와 6Cm로 설정됩니다. respect = TRUE) # 가로의 넓이와 세로의 높이의 비율을 고려합니다. plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 2&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 3&quot;) layout.show(layout.2) # Reset par to the default values at startup par(op) 참고자료 https://rfriend.tistory.com/148?category=605866 https://rfriend.tistory.com/149?category=605866 https://rfriend.tistory.com/150?category=605866 https://rfriend.tistory.com/151?category=605866 "],["낮은-수준의-그래프-함수.html", "Chapter 22 낮은 수준의 그래프 함수", " Chapter 22 낮은 수준의 그래프 함수 높은 수준의 그래프 함수로 그래프의 골격을 만들수 있고, 그래픽 모수로 기호 모양이나 색, 크기 등을 설정할 수 있는데요, 이것 만으로는 원하는 그래프를 만드는데 부족함이 있습니다. 가령 그래프 제목을 추가하고 싶거나, 선이나 점을 추가하고 싶거나, 문자나 범례를 추가하고 싶다거나, XY축을 변경하고 싶을 때가 있는데요, 이때 추가적인 정보를 입력하기 위해 사용하는 것이 ’낮은 수준의 그래프 함수 (Low level graphic functions)’가 되겠습니다. [ 낮은 수준의 그래프 함수 (Low level graphic function) ] 높은 수준의 그래프 함수로 만약 plot(x, y, **type = \"n\"**) 으로 하면 그래프 창만 열리고 플롯 영역 안에는 빈 공간만 있게 됩니다. 여기에 낮은 수준의 그래프 함수로 그래프 기호, 선, 점, 범례 등을 추가해 나갈 수 있습니다. "],["제목과-xy축-레이블-추가하기.html", "22.1 제목과 XY축 레이블 추가하기", " 22.1 제목과 XY축 레이블 추가하기 먼저 그래프 제목(main/sub title)과 XY축 라벨(XY axis label)을 추가하는 방법으로 title() 함수의 사용 방법에 대하여 알아 보겠습니다. title() 함수에 사용하는 옵션으로는 주 제목 main, 부 제목 sub, X축 라벨 xlab, Y축 라벨 ylab 등이 있습니다. title(main = &quot;main title to the top of plot in a large font&quot;, sub = &quot;sub-title sub at the bottom in a smaller font&quot;, xlab = &quot;x axis label&quot;, ylab = &quot;y axis label&quot;) 높은 수준의 그래프 함수, 즉 hist(), boxplot(), barplot(), plot() 등의 함수 안에서도 주 제목, 부 제목, X축 레이블, Y축 레이블을 직접 지정할 수도 있습니다. 다음의 예는 높은 수준의 그래프 함수로 이를 표시한 예입니다. ##---------------------------------------------- ## 제목, 부제목, X축과 Y축의 레이블 추가하기 ##---------------------------------------------- library(MASS) par(mfrow = c(1, 1)) # 방법 (1) : 높은 수준의 함수 plot() 함수의 예 plot(MPG.highway ~ Weight, Cars93, main = &quot;제목 : Weight와 MPG.highway의 산점도&quot;, sub = &quot;부제목 : 높은 수준의 그래픽 함수&quot;, xlab = &quot;x 레이블 : Weight&quot;, ylab = &quot;y 레이블 : MPG.highway&quot;) 위의 그래프와 똑같은 그래프를 낮은 수준의 그래프 함수를 사용해서 그려보겠습니다. 먼저 고급 수준의 함수 plot() 함수를 이용하여 플롯을 합니다. plot() 함수의 인수로 “ann = FALSE” 옵션을 추가해서 기본 플롯만 그립니다. 그런 다음, 위의 기본 플롯에 낮은 수준의 그래프 함수(Low level graphic function) title() 함수를 사용해서 제목, 부제목, x 레이블, 그리고 y 레이블 등의 부가정보를 추가해 보겠습니다. library(MASS) # 방법 (2) : 낮은 수준의 함수 title() 함수의 사용 예 # 1) 고급 수준의 함수 plot() 함수를 이용하여 기본 플롯을 작성합니다. # X와 Y 레이블의 삭제 : ann = FALSE plot(MPG.highway ~ Weight, Cars93, ann = FALSE) # 2) 낮은 수준의 함수 title() 함수를 이용해 제목, 부제목, x 레이블, 그리고 y 레이블 등의 부가정보를 추가합니다 title(main = &quot;플롯의 상단부에 큰 폰트로 표시되는 제목&quot;, sub = &quot;바닥에 작은 폰트로 표시되는 부제목&quot;, xlab = &quot;x 축 레이블&quot;, ylab = &quot;y 축 레이블&quot;) 높은 수준의 그래프 함수에서도 주 제목, 부 제목, XY축 Label 등을 설정할 수 있는데 왜 굳이 낮은 수준의 그래프 함수 title() 을 가지고 추가 정보를 입력하는지 의아할 수도 있겠습니다. 높은 수준의 그래프 함수 중에 부가정보를 입력할 수 없는 그래프 함수도 있으며, R의 장점 중에 하나가 대화형으로 그래프의 부가 정보를 추가하는 것을 직접 확인할 수 있습니다. 따라서 매우 직관적으로 탐색적 데이터 분석을 할 수 있다는 점입니다. 참고로, 지난번 포스팅에서 소개한 그래프 모수 (graphics parameters) 중에서 기호의 크기를 설정하는 “cex.main =,” “cex.sub =,” “cex.lab =” 옵션을 사용해서 주 제목, 부 제목, XY축 레이블의 크기를 변경해보겠습니다. library(MASS) # 제목, 부제목, xy 레이블의 글자 크기를 수정하기 # X와 Y 레이블의 삭제 : ann = FALSE plot(MPG.highway ~ Weight, Cars93, ann = FALSE) # 제목, 부제목, x 레이블, 그리고 y 레이블 등의 부가정보를 추가하면서, 글자 크기도 수정합니다. title(main = &quot;cex가 2.2인 제목&quot;, sub = &quot;cex가 1.5인 부제목&quot;, xlab = &quot;cex가 1인 x 레이블&quot;, ylab = &quot;cex가 1인 y 레이블&quot;, cex.main = 2.2, # 제목의 글자 크기 cex.sub = 1.5, # 부제목의 글자 크기 cex.lab = 1) # x와 y 레이블 글자 크기 "],["xy축-형태-변환-axisside-.html", "22.2 XY축 형태 변환 : axis(side, ...)", " 22.2 XY축 형태 변환 : axis(side, ...) 이번 절에서는 낮은 수준의 그래프 함수 두번째로 XY축의 형태를 변환시켜 주는 axis(side, ...) 함수 에 대해서 학습하겠습니다. XY축의 형태를 변경하는 axis() 함수의 기본 사용법은 다음과 같습니다. axaxis(side, at = NULL, labels = TRUE, tick = TRUE, line = NA, pos = NA, outer = FALSE, font = NA, lty = &quot;solid&quot;, lwd = 1, lwd.ticks = lwd, col = NULL, col.ticks = NULL, hadj = NA, padj = NA, ...) 위의 axis() 함수의 모수 중에서 사용빈도가 높은 주요 모수에 대해서 기능 설명과 예를 들어보겠습니다. 모수 설명 side 그래프의 어느 쪽에 축을 그릴지 지정하는 정수. 1 = 아래쪽 (below side) 2 = 왼쪽 (left side) 3= 위쪽 (above side) 4 = 오른쪽 (right side) at 축의 눈금이 그려질 곳의 위치를 지정하는 점들 labels 축 눈금에 레이블 데이터를 입력하는 숫자형 벡터, 혹은 문자형 벡터 tick 축의 눈금과 축의 선을 그릴지를 설정하는 논리형 값 pos 해당 축이 다른 축과 교차하는 좌표 lty 축과 눈금의 선의 유형 lwd 축의 눈금의 선의 두께 col 축과 눈금 선의 색깔 tck 눈금의 방향과 길이 설정- 양수 : 그래프 안쪽으로 눈금 생성- 음수 : 그래프 바깥쪽으로 눈금 생성 hadj 수평 라벨에 대한 수정 padj 수직 라벨에 대한 수정 22.2.0.1 X축과 Y축의 제거 X축과 Y축을 변경하기 전에 먼저 “axes = FALSE” 옵션을 사용해서 X축과 Y축을 제거해야 합니다. X축만 선별적으로 제거하려면 xaxt = \"n\", Y축만 선별적으로 제거하려면 yaxt = \"n\" 옵션을 사용하면 되겠습니다. 아래에 각각의 예를 들어보았습니다. library(MASS) ##--------------------------------------------- ## 낮은 수준의 그래픽 함수 : axis(side, ...) ##--------------------------------------------- # 기본 par 설정값을 저장합니다. op &lt;- par(no.readonly = TRUE) # par() 함수의 옵션을 변경합니다. par(mfrow=c(2, 2)) # 프레임을 2행 2열로 분할합니다. # X와 Y축을 플롯합니다. plot(MPG.highway ~ Weight, Cars93, main = &quot;plot with X and Y axis&quot;) # X와 Y축을 제거합니다. : axes = FALSE plot(MPG.highway ~ Weight, Cars93, axes = FALSE, main = &quot;axes = FALSE&quot;) # X 축만 제거합니다 : xaxt = &quot;n&quot; plot(MPG.highway ~ Weight, Cars93, xaxt = &quot;n&quot;, main = &quot;xaxt = n&quot;) # Y 축만 제거합니다 : yaxt = &quot;n&quot; plot(MPG.highway ~ Weight, Cars93, yaxt = &quot;n&quot;, main = &quot;yaxt = n&quot;) # 원래의 par 기본 값을 불러옵니다. par(op) 22.2.0.2 X축과 Y축의 눈금 간격 변경 X축과 Y축의 범위를 알아보기 위해 summary() 함수로 기술통계량을 알아보겠습니다. library(MASS) # x축과 y축의 통계 요약 정보를 확인합니다. summary(Cars93$Weight) # X 축 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1695 2620 3040 3073 3525 4105 summary(Cars93$MPG.highway) # Y 축 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 20.00 26.00 28.00 29.09 31.00 50.00 X축으로 Weight (차의 무게)를, Y축으로는 MPG.highway(고속도로 연비)로 하는 산점도를 그렸을 때, X축은 1600~4200까지의 범위로 100씩 증가하는 눈금을, Y축은 18~52까지의 범위로 2씩 증가하는 눈금으로 그려보겠습니다. # X 축의 범위 (1600 ~ 4200, by 100) # Y 축의 범위 (18 ~ 52, by 2) # 1) X축과 Y축이 없는 산점도를 그립니다. plot(MPG.highway ~ Weight, Cars93, axes = FALSE, xlim = c(1600, 4200), ylim = c(18, 52), main = &quot;Weight와 MPG.highway의 산점도&quot;) x &lt;- seq(1600, 4200, by = 100) # x 축의 눈금 설정 y &lt;- seq(18, 52, by = 2) # y 축의 눈금 설정 # 2) X축의 눈금을 그립니다. axis(side = 1, # bottom side at = x, labels = TRUE, pos = 18, # X 축의 시작점 좌표. tck = 0.02) # 0.02 길이로 수직 방향의 틱 마크 표시 # 3) Y축의 눈금을 그립니다. axis(side = 2, # left side + at = y, labels = TRUE, pos = 1600, # Y 축의 시작점 좌표 tck = -0.02) # 0.02 길이로 수평 방향의 틱 마크 표시 "],["직선의-연결과-추가.html", "22.3 직선의 연결과 추가", " 22.3 직선의 연결과 추가 이번 절에서는 낮은 수준의 그래프 함수 세 번째로 lines(x, y), abline(a, b), abline(h=y), abline(v=x) 등의 함수를 이용한 직선 연결 및 추가에 대해서 소개하겠습니다. MASS 패키지에 들어있는 Cars93 데이터프레임의 **Weight (차의 무게)**와 **MPG.highway (고속도로 연비)** 두 개의 변수를 가지고 산포도를 그린 후에, **lines() 함수로 선형 회귀식을 추가해보고, abline() 함수로 x축과 y축의 평균으로 수직선과 수평선을 추가**하여 보겠습니다. lines()함수의 일반적인 사용법은 다음과 같습니다. lines(x, y = NULL, type = &quot;l&quot;, ...) 구분 기능 설명 x, y x, y 좌표 벡터 (coordinate vectors of points to join) type = \"l\" 선(line) 그래프라는 뜻임 (character indicating the type of plotting) ... 선 유형 (lty), 선 색깔 (col), 선 두께(lwd) 등의 그래프 모수 입력 (Further graphical parameters) abline() 함수의 사용법은 다음과 같습니다. abline(a = NULL, b = NULL, h = NULL, v = NULL, reg = NULL, coef = NULL, untf = FALSE, ...) 구분 기능 설명 a, b 절편과 기울기, 단일 값 (the intercept and slope, single values) h y값을 지나는 수평인 직선 (the y-value(s) for horizontal line(s).) v x값을 지나는 수직인 직선 (the x-value(s) for vertical line(s).) reg 회귀직선 추가 (an object with a coef method) coef 절편과 기울기로 이루어진 벡터 (a vector of length two giving the intercept and slope) untf 변환 안된 값을 쓸지를 묻는 옵션. 만약 y값을 로그변환한 경우 untf = TRUE 라고 설정하면 로그변환 전의 원래값 기준으로 좌표에 그래프가 그려짐 (logical asking whether to untransform.If untf is true, and one or both axes are log-transformed, then a curve is drawn corresponding to a line in original coordinates, otherwise a line is drawn in the transformed coordinate system. The h and v parameters always refer to original coordinates) * 출처 : http://sites.stat.psu.edu/~dhunter/R/html/graphics/html/abline.html 먼저 회귀모형을 구하는 lm() 함수를 사용해서 y = MPG.highway (고속도로 연비), x = Weight (차의 무게) 변수 간의 선형 회귀모형을 만들면 아래와 같습니다. library(MASS) ##------------------------------------ ## 플롯에 선을 추가합니다. ##------------------------------------ # 회귀 모형을 적용합니다. str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... # fitting regression model fit.1 &lt;- lm(MPG.highway ~ Weight, data = Cars93) 다음으로, Weight (무게)와 MPG.highway (고속도로 연비)의 두 변수 산포도를 그리고, 위에서 만든 선형 회귀선을 추가해보겠습니다. 플롯에 선을 추가하는 데에는 세 가지 방법이 있습니다. lines() 함수를 사용하는 방법, abline(reg = ) 함수를 사용하는 방법, abline(a = coef[1], b = coef[2])를 사용하는 방법 등입니다. 참고로, 이렇게 추가되는 선에 대하여 그래프 모수(parameters)로서 색깔 지정은 col, 선 유형 지정은 lty, 선 두께 지정은 lwd 를 사용하면 됩니다. library(MASS) ## 현재의 플롯에 선을 추가하는 방법입니다. # (1) lines() 함수의 이용 with(Cars93, plot(MPG.highway ~ Weight)) # Weight와 MPG.highway의 산점도를 그립니다. lines(Cars93$Weight, fit.1$fitted.values, col = &quot;blue&quot;) # 산점도 위에 선을 추가합니다. title(&quot;회귀선의 추가 : lines()&quot;) # (2) abline(reg = regression_model) 함수의 이용 with(Cars93, plot(MPG.highway ~ Weight)) abline(reg = fit.1, col = &quot;red&quot;, lwd = 3) title(&quot;회귀선의 추가 : abline(reg = )&quot;) # (3) abline(a = fit.1$coef[1], b = fit.1$coef[2]) 함수의 이용 with(Cars93, plot(MPG.highway ~ Weight)) abline(a = fit.1$coef[1], b = fit.1$coef[2], col = &quot;black&quot;, lwd = 3) title(&quot;회귀선의 추가 : abline(a = coef[1], b = coef[2])&quot;) fit.1$coef # 회귀 모형의 계수(기울기와 절편)입니다. ## (Intercept) Weight ## 51.601365429 -0.007327059 fit.1$coef[1] # 절편입니다. ## (Intercept) ## 51.60137 fit.1$coef[2] # 기울기입니다. ## Weight ## -0.007327059 이번에는 loess.smooth() 함수로 비모수 회귀곡선을 적합시키고, lines() 함수로 평탄화된 회귀선(smoothed regression line)을 현재 그래프에 추가해보는 방법을 알아보겠습니다. library(MASS) ## 현재의 플롯에 평탄화된 회귀선을 추가합니다.: lines(), loess.smooth() # (1) 비모수 회귀선 적합화 fit.2 &lt;- loess.smooth(x = Cars93$Weight, y = Cars93$MPG.highway) names(fit.2) ## [1] &quot;x&quot; &quot;y&quot; fit.2$x ## [1] 1695.000 1744.184 1793.367 1842.551 1891.735 1940.918 1990.102 2039.286 ## [9] 2088.469 2137.653 2186.837 2236.020 2285.204 2334.388 2383.571 2432.755 ## [17] 2481.939 2531.122 2580.306 2629.490 2678.673 2727.857 2777.041 2826.224 ## [25] 2875.408 2924.592 2973.776 3022.959 3072.143 3121.327 3170.510 3219.694 ## [33] 3268.878 3318.061 3367.245 3416.429 3465.612 3514.796 3563.980 3613.163 ## [41] 3662.347 3711.531 3760.714 3809.898 3859.082 3908.265 3957.449 4006.633 ## [49] 4055.816 4105.000 # (2) 평탄화된 회귄서의 추가 with(Cars93, plot(MPG.highway ~ Weight)) lines(fit.2$x, fit.2$y, col = &quot;blue&quot;, lwd = 3) title(&quot;평판화된 회귀선의 추가: lines(), loess.smooth()&quot;) abline()함수를 이용하여 플롯에 수평선과 수직선을 추가할 수 있습니다. library(MASS) ## 수평선과 수직선을 추가하기 : abline() with(Cars93, plot(MPG.highway ~ Weight)) # (1) 수직선의 추가 abline(v = mean(Cars93$Weight), col = &quot;black&quot;, lty = 3, lwd = 2) # (2) 수평선의 추가 abline(h = mean(Cars93$MPG.highway), col = &quot;blue&quot;, lty = 3, lwd = 2) title(&quot;수평선과 수직선 추가 : abline()&quot;) "],["점-추가-pointsx-y.html", "22.4 점 추가 : points(x, y)", " 22.4 점 추가 : points(x, y) 이번 절에서는 낮은 수준의 그래프 함수 네번째로 points(x, y) 함수를 이용하여 점을 추가하는 방법에 대하여 학습하겠습니다. points() 함수의 일반적인 사용법은 다음과 같습니다. points(x, y = NULL, type = &quot;p&quot;, ...) 구분 기능 설명 x,y x, y 좌표 벡터 (coordinate vectors of points to plot) type = \"p\" 그래프 유형 = “점 그래프” ... 기호 모양(pch), 색깔(col), 크기(cex) 등의 그래프 모수 (parameters) 사용 MASS 패키지에 내장되어 있는 Cars93 데이터프레임의 차량 무게(Weight), 고속도로 연비 (MPG.highway), 차종 (Type) 변수를 사용해서 점을 추가하는 그래프를 실습해보겠습니다. 높은 수준의 그래프 함수 중에서 plot(x, y, type = 'p') 로 하면 점 그래프 (points plot)을 그릴 수 있습니다. plot(x, y, type = 'p')로 산점도를 그리고, 그 위에 points(x, y) 함수로 점을 추가하는 예를 살펴 보겠습니다. 정확히 두 개 그래프가 일치합니다. library(MASS) ##----------------------------------------- ## 점 추가 : point(x, y) ##----------------------------------------- # 고수준 함수 plot()을 이용하여 산점도 그리기 attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders plot(Weight, MPG.highway, type = &#39;p&#39;) # 점 플롯입니다. # 플롯 위에 낮은 수준의 함수 point() 를 이용하여 점을 추가합니다. plot(Weight, MPG.highway, type = &#39;n&#39;) # 빈 플롯입니다. points(Weight, MPG.highway) # 위의 플롯과 정확히 똑 같습니다. detach(Cars93) 그러면 왜 굳이 points() 라는 낮은 수준의 함수를 가지고 점을 추가하려고 하는 것인지 의문이 들것입니다. 그 이유는 points() 함수를 가지고 필요에 따라서 순차적으로 점을 추가할 수 있고, 조건을 부여하고 그래프 모수 중에 색깔이나 기호 모양 등을 다르게 해서 탐색적 분석을 진행하는데 유용하기 때문입니다. 물론 plot(x, y, type = 'p')로 원하는 그래프를 그릴 수 있다면 points()함수를 사용할 필요는 없겠지요. 아래에 points()의 몇 가지 사용 형태를 보시고 필요한 상황에 맞게 골라 쓰면 되겠습니다. 아래에는 차종(Type)별로 기호 모양과 색깔을 달리하면서 무게(Weight)와 고속도로 연비(MPG.highway) 산점도를 그려보겠습니다. 2차원의 x, y 공간에 차종(Type)이라는 제3의 차원을 추가해서 볼 수 있는 매우 유용한 방법입니다. 대신 Base Graphics 에서는 조건의 갯수만큼 손이 참 많이 가는 단점이 있습니다 (참고로, ggplot2 plotting system을 사용하면 조건에 따른 색이나 기호를 달리하도록 지정하는게 한 줄이면 끝나고, 범례(legend)도 알아서 추가해주므로 편합니다). library(MASS) attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders # 현재의 빈 플롯에 pch, col, cex 모수를 설정한 점을 추가합니다. plot(Weight, MPG.highway, type = &#39;n&#39;) # 빈 플롯입니다. points(Weight, MPG.highway, pch = 15, col = &quot;blue&quot;, cex = 1.5) detach(Cars93) 산점도의 점들을 조건에 따라 상이한 문자의 점으로 추가할 수도 있습니다. library(MASS) attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders # 조건에 따라 상이한 문자의 점을 추가합니다. plot(Weight, MPG.highway, type = &#39;n&#39;) # 빈 플롯을 그립니다. table(Cars93$Type) ## ## Compact Large Midsize Small Sporty Van ## 16 11 22 21 14 9 # Type = Compact 인 경우 points(Weight[Type == &quot;Compact&quot;], MPG.highway[Type == &quot;Compact&quot;], pch = 0) # Type = Large 인 경우 points(Weight[Type == &quot;Large&quot;], MPG.highway[Type == &quot;Large&quot;], pch = 1) # Type = Midsize 인 경우 points(Weight[Type == &quot;Midsize&quot;], MPG.highway[Type == &quot;Midsize&quot;], pch = 17, col = &quot;yellow&quot;) # Type = Small 인 경우 points(Weight[Type == &quot;Small&quot;], MPG.highway[Type == &quot;Small&quot;], pch = 3) # Type = Sporty 인 경우 points(Weight[Type == &quot;Sporty&quot;], MPG.highway[Type == &quot;Sporty&quot;], pch = 9) # Type = Van 인 경우 points(Weight[Type == &quot;Van&quot;], MPG.highway[Type == &quot;Van&quot;], pch = 15, col = &quot;blue&quot;) title(&quot;자동차 종류에 따라 상이한 문자의 점 추가&quot;) # 상단부 오른쪽에 범례를 추가합니다. legend(&quot;topright&quot;, # 범례의 표시 위치입니다. c(&quot;Compact&quot;, &quot;Large&quot;, &quot;Midsize&quot;, &quot;Small&quot;, &quot;Sporty&quot;, &quot;Van&quot;), # 범례로 출력될 문자열입니다. col = c(&quot;black&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;black&quot;, &quot;blue&quot;), # 범례의 색깔입니다 pch = c(0, 1, 17, 3, 9, 15) # 표시될 기호 문자입니다. ) detach(Cars93) "],["문자열-추가.html", "22.5 문자열 추가", " 22.5 문자열 추가 이번 절에서는 낮은 수준의 그래프 함수 네번째로 text(x, y, labels, ...), mtext() 함수를 이용하여 문자열을 추가하는 방법에 대해서 학습하겠습니다. 그래프에 문자를 추가할 때 text() 함수와 mtext() 함수를 사용합니다. 차이점은 text()가 그래프 내에 문자열을 추가할 때 사용하는 반면, mtext()는 외부 마진 영역(1 하단, 2 좌측, 3 상단, 4 우측)에 문자를 추가할 때 사용한다는 것입니다. text() 함수와 mtext() 함수의 일반적인 사용법은 아래와 같습니다. 함수 (function) 사용법 (usage) text() text(x, y, labels = , pos = , ... ) mtext() mtext(\"text to place\", side = , line = , adj, outer = , ... ) 함수 옵션 기능 설명 text() x, y 문자를 추가할 위치의 x, y좌표. 단, x, y 좌표 대신에 locator(1) 을 입력하면 커서로 지적하는 곳에 문자를 추가함 labels = 추가할 문자 pos = 1 = 하단부2 = 왼쪽3 = 상단부(기본값)4 = 오른쪽 좌표를 기준으로 문자를 입력할 상대적인 위치 ... 폰트, 색깔, 크기 등의 그래프 모수 지정 mtext() 추가할 문자 side = 1 = 하단부2 = 왼쪽3 = 상단부(기본값)4 = 오른쪽 문자를 추가할 위치 line = 0 ~ 문자와 그래프와의 마진 거리 adj = 0 : 왼쪽/아래쪽 정렬1 : 위쪽/오른쪽 정렬생략 : 중앙 정렬 outer = TRUE : 외부마진에 문자 추가 FALSE : 내부마진에 문자 추가 ... 폰트, 색깔, 크기 등의 그래프 모수 지정 22.5.1 text() 함수의 사용 먼저 text() 함수를 사용하여 그래프 내에 문자열을 추가하는 방법을 살펴보도록 하겠습니다. MASS 패키지에 내장되어있는 Cars93 데이터프레임의 차 무게 (Weight), 고속도로 연비 (MPG.highway) 변수를 활용해서 산점도를 그리고, 각 점에 해당하는 모델명을 모델명(Model) 변수의 텍스트로 추가해 보겠습니다. library(MASS) ##------------------------------------------- ## 플롯에 문자열 추가 : text(), mtext() ##------------------------------------------- ## 플롯에 문자열 추가 : text() attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders plot(Weight, MPG.highway, main = &quot;MPG.highway ~ Weight의 산점도&quot;) text(x = Weight, y = MPG.highway, labels = Model, pos = 3, cex = 0.5) text(x, y, ) 좌표 대신에 text(locator(1), ) 옵션을 사용하면 대화방식으로 플롯 화면 상에 문자가 들어갈 위치를 마우스로 클릭해서 지정할 수 있습니다. 재현 가능성(reproducible research) 관점에서 보면 추천할 만한 방법은 아닙니다. 그러나, x, y 좌표를 정확히 모르거나, 한번만 간편하게 그래프를 그려볼 목적이라면 큰 문제는 없습니다. # 텍스트가 들어갈 위치를 마우스로 선택하기 : locator(1) text(locator(1), labels = &quot;연비가 낮음&quot;) detach(Cars93) 22.5.2 mtext() 함수의 사용 다음으로 mtext() 를 사용해서 그래프 외부 마진 영역에 문자열을 추가해보는 예제입니다. title() 함수로 제목을 추가하는 것과 유사한 측면이 있습니다. mtext()의 경우 여러 개의 그래프를 결합했을 때 외부마진에 그래프 전체의 제목을 자유롭게 추가할 수 있다는 유용한 장점이 있습니다. library(MASS) ## 4개의 마진 중 한 곳에 문자열 추가하기 : mtext() # 기본 par 설정 값을 저장합니다. op &lt;- par(no.readonly = TRUE) # 1개 행에 2개의 그래프를 배치합니다. par(mfrow = c(1,2), # 1행 2개 플롯 oma = c(2, 2, 4, 1)) # 외부 마진 attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders ## The following objects are masked from Cars93 (pos = 3): ## ## AirBags, Cylinders, DriveTrain, EngineSize, Fuel.tank.capacity, ## Horsepower, Length, Luggage.room, Make, Man.trans.avail, ## Manufacturer, Max.Price, Min.Price, Model, MPG.city, MPG.highway, ## Origin, Passengers, Price, Rear.seat.room, Rev.per.mile, RPM, ## Turn.circle, Type, Weight, Wheelbase, Width plot(Weight, MPG.highway, main = &quot;MPG.highway ~ Weight&quot;) # 그림 1 plot(Horsepower, MPG.highway, main = &quot;MPG.highway ~ Horsepower&quot;) # 그림 2 mtext(&quot;Weight, Horsepower와 MPG.Highway&quot;, side = 3, # 문자열 위치 : 3 = 상단부 line = 1, # 그래프와 문자열의 마진 거리 (0부터 시작) adj = 2, # 문자열 정렬 위치 : 가운데 정렬 cex = 2, # 폰트 크기 outer = TRUE) # TRUE : 외부 마진에 문자열 위치 detach(Cars93) # 원래의 par 설정값으로 환원 par(op) 위의 예에서 mtext() 함수 내의 side, line, adj, cex, outer 등의 설정값을 하나씩 수정하면서 연습해 보면 옵션 설정을 이해하는데 도움이 될 것입니다. "],["범례-추가-legendx-y-legend-.html", "22.6 범례 추가 : legend(x, y, legend, ...)", " 22.6 범례 추가 : legend(x, y, legend, ...) 이번 절에서는 낮은 수준의 그래프 함수 네번째로 legend(x, y, legend, ...) 함수를 이용하여 범례(legend)를 추가하는 방법에 대해 살펴보겠습니다. 범례를 추가하는 legend()함수의 일반적인 사용법은 아래와 같습니다. legend(x, y = NULL, legend, fill = NULL, col = par(&quot;col&quot;), border = &quot;black&quot;, lty, lwd, pch, angle = 45, density = NULL, bty = &quot;o&quot;, bg = par(&quot;bg&quot;), box.lwd = par(&quot;lwd&quot;), box.lty = par(&quot;lty&quot;), box.col = par(&quot;fg&quot;), pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd, xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1, adj = c(0, 0.5), text.width = NULL, text.col = par(&quot;col&quot;), text.font = NULL, merge = do.lines &amp;&amp; has.pch, trace = FALSE, plot = TRUE, ncol = 1, horiz = FALSE, title = NULL, inset = 0, xpd, title.col = text.col, title.adj = 0.5, seg.len = 2) 플롯 위에 범례를 표시하기 위한 옵션도 엄청나게 많습니다. 그만큼 선택의 폭이 넓다는 것입니다. 이 절에서는 이 중에 몇 가지 중요한 옵션을 중심으로 살펴보겠습니다. 구분 옵션 기능 x, y \"bottomright\"\"bottom\"\"bottomleft\"\"left\"\"topleft\"\"top\"\"topright\"\"right\"\"center\" 범례를 추가할 위치를 설정하는 3가지 방법 (1) x, y 좌표를 입력하면 범례 사각형의 왼쪽 상단이 그 지점에 위치함 (2) locator(1)을 입력하면 마우스 포인터로 가리키는 지점에 범례 생성 (3) 위치를 나타내는 아래의 9개 단어 중 하나를 선택해서 입력 legend 길이가 1보다 큰 문자(character) 혹은 범례를 담은 벡터 col 색깔 지정 벡터 lty 선 유형 지정 벡터 lwd 선 두께 지정 벡터 pch 기호 지정 벡터 ... 그래픽 모수 추가 설정 가능 MASS 패키지에 내장된 Cars93데이터프레임의 차종(Type) 별로 차 무게(Weight)와 고속도로 연비 (MPG.highway) 변수를 사용해서 산점도를 그려보겠습니다. 그리고 차종(Type) 그룹에 대한 범례(legend)를 추가해보겠습니다. 22.6.1 x, y 좌표를 직접 입력하여 범례 위치 설정 library(MASS) # 산점도를 먼저 그립니다. attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders ## The following objects are masked from Cars93 (pos = 3): ## ## AirBags, Cylinders, DriveTrain, EngineSize, Fuel.tank.capacity, ## Horsepower, Length, Luggage.room, Make, Man.trans.avail, ## Manufacturer, Max.Price, Min.Price, Model, MPG.city, MPG.highway, ## Origin, Passengers, Price, Rear.seat.room, Rev.per.mile, RPM, ## Turn.circle, Type, Weight, Wheelbase, Width # 빈 산점도를 그립니다. plot(Weight, MPG.highway, type = &#39;n&#39;) # blank plot # 자동차의 종류(Type) 별로 산점도에 점으로 표시될 기호와 색깔을 다르게 선택합니다. types &lt;- levels(Type) pchs &lt;- c(0, 1, 17, 3, 0, 15) cols &lt;- c(&quot;black&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;black&quot;, &quot;blue&quot;) for (i in 1:6) { # for() 반복구문을 이용하여 차종별 점을 points() 함수로 그립니다. points(Weight[Type == types[i]], MPG.highway[Type == types[i]], pch = pchs[i], col = cols[i]) } title(&quot;플롯에 범례 추가하기&quot;) # 전체 제목을 표시합니다. # 상단부 오른쪽(&quot;topright&quot;)에 범례를 추가합니다. legend(x = 3500, y = 50, types, col = cols, pch = pchs ) detach(Cars93) 22.6.2 범례의 위치를 문자열로 지정하기 library(MASS) # 산점도를 먼저 그립니다. attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders ## The following objects are masked from Cars93 (pos = 3): ## ## AirBags, Cylinders, DriveTrain, EngineSize, Fuel.tank.capacity, ## Horsepower, Length, Luggage.room, Make, Man.trans.avail, ## Manufacturer, Max.Price, Min.Price, Model, MPG.city, MPG.highway, ## Origin, Passengers, Price, Rear.seat.room, Rev.per.mile, RPM, ## Turn.circle, Type, Weight, Wheelbase, Width # 빈 산점도를 그립니다. plot(Weight, MPG.highway, type = &#39;n&#39;) # blank plot # 범례가 표시될 위치를 문자열 키워드로 지정합니다. loc &lt;- &quot;topright&quot; # 자동차의 종류(Type) 별로 산점도에 점으로 표시될 기호와 색깔을 다르게 선택합니다. types &lt;- levels(Type) pchs &lt;- c(0, 1, 17, 3, 0, 15) cols &lt;- c(&quot;black&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;black&quot;, &quot;blue&quot;) for (i in 1:6) { # for() 반복구문을 이용하여 차종별 점을 points() 함수로 그립니다. points(Weight[Type == types[i]], MPG.highway[Type == types[i]], pch = pchs[i], col = cols[i]) } title(&quot;플롯에 범례 추가하기&quot;) # 전체 제목을 표시합니다. # 상단부 오른쪽(&quot;topright&quot;)에 범례를 추가합니다. legend(loc, types, col = cols, pch = pchs ) detach(Cars93) 앞의 예에서 문자열의 위치를 loc 변수에 “topright”로 지정하고 있습니다. 이 값을 다른 값으로 수정해서 다시 그래프를 그려보기 바랍니다. "],["다각형-추가-polygonx-y.html", "22.7 다각형 추가 : polygon(x, y, …)", " 22.7 다각형 추가 : polygon(x, y, …) 이번 절에서는 낮은 수준의 그래프 함수로 polygon(x, y, ...) 함수를 이용하여 다각형을 추가하는 방법에 대해서 알아 보겠습니다. 다각형을 그리는 polygon()함수의 일반적인 사용법은 다음과 같습니다. polygon(x, y = NULL, density = NULL, angle = 45, border = NULL, col = NA, lty = par(&quot;lty&quot;), ..., fillOddEven = FALSE) 구분 옵션 설명 x, y 다각형의 좌표의 벡터 density 다각형 안을 채우는 음영 선의 밀도 (default 는 NULL) angle 음영있는 선의 각도 (수평선을 기준으로 해서 반시계방향) border 다각형 테두리의 색깔 col 다각형을 채우는 색깔 (default 는 NA) lty 0 = blank1 = solid (기본 값)2 = dashed3 = dotted4 = dot dash5 = long dash6 = two dash par()함수에서 사용하는 선 유형 ... 추가로 그래프 모수 사용 가능 fillOddEven 다각형의 음영을 논리적으로 조절하는 모드 (default 는 FALSE) 두 개의 삼각형을 테두리의 색깔(border)과 선 유형(lty), 다각형을 채우는 색깔(col), 다각형을 채우는 선의 밀도(density)와 각도(angle), 색깔(col)을 달리해서 그려보겠습니다. x와 y의 좌표값의 중간에 “NA” 가 들어있음에 주의해서 보시기 바랍니다. ##------------------------------------- ## 다각형 추가하기 : polygon(x, y, ...) ##------------------------------------- # NA 값을 갖는 복수 개의 다각형 plot(c(1, 6), c(-3.5, 3.5), type = &quot;n&quot;) x &lt;- c(1, 2, 3, NA, 4, 4, 6) y &lt;- c(1, -3, 2, NA, -3, 3, -3) polygon(x, y, col = c(&quot;yellow&quot;, &quot;blue&quot;), border = c(&quot;black&quot;, &quot;red&quot;), lwd = 2, lty = c(&quot;dotted&quot;, &quot;solid&quot;)) title(&quot;NA 값을 갖는 복수 개의 다각형&quot;) 아래의 다각형은 위의 예와 거의 비슷합니다. 단 한가지 차이점이라면 x, y의 좌표값에 “NA”가 없다는 점입니다. “NA” 가 없다보니 중간에 다각형을 분리하지를 못하고, 그냥 하나의 색깔, 선 유형, 다각형 채우는 색을 계속 사용하고 있습니다. ## NA가 없는 경우의 복수 개의 다각형 plot(c(1, 6), c(-3.5, 3.5), type = &quot;n&quot;) x &lt;- c(1, 2, 3, 4, 4, 6) y &lt;- c(1, -3, 2, -3, 3, -3) polygon(x, y, col = c(&quot;yellow&quot;, &quot;blue&quot;), border = c(&quot;black&quot;, &quot;red&quot;), lwd = 2, lty = c(&quot;dotted&quot;, &quot;solid&quot;)) title(&quot;NA가 없는 경우의 복수 개의 다각형&quot;) 이번에는 다각형 안의 음영을 선으로 채우는 방법을 소개하겠습니다. density 로 선의 밀도(숫자가 클 수록 촘촘해짐)를 지정하고, angle 로 선의 각도(수평선을 기준으로 반시계방향)를 지정하면 됩니다. # 선이 추가된 다각형 plot(c(1, 6), c(-3.5, 3.5), type = &quot;n&quot;) x &lt;- c(1, 2, 3, NA, 4, 4, 6) y &lt;- c(1, -3, 2, NA, -3, 3, -3) polygon(x, y, col = c(&quot;yellow&quot;, &quot;blue&quot;), border = c(&quot;black&quot;, &quot;red&quot;), lwd = 2, lty = c(&quot;dotted&quot;, &quot;solid&quot;), density = c(10, 20), angle = c(45, -45)) title(&quot;선이 추가된 다각형&quot;) 아래 다각형은 x, y 좌표값이 위의 예와는 좀 다릅니다. 두 좌표 값들 간의 거리에 색깔을 채워넣은 형태의 그래프인데요, polygon() 함수로 이런 그래프도 그릴 수 있다는 예시로 보면 좋겠다 싶어서 www.math.cula.edu 사이트에서 참조하였습니다. ## 색칠된 다각형 # 출처 : http://www.math.ucla.edu/~anderson/rw1001/library/base/html/polygon.html set.seed(3232) n &lt;- 100 xx &lt;- c(0:n, n:0) yy &lt;- c(c(0, cumsum(rnorm(n))), rev(c(0, cumsum(rnorm(n))))) plot(xx, yy, type=&quot;n&quot;, xlab=&quot;Time&quot;, ylab=&quot;Distance&quot;) polygon(xx, yy, col=&quot;green&quot;, border = &quot;red&quot;) title(&quot;색칠된 다각형&quot;) 참고자료 https://rfriend.tistory.com/152?category=605866 https://rfriend.tistory.com/153?category=605866 https://rfriend.tistory.com/155?category=605866 https://rfriend.tistory.com/156?category=605866 https://rfriend.tistory.com/157?category=605866 https://rfriend.tistory.com/158?category=605866 https://rfriend.tistory.com/159?category=605866 https://rfriend.tistory.com/159?category=605866 "]]
