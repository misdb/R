[["index.html", "bookdown 사용 Preface", " bookdown 사용 Dae Ho Kim 2021-01-13 Preface 이 짧은 책은 책 쓰기 워크 플로를 변경하기 위해 R 패키지 bookdown을 소개합니다. 책을 쓰는 것은 기술적으로 쉬우며, 책을 보는 것이 시각적으로 즐겁고, 책과 상호 작용하는 것이 즐겁고, 책을 탐색하는 것이 편리해야 하며, 독자가 책 저자에게 기여하거나 피드백을 남길 수 있어야 합니다. 저자는 조판 세부 사항에 항상 주의를 산만하게해서는 안됩니다. bookdown 패키지는 R Markdown(http://rmarkdown.rstudio.com) 위에 빌드되며 Markdown 구문의 단순성을 상속합니다 (5분 안에 기본 사항을 배울 수 있습니다. 섹션 (Markdown) 참조). 뿐만 아니라 여러 유형의 출력 형식(PDF/HTML/Word/…) 또한 다중 페이지 HTML 출력, 번호 매기기 및 그림 / 표 / 섹션 / equations 교차 참조, 부품 / 부록 삽입, GitBook 스타일(https://www.gitbook.com)을 사용하여 우아하고 매력적인 HTML 책을 만듭니다. 이 책 자체는 일련의 R Markdown 문서에서 책을 만드는 방법의 예이며 인쇄 버전과 온라인 버전 모두 전문적으로 보일 수 있습니다. 더 많은 예는 https://bookdown.org에서 확인할 수 있습니다. “book”이라는 단어가 포함된 패키지 이름에도 불구하고 bookdown은 책에만 해당되는 것은 아닙니다. “책”은 코스 유인물, 학습 노트, 소프트웨어 매뉴얼, 논문 또는 일기와 같이 선형 순서로 읽을 수 있는 여러 R Markdown 문서로 구성된 모든 것이 될 수 있습니다. 실제로 많은 bookdown 기능이 단일 R Markdown 문서에도 적용됩니다 (섹션 (a-single-document) 참고). The online version of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. You can purchase a hardcopy from Chapman &amp; Hall or Amazon. "],["Introduction.html", "1 서론", " 1 서론 이 책은 R Markdown (Allaire, Xie, McPherson, et al. 2020)과 R 패키지 bookdown (Xie 2020a)을 사용하여 책 및 기술 문서를 작성하는 방법에 대한 가이드입니다. 다음과 같은 서적, 긴 형식의 기사 또는 보고서 작성과 관련된 기능에 중점을 둡니다. 방정식, 정리, 그림 및 표를 조판하고 상호 참조하는 방법 단일 도서에 대해 HTML, PDF 및 전자 책과 같은 여러 출력 형식을 생성하는 방법 책 템플릿을 사용자 정의하고 책의 다양한 요소를 스타일링하는 방법 편집기 지원 (특히 RStudio IDE)과 책을 출판하는 방법. bookdown이 구축되어 있는 R Markdown 또는 knitr 패키지에 대한 포괄적인 소개가 아닙니다 (Xie 2020b). R Markdown에 대한 자세한 내용은 온라인 문서 http://rmarkdown.rstudio.com를 확인하십시오. knitr의 경우 Xie (2015) 을 참조하세요. 이 책을 읽기 위해 R 언어 (R Core Team 2016)의 전문가일 필요는 없지만 R Markdown 및 knitr에 대한 기본 지식이 있어야 합니다. 초보자의 경우 https://www.rstudio.com/resources/cheatsheets/ 에서 치트 시트를 시작할 수 있습니다. 이 책의 부록에는 이러한 소프트웨어 패키지에 대한 간략한 소개가 포함되어 있습니다. 책 템플릿과 테마를 사용자가 정의하하면 LaTeX, HTML 및 CSS에 익숙해야 합니다. References "],["Motivation.html", "1.1 동기", " 1.1 동기 Markdown은 섹션, 단락, 목록, 링크 및 이미지 등과 같은 요소를 포함하는 비교적 간단한 문서를 작성할 수 있는 훌륭한 언어입니다. Pandoc (http://pandoc.org)에는 원본 Markdown 구문을 크게 확장하고 각주, 인용 그리고 표와 같은 몇 가지 유용한 새 기능을 추가했습니다. 더 중요한 것은 Pandoc을 사용하면 HTML, LaTeX / PDF, Word 그리고 슬라이드를 포함하여 Markdown에서 다양한 형식의 출력 문서를 생성할 수 있습니다. HTML 출력에서 그림과 표의 자동 번호 매기기, 그림과 표의 상호 참조, 그림의 모양에 대한 미세한 조절(예 : 현재 Markdown 구문을 사용하여 이미지 정렬을 지정하는 것은 불가능)과 같이 책과 같은 비교적 복잡한 문서를 작성하는 데 필요한 것들이 현재는 Pandoc의 Markdown에서는 지원하지 못하는 몇 가지 유용한 기능이 아직 있습니다. bookdown 패키지에서 해결한 몇 가지 문제들입니다. 책을 여러 출력 형식으로 제작하려는 제약 조건 하에서 이러한 다양한 출력 형식에 특정한 가능한 모든 기능을 다루는 것은 거의 불가능합니다. 예를 들어, (R) Markdown 구문을 사용하여 HTML 출력에서 복잡한 특정 LaTeX 환경을 재창조하는 것은 어려울 수 있습니다. 우리의 주요 목표는 모든 것을 Markdown으로 대체하는 것이 아니라 비교적 복잡한 문서를 작성하는 데 필요한 가장 일반적인 기능을 다루고 이러한 기능의 구문을 모든 출력 형식에서 일관되게 함으로써 그 중 하나만 학습하면 되고, 그러면 모든 출력 형식에서 작동하게 하는 것입니다. 이 프로젝트의 또 다른 목표는 시각적으로 보기 좋은 책을 쉽게 제작할 수 있도록 하는 것입니다. 좋은 기존 예제로는 GitBook(https://www.gitbook.com), Tufte CSS(http://edwardtufte.github.io/tufte-css/) 그리고 Tufte-LaTeX(https://tufte-latex.github.io/tufte-latex/) 등이 있습니다. 이러한 테마와 스타일을 bookdown에 통합하기를 희망하므로 작성자는 특정 LaTeX 클래스를 사용하는 방법이나 HTML 출력을 위해 CSS를 구성하는 방법에 대해 자세히 살펴볼 필요가 없습니다. "],["GetStarted.html", "1.2 시작하기", " 1.2 시작하기 초보자가 R Markdown과 bookdown으로 책 쓰기를 시작하는 가장 쉬운 방법은 GitHub에 수록되어 있는 bookdown-demo를 사용하는 것입니다. GitHub 저장소에서 Zip 파일을 다운로드한 다음 자신의 디렉토리에서 압축을 풉니다. RStudio IDE를 설치합니다. 1.0.0보다 높은 버전이 필요합니다. RStudio 버전이 1.0.0 미만인 경우 최신 버전을 다운로드 하세요. bookdown 패키지를 설치합니다. # stable version on CRAN install.packages(&quot;bookdown&quot;) # or development version on GitHub # devtools::install_github(&#39;rstudio/bookdown&#39;) bookdown-demo.Rproj를 클릭하여 RStudio를 실행시켜 bookdown-demo 저장소를 엽니다. R Markdown 파일인 index.Rmd를 열고 RStudio의 Build 탭에서 Build Book 버튼을 클릭합니다. 책을 PDF로 인쇄할 계획이라면 LaTeX 배포판이 필요합니다. TinyTeX(XeLaTeX 포함)를 설치하는 것이 좋습니다 : https://yihui.org/tinytex/. 이제 RStudio Viewer에서 이 책 데모의 색인 페이지를 볼 수 있습니다. R Markdown 파일을 추가하거나 변경하고 ‘Knit’ 버튼을 다시 눌러 책을 미리 볼 수 있습니다. RStudio를 사용하지 않으려면 명령 줄을 통해 책을 컴파일할 수도 있습니다. 자세한 내용은 다음 절을 참조하십시오. bookdown-demo 예제에서 꽤 많은 파일을 볼 수 있지만 대부분이 책에 필수적인 것은 아닙니다. 파일 수에 압도 당했다고 느끼면 기본적으로 하나의 파일인 index.Rmd : https://github.com/yihui/bookdown-minimal을 최소한의 예제로 대신 사용할 수 있습니다. bookdown-demo 예제에는 LaTeX 프리앰블을 사용자가 정의하고 CSS를 조정하고 GitHub에서 책을 빌드하는 방법 등과 같이 나중에 학습할 몇 가지 고급 설정이 포함되어 있습니다. "],["usage.html", "1.3 사용법", " 1.3 사용법 일반적인 bookdown 책에는 여러 장이 포함되어 있으며 하나의 장은 파일 이름 확장자가 .Rmd 인 하나의 R Markdown 파일로 저장되어 있습니다. 각 R Markdown 파일은 첫 번째 수준 제목을 사용하는 장 제목으로 바로 시작해야 합니다 (예 :# Chapter Title). 모든 R Markdown 파일은 특히 중국어, 일본어 그리고 한국어와 같은 멀티 바이트 문자가 포함된 경우 UTF-8로 인코딩해야 합니다. 다음은 하나의 예입니다 (6개의 Rmd 파일과 그 내용을 보여 주고 있습니다.) index.Rmd # Preface {-} In this book, we will introduce an interesting method. 01-intro.Rmd # Introduction This chapter is an overview of the methods that we propose to solve an **important problem**. 02-literature.Rmd # Literature Here is a review of existing methods. 03-method.Rmd # Methods We describe our methods in this chapter. 04-application.Rmd # Applications Some _significant_ applications are demonstrated in this chapter. ## Example one ## Example two 05-summary.Rmd # Final Words We have finished a nice book. 기본적으로 bookdown은 파일 이름 순서에 따라 모든 Rmd 파일을 병합합니다. 예를 들어 ‘01 -intro.Rmd ’는 ’02 -literature.Rmd’ 앞에 표시됩니다. 밑줄 _로 시작하는 Rmd 파일은 건너 뜁니다. ’index.Rmd’라는 Rmd 파일이 있는 경우 모든 Rmd 파일을 병합할 때 항상 제일 첫 번째 파일로 처리됩니다. 이 특별한 처리의 이유는 ’index.Rmd’에서 생성되는 HTML 파일인 ’index.html’이 일반적으로 웹 사이트를 볼 때 기본 색인 파일이기 때문입니다. 즉, http://yihui.org/에 접속하면, 실제로는 http://yihui.org/index.html이 열리는 것입니다. 책 디렉토리에 _bookdown.yml이라는 구성 파일을 수정하여 위의 동작을 재정의할 수 있습니다. 이 파일은 YAML 파일이며 R Markdown 사용자는 R Markdown 문서의 시작 부분에서 메타 데이터를 작성하는데도 사용해 보았기 때문에 이 형식에 익숙할 것입니다. 섹션 B.2)에서 YAML에 대해 자세히 알아보겠습니다. 특히, ’rmd_files’라는 필드를 사용하여 책에 대한 Rmd 파일의 목록과 순서를 정의할 수도 있습니다. 예를 들면 rmd_files: [&quot;index.Rmd&quot;, &quot;abstract.Rmd&quot;, &quot;intro.Rmd&quot;] 이 경우 bookdown은 이 YAML 필드에서 정의한 파일 목록을 사용합니다 (존재하는 경우 ’index.Rmd’가 목록에 추가되고 밑줄로 시작하는 파일 이름은 항상 무시됨). 책에서 HTML 및 LaTeX / PDF 출력을 모두 원하고 HTML 및 LaTeX 출력에 서로 다른 Rmd 파일을 사용하려면 두 출력 형식에 대해 이러한 파일을 별도로 지정할 수 있습니다. rmd_files: html: [&quot;index.Rmd&quot;, &quot;abstract.Rmd&quot;, &quot;intro.Rmd&quot;] latex: [&quot;abstract.Rmd&quot;, &quot;intro.Rmd&quot;] R Markdown 파일에 대해 이야기했지만 각 장의 파일들이 실제로 R Markdown 파일일 필요는 없습니다. 일반 마크 다운 파일(.md)일 수 있으며 R 코드 청크를 전혀 포함할 필요도 없습니다. bookdown을 사용하여 소설이나 시를 작성할 수도 있습니다! 현재 사용할 수 있는 주요 출력 형식에는 bookdown::pdf_book, bookdown::gitbook, bookdown::html_book 그리고 bookdown::epub_book 등이 있습니다. rmarkdown::render()와 유사한 bookdown::render_book() 함수가 있지만 출력 형식 함수를 사용하여 multiple Rmd 문서를 책으로 렌더링하도록 설계되었습니다. RStudio IDE의 콘솔 명령 줄에서 직접 이 함수를 호출하거나 RStudio IDE에서 관련 메뉴 버튼을 클릭할 수도 있습니다. 다음은 몇 가지 명령 줄의 예입니다. bookdown::render_book(&quot;foo.Rmd&quot;, &quot;bookdown::gitbook&quot;) bookdown::render_book(&quot;foo.Rmd&quot;, &quot;bookdown::pdf_book&quot;) bookdown::render_book(&quot;foo.Rmd&quot;, bookdown::gitbook(lib_dir = &quot;libs&quot;)) bookdown::render_book(&quot;foo.Rmd&quot;, bookdown::pdf_book(keep_tex = TRUE)) RStudio IDE에서 render_book() 함수와 출력 형식 함수를 사용할 수 도 있습니다 그렇게 하려면 bookdown::bookdown_site1의 값을 사용하는 site라는 YAML 필드를 정의할 수 있고, 출력 형식식 함수는 output 필드에서 사용될 수 있습니다. --- site: &quot;bookdown::bookdown_site&quot; output: bookdown::gitbook: lib_dir: &quot;book_assets&quot; bookdown::pdf_book: keep_tex: yes --- 그런 다음 RStudio의 Build 창에서 Build Book 버튼을 클릭하여 Rmd 파일을 책으로 컴파일하거나 도구 모음에서 Knit 버튼을 클릭하여 현재 장에 있는 Rmd 파일을 미리 볼 수 있습니다. _bookdown.yml의 더 많은 bookdown 구성 옵션은 섹션 4.4에 설명되어 있습니다. 이러한 구성 외에도 책의 제목, 저자 그리고 날짜 등과 같은 책의 첫 번째 Rmd 파일(예, index.Rmd 파일)의 YAML 메타 데이터 영역에 Pandoc 관련 구성을 지정할 수도 있습니다. 예를 들면 다음과 같습니다. --- title: &quot;Authoring A Book with R Markdown&quot; author: &quot;Dae Ho Kim&quot; date: &quot;2021-01-13&quot; site: &quot;bookdown::bookdown_site&quot; output: bookdown::gitbook: default documentclass: book bibliography: [&quot;book.bib&quot;, &quot;packages.bib&quot;] biblio-style: apalike link-citations: yes --- 이 함수는 bookdown::render_book() 함수를 호출합니다. "],["RenderingApproach.html", "1.4 두 가지 렌더링 접근 방식", " 1.4 두 가지 렌더링 접근 방식 모든 장들을 하나의 Rmd 파일로 병합하고 knit하는 것은 bookdown에서 책을 렌더링하는 한 가지 방법입니다. 실제로 다른 방법도 있습니다. R 세션에서 별도의 파일로 각 장을 편성하면 bookdown이 모든 장의 Markdown 출력을 병합하여 책을 렌더링합니다. 우리는 이 두 가지 접근 방식을 각각 “Merge and Knit”(M-K) 및 “Knit and Merge”(K-M)라고 합니다. 이 방법 사이의 차이는 미묘해 보일 수 있지만 사용 사례에 따라 상당히 중요할 수 있습니다. 가장 큰 차이점은 M-K는 하나의 R 세션으로 모든 챕터의 모든 코드 청크를 실행하는 반면, K-M은 개별 챕터에 대해 별도의 R 세션을 사용한다는 것입니다. M-K의 경우 이전 챕터의 R 세션 상태가 이후 챕터로 이월됩니다 (예 : 의도적으로 삭제하지 않는 한 이전 챕터에서 만든 개체를 이후 챕터에서 사용할 수 있음). 반면에, K-M의 경우는 모든 챕터가 서로 분리되어 있습니다2 각 챕터가 깨끗한 상태에서 컴파일되도록 하려면 K-M 접근방법을 사용하는게 좋습니다. M-K 접근 방식을 사용하는 경우 실행 중인 R 세션을 완전히 깨끗한 상태로 복원하는 것은 매우 까다롭고 어려울 수 있습니다. 예를 들어, 이전 장에서 로드한 패키지를 분리/언로드하더라도 R은 이러한 패키지에 등록된 S3 메서드를 정리하지 않습니다. knitr는 소스 문서에서 중복 청크 레이블을 허용하지 않기 때문에 M-K 접근방식을 사용할 때 책 장에 중복 레이블이 없는지 확인해야 합니다. 그렇지 않으면 병합된 Rmd 파일을 knit할 때 knitr에서 오류 신호를 보냅니다. 이것은 전체 책에 중복된 레이블이 있어서는 안된다는 것을 의미합니다. K-M 접근 방식은 단일 Rmd 파일 내에서만 중복 레이블을 허용하지 않습니다. K-M은 Rmd 파일이 하위 디렉터리에 있는 것을 허용하지 않지만 M-K는 허용합니다. bookdown의 기본 접근방식은 M-K입니다. K-M으로 전환하려면 render_book()을 호출할 때 new_session = TRUE 인수를 사용하거나 구성 파일인 _bookdown.yml에서 new_session: yes를 설정해야 합니다. K-M 접근 방식을 위해 _bookdown.yml에서 book_filename 옵션을 구성할 수 있지만, 확장자는 실제로 중요하지 않지만 마크다운 파일 이름이어야 하며(예 :_main.md), 심지어 book_filename: _main 처럼 확장자는 생략할 수도 있습니다. 다른 모든 설정은 M-K와 K-M 모두에서 작동합니다. 물론 한 장에 일부 파일을 쓰고 다른 장에서 읽을 수도 있지만 그에 따른 부작용을 제거하기는 쉽지 않습니다. "],["tips.html", "1.5 팁", " 1.5 팁 페이징 제약 조건(예 : LaTeX / PDF 출력의 경우)에 따른 조판은 매우 지루하고 시간이 많이 걸리는 작업 일 수 있습니다. 대부분의 경우 만족할 가능성이 거의 없기 때문에 PDF 출력을 자주 보지 않는 것이 좋습니다. 텍스트가 페이지 여백으로 넘칠 수 있고 그림이 너무 멀리 떨어져 있을 수 있습니다. 즉시 제대로 보이게 하려고 마십시오. 책을 계속 수정해 가면서 실망할 수 있고 약간만 변경하더라도 상황이 다시 엉망이 될 수 있습니다 (http://bit.ly/tbrLtx 의 예를 참조하세요). 책을 미리 보려면 HTML 출력으로 미리보기 바랍니다. 책의 내용을 완성한 후에 PDF 버전으로 작업하시고, 그러면 중요한 수정사항이 필요하지 않을 것입니다. 만일 R Markdown 문서의 특정 코드 청크를 실행하는 데 시간이 오래 걸리는 경우 청크 헤더에 cache = TRUE 청크 옵션을 추가하여 캐시할 수 있으며 이러한 코드 청크에도 다음과 같이 레이블을 지정하는 것이 좋습니다. ```{r important-computing, cache = TRUE} 5에서는 편집하면서 책을 빠르게 미리 보는 방법에 대해 설명합니다. 간단히 말해 콘솔의 명령 줄에서 preview_chapter() 함수를 사용하여 전체 책 대신 단일 장을 렌더링할 수 있습니다. 마찬가지로 serve_book()함수를 사용하면 HTML 책 페이지를 쉽게 실시간으로 View 창에서 미리 볼 수 있습니다. Rmd 파일을 수정할 때마다 책을 다시 컴파일하고 그에 따라 브라우저를 자동으로 새로 고칠 수 있습니다. "],["Components.html", "2 구성요소", " 2 구성요소 이 장에서는 코드 청크, 그림, 표, 인용, 수학 정리 및 방정식을 포함하여 bookdown으로 작성된 책의 일반적인 구성 요소 구문을 보여줍니다. 이 접근 방식은 Pandoc을 기반으로 하므로 Pandoc의 Markdown 버전 구문부터 시작합니다. "],["Markdown.html", "2.1 Markdown 구문", " 2.1 Markdown 구문 이 절에서는 Pandoc의 Markdown에 대해 매우 간략하게 소개하면서 시작합니다. Markdown에 익숙한 독자는 이 섹션을 건너 뛸 수 있습니다. Pandoc Markdown의 포괄적인 구문은 Pandoc 웹 사이트 http://pandoc.org에서 찾을 수 있습니다. 2.1.1 인라인 형식 텍스트를 밑줄이나 별표로 묶어 기울임 꼴로 만들 수 있습니다 (예 :_text_나 *text*는 text로 변환됨). 굵은 텍스트의 경우 두 개의 밑줄 (__굵은__) 또는 별표 (**굵은**)를 사용합니다. ~로 둘러싸인 텍스트는 아래 첨자로 변환되고(예 :H~2~SO~4~는 H2SO4를 렌더링 함), 비슷하게 두 개의 캐럿 (^)이 위 첨자를 생성합니다(예 :Fe^2+^는 Fe2+를 렌더링합니다). 텍스트를 ‘인라인 코드’로 표시하려면 한 쌍의 백틱을 사용합니다 (예 :`code`는 code로 렌더링함).3 작은 대문자(Small caps)는 HTML의 태그인 span을 사용하여 생성할 수 있습니다. 예를 들어, &lt;span style=\"font-variant:small-caps;\"&gt;Small Caps&lt;/span&gt; 은 Small Caps와 같이 출력됩니다. NOTICE!!! Small Caps를 사용하려면 style.css 파일에 다음의 내용이 정의되어 있어야 합니다. .smallcaps { font-variant: small-caps; } 링크는 [text](link) 형태로 생성합니다 .예를 들어, [RStudio](https://www.rstudio.com)는 RStudio에 대한 링크를 생성해 줍니다. 마찬가지로, 이미지 삽입 구문도 비슷한데, 단지 맨 앞에 감탄부호(!)를 붙여 줍니다. 예를 들어, ![Important image](images/important.png) 는 와 같이 이미지를 출력해 줍니다. 각주는 캐럿 기호(^) 다음의 대괄호([]) 안에 기입합니다. 예를 들어, ^[This is a footnote.]는 각주4와 같이 출력됩니다. 인용에 대해서는 섹션 2.8에서 설명합니다. 2.1.2 블록 수준의 요소 장/절의 제목들은 1개 이상의 # 기호 다음에 작성합니다. 예를 들어, # 제1수준 제목 ## 제2수준 제목 ### 제3수준 제목 특정 제목에 번호를 매기고 싶지 않으면 제목 끝에 {-}를 추가합니다 (예 : # 서론 {-} 순서가 없는 목록의 항목은 *, - 또는 +로 시작하며, 하위 목록은 네 개의 공백으로 들여 쓰기합니다. 다른 목록 내에 하나의 목록을 중첩할 수 있습니다. - 항목 - 항목 - 항목 - 항목 - 항목 그 결과는 다음과 같습니다: 항목 항목 항목 항목 항목 번호가 붙은 목록의 항목은 숫자로 시작합니다(중첩된 목록의 규칙은 위와 동일). 예를 들어, 1. 제1항목 1. 제1-1항목 2. 제1-2항목 2. 제2항목 3. 제3항목 그 결과는 Markdown과 크게 다르지 않습니다: 제1항목 제1-1항목 제1-2항목 제2항목 제3항목 인용문은 &gt; 다음에 작성합니다. 예를 들어, &gt; &quot;I thoroughly disapprove of duels. If a man should challenge me, I would take him kindly and forgivingly by the hand and lead him to a quiet place and kill him.&quot; &gt; &gt; --- Mark Twain 실제 출력결과(이 책에서는 인용문의 스타일도 변경할 수 있습니니다.) : “I thoroughly disapprove of duels. If a man should challenge me, I would take him kindly and forgivingly by the hand and lead him to a quiet place and kill him.” –— Mark Twain 일반 코드 블록은 세 개 이상의 백틱 뒤에 작성할 수 있으며 블록을 네 개의 공백으로 들여쓰기 할 수도 있습니다. ``` This text is displayed verbatim / preformatted ``` Or indent by four spaces: This text is displayed verbatim / preformatted 2.1.3 수식 표현 인라인 LaTeX 방정식은 LaTeX 구문을 사용하여 달러($ $) 기호의 내부에 작성할 수 있습니다. 예 :$f(k) = {n \\choose k} p^{k}(1-p)^{n-k}$로 표시되는 스타일의 수학 표현식은 \\(f(k) = {n \\choose k} p^{k}(1-p)^{n-k}\\))로 표시가 됩니다. 그리고 두 개의 달러 기호($$ $$) 안에 수식을 작성할 수도 있습니다. 예를 들어, $$f(k) = {n \\choose k}p^{k}(1-p)^{n-k}$$의 출력은 다음과 같습니다: \\[f(k) = {n \\choose k} p^{k} (1-p)^{n-k}\\] 그리고 $ $ 또는 $$ $$내에서 수학 환경을 사용할 수도 있습니다. 예를 들어, 아래의 표현은 $$\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}$$ 다음과 같은 배열(array)로 표현해 줍니다. \\[\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}\\] 다음의 표현은 $$X = \\begin{bmatrix}1 &amp; x_{1}\\\\ 1 &amp; x_{2}\\\\ 1 &amp; x_{3} \\end{bmatrix}$$ 다음과 같이 대괄호 안에 행렬을 표시해 줍니다. \\[X = \\begin{bmatrix}1 &amp; x_{1}\\\\ 1 &amp; x_{2}\\\\ 1 &amp; x_{3} \\end{bmatrix}\\] 다음의 표현은 $$\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}$$ 큰 괄호 안에 행렬을 표시해 줍니다. \\[\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}\\] 그리고 다음의 표현은 $$\\begin{vmatrix}a &amp; b\\\\ c &amp; d \\end{vmatrix}=ad-bc$$ 다음과 같이 행렬식으로 표시해 줍니다. \\[\\begin{vmatrix}a &amp; b\\\\ c &amp; d \\end{vmatrix}=ad-bc\\] 리터럴 백틱()을 포함하려면 바깥쪽에 더 많은 백틱을 사용해야 합니다. 예를 들어 두 개의 백틱을 사용하여 내부에 하나의 백틱을 유지할 수 있습니다 (`code`는 code로 렌더링 함). 이것은 각주의 예를 보여준다. "],["MarkdownExpand.html", "2.2 Markdown의 확장", " 2.2 Markdown의 확장 Pandoc의 Markdown은 원래 Markdown 구문보다 훨씬 더 풍부하지만 학술적 문서 작성에 필요한 많은 것들이 여전히 부족합니다. 예를 들어 수학 방정식을 지원하지만 다중 페이지 HTML 또는 EPUB 출력에서 방정식에 번호를 매기고 참조할 수 없습니다. bookdown에서는 몇 가지 Markdown 확장 기능을 제공하여 그러한 부족한 부분을 메워주고 있습니다. 2.2.1 수식의 번호와 참고 수식에 번호를 붙이고 참고하려면, 수식 환경에 수식을 입력하고 (\\#eq:label) 구문을 이용하여 라벨을 붙일 수 있습니다. 예를 들어, \\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} (\\#eq:binom) \\end{equation} 그러면 다음과 같은 수식을 출력합니다: \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{2.1} \\end{equation}\\] 이 수식에서 (\\#eq:binom)을 삽입해서 위의 수식은 binom 이라는 라벨이 부여되었고, 이 라벨은 본문에 \\@ref(eq:binom)로 삽입하여 수식을 참조할 수도 있습니다. 예를 들어, 수식 (2.1)을 참고하기 바랍니다. 수학 방정식의 라벨은 bookdown에서 접두사 eq:로 시작해야 합니다. bookdown의 모든 라벨에는 영숫자 문자, :, - 그리고/또는 /만 포함되어야 합니다. 수식의 참조는 LaTeX / PDF 출력에 가장 적합하며 Word 출력이나 전자 책에서는 잘 지원되지 않습니다. HTML 출력의 경우 bookdown은 라벨이 있는 방정식에만 번호를 지정할 수 있습니다. 라벨이 없는 방정식은 equation* 환경을 사용하거나 방정식에 \\nonumber 또는 \\notag를 추가하여 번호가 매겨지지 않았는지 확인하십시오. 동일한 규칙이 eqnarray, gather, align 등과 같은 다른 수학 환경에도 적용됩니다(예 :align *환경을 사용할 수 있음). 아래에서는 몇 가지 수학 방정식 환경을 더 보여 줍니다. 다음은 equation* 환경을 사용하는 숫자가 지정되지 않은 방정식입니다. \\begin{equation*} \\frac{d}{dx}\\left( \\int_{a}^{x} f(u)\\,du\\right)=f(x) \\end{equation*} \\[\\begin{equation*} \\frac{d}{dx}\\left( \\int_{a}^{x} f(u)\\,du\\right)=f(x) \\end{equation*}\\] 아래는 align 환경을 보여주고 있으며 라벨을 eq:align으로 지정하고 있습니다 (2.2). \\begin{align} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] (\\#eq:align) \\end{align} \\[\\begin{align} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\tag{2.2} \\end{align}\\] 다음의 예는 equation 내에서 split 환경을 보여 주고 있으며, 또한 수식의 라벨을 (eq:var-beta)로 지정함으로써 수식 번호 (2.3)를 공유할 수 있습니다. \\begin{equation} \\begin{split} \\mathrm{Var}(\\hat{\\beta}) &amp; =\\mathrm{Var}((X&#39;X)^{-1}X&#39;y)\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)((X&#39;X)^{-1}X&#39;)&#39;\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)X(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\sigma^{2}IX(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}\\sigma^{2} \\end{split} (\\#eq:var-beta) \\end{equation} \\[\\begin{equation} \\begin{split} \\mathrm{Var}(\\hat{\\beta}) &amp; =\\mathrm{Var}((X&#39;X)^{-1}X&#39;y)\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)((X&#39;X)^{-1}X&#39;)&#39;\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)X(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\sigma^{2}IX(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}\\sigma^{2} \\end{split} \\tag{2.3} \\end{equation}\\] 기본적으로 align 환경의 각 줄에는 방정식 번호가 할당됩니다. 그런데 위의 align 예제 (2.2)에서는 \\notag를 사용하여 첫 번째 줄의 번호를 숨기고 있습니다. 그리고 split 환경 예제 (2.3) 에서는 단일 번호가 할당되었습니다. 2.2.2 정리와 증명 정리와 증명은 일반적으로 수학 논문들과 책에서 사용됩니다. 그러나 그 이름으로 오해하지는 마십시오. “정리(theorem)”는 번호가 매겨지고 라벨이 지정된 환경이며 꼭 수학의 정리일 필요는 없습니다 (예 : 수학과 무관한 예일 수도 있음). 마찬가지로 “증명(proof)”은 번호가 지정되지 않은 환경입니다. 이 섹션에서는 명시적으로 언급하지 않는 한 “정리”와 “증명”의 일반적 의미를 사용하겠습니다. bookdown에서 지원되는 정리 환경의 유형은 표 2.1과 같습니다. Table 2.1: bookdown의 정리 환경 환경 출력 이름 접두어 theorem Theorem thm lemma Lemma lem corollary Corollary cor proposition Proposition prp conjecture Conjecture cnj definition Definition def example Example exm exercise Exercise exr 정리(theorem)를 작성하려면 아래와 같은 구문을 사용할 수 있습니다. ```{theorem} Here is my theorem. ``` 그리고 표 2.1에 있는 것처럼 정리의 환경 이름을 ```{theorem}에서 ```{lemma}로 바꾸면 lemma 환경으로 작성할 수 있다. 정리는 name 옵션을 가질 수 있으므로 그 이름은 다음과 같이 작성될 수 있습니다. ```{theorem, name=&quot;피타고라스 정리&quot;} 직각 삼각형의 경우 $c$가 빗변의 길이를 나타내고 $a$와 $b$가 다른 두 변의 길이를 나타내면 $a$, $b$ 그리고 $c$의 관계는 다음과 같이 표현된다. `$$a^2 + b^2 = c^2$$` ``` 위의 내용은 다음과 같이 표시가 됩니다. Theorem 2.1 (피타고라스 정리) 직각 삼각형의 경우 \\(c\\)가 빗변의 길이를 나타내고 \\(a\\)와 \\(b\\)가 다른 두 변의 길이를 나타내면 \\(a\\), \\(b\\) 그리고 \\(c\\)의 관계는 다음과 같이 표현된다. \\[a^2 + b^2 = c^2\\] 만일 이 정리를 본문에서 참조하고자 한다면, label을 사용을 해야 합니다. 그런 다음에 본문에서 이 라벨을 참조하면 됩니다. 그런데, 라벨은 다음과 같이 ```{theorem, 다음에 작성합니다. ```{theorem, label=&quot;foo1&quot;} foo1 이라는 라벨이 붙여진 정리 ``` label 이라는 옵션 이름은 생략할 수 있습니다. 즉, 다음의 정리는 bar 라가 정리의 라벨이 됩니다. ```{theorem, bar} bar 라는 라벨이 붙여진 정리 ``` 이제 정리에 라벨을 지정한 후 \\@ref(prefix:label) 구문을 사용하여 참조할 수 있습니다. 각각의 prefix 값은 표 2.1의 각 환경에 대한 접두어(Label Prefix) 열을 참조하기 바랍니다. 예를 들어, 아래에 라벨(pyth)이 지정되고 이름(name =)이 붙여진 정리가 있다면 \\@ref(thm:pyth)는 정리 번호 2.2를 생성합니다. ```{theorem, pyth, name=&quot;피타고라스 정리&quot;} 직각 삼각형의 경우 $c$가 빗변의 길이를 나타내고 $a$와 $b$가 다른 두 변의 길이를 나타내면 $a$, $b$ 그리고 $c$의 관계는 다음과 같이 표현된다. `$$a^2 + b^2 = c^2$$` ``` Theorem 2.2 (피타고라스 정리) 직각 삼각형의 경우 \\(c\\)가 빗변의 길이를 나타내고 \\(a\\)와 \\(b\\)가 다른 두 변의 길이를 나타내면 \\(a\\), \\(b\\) 그리고 \\(c\\)의 관계는 다음과 같이 표현된다. \\[a^2 + b^2 = c^2\\] 이외에도 현재 지원되는 증명 환경은 proof, remark, solution 등이 있습니다. 구문은 정리 환경과 유사하며 증명 환경의 이름도 지정할 수 있습니다. 유일한 차이점은 번호가 지정되지 않기 때문에 참조할 수 없다는 것입니다. 출력이 PDF, HTML 또는 EPUB 인지에 관계없이 이러한 모든 정리 및 증명 환경이 즉시 작동하게 하였습니다. LaTeX 또는 HTML 전문가라면 어쨌든 이러한 환경의 스타일을 사용자가 정의할 수 있습니다 (4장 참조). CSS를 사용하면 HTML에서 쉽게 사용자 정의를 할 수 있으며 각 환경은 &lt;div class = \"lemma\"&gt; &lt;/div&gt;처럼 &lt;div&gt; &lt;/div&gt; 안에 환경 이름을 삽입하면 됩니다 LaTeX 출력의 경우 definition, example, 그리고 exercise 환경에서는 스타일을 definition으로, proof와 remark 환경에서는 remark로 미리 정의했습니다. 다른 모든 환경은 plain 스타일을 사용합니다. 스타일 정의는 amsthm 패키지의 \\theoremstyle{} 명령을 통해 수행됩니다. 정리는 기본적으로 장별로 번호가 매겨집니다. 문서에 장이 없으면 대신 섹션으로 번호가 매겨집니다. 전체 문서의 번호가 지정되지 않은 경우(output 형식 옵션에 number_sections = FALSE로 설정된 경우), 모든 정리는 1, 2,…, N 등과 같이 순차적으로 번호가 지정됩니다. LaTeX는 정리 환경을 순차적으로 번호 매기도록 지원합니다. 예를 들어, 정리와 렘마가 동일한 카운터를 공유합니다. bookdown의 HTML / EPUB 출력은 지원하지 않습니다. 여러분 자신의 정리 환경을 정의하여 LaTeX 프리앰블에서 번호 매기기 체계를 변경할 수도 있습니다. \\newtheorem{theorem}{Theorem} \\newtheorem{lemma}[theorem]{Lemma} bookdown이 LaTeX 프리앰블에서 \\newtheorem{theorem}을 감지하면 기본 정리 정의를 작성하지 않으므로 모든 정리 환경을 직접 정의해야 합니다. 단순성과 일관성을 위해 이 작업을 수행하지 않는 것이 좋습니다. PDF의 ’Theorem 18’이 HTML의 ’Theorem 2.4’가 될 때 혼란스러울 수 있가 때문입니다. 청크 옵션이 echo = FALSE로 설정되면 정리 및 증명 환경이 숨겨집니다. 항상 표시되도록 하려면 청크 옵션 echo = TRUE를 추가할 수 있습니다. ```{theorem, echo=TRUE} 여기는 내 정리이다. ``` 아래에서는 정리 및 증명 환경의 더 많은 예5를 보여 주므로 bookdown에서 기본 스타일을 볼 수 있습니다. Definition 2.1 랜덤 변수 \\(X\\)의 특성 함수는 다음과 같이 정의됩니다. \\[\\begin{equation} \\varphi_{X} (t) = \\operatorname {E} \\left[e^{itX}\\right], \\; t\\in\\mathcal{R} \\end{equation}\\] Example 2.1 확률 밀도 함수 \\(f(x)=\\mathbf{1}_{x \\in [0,1]}\\)에서 \\(XU(0,1)\\)의 특성 함수를 도출합니다. \\[\\begin{equation*} \\begin{split} \\varphi _{X}(t) &amp;= \\operatorname {E} \\left[e^{itX}\\right]\\\\ &amp; =\\int e^{itx}f(x)dx\\\\ &amp; =\\int_{0}^{1}e^{itx}dx\\\\ &amp; =\\int_{0}^{1}\\left(\\cos(tx)+i\\sin(tx)\\right)dx\\\\ &amp; =\\left.\\left(\\frac{\\sin(tx)}{t}-i\\frac{\\cos(tx)}{t}\\right)\\right|_{0}^{1}\\\\ &amp; =\\frac{\\sin(t)}{t}-i\\left(\\frac{\\cos(t)-1}{t}\\right)\\\\ &amp; =\\frac{i\\sin(t)}{it}+\\frac{\\cos(t)-1}{it}\\\\ &amp; =\\frac{e^{it}-1}{it} \\end{split} \\end{equation*}\\] \\(e^{ix}=\\cos(x)+i\\sin(x)\\) 를 두 번 사용하고 있음을 주목하기 바랍니다. Lemma 2.1 두 개의 확률변수 \\(X_1\\), \\(X_2\\)에 대하여 두 변수는 다음의 필요충분 조건을 만족시키면 동일한 확률 분포를 가집니다. \\[φX1(t)=φX2(t)\\] Theorem 2.3 \\(X_1\\), …, \\(X_n\\) 등이 독립적인 확률변수이고, \\(a_1\\), …, \\(a_n\\) 등이 상수이면, 다음의 선형 결합 \\(S_n=\\sum_{i=1}^na_iX_i\\)의 특성 함수는 다음과 같습니다. \\[\\varphi _{S_{n}}(t)=\\prod_{i=1}^n\\varphi _{X_i}(a_{i}t)=\\varphi _{X_{1}}(a_{1}t)\\cdots \\varphi _{X_{n}}(a_{n}t)\\] Proposition 2.1 독립적인 포아송 확률 변수의 합 \\(X_i \\sim \\mathrm{Pois}(\\lambda_i),\\: i=1,2,\\cdots,n\\)의 분포는 \\(\\mathrm{Pois}(\\sum_{i=1}^n\\lambda_i )\\)입니다. Proof. \\(X\\sim\\mathrm{Pois}(\\lambda)\\)의 특성 함수는 \\(\\varphi _{X}(t)=e^{\\lambda (e^{it}-1)}\\)입니다. \\(P_n=\\sum_{i=1}^nX_i\\)이라고 할 때, 정리 2.3로 부터 다음의 사실을 알 수 있습니다. \\[\\begin{equation*} \\begin{split} \\varphi _{P_{n}}(t) &amp; =\\prod_{i=1}^n\\varphi _{X_i}(t) \\\\ &amp; =\\prod_{i=1}^n e^{\\lambda_i (e^{it}-1)} \\\\ &amp; = e^{\\sum_{i=1}^n \\lambda_i (e^{it}-1)} \\end{split} \\end{equation*}\\] 이것은 파라미터가 \\(\\lambda=\\sum_{i=1}^n \\lambda_i\\)인 포아송 확률변수의 특성 함수입니다. Lemma 2.1로 부터, \\(P_n\\)의 분포는 \\(\\mathrm{Pois}(\\sum_{i=1}^n\\lambda_i)\\)입니다. Remark. 어떤 경우에는 특성 함수를 이용하여 독립적인 확률변수 합의 분포를 구하는 것이 매우 편리하고 쉽습니다. Corollary 2.1 두 개의 독립적인 확률변수 \\(X_1\\)과 \\(X_2\\)의 합의 특성 함수는 \\(X_1\\)과 \\(X_2\\)의 특성 함수의 곱입니다. 즉, \\[\\varphi _{X_1+X_2}(t)=\\varphi _{X_1}(t) \\varphi _{X_2}(t)\\] Exercise 2.1 (표본평균의 특성 함수) Let \\(\\bar{X}=\\sum_{i=1}^n \\frac{1}{n} X_i\\)가 독립적이고 동일하게 분포하고(i.i.d) 각각의 특성 함수가 \\(\\varphi _{X}\\)인 확률변수의 표본평균이라고 할 때, \\(\\bar{X}\\)의 특성 함수를 구하시오. Solution. 정리 2.3를 적용하면 다음과 같습니니다. \\[\\varphi _{\\bar{X}}(t)=\\prod_{i=1}^n \\varphi _{X_i}\\left(\\frac{t}{n}\\right)=\\left[\\varphi _{X}\\left(\\frac{t}{n}\\right)\\right]^n\\]. 2.2.3 특수 헤더 bookdown에서 다르게 처리되는 몇 가지 특별한 유형의 첫 번째 수준 헤더가 있습니다. 첫 번째 유형은 (PART) 토큰으로 시작하는 번호가 지정되지 않은 헤더입니다. 이러한 종류의 헤더는 부(Part) 제목으로 번역됩니다. LaTeX에 익숙하다면 기본적으로\\part{}를 의미합니다. 책에 많은 수의 장이 있는 경우 이를 여러 부분으로 구성할 수 있습니다. # (PART) Part I {-} # Chapter One # Chapter Two # (PART) Part II {-} # Chapter Three ’Part I’의 첫번째 제목 바로 다음에 장 제목을 작성해야 합니다. Part의 제목에 번호를 매기면 안되는 경우 (PART) 대신 (PART\\*) (*앞의 백 슬래시가 필요함)를 사용할 수 있습니다. 두 번째 유형은 (APPENDIX)로 시작하는 번호가 지정되지 않은 헤더로, 이 헤더 뒤의 모든 장이 부록임을 나타냅니다. # Chapter One # Chapter Two # (APPENDIX) Appendix {-} # Appendix A # Appendix B ## Appendix 부록의 번호 지정 스타일은 LaTeX / PDF 및 HTML 출력(일반적으로 A, A.1, A.2, B, B.1,… 형식)에서 자동으로 변경됩니다. 이 기능은 전자 책이나 Word 출력에는 사용할 수 없습니다. 2.2.4 텍스트 참조 일부 텍스트에 라벨을 할당하고 문서의 다른 곳에서 라벨을 사용하여 텍스트를 참조할 수 있습니다. 이것은 긴 그림/표 캡션 (섹션 2.4와 2.5에 특히 유용할 수 있습니다. 이 경우 일반적으로 청크 헤더(예 :fig.cap = \"A long long figure caption.') 또는 R 코드(예 :kable (caption = \"A long long table caption.\"))에 전체 문자열을 작성해야만 합니다. 이러한 캡션에 특수 HTML 또는 LaTeX 문자가 포함된 경우에도 유용합니다. 예를 들어, 그림 캡션에 밑줄이 포함된 경우 HTML 출력에서는 작동하지만 LaTeX에서는 밑줄을 이스케이프해야 하므로 LaTeX 출력에서는 작동하지 않을 수 있습니다. 텍스트 참조의 구문은 (ref:label)text이며 여기서 label은 text 문서 전체에서 고유한 라벨입니다.6 위와 아래에 빈 줄이 있는 별도의 단락에 있어야 합니다. 단락은 여러 줄로 둘러 싸여서는 안되며 공백으로 끝나서는 안됩니다. 예를 들면 (ref:foo) Define a text reference **here**. 그런 다음 그림/표 캡션에 (ref:foo)를 사용할 수 있습니다. 텍스트는 단일 단락이면 마크 다운이 지원하는 모든 것을 포함할 수 있습니다. 다음은 하나의 완전한 예입니다. A normal paragraph. (ref:foo) **base** R graphics를 이용한 `cars` 데이터의 산포도. ```{r foo, fig.cap=&#39;(ref:foo)&#39;}` plot(cars) # a scatterplot ```` 텍스트 참조는 문서의 어디에서나 사용할 수 있습니다 (그림 캡션에 국한되지 않음). 여러 위치에서 텍스트의 일부를 재사용하려는 경우에도 유용할 수 있습니다. 위키피디아 페이지 https://en.wikipedia.org/wiki/Characteristic_function_(probability_theory)에서 일부 예를 발췌하였다. 코드 청크 라벨의 사용을 고려할 수 있습니다. "],["RCode.html", "2.3 R 코드", " 2.3 R 코드 R Markdown/knitr 문서에는 R 코드 청크와 인라인 R 코드 등 두 가지 유형의 R 코드가 있습니다. 후자의 구문은 r R_CODE 이며 다른 문서 요소와 함께 인라인으로 포함될 수 있습니다. R 코드 청크는 일반 코드 블록처럼 보이지만 세 개의 백틱 뒤에{r}이 있고 (선택적으로){}안에 청크 옵션을 기입하게 됩니다. ```{r chunk-label, echo = FALSE, fig.cap = &#39;A figure caption.&#39;} 1 + 1 rnorm(10) # 10 random numbers plot(dist ~ speed, cars) # a scatterplot ``` knitr 청크 옵션에 대한 자세한 내용은 Xie (2015) 또는 웹 페이지 http://yihui.org/knitr/options 를 참조하세요. 책의 경우 각 장 앞/뒤에 추가 R 코드를 실행할 수 있습니다. 섹션 4.4의 before_chapter_script 및 after_chapter_script를 참조하세요. References "],["Figure.html", "2.4 그림", " 2.4 그림 기본적으로 knitr로 생성되어 출력되는 그림에는 캡션이 없습니다. 즉, R 코드에서 생성된 위치에 배치됩니다. 다음은 그러한 예입니다. par(mar = c(4, 4, 0.1, 0.1)) plot(pressure, pch = 19, type = &quot;b&quot;) 이런 식으로 그림을 편집하는데에 따르는 단점은 현재 페이지에 그림을 배치하기에 충분한 공간이 없을 때 페이지 하단에 도달하거나 (따라서 페이지 여백을 초과 함) 현재 페이지 하단에 큰 흰색 여백을 남기면서 다음 페이지로 밀릴 수 있다는 것입니다. 이것이 기본적으로 LaTeX에 “플로팅 환경”이 있는 이유입니다. 여러 페이지로 나눌 수 없는 요소(그림과 같이)는 플로팅 환경에 배치되어 충분한 공간이 있는 페이지로 플로팅할 수 있습니다. 하지만 앞뒤로 떠 다니는 단점도 있습니다. 즉, 독자는 현재 페이지에 언급된 그림을 찾기 위해 다른 페이지로 이동해야 함을 의미합니다. 이것은 고정된 크기의 여러 페이지에 항목을 조판해야 하는 자연스러운 결과입니다. 그러나 이 문제는 HTML에는 존재하지 않습니다. 모든 것이 하나의 단일 페이지에 연속적으로 배치 될 수 있고 (아마도 무한한 높이로) 동일한 페이지 크기의 여러 페이지에 어떤 것도 분할할 필요가 없기 때문입니다. chunk 옵션 fig.cap을 통해 코드 청크에 그림 캡션을 할당하면 R 플롯이 그림 환경에 배치되고 자동으로 라벨이 지정되고, 번호가 지정되며, 상호 참조될 수도 있습니다. 그림 환경의 라벨은 코드 청크의 라벨에서 생성됩니다. 예를 들어 청크 라벨이 ‘foo’인 경우 그림 라벨은’fig:foo‘가됩니다(접두사’fig:‘가’foo’앞에 추가됨). 그림을 참조하려면\\ @ref (label)7 구문을 사용합니다. 여기서 label은 그림 라벨입니다. 예 : fig:foo. 그림 캡션 내에서 마크 다운 형식을 활용하려면 텍스트 참조를 사용해야 합니다 (2.2.4 섹션 참조 ). 예를 들어, 출력 형식이 LaTeX/PDF 인 경우 ‘_italic text_’가 포함된 그림 캡션은 LaTeX에서 밑줄이 특수 문자이므로 작동하지 않지만 텍스트 참조를 사용하는 경우, 출력이 LaTeX 일 때 코드일 때’_italic text_’는 LaTeX로 변환됩니다. 코드 청크에서 생성된 그림이나 표를 상호 참조하려면 청크 라벨에 영숫자문자(a-z, A-Z, 0-9), 슬래시 (/) 또는 대시 (-) 만 포함되어 있는지 확인하십시오. 밑즐(-)은 사용할 수 없습니다. 청크 옵션 fig.asp는 플롯의 종횡비, 즉 그림 높이/너비의 비율을 설정하는 데 사용할 수 있습니다. 그림 너비가 6 인치 (fig.width = 6)이고, fig.asp = 0.7 인 경우, 그림의 높이는 fig.width * fig.asp = 6 * 0.7 = 4.2에 의해 자동으로 계산됩니다. 그림 2.1은 아래 코드로 생성된 청크 옵션 fig.asp = 0.7,fig.width = 6 그리고 fig.align = 'center'을 사용한 예입니다: par(mar = c(4, 4, 0.1, 0.1)) plot(pressure, pch = 19, type = &quot;b&quot;) Figure 2.1: A figure example with the specified aspect ratio, width, and alignment. 플롯의 실제 크기는 청크 옵션 fig.width와 fig.height (그래픽 장치에서 생성된 플롯의 크기)에 의해 결정되며, 청크 옵션 out.width 및 out.height을 통해 플롯의 출력 크기를 지정할 수 있습니다. 이 두 옵션의 가능한 값은 문서의 출력 형식에 따라 다릅니다. 예를 들어 out.width = '30%'는 HTML 출력에 유효한 값이지만 LaTeX/PDF 출력에는 유효하지 않습니다. 그러나 knitr는 x%형식의 out.width에 대한 백분율 값을 (x / 100) \\linewidth로 자동 변환합니다. 예를 들어 out.width = '70%'는 출력 형식이 LaTeX 인 경우 .7\\linewidth로 처리됩니다. 이를 통해 일관된 방식으로 플롯의 상대적 너비를 지정할 수 있습니다. 그림 2.2은 out.width = 70%의 예입니다. par(mar = c(4, 4, 0.1, 0.1)) plot(cars, pch = 19) Figure 2.2: A figure example with a relative width 70%. 하나의 그림 환경에 여러 플롯을 배치하려면 fig.show ='hold' 청크 옵션을 사용하여 코드 청크에서 여러 플롯을 보유하고 하나의 환경에 포함해야 합니다. 모든 플롯의 너비의 합이 현재 선 너비보다 작거나 같은 경우 플롯을 나란히 배치할 수도 있습니다. 예를 들어 두 플롯의 너비가 ’50%’인 경우 나란히 배치됩니다. 마찬가지로 out.width = '33%'를 지정하여 3 개의 플롯을 한 줄에 배열할 수 있습니다. 그림 2.3는 각각 너비가 ’50%’인 2 개 플롯을 보여주는 예입니다. par(mar = c(4, 4, 0.1, 0.1)) plot(pressure, pch = 19, type = &quot;b&quot;) plot(cars, pch = 19) Figure 2.3: Two plots placed side by side. 때때로 R 코드에서 생성되지 않은 특정 이미지가 있을 수 있으며 knitr::include_graphics()함수를 통해 R Markdown에 포함할 수 있습니다. 그림 2.4는 그림 환경에 포함된 세 개의 knitr 로고의 예입니다. 하나 또는 여러 개의 이미지 경로를 include_graphics() 함수에 전달할 수 있으며, 일반 R 플롯에 적용되는 모든 청크 옵션도 이러한 이미지에 적용됩니다. 예를 들어 출력 문서에서 out.width = '33%'를 사용하여 이러한 이미지의 너비를 설정할 수 있습니다. . knitr::include_graphics(rep(&quot;images/search_console/knit-logo.png&quot;, 3)) Figure 2.4: Three knitr logos included in the document from an external PNG image file. include_graphics()를 사용하면 몇 가지 이점이 있습니다. 문서 출력 형식에 대해 걱정할 필요가 없습니다. 예를 들어 출력 형식이 LaTeX인 경우 LaTeX 명령 \\includegraphics{}를 사용하여 이미지를 포함할 수 있으며, 출력 형식이 Markdown 인 경우 ![]()를 사용해야 합니다. knitr의 함수 include_graphics()는 이러한 세부 사항을 자동으로 처리합니다. 이미지 속성을 제어하는 구문은 R 코드에서 이미지를 생성할 때와 동일합니다. 예를 들어 청크 옵션 fig.cap,out.width와 fig.show는 여전히 동일한 의미를 갖습니다. include_graphics()는 출력 형식이 LaTeX이고 PDF 그래픽 파일이 있을 때 자동으로 PDF 그래픽을 사용할 수 있을 만큼 똑똑합니다. 예를 들어 이미지 경로 foo/bar.png는 foo/bar.pdf로 자동 대체될 수 있습니다. PDF 이미지는 종종 LaTeX/PDF 출력에서 래스터 이미지보다 품질이 더 좋습니다. 이 기능을 사용하려면 인수 auto_pdf = TRUE를 설정하거나 전역 옵션 options(knitr.graphics.auto_pdf = TRUE)를 설정하여 R 세션에서 이 기능을 전역적으로 활성화합니다. 동일한 비율을 사용하여 이러한 이미지의 비율을 쉽게 조정할 수 있습니다. 이는 기본적으로 청크 옵션 dpi에서 값을 가져 오는 dpi(dpi, dot per inch 인치당 도트 수) 인수를 통해 수행 할 수 있습니다. 숫자 값이고 청크 옵션 out.width가 설정되지 않은 경우 이미지의 출력 너비는 실제 너비 (픽셀)를 dpi로 나눈 값이되고 단위는 인치가 됩니다. 예를 들어 크기가 672 x 480 인 이미지의 경우 출력 너비는 dpi = 96 일 때 7 인치 (7in)가 됩니다. 이 기능을 사용하려면 png 그리고/또는 jpeg 패키지가 설치되어 있어야 합니다. 청크 옵션out.width에 NULL이 아닌 값을 제공하거나 include_graphics(dpi = NA)를 사용하여 항상 (인치로) 너비의 자동 계산을 재정의 할 수 있습니다. 선행 백 슬래시(\\)를 잊지 마세요! 또한ref 뒤에있는 괄호()에 유의하십시오. 중괄호{}가 아닙니다 "],["Table.html", "2.5 표", " 2.5 표 현재 표를 생성하는 가장 편리한 방법은 knitr::kable() 함수입니다. knitr에는 bookdown과 함께 작동하도록 하는 내부 트릭이 있으며 사용자는 이러한 구현의 세부 사항에 대해 알 필요가 없습니다. 이 섹션의 뒷부분에서 다른 패키지와 기능을 사용하는 방법에 대해 설명할 것입니다. 그림과 마찬가지로 캡션이 있는 표에도 번호가 매겨지고 참조될 수 있습니다. kable()함수는 테이블 환경에 대한 라벨을 자동으로 생성합니다. 이 라벨은 접두사 tab :과 청크 라벨입니다. 예를 들어, 라벨이 foo 인 코드 청크의 표 라벨은 tab:foo가 되며 여전히 \\@ref(label) 구문을 사용하여 표를 참조할 수 있습니다. 표 2.2은 간단한 예입니다. knitr::kable( head(mtcars[, 1:8], 10), booktabs = TRUE, caption = &#39;A table of the first 10 rows of the mtcars data.&#39; ) Table 2.2: A table of the first 10 rows of the mtcars data. mpg cyl disp hp drat wt qsec vs Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 단일 테이블 환경에 여러 테이블을 배치하려면 데이터 개체(일반적으로 R의 데이터 프레임)를 목록으로 래핑합니다. 예는 표 2.3을 참조하세요. 이 기능은 HTML 및 PDF 출력에서만 사용할 수 있습니다. knitr::kable( list( head(iris[, 1:2], 3), head(mtcars[, 1:3], 5) ), caption = &#39;A Tale of Two Tables.&#39;, booktabs = TRUE ) Table 2.3: A Tale of Two Tables. Sepal.Length Sepal.Width 5.1 3.5 4.9 3.0 4.7 3.2 mpg cyl disp Mazda RX4 21.0 6 160 Mazda RX4 Wag 21.0 6 160 Datsun 710 22.8 4 108 Hornet 4 Drive 21.4 6 258 Hornet Sportabout 18.7 8 360 표가 PDF에서 분리되는 것(floating)을 원치 않을 경우 여러 페이지에 걸쳐 표를 나눌 수 있는 LaTeX 패키지 longtable를 사용할 수 있습니다. longtable을 사용하려면 longtable = TRUE를 kable()에 전달하고 LaTeX 프리앰블 (섹션 4.1에서 LaTeX 프리앰블을 맞춤 설정하는 방법 참고)에 \\usepackage{longtable}을 포함해야 합니다. 물론 이것은 HTML의 테이블은 플로팅할 필요가 없기 때문에 HTML 출력과는 무관합니다. knitr::kable( iris[1:55, ], longtable = TRUE, booktabs = TRUE, caption = &#39;A table generated by the longtable package.&#39; ) Table 2.4: A table generated by the longtable package. Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa 5.4 3.4 1.7 0.2 setosa 5.1 3.7 1.5 0.4 setosa 4.6 3.6 1.0 0.2 setosa 5.1 3.3 1.7 0.5 setosa 4.8 3.4 1.9 0.2 setosa 5.0 3.0 1.6 0.2 setosa 5.0 3.4 1.6 0.4 setosa 5.2 3.5 1.5 0.2 setosa 5.2 3.4 1.4 0.2 setosa 4.7 3.2 1.6 0.2 setosa 4.8 3.1 1.6 0.2 setosa 5.4 3.4 1.5 0.4 setosa 5.2 4.1 1.5 0.1 setosa 5.5 4.2 1.4 0.2 setosa 4.9 3.1 1.5 0.2 setosa 5.0 3.2 1.2 0.2 setosa 5.5 3.5 1.3 0.2 setosa 4.9 3.6 1.4 0.1 setosa 4.4 3.0 1.3 0.2 setosa 5.1 3.4 1.5 0.2 setosa 5.0 3.5 1.3 0.3 setosa 4.5 2.3 1.3 0.3 setosa 4.4 3.2 1.3 0.2 setosa 5.0 3.5 1.6 0.6 setosa 5.1 3.8 1.9 0.4 setosa 4.8 3.0 1.4 0.3 setosa 5.1 3.8 1.6 0.2 setosa 4.6 3.2 1.4 0.2 setosa 5.3 3.7 1.5 0.2 setosa 5.0 3.3 1.4 0.2 setosa 7.0 3.2 4.7 1.4 versicolor 6.4 3.2 4.5 1.5 versicolor 6.9 3.1 4.9 1.5 versicolor 5.5 2.3 4.0 1.3 versicolor 6.5 2.8 4.6 1.5 versicolor Pandoc은 단순 테이블, 여러 줄 테이블, 그리드 테이블 및 파이프 테이블과 같은 여러 유형의 마크 다운 테이블을 지원합니다. knitr::kable ()이 생성하는 것은 다음과 같은 간단한 테이블입니다. Table: A simple table in Markdown. Sepal.Length Sepal.Width Petal.Length Petal.Width ------------- ------------ ------------- ------------ 5.1 3.5 1.4 0.2 4.9 3.0 1.4 0.2 4.7 3.2 1.3 0.2 4.6 3.1 1.5 0.2 5.0 3.6 1.4 0.2 5.4 3.9 1.7 0.4 문서에서 모든 유형의 마크 다운 테이블을 사용할 수 있습니다. 마크 다운 테이블을 상호 참조 할 수 있으려면Table:(\\#label) Caption here 형식의 라벨이 지정된 캡션이 있어야 합니다. 여기서label에는 접두사tab:이 있어야합니다 (예 :tab:단순-테이블). 다른 R 패키지를 사용하여 테이블을 생성하기로 결정한 경우 테이블 캡션의 시작 부분에 테이블 환경의 라벨이(\\#label) 형식으로 표시되는지 확인해야 합니다(다시 말하지만label에는 접두사tab:이 있어야 합니다). 테이블 생성 함수의 이동성(protability)에 대해 매우 주의해야 합니다. HTML 및 LaTeX 출력 모두에서 자동으로 작동해야하므로 내부적으로 출력 형식을 고려해야 합니다 (knit::opts_knit$get('rmarkdown.pandoc.to') 확인). HTML 테이블을 작성할 때 캡션은 &lt;caption&gt; &lt;/caption&gt;태그에 작성해야 합니다. 간단한 테이블의 경우 kable()이면 충분합니다. 복잡한 테이블을 만들어야 하는 경우(예 : 특정 셀이 여러 열/행에 걸쳐있는 경우) 앞서 언급한 문제를 고려해야 합니다. "],["CressRef.html", "2.6 교차 참조", " 2.6 교차 참조 우리는 이미 수식(섹션 2.2.1), 정리와 증명(섹션 2.2.2), 그림(섹션 2.4) 그리고 표(섹션 2.5)에서 상호 참조가 어떻게 작동하는지 설명한 바 있습니다. 실제로 동일한 구문 \\@ref(label)을 사용하여 섹션을 참조할 수도 있습니다. 여기서 label은 ’섹션 ID’입니다. 기본적으로 Pandoc은 모든 섹션 헤더에 자동으로 ID를 생성합니다. 예를 들어 # Hello World 섹션에는 hello-world라는 ID가 있습니다. 섹션 헤더를 변경한 후 참조 라벨을 업데이트하는 것을 잊지 않도록 섹션 헤더에 ID를 수동으로 할당하는 것이 좋습니다. 섹션 헤더에 ID를 할당하려면 섹션 헤더 끝에 {#id}를 추가하면 됩니다. 섹션 헤더의 추가 속성은 표준 Pandoc 구문을 사용하여 설정할 수 있습니다. 참조된 라벨을 찾을 수 없는 경우 ??와 같은 두 개의 물음표가 표시되며, 책을 렌더링할 때 R 콘솔에 경고 메시지가 표시됩니다. 명시적이거나 자동 생성된 섹션 ID 또는 심지어 실제 섹션 헤더 텍스트를 사용하여 텍스트 기반 링크를 만들 수도 있습니다. 섹션 제목을 링크 텍스트로 사용하고 싶으면 간단하게 섹션의 제목을 대괄호 안에 사용하면 됩니다. [섹션 제목]: 예, 섹션 3.4의 제목을 대괄호 안에 기입하여 [단일 문서] 형태로 기입하면 “단일 문서”라는 링크를 생성합니다. [링크 텍스트][섹션 제목 텍스트] : 예, 섹션 4.5의 텍스트 링크를 위해 [비영어권 책][국제화]를 통한 “비영어권 책” 링크를 생성합니다. [링크 텍스트](#ID), 예 : 섹션 2.5에 대하여 [표 작성](#Table)를 통해 “표 작성”의 링크를 생성합니다. Pandoc 문서는 자동 섹션 ID 그리고 묵시적 헤더 참조에 대한 자세한 내용을 제공합니다. PDF 또는 HTML 출력의 현재 페이지에 없는 항목을 참조하는 경우에도 상호 참조는 계속 작동합니다. 예를 들어 수식 (2.1) 그리고 그림 2.4를 참고하기 바랍니다. "],["CustomBlock.html", "2.7 맞춤 블록", " 2.7 맞춤 블록 knitr의 block 엔진, 즉 청크 옵션 engine = 'block' 또는 보다 간결한 구문 ```{block} 을 사용하여 맞춤형 블록(custom block)을 생성할 수 있습니다. 이 엔진은 문자열을 받는 청크 옵션 type과 함께 사용해야 합니다. block 엔진을 사용하면 출력 형식이 HTML인 경우 청크 콘텐츠를 래핑하는 &lt;div&gt;를 생성하고 출력이 LaTeX 인 경우 LaTeX 환경을 생성합니다. type 옵션은 &lt;div&gt;의 클래스와 LaTeX 환경의 이름을 지정합니다. 예를 들어, 다음과 같은 청크의 R Markdown 소스가 있다고 할 떄, ```{block, type=&#39;FOO&#39;} Some text for this block. ``` 다음과 같이 출력할 수 있습니다. Some text for this block. HTML의 출력형태는 다음과 같습니다. &lt;div class=&quot;FOO&quot;&gt; Some text for this block. &lt;/div&gt; 그리고 LaTeX의 출력은 다음과 같습니다: \\begin{FOO} Some text for this block. \\end{FOO} 블록의 스타일을 정의하는 방법은 책 저자에게 달려 있습니다. CSS에서 &lt;div&gt;의 스타일을 정의하고 YAML 메타 데이터의 includes 옵션을 통해 출력에 포함할 수 있습니다. 마찬가지로 \\newenvironment를 통해 LaTeX 환경을 정의하고 includes 옵션을 통해 LaTeX 출력에 정의를 포함할 수 있습니다. 예를 들어, CSS 파일 즉 style.css 파일에 다음의 스타일을 저장할 수 있습니다. div.FOO { font-style: italic; color: red; } 같은 방법으로 b.BAR { font-style: normal; font-weight: bold; color: blue; } 를 style.css 파일에 정의합니니다. R Markdown 문서의 HTML 문서 작성을 위한 YAML 메타 데이터는 다음과 같습니다. --- output: bookdown::html_book: includes: in_header: style.css --- 그러면 위의 &lt;div&gt;와 &lt;b&gt;를 다음과 같이 R Markdown에 문서에 사용할 수 있습니다. &lt;div class=&quot;FOO&quot;&gt;Some &lt;b class=&quot;BAR&quot;&gt;text&lt;/b&gt; for this block.&lt;/div&gt; 출력 결과는 다음과 같습니다. Some text for this block. 한편, 공지(note), 팁(tip), 중요사항(important), 주의(caution) 그리고 경고(warning) 등을 표시하기 위한 몇 가지 유형의 블록을 정의할 수 있습니다. 다음은 몇 가지 예입니다. 이를 위해서는 style.css 파을을 다음과 같이 생성합니다. .blackbox { padding: 1em; background: black; color: white; border: 2px solid orange; border-radius: 10px; } .center { text-align: center; } .infobox { padding: 1em 1em 1em 4em; margin-bottom: 10px; border: 2px solid orange; border-radius: 10px; background: #f5f5f5 5px center/3em no-repeat; } .caution { background-image: url(&quot;images/caution.png&quot;); } .warning { background-image: url(&quot;images/warning.png&quot;); } .note { background-image: url(&quot;images/note.png&quot;); } .tip { background-image: url(&quot;images/tip.png&quot;); } .important { background-image: url(&quot;images/warning.png&quot;); } 그리고 gitbook 작성을 위한 YAML 메타 데이터는 다음과 같이 수정해 줍니다. R Markdown 문서의 gitbook 작성을 위한 YAML 메타 데이터는 다음과 같습니다. --- output: bookdown::gitbook: css: style.css --- 경고 박스 부분에 대한 R Markdown 소스는 다음과 같습니다. ::: {.infobox .warning data-latex=&quot;{warning}&quot;} **WARNING!** Thank you for noticing this **new warningn**! Your noticing it has been noted, and _will be reported to the authorities_! ::: 나머지 공지(note), 팁(tip), 중요사항(important) 그리고 주의(caution) 등은 ::: {.infobox .warning 중 warning을 note, tip, notice, 그리고 caution 등으로 수정해서 복사해 주면 됩니다. WARNING! Thank you for noticing this new warning! 경고 사항을 꼭 주지 하시기 바랍니다. CAUTION! Thank you for noticing this new caution! 향후 이 부분을 주의하시기 바랍니다. NOTE! Thank you for noticing this new note! 향후 이 부분은 꼭 참고하시기 바랍니다. TIP! Thank you for noticing this new tip! 향후 이 팁을 알고 계시면 도움이 될 것입니다. IMPORTANT! Thank you for noticing this new important! 이 부분은 매우 중요한 사항입니다. 한편 위의 style.css 파일에는 blackbox에 대한 정의가 되어 있다. 이에 대한 R Markdown 소스를 다음과 같이 삽입해 보자. :::: {.blackbox data-latex=&quot;&quot;} ::: {.center data-latex=&quot;&quot;} **NOTICE!** ::: Thank you for noticing this **new notice**! **공지 사항**을 꼭 주지 하시기 바랍니다. :::: 그러면 다음과 같은 검은 상자 안에 글의 내용이 표시가 된다. NOTICE! Thank you for noticing this new notice! 공지 사항을 꼭 주지 하시기 바랍니다. knitr block 엔진은 간단한 콘텐츠(일반적으로 일반 텍스트 단락)를 표시하도록 설계되었습니다. 특정 단어를 굵게 또는 기울임 꼴로 만드는 것과 같은 간단한 형식 지정 구문을 사용할 수 있지만 인용 및 상호 참조와 같은 고급 구문은 작동하지 않습니다. 그러나 임의의 Markdown 구문을 지원하는 block2라는 대체 엔진이 있습니다. 예를 들어, ```{block2, type=&#39;FOO&#39;} Some text for this block [@citation-key]. - a list item - another item More text. ``` 위의 내용은 다음과 같이 출력됩니다. Some text for this block (citation-key?). a list item another item More text. 문서에 커스텀 블록이 많으면 block2엔진이 block 엔진보다 빠르지만 구현은 hack을 기반으로 합니다. 그래서 우리는 그것이 항상 미래에 작동할 것인지 100% 확신하지 못합니다. 그렇지만 Pandoc v1.17.2에서 아직까지 문제가 발생하지는 않았습니다. block2 엔진에 대한 한 가지 더 주의해야 사항은 블록의 마지막 요소가 일반 단락이 아닌 경우 끝에 빈 줄을 남겨야 합니다. ```{block2, type=&#39;FOO&#39;} Some text for this block [@citation-key]. - a list item - another item - end the list with a blank line ``` 섹션 2.2.2의 정리 및 증명 환경은 실제로 block2 엔진을 통해 구현된 것입니다. block 또는 block2 엔진을 기반으로 하는 모든 사용자 정의 블록에는 블록을 표시(echo = TRUE) 하거나 숨기는 데 사용할 수 있는 (echo = FALSE) 하나의 청크 옵션 echo가 있습니다. "],["Citation.html", "2.8 인용", " 2.8 인용 Pandoc은 문서에서 인용과 참고 문헌을 관리하는 두 가지 방법을 제공합니다. 기본 방법은 인용 스타일 언어(CSL)의 사양을 따르는 pandoc-citeproc라는 Pandoc 도우미 프로그램을 사용하는 것입니다. 사용 가능한 수 많은 CSL 스타일 파일 중 하나에서 특정 형식 지정 지침을 얻습니다. 사용자는 bibtex 기반의 natbib 또는 biblatex를 “인용 패키지”로 사용합니다. 이 경우 서지 데이터 파일은 bibtex 또는 biblatex 형식이어야 하며 문서 출력 형식은 PDF로 제한됩니다. 다시 말하지만, 다양한 서지 스타일을 사용할 수 있습니다 (이러한 패키지의 문서를 참조하십시오). natbib 또는 biblatex를 사용하여 참조를 처리하기 위해 R Markdown 출력 형식의 citation_package 옵션을 설정할 수 있습니다. output: pdf_document: citation_package: natbib bookdown::pdf_book: citation_package: biblatex PDF 출력으로 natbib 또는 biblatex를 선택하더라도 다른 모든 출력 형식은 pandoc-citeproc을 사용합니다. 일치하는 스타일을 사용하는 경우 (예 :biblatex의 경우 biblio-style: apa, pandoc-citeproc의 경우 csl: apa.csl), 반드시 동일한 것은 아니지만, PDF 및 비 PDF 형식으로의 출력은 매우 유사합니다. PDF가 아닌 출력 형식의 경우 pandoc-citeproc 만 사용할 수있는 옵션입니다. PDF 및 비PDF 출력 형식 간의 일관성이 중요한 경우 전체적으로 pandoc-citeproc을 사용하십시오. 서지 데이터는 여러 형식이 될 수 있습니다. 이 섹션에는 BibTeX 데이터베이스의 예만 나와 있으며, 다른 가능한 형식은 Pandoc 매뉴얼의 인용 섹션을 참조하십시오. BibTeX 데이터베이스는 다음과 같은 참고 문헌 항목으로 구성된 일반 텍스트 파일(일반적인 파일 이름의 확장자로 .bib 사용)입니다. @Manual{R-base, title = {R: A Language and Environment for Statistical Computing}, author = {{R Core Team}}, organization = {R Foundation for Statistical Computing}, address = {Vienna, Austria}, year = {2016}, url = {https://www.R-project.org/}, } 참고문헌 항목은 @type{으로 시작합니다. 여기서 type은 article, book, manual 등일 수 있습니다.8 위의 예에서 R-base와 같은 인용 키가 있습니다. 항목을 인용하려면 @key 또는[@key] (후자는 중괄호로 인용)를 사용합니다. 예를 들어 @R-base는 “R Core Team (2016)”로 렌더링됩니다. 그리고 [@R-base]는 “(R Core Team 2016)”을 생성합니다 (또한 해당 페이지의 하단부에 참고뭔헌이 표시됨). LaTeX의 natbib 패키지에 익숙하다면 @key는 기본적으로 \\citet{key}이고 [@key]는 \\citep{key}와 같습니다. 참고문헌 항목에는 title, author 그리고 year 등과 같은 여러 필드가 있습니다. BibTeX의 가능한 항목 유형과 필드는 https://en.wikipedia.org/wiki/BibTeX에서 확인할 수 있습니다. knitr에는 R 패키지에 대한 BibTeX 항목을 자동으로 생성하는 도우미 함수 write_bib()이 있습니다. # the second argument can be a .bib file knitr::write_bib(c(&quot;knitr&quot;, &quot;stringr&quot;), &quot;&quot;, width = 60) @Manual{R-knitr, title = {knitr: A General-Purpose Package for Dynamic Report Generation in {R}}, author = {Yihui Xie}, year = {2020}, note = {R package version 1.30}, url = {https://yihui.org/knitr/}, } @Manual{R-stringr, title = {stringr: Simple, Consistent Wrappers for Common String Operations}, author = {Hadley Wickham}, year = {2019}, note = {R package version 1.4.0}, url = {https://CRAN.R-project.org/package=stringr}, } @Book{knitr2015, title = {Dynamic Documents with {R} and knitr}, author = {Yihui Xie}, publisher = {Chapman and Hall/CRC}, address = {Boca Raton, Florida}, year = {2015}, edition = {2nd}, note = {ISBN 978-1498716963}, url = {https://yihui.org/knitr/}, } @InCollection{knitr2014, booktitle = {Implementing Reproducible Computational Research}, editor = {Victoria Stodden and Friedrich Leisch and Roger D. Peng}, title = {knitr: A Comprehensive Tool for Reproducible Research in {R}}, author = {Yihui Xie}, publisher = {Chapman and Hall/CRC}, year = {2014}, note = {ISBN 978-1466561595}, url = {http://www.crcpress.com/product/isbn/ 9781466561595}, } 하나 또는 여러 개의 .bib 파일이 있으면 첫 번째 R Markdown 문서(일반적으로index.Rmd)의 YAML 메타 데이터에서 bibliography 필드를 사용할 수 있으며 biblio-style(PDF 출력에만 적용됨)을 통해 참고문헌 스타일을 지정할 수도 있습니다. --- bibliography: [&quot;one.bib&quot;, &quot;another.bib&quot;, &quot;yet-another.bib&quot;] biblio-style: &quot;apalike&quot; link-citations: true --- link-citations 필드는 저자-연도 스타일의 인용 텍스트에서 HTML 출력의 참고문헌 항목으로의 내부 링크를 추가하는 데 사용할 수 있습니다. 출력 형식이 LaTeX 인 경우 참고문헌 목록은 문서 끝에 있는 장이나 섹션에 자동으로 배치됩니다. LaTeX가 아닌 출력의 경우 책의 마지막 장으로 빈 장을 추가할 수 있습니다. 예를 들어, 마지막 장인 Rmd 파일이 06-references.Rmd 인 경우 내용은 인라인 R 표현식이 될 수 있습니다. # References {-} 인용 사용 방법에 대한 자세한 지침과 추가 예제는 Pandoc 설명서의 “Citations” 섹션을 참조하십시오. References "],["Index.html", "2.9 색인", " 2.9 색인 현재 색인은 LaTeX / PDF 출력에 대해서만 지원됩니다. 책 뒤에 색인을 인쇄하려면 서문에서 LaTeX 패키지 makeidx를 사용할 수 있습니다(섹션 4.1 참조) : \\usepackage{makeidx} \\makeindex 그런 다음 YAML 옵션 includes-&gt; after_body를 통해 책 끝에 \\printindex를 삽입합니다. 책 본문의 \\index{} 명령을 통해 색인 항목을 생성할 수 있습니다 (예 :\\index{GIT}). "],["HTMLWidget.html", "2.10 HTML 위젯", " 2.10 HTML 위젯 R의 가장 큰 장점 중 하나는 데이터 시각화이지만 훨씬 풍부한 데이터 시각화를 위한 JavaScript 라이브러리가 많이 있습니다. 이러한 라이브러리는 웹 브라우저에서 쉽게 렌더링할 수있는 대화형 애플리케이션을 구축하는 데 사용할 수 있으므로 사용자는 시각화를 보기 위해 추가 소프트웨어 패키지를 설치할 필요가 없습니다. 이러한 JavaScript 라이브러리를 R로 가져 오는 한 가지 방법은 htmlwidgets 패키지 (Vaidyanathan et al. 2020)를 통하는 것입니다.. HTML 위젯은 독립형 웹 페이지 (예 : R 플롯)로 렌더링하거나 R Markdown 문서와 Shiny 애플리케이션에 포함할 수 있습니다. 원래 HTML 출력 전용으로 설계되었으며 JavaScript의 가용성이 필요하므로 LaTeX / PDF와 같은 비 HTML 출력 형식에서는 작동하지 않습니다. knitr v1.13 이전에서는 HTML 위젯을 HTML이 아닌 출력 형식으로 렌더링할 때 오류가 발생합니다. knitr v1.13부터 HTML 위젯은 webshot 패키지 (Chang 2019)를 통해 찍은 스크린 샷으로 자동 렌더링됩니다. 물론 webshot 패키지를 설치해야 합니다. 또한 PhantomJS (http://phantomjs.org)를 설치해야 합니다. 이는 webshot이 스크린 샷을 캡처하는 데 사용하는 것입니다. webshot과 PhantomJS는 모두 R에서 자동으로 설치할 수 있습니다. install.packages(&quot;webshot&quot;) webshot::install_phantomjs() install_phantomjs() 함수는 Windows, OS X 및 Linux에서 작동합니다. 시스템 환경 변수 PATH를 수정하는 데 익숙하다면 PhantomJS를 직접 다운로드하여 설치할 수도 있습니다. knitr가 코드 청크에서 HTML 위젯 개체를 감지하면 현재 출력 형식이 HTML 일 때 위젯을 정상적으로 렌더링하거나 위젯을 HTML 페이지로 저장하고 출력 형식이 HTML이 아닌 경우 webshot을 호출하여 HTML 페이지 화면을 캡처합니다. 다음은 DT 패키지 (Xie, Cheng, and Tan 2020)에서 생성된 테이블의 예입니다 : DT::datatable(iris) Figure 2.5: DT 패키지를 통한 테이블 위젯 지금 이 책을 웹 페이지로 읽고 있다면 위의 코드 청크에서 생성된 대화형 표를 볼 수 있습니다. 예를 들어 열을 정렬하고 표에서 검색할 수 있습니다. 이 책의 HTML이 아닌 버전을 읽는 경우 표의 스크린 샷이 표시되어야 합니다. 스크린 샷은 실제 웹 브라우저와 PhantomJS의 가상 브라우저의 차이로 인해 웹 브라우저에서 렌더링된 실제 위젯과 약간 다를 수 있습니다. 화면 캡처와 관련된 knitr 청크 옵션이 많이 있습니다. 첫째, 자동 스크린 샷의 품질이 만족스럽지 않거나 특정 상태 (예 : 표의 특정 열을 클릭하고 정렬 한 후)의 위젯 스크린 샷을 원하는 경우 수동으로 화면을 캡처할 수 있습니다. 청크 옵션 screenshot.alt (대체 스크린 샷)를 통해 자신의 스크린 샷을 제공합니다. 이 옵션은 이미지 경로를 사용합니다. 청크에 여러 위젯이 있는 경우 이미지 경로 벡터를 제공할 수 있습니다. 이 옵션이 있으면 knitr는 더 이상 webshot을 호출하여 자동 스크린 샷을 찍지 않습니다. 둘째, HTML 페이지에서도 실제 위젯을 렌더링하는 대신 knitr가 정적 스크린 샷을 사용하도록 강제하고 싶을 수 있습니다. 이 경우 청크 옵션 screenshot.force = TRUE를 설정할 수 있으며 위젯은 항상 정적 이미지로 렌더링됩니다. 여전히 자동 또는 사용자 지정 스크린 샷을 사용하도록 선택할 수 있습니다. 셋째, webshot에는 자동 스크린 샷을 제어할 수있는 몇 가지 옵션이 있으며,list(delay = 2, cliprect = 'viewport')와 같은 목록을 취하는 청크 옵션 screenshot.opts를 통해 이러한 옵션을 지정할 수 있습니다. 가능한 옵션의 전체 목록은 도움말 페이지 ? webshot::webshot와 package vignette vignette('intro', package = 'webshot')은 이러한 옵션의 효과를 보여줍니다. 여기서 delay 옵션은 렌더링하는 데 오랜 시간이 걸리는 위젯에 중요할 수 있습니다. delay는 PhantomJS가 스크린 샷을 찍기 전에 대기할 시간 (초)을 지정합니다. 불완전한 스크린 샷이 표시되면 더 긴 지연을 지정할 수 있습니다(기본값은 0.2 초). 넷째, 스크린 샷 캡처가 느리거나 코드 청크가 실행될 때마다 캡처하고 싶지 않은 경우 청크 옵션 cache = TRUE 를 사용하여 청크를 캐시할 수 있습니다. 캐싱은 HTML 및 비 HTML 출력 형식 모두에서 작동합니다. 스크린 샷은 fig.width, fig.height, out.width, fig.cap 등을 포함하여 그림과 관련된 많은 청크 옵션이 스크린 샷에도 적용된다는 점에서 일반 R 플롯처럼 작동합니다. 따라서 출력 문서에서 스크린 샷의 크기를 지정하고 그림 캡션도 할당할 수 있습니다. 자동 스크린 샷의 이미지 형식은 청크 옵션 dev를 통해 지정할 수 있으며 가능한 값은 pdf, png 그리고 jpeg 등입니다. PDF 출력의 기본값은 pdf이고 다른 유형의 출력은 png입니다. pdf는 png 만큼 충실하게 작동하지 않을 수 있습니다. 때로는 HTML 페이지에 PDF 스크린 샷으로 렌더링하지 못하는 특정 요소가 있으므로 PDF 출력에도dev = 'png'를 사용할 수 있습니다. HTML 위젯의 특정 사례에 따라 다르며 어떤 형식이 더 바람직한 지 결정하기 전에 pdf와 png (또는jpeg)를 모두 사용해 볼 수 있습니다. References "],["WebShiny.html", "2.11 웹 페이지와 Shiny 앱", " 2.11 웹 페이지와 Shiny 앱 HTML 위젯과 마찬가지로 임의의 웹 페이지를 책에 삽입할 수 있습니다. knitr::include_url()함수를 사용하여 URL을 통해 웹 페이지를 포함할 수 있습니다. 출력 형식이 HTML인 경우 iframe이 사용됩니다.9 다른 경우에는 knitr는 웹 페이지의 스크린 샷을 찍으려고 합니다 (또는 제공한 사용자 지정 스크린 샷 사용). 모든 청크 옵션은 HTML 위젯의 옵션과 동일합니다. 특별한 주의가 필요한 옵션 중 하나는 delay 옵션입니다. HTML 위젯은 로컬로 렌더링되므로 일반적으로 PhantomJS가 스크린 샷을 찍기 위해 로드하는 것이 빠르지 만 임의의 URL은 로드하는 데 더 오래 걸릴 수 있으므로 사용하는 것이 좋습니다. 더 큰 delay 값, 예를 들어 chunk 옵션 screenshot.opts = list (delay = 5)를 사용하기 바랍니니다. 관련 함수는 knitr::include_app() 함수로 include_url()과 매우 유사하며 URL을 통해 Shiny 앱을 출력에 포함하도록 설계되었습니다. include_url()과의 유일한 차이점은 URL에 다른 쿼리 매개 변수가 없는 경우 스크린 샷이나 iframe에 유용하지 않을 수 있는 Shiny 쇼케이스 모드를 비활성화하기 위해 URL에 쿼리 매개 변수 ?showcase=0을 자동으로 추가한다는 것입니다. 쇼케이스 모드를 원한다면 include_app ()대신에 include_url()을 사용하기 바랍니다. 아래는 Shiny 앱의 예입니다 (그림 2.6) : knitr::include_url(&quot;https://yihui.org&quot;) Figure 2.6: miniUI 패키지로 생성된 Shiny 앱; https://yihui.shinyapps.io/miniUI/ 에서 실시간 버전을 볼 수 있다. # knitr::include_app(&quot;https://yihui.shinyapps.io/miniUI/&quot;) 다시 말하지만 이 책의 HTML 버전을 읽는 경우 라이브 앱이 표시되고 다른 유형의 형식을 읽는 경우 정적 스크린 샷이 표시됩니다. 위의 Shiny 앱은 miniUI 패키지 (Cheng 2018)를 사용하여 생성되었는데, 작은 화면의 Shiny 앱에 특히 좋은 레이아웃 기능을 제공합니다. 일반적인 Shiny 레이아웃 기능을 사용하는 경우 페이지 크기가 너무 커서 iframe에 맞지 않기 때문에 iframe에 가로/세로 스크롤바가 표시될 수 있습니다. iframe의 기본 너비가 너무 작으면 out.width 청크 옵션을 사용하여 변경할 수 있습니다. iframe의 높이는 include_url() / include_app()의 height 인수를 사용합니다. Shiny 앱은 일반적인 URL보다 로드하는 데 더 오래 걸릴 수 있습니다. 예를 들어, 10과 같이 delay 옵션에 대해 보수적인 값을 사용할 수 있습니다. 말할 필요도 없이 include_url()과 include_app()에는 이전에 청크를 캐시하지 않은 경우 작동하는 인터넷 연결을 요구합니다(그러나 웹 iframe 내웁의 웹 페이지는 인터넷 연결 없이는 여전히 작동하지 않습니다). References "],["Output-Format.html", "3 출력 형식", " 3 출력 형식 bookdown 패키지는 주로 HTML, LaTeX / PDF 및 전자 책(EPUB) 등 세 가지 유형의 출력 형식을 지원합니다. 이 장에서는 이러한 형식에 가능한 옵션을 소개합니다. 출력 형식은 book의 첫 번째 Rmd 파일(예를 들어, index.Rmd)의 YAML 메타 데이터 또는 책의 루트 디렉토리 아래에있는 _output.yml 이라는 별도의 YAML 파일에 지정될 수 있습니다. 다음은 전자의 간단한 예입니다 (출력 형식은 YAML 메타 데이터의 output필드에 지정됨). --- title: &quot;An Impressive Book&quot; author: &quot;Li Lei and Han Meimei&quot; output: bookdown::gitbook: lib_dir: assets split_by: section config: toolbar: position: static bookdown::pdf_book: keep_tex: yes bookdown::html_book: css: toc.css documentclass: book --- 다음은 _output.yml의 예입니다. bookdown::gitbook: lib_dir: assets split_by: section config: toolbar: position: static bookdown::pdf_book: keep_tex: yes bookdown::html_book: css: toc.css 이 경우 모든 형식은 output 필드가 아닌 최상위 수준에 있어야 합니다. _output.yml에는 세 개의 대시 ---가 필요하지 않습니다. "],["HTMLformat.html", "3.1 HTML", " 3.1 HTML (bookdown을 사용한) 책 렌더링과 (rmarkdown을 사용한) 단일 R Markdown 문서를 HTML로 렌더링하는 것의 주요 차이점은 책은 기본적으로 여러 HTML 페이지를 생성한다는 것입니다. 일반적으로 장(Chapter)당 하나의 HTML 파일을 생성합니다. 이렇게 하면 책을 읽을 때 특정 장을 북마크하거나 다른 사람과 URL을 공유하기가 더 쉽고 웹 브라우저에 책을 더 빨리 로드할 수 있습니다. 현재 HTML 출력에 대해 GitBook 스타일, Bootstrap 스타일 그리고 Tufte 스타일 등과 같은 다양한 스타일을 제공하고 있습니다. 3.1.1 GitBook 스타일 GitBook 스타일은 Friendcode, Inc.(https://www.gitbook.com)에서 시작한 프로젝트인 GitBook에서 차용했으며 Markdown으로 저자가 책을 쓸 수 있도록 지원하고 있습니다. 왼쪽에 목차를 보여주는 사이드 바와 오른쪽에 책의 본문을 보여주는 레이아웃으로 아름다운 스타일을 제공합니다. 디자인은 창 크기에 반응합니다. 예를 들어, 창이 충분히 넓을 때 탐색 버튼이 책 본문의 왼쪽/오른쪽에 표시되고 창이 좁으면 하단으로 축소되어 독자가 책의 본문을 읽을 수있는 수평 공간을 더 많이 제공합니다. 원래 GitBook 프로젝트에 비해 몇 가지 개선 사항이 있습니다. 가장 중요한 점은 Markdown 엔진을 Pandoc 기반의 R Markdown v2로 대체하여 책을 쓸 때 사용할 수 있는 더 많은 기능이 있다는 것입니다. Markdown에 R 코드 청크와 인라인 R 표현식을 포함할 수 있으며, 이를 통해 재현 가능한 문서를 쉽게 생성하고 계산을 실제 출력과 동기화하는 것에서 자유롭게 해 줍니다 (knitr이 자동으로 처리합니다). Markdown 구문은 훨씬 더 풍부합니다. LaTeX 수학 표현 그리고 인용과 같이 Pandoc의 Markdown이 지원하는 모든 것을 작성할 수 있습니다. 책에 HTML 위젯 그리고 Shiny 앱과 같은 대화형 콘텐츠 (HTML 출력 전용)를 포함할 수 있습니다. 또한 곧 소개할 몇 가지 유용한 기능을 사용자 인터페이스에 추가했습니다. bookdown에서 GitBook 스타일의 출력 형식 함수는 gitbook()입니다. 그 인수는 다음과 같습니다. gitbook(fig_caption = TRUE, number_sections = TRUE, self_contained = FALSE, anchor_sections = TRUE, lib_dir = &quot;libs&quot;, pandoc_args = NULL, ..., template = &quot;default&quot;, split_by = c(&quot;chapter&quot;, &quot;chapter+number&quot;, &quot;section&quot;, &quot;section+number&quot;, &quot;rmd&quot;, &quot;none&quot;), split_bib = TRUE, config = list(), table_css = TRUE) fig_caption, lib_dir 그리고 ...를 포함한 대부분의 인수는 rmarkdown::html_document()로 전달됩니다. 가능한 옵션의 전체 목록은 rmarkdown::html_document()의 도움말 페이지를 확인하세요. 다음 두 가지 이유로 fig_caption = TRUE를 사용하는 것이 좋습니다. 캡션을 사용하여 그림을 설명하는 것이 중요합니다. 그림 캡션 사용은 출력이 LaTeX 일 때 그림이 부동(floating) 환경에 배치된다는 것을 의미합니다. 그렇지 않으면 특정 페이지에 많은 공백이 생길 수 있습니다. 그림/표 번호의 형식은 섹션에 번호가 매겨져 있는지 여부에 따라 달라집니다. number_sections = TRUE인 경우 이 숫자는 X.i 형식이 됩니다. 여기서 X는 장 번호이고 i는 증가하는 숫자입니다. 만일 섹션에 번호가 지정되지 않은 경우 모든 그림/표는 1, 2,…, N으로 책 전체에 걸쳐 순차적으로 번호가 매겨집니다. 두 경우 모두 그림과 표는 독립적으로 번호가 지정됩니다. ...의 가능한 모든 인수 중에서 css 인수를 사용하여 하나 이상의 사용자 정의 CSS 파일을 제공하여 기본 CSS 스타일을 수정할 수 있습니다. gitbook()에 하드 코딩된 html_document()의 몇 가지 인수가 있으며 그것을 변경할 수 없습니다. toc = TRUE (toc : table of content, 목차 표시), theme = NULL ( Bootstrap 테마를 사용하지 않음) 그리고 template (내부 GitBook 템플릿 사용). 자체 포함된 HTML 페이지를 만들기 위해서는 self_contained = TRUE를 변경하면 모든 단일 HTML 파일에 포함되어야 하는 JS 및 CSS 파일이 많기 때문에 모든 HTML 파일의 전체 크기가 크게 증가할 수 있습니다. 이러한 html_document()옵션 외에도 gitbook()에는 split_by, split_bib 그리고 config 등의 세 가지 인수가 있습니다. split_by 인수는 HTML 출력을 여러 페이지로 분할하는 방법을 지정하며 가능한 값은 다음과 같습니다. rmd : 입력 Rmd 파일의 기본 파일 이름을 사용하여 HTML 파일 이름을 만듭니다. 예를 들어 chapter3.Rmd에 대해 chapter3.html을 생성합니다. none : HTML 파일을 분할하지 않습니다(책 전체가 하나의 HTML 파일이 됩니다). chapter : 첫 번째 수준의 헤더(#) 즉 장별로 파일을 분할합니다. section: 두 번째 수준 헤더(##) 즉 절별로 파일을 분할합니다. chapter + number 그리고 section + number : chapter 그리고 section과 유사하지만 파일에 번호가 지정됩니다. chapter와 section의 경우 HTML 파일 이름은 헤더 식별자에 의해 결정됩니다. 예를 들어, 장 제목이 # Introduction 인 첫 번째 장의 파일 이름은 기본적으로 introduction.html이 됩니다. chapter + number 그리고 section + number의 경우 ‘장/섹션 번호’가 HTML 파일 이름 앞에 추가됩니다 (예 :1-introduction.html 과 2-1-literature.html). 헤더 식별자(헤더 ID)는 기본적으로 헤더 텍스트10 에서 자동으로 생성되며, 헤더 텍스트 뒤에 {#your-custom-id} 구문을 사용하여 헤더 식별자를 수작업으로 지정할 수 있습니다. 예 : # An Introduction {#introduction} The default identifier is `an-introduction` but we changed it to `introduction`. 기본적으로 참고 문헌이 분할되고 관련 인용 항목이 각 페이지 하단에 배치되므로, 독자가 인용 세부 정보를 보기 위해 다른 참고 문헌 페이지로 이동할 필요가 없습니다. 이 기능은 split_bib = FALSE를 사용하여 비활성화할 수 있으며, 이 경우 모든 인용이 별도의 페이지에 배치됩니다. config 옵션에는 사용자 인터페이스의 세부 사항을 조정할 수 있는 몇 가지 하위 옵션이 있습니다. 모든 출력 형식 옵션 (bookdown::gitbook 뿐 만 아니라)은 명령 줄 인터페이스 bookdown::render_book()을 사용하는 경우 format 함수로 전달되거나 YAML 메타 데이터로 작성될 수 있습니다. gitbook 형식의 config 기본 하위 옵션을 아래의 YAML 메타 데이터로 표시합니다(config 옵션 아래에 들여 쓰기가 되어 있음을 주의하기 바랍니다). bookdown::gitbook: config: toc: collapse: subsection scroll_highlight: yes before: null after: null toolbar: position: fixed edit : null download: null search: yes fontsettings: theme: white family: sans size: 2 sharing: facebook: yes github: no twitter: yes linkedin: no weibo: no instapaper: no vk: no all: [&#39;facebook&#39;, &#39;twitter&#39;, &#39;linkedin&#39;, &#39;weibo&#39;, &#39;instapaper&#39;] info: yes toc 옵션은 목차(TOC, Table of Contents)의 동작을 제어합니다. collapse옵션을 통해 페이지가 로드될 때 처음에 일부 항목을 축소할 수 있습니다. 가능한 값은 subsection, section, none(또는 null) 등입니다. 이 옵션은 TOC가 매우 길고, 3 개 이상의 제목 수준이 있는 경우 유용할 수 있습니다. subsection은 하위 섹션 (X.X.X)에 대한 모든 TOC 항목을 축소하는 것을 의미하고, section은 섹션 (X.X)에 대한 항목을 의미하므로 맨 위 레벨의 제목은 처음에 표시되며, None은 TOC의 항목을 축소하지 않음을 의미합니다. 축소된 TOC 항목의 경우 상위 TOC 항목을 클릭하여 가시성을 전환할 수 있습니다. 예를 들어 목차에서 장 제목을 클릭하여 섹션을 표시하거나 숨길 수 있습니다. toc의scroll_highlight 옵션은 책 본문을 스크롤할 때 목차 항목 강조 표시를 활성화할 지 여부를 나타냅니다(기본적으로 이 기능은 활성화되어 있음). 아래/위로 스크롤할 때 새 헤더가 현재 화면에 올 때마다 왼쪽의 목차에서 해당 항목이 강조 표시됩니다. 사이드 바의 너비가 고정되어 있으므로 제목 텍스트가 너무 넓어서 목차의 항목이 잘린 경우, 커서를 항목 위로 가져가면 전체 텍스트를 보여주는 도구 설명을 볼 수 있습니다. HTML 태그 &lt;li&gt;를 사용하여 TOC 앞뒤에 항목을 더 추가할 수 있습니다. 이러한 항목은 수평 구분선을 사용하여 TOC에서 분리됩니다. 파이프 문자 |를 사용하면 YAML 구문을 따르는 이러한 항목의 문자를 이스케이프할 필요가 없습니다. toc: before: | &lt;li&gt;&lt;a href=&quot;...&quot;&gt;My Awesome Book&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;...&quot;&gt;John Smith&lt;/a&gt;&lt;/li&gt; after: | &lt;li&gt;&lt;a href=&quot;https://github.com/rstudio/bookdown&quot;&gt; Proudly published with bookdown&lt;/a&gt;&lt;/li&gt; 다른 HTML 페이지를 탐색할 때 TOC의 스크롤 위치를 유지하려고 할 것입니다. 일반적으로 다음 페이지로 이동하더라도 고정된 위치에 TOC의 스크롤 막대가 표시됩니다. 그러나 페이지가 로드될 때 현재 장/섹션의 목차 항목이 표시되지 않으면 목차가 자동으로 스크롤되어 표시됩니다. GitBook 스타일에는 책 설정을 동적으로 변경할 수 있도록 각 페이지 상단에 툴 바(그림 3.1 참고)가 있습니다. toolbar 옵션에는 fixed 또는 static 값을 취할 수 있는 하위 옵션인 position이 있습니다. 기본값은 도구 모음이 페이지 상단에 고정(Fixed)되므로 페이지를 아래로 스크롤해도 도구 모음이 계속 표시됩니다. static인 경우 툴바가 페이지와 함께 스크롤되지 않습니다. 즉, 스크롤을 내리면 더 이상 볼 수 없습니다. Figure 3.1: GitBook 툴 바 도구 모음의 첫 번째 버튼은 ‘사이드 바(왼쪽의 메뉴)’의 표시와 숨기기를 전환할 수 있습니다. 키보드의 S 키를 눌러도 동일한 작업을 수행할 수 있습니다. GitBook 스타일은 사이드 바의 가시성 상태를 기억할 수 있습니다. 예를 들어 사이드 바를 닫은 경우 다음에 책을 열면, 그대로 닫힌 상태로 유지됩니다. 실제로 GitBook 스타일은 검색 키워드 그리고 글꼴 설정과 같은 다른 많은 설정도 기억합니다. 도구 모음의 두 번째 버튼은 ‘검색’ 버튼입니다. 키보드 단축키는 F(Find)입니다. 버튼을 클릭하면 사이드 바 상단에 검색 창이 표시됩니다. 상자에 입력하면 목차가 필터링되어 검색 키워드와 일치하는 섹션을 표시합니다. 이제 화살표 키 위/아래를 사용하여 검색 결과에서 이전/다음 일치 항목을 강조 표시할 수 있습니다. 검색 버튼을 다시 클릭하거나 검색 창 밖에서 F를 누르면 검색 키워드가 비워지고 검색 창이 숨겨집니다. 검색을 비활성화하려면 config에서 search: no 옵션을 설정합니다. 세 번째 버튼은 ‘글꼴/테마 설정’을 위한 것입니다. 독자는 글꼴 크기(크거나 작게), 글꼴 모음 (serif 또는 sans serif) 그리고 테마 (White, Sepia 또는 Night)를 변경할 수 있습니다. fontsettings 옵션을 통해 이러한 설정의 초기 값을 설정할 수 있습니다. 글꼴 크기는 0 ~ 4의 척도로 측정됩니다. 초기 값은 1, 2 (기본값), 3 또는 4로 설정할 수 있습니다. fontsettings: null(또는 no)을 설정하여 도구 모음에서 버튼을 제거할 수 있습니다. # changing the default fontsettings: theme: night family: serif size: 3 edit 옵션은 섹션 ??에 언급된 옵션과 동일합니다. 비어 있지 않으면 편집 버튼이 도구 모음에 추가됩니다. 이것은 버튼을 클릭하고 풀 요청을 보낸 후 GitHub에서 책을 편집하여 책에 대한 잠재적 기여자가 기여할 수 있도록 설계되었습니다. history와 view 옵션은 동일한 방식으로 작동합니다. 책에 독자가 다운로드할 수 있는 다른 출력 형식이 있는 경우 다운로드 버튼을 툴바에 추가 할 수 있도록 download 옵션을 제공할 수 있습니다. 이 옵션은 문자형 벡터 또는 각 벡터의 길이가 2 인 문자형 벡터 목록을 사용합니다. 문자형 벡터인 경우 ‘파일 이름’ 벡터이거나 파일 이름의 ‘확장자명’이어야 합니다. 예를 들어 다음 설정 모두 괜찮습니다. download: [&quot;book.pdf&quot;, &quot;book.epub&quot;] download: [&quot;pdf&quot;, &quot;epub&quot;, &quot;mobi&quot;] 파일 이름의 확장자만 제공하는 경우 파일 이름은 구성 파일_bookdown.yml의 책 파일 이름에서 파생됩니다 (섹션 ?? 참고). download가 null이면 gitbook()은 책 출력 디렉토리에서 PDF, EPUB 및 MOBI 파일을 찾아서 download 옵션에 자동으로 추가합니다. 다운로드 버튼 만 숨기려면 download: no를 사용하세요. 독자가 다운로드할 모든 파일이 드롭 다운 메뉴에 표시되고 파일 이름 확장자가 메뉴 텍스트로 사용됩니다. 독자가 다운로드 할 수 있는 유일한 형식이 PDF 인 경우 다운로드 버튼은 드롭 다운 메뉴 대신 단일 PDF 버튼이 됩니다. download 옵션 값의 다른 형식은 길이-2 벡터의 목록입니다. 예를 들어, download: [[&quot;book.pdf&quot;, &quot;PDF&quot;], [&quot;book.epub&quot;, &quot;EPUB&quot;]] 이는 다음과 같이 작성할 수도 있습니다. download: - [&quot;book.pdf&quot;, &quot;PDF&quot;] - [&quot;book.epub&quot;, &quot;EPUB&quot;] 목록의 각 벡터는 메뉴에 표시할 파일 이름과 텍스트로 구성됩니다. 첫 번째 양식과 비교하여 이 양식을 사용하면 메뉴 텍스트를 사용자가 정의할 수 있습니다. 예를 들어 독자가 다운로드 할 PDF 사본이 두 개 있을 수 있으며 메뉴 항목을 다르게 만들어야 합니다. 툴바의 오른쪽에는 Twitter, Facebook, Linkedin과 같은 소셜 네트워크 웹 사이트에서 링크를 공유하는 버튼이 있습니다. sharing 옵션을 사용하여 활성화할 버튼을 결정할 수 있습니다. 이러한 버튼을 완전히 제거하려면 sharing: null (또는no)을 사용하면 됩니다. 도구 모음에 표시되는 또 다른 버튼은 문서를 탐색하는 데 사용할 수 있는 키보드 단축키를 나열하는 정보 (i) 버튼입니다. 이 버튼은 info: no를 설정하여 숨길 수 있습니다. 마지막으로 Pandoc을 통해 GitBook HTML 템플릿에 전달할 수있는 YAML 메타 데이터의 최상위 옵션이 몇 가지 더 있습니다. HTML 출력에 명확한 가시적 효과가 없을 수 있지만 HTML 출력을 웹 사이트로 배포 할 때 유용할 수 있습니다. 이러한 옵션은 다음과 같습니다. description : HTML 헤드의&lt;meta name = \"description\" content = \"\"&gt;태그의 content 속성에 쓸 문자열 (누락된 경우 책 제목이 사용됨) ). 이는 검색 엔진 최적화 (SEO, Search Engine Optimization)에 유용할 수 있습니다. _italic_ 또는 **bold**와 같은 마크 다운 형식이 없는 일반 텍스트여야 합니다. url : 도서 웹 사이트의 URL, 예 :https://bookdown.org/yihui/bookdown/.11 github-repo : user/repo 형식의 책의 GitHub 저장소입니다. cover-image : 책의 표지 이미지 경로입니다. apple-touch-icon : 아이콘의 경로 (예 : PNG 이미지). 이것은 iOS 전용입니다. 웹 사이트가 홈 화면에 추가되면 링크가 이 아이콘으로 표시됩니다. apple-touch-icon-size : 아이콘의 크기 (기본적으로 152 x 152 픽셀). favicon : “favorite icon(즐겨 찾기 아이콘)” 경로입니다. 일반적으로 이 아이콘은 브라우저의 주소 표시 줄에 표시되거나 브라우저가 탭을 지원하는 경우 탭의 페이지 제목 앞에 표시됩니다. 아래는 몇 가지 샘플 YAML 메타 데이터를 보여줍니다 (다시 말하지만, 이들은 최상위 옵션입니다). --- title: &quot;An Awesome Book&quot; author: &quot;John Smith&quot; description: &quot;This book introduces the ABC theory, and ...&quot; url: &#39;https\\://bookdown.org/john/awesome/&#39; github-repo: &quot;john/awesome&quot; cover-image: &quot;images/cover.png&quot; apple-touch-icon: &quot;touch-icon.png&quot; apple-touch-icon-size: 120 favicon: &quot;favicon.ico&quot; --- description과 cover-image 설정의 좋은 효과는 트위터와 같은 일부 소셜 네트워크 웹 사이트에서 책의 링크를 공유하면 링크가 자동으로 책의 표지 이미지와 설명이 있는 카드로 확장될 수 있다는 것입니다. 3.1.2 Bootstrap 스타일 이전에 R Markdown을 사용한 적이 있다면 R Markdown HTML 출력의 기본 스타일인 Bootstrap 스타일(http://getbootstrap.com)에 익숙해야 합니다. rmarkdown의 출력 형식 함수는 html_document()이며, 기본 형식으로 html_document()를 사용하는 bookdown에 해당 형식 html_book()이 있습니다. 사실 bookdown에는 보다 일반적인 형식인 html_chapters()가 있으며 html_book()은 특별한 경우입니다. html_chapters(toc = TRUE, number_sections = TRUE, fig_caption = TRUE, lib_dir = &quot;libs&quot;, template = bookdown_file(&quot;templates/default.html&quot;), pandoc_args = NULL, ..., base_format = rmarkdown::html_document, split_bib = TRUE, page_builder = build_chapter, split_by = c(&quot;section+number&quot;, &quot;section&quot;, &quot;chapter+number&quot;, &quot;chapter&quot;, &quot;rmd&quot;, &quot;none&quot;)) 기본 출력 형식 함수를 사용하는 base_format 인수가 있으며 html_book()은 기본적으로 html_chapters(base_format = rmarkdown::html_document)입니다. html_book()의 모든 인수는 html_chapters()로 전달됩니다. html_book(...) 즉,toc (목차 표시 여부), number_sections (섹션 제목 번호 지정 여부) 등과 같은 rmarkdown::html_document의 대부분의 인수를 사용할 수 있습니다. 다시 한 번 rmarkdown::html_document의 도움말 페이지에서 가능한 옵션의 전체 목록을 확인하세요. self_contained 인수는 내부적으로 FALSE로 하드 코딩되어 있으므로 이 인수의 값을 변경할 수 없습니다. 이전 섹션에서 split_by 인수에 대해 설명했습니다. template 과 page_builder 인수는 고급 사용자를 위한 것이며 HTML 출력을 사용자 정의해야 할 강력한 필요성이 있지 않다면, rmarkdown::html_document()에서 제공하는 많은 옵션들이 여러분이 원하는 것을 주지않는다는 것입니다. 다른 HTML 템플릿을 template 인수에 전달하려면 템플릿에 세 쌍의 HTML 주석이 포함되어야 하며 각 주석은 별도의 줄에 있어야 합니다. &lt;!-bookdown:title:start-&gt;와 &lt;!-bookdown:title:end-&gt;는 책의 제목 섹션을 표시합니다. 이 섹션은 렌더링 된 책의 첫 페이지에만 배치됩니다. &lt;!-bookdown:toc:start-&gt;와 &lt;!-bookdown:toc:end-&gt;는 모든 HTML 페이지에 배치될 목차 섹션을 표시합니다. &lt;!-bookdown:body:start-&gt;와 &lt;!-bookdown:body:end-&gt;는 책의 HTML 본문을 표시하고 HTML 본문은 여러 개별 페이지로 분할됩니다. 모든 R Markdown 또는 Markdown 파일을 병합하고 단일 HTML 파일로 렌더링한 다음 분할합니다. 기본 HTML 템플릿을 열어 이러한 주석이 삽입된 위치를 확인할 수 있습니다. bookdown:::bookdown_file(&quot;templates/default.html&quot;) # you may use file.edit() to open this file bookdown이 내부적으로 여러 페이지의 HTML 출력을 생성하는 방법에 대해 알게 되면 위의 주석 토큰에서 추출한 HTML 조각을 사용하여 각 개별 HTML 페이지를 구성하는 함수인 page_builder 인수를 더 쉽게 이해할 수 있습니다. page_builder의 기본값은 bookdown의 build_chapter 함수이며 소스 코드는 비교적 간단합니다 (button_link()와 같은 내부 함수는 무시). build_chapter = function( head, toc, chapter, link_prev, link_next, rmd_cur, html_cur, foot ) { # add a has-sub class to the &lt;li&gt; items that has sub lists toc = gsub(&#39;^(&lt;li&gt;)(.+&lt;ul&gt;)$&#39;, &#39;&lt;li class=&quot;has-sub&quot;&gt;\\\\2&#39;, toc) paste(c( head, &#39;&lt;div class=&quot;row&quot;&gt;&#39;, &#39;&lt;div class=&quot;col-sm-12&quot;&gt;&#39;, toc, &#39;&lt;/div&gt;&#39;, &#39;&lt;/div&gt;&#39;, &#39;&lt;div class=&quot;row&quot;&gt;&#39;, &#39;&lt;div class=&quot;col-sm-12&quot;&gt;&#39;, chapter, &#39;&lt;p style=&quot;text-align: center;&quot;&gt;&#39;, button_link(link_prev, &#39;Previous&#39;), source_link(rmd_cur, type = &#39;edit&#39;), source_link(rmd_cur, type = &#39;history&#39;), source_link(rmd_cur, type = &#39;view&#39;), button_link(link_next, &#39;Next&#39;), &#39;&lt;/p&gt;&#39;, &#39;&lt;/div&gt;&#39;, &#39;&lt;/div&gt;&#39;, foot ), collapse = &#39;\\n&#39;) } 기본적으로 이 함수는 HTML 제목, 목차, 장 본문 등과 같은 여러 구성 요소를 사용하며 완전한 HTML 페이지의 HTML 소스인 문자열을 반환할 것으로 예상됩니다. gsub()과 paste()와 같은 텍스트 처리 함수를 사용하여 이 함수의 모든 구성 요소를 조작할 수 있습니다. 기본 페이지 빌더가 하는 일은 첫 번째 행에 TOC를, 두 번째 행에 본문을, 본문 하단에 탐색 버튼을 배치하고, 이를 HTML 머리말과 꼬리말을 연결하는 것입니다. 다음은 build_chapter()의 출력을 이해하는 데 도움이 되는 HTML 소스 코드의 예입니다. &lt;html&gt; &lt;head&gt; &lt;title&gt;A Nice Book&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;row&quot;&gt;TOC&lt;/div&gt; &lt;div class=&quot;row&quot;&gt; CHAPTER BODY &lt;p&gt; &lt;button&gt;PREVIOUS&lt;/button&gt; &lt;button&gt;NEXT&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 모든 HTML 페이지의 주요 차이점은 장의 본문이며 나머지 요소의 대부분은 동일합니다. html_book()의 기본 출력에는 &lt;head&gt;태그에 Bootstrap CSS와 JavaScript 파일이 포함됩니다. 목차(TOC)는 종종 탐색 목적으로 사용됩니다. GitBook 스타일에서 목차는 사이드 바에 표시됩니다. Bootstrap 스타일의 경우 특별한 스타일을 적용하지 않았으므로 정렬되지 않은 일반 목록으로 표시됩니다 (HTML 태그의 &lt;ul&gt;). CSS 기술을 사용하면 이 목록을 탐색 모음으로 쉽게 전환할 수 있습니다. 이 패키지에서 toc.css를 CSS 파일로 사용할 수 있으며, 여기에서 찾을 수 있습니다. 이 toc.css 파일을 책의 루트 디렉토리에 복사하고 css 옵션을 통해 HTML 출력에 적용할 수 있습니다. --- output: bookdown::html_book: toc: yes css: toc.css --- 웹에서 조금만 검색하면 &lt;ul&gt;목록을 내비게이션 메뉴로 전환할 수 있는 방법이 많이 있으며, 원하는 메뉴 스타일을 선택할 수 있습니다. 방금 언급 한 toc.css는 검정색 배경에 흰색 메뉴 텍스트가 있는 스타일이며 하위 메뉴를 지원합니다 (예 : 섹션 제목은 장 제목 아래에 드롭 다운 메뉴로 표시됩니다). 사실 theme 옵션을 null로 설정하면 html_document()에서 Bootstrap 스타일을 제거할 수 있으며, css 옵션(HTML head / foot에 임의의 콘텐츠를 포함하려는 경우 includes 옵션)을 사용하여 HTML 출력에 임의의 스타일을 적용할 수 있습니다. 3.1.3 Tufte 스타일 Bootstrap 스타일과 마찬가지로 Tufte 스타일은 출력 형식 tufte_html_book()으로 제공되며, 이는 기본 형식으로 tufte::tufte_html()을 사용하는 html_chapters()의 특수한 경우이기도 합니다. Tufte 스타일에 익숙하지 않은 경우 tufte 패키지 (Xie and Allaire 2020)를 참조하세요. 기본적으로 왼쪽에 메인 열이 있고 오른쪽에 여백 열이 있는 레이아웃입니다. 본문은 주 열에 있고 여백 열은 각주, 여백 메모, 참조 그리고 여백 그림 등을 배치하는 데 사용됩니다. tufte_html_book()의 모든 인수는 html_book()과 정확히 동일한 의미를 갖습니다. 예를 들어 css 옵션을 통해 CSS를 맞춤 설정할 수도 있습니다. 그러나 여백 메모, 여백 그림 및 전체 너비 그림과 같이 Tufte 스타일에 특정한 몇 가지 요소가 있습니다. 이러한 요소를 생성하려면 특수 구문이 필요합니다. tufte 패키지의 설명서를 참조하십시오. 각주 및 참조는 자동으로 여백에 배치되기 때문 이에 대해 특별한 작업을 수행할 필요가 없습니다(일반적인 Markdown 구문 ^[footnote]와 [@citation] 사용). tufte_html_book 형식의 간단한 YAML 예는 다음과 같습니다 : --- output: bookdown::tufte_html_book: toc: yes css: toc.css --- References "],["LatexPdfFormat.html", "3.2 LaTeX/PDF", " 3.2 LaTeX/PDF 책을 개발할 때 LaTeX 대신 HTML 출력 형식을 사용하는 것이 좋습니다. 책의 PDF 출력물을 계속해서 보면 많은 문제가 될 수 있는 조판(typesetting) 세부 사항에 신경쓰지 않아도 되기 때문입니다. (이상적으로는 책의 내용을 실제로 완성할 때까지)세심한 조판 작업은 끝까지 남겨 두는게 좋습니다. LaTeX / PDF 출력 형식은 bookdown의 pdf_book()에서 제공합니다. rmarkdown에서pdf_book()과pdf_document()형식 사이에는 큰 차이가 없습니다. pdf_book()의 주요 목적은 섹션 2.4, 2.5 그리고 2.6에 설명된 구문을 사용하여 작성된 레이블 및 상호 참조를 확인하는 것입니다. 책에 대해 원하는 유일한 출력 형식이 LaTeX / PDF 인 경우, Pandoc은 Markdown에서 LaTeX 명령을 지원하기 때문에 그림/표/ 섹션에 레이블을 지정하려면 \\label{}을 또 레이블을 통해 그들을 교차참조하려면 \\ref{} 등의 LaTeX에 특정한 구문을 사용할 수 있습니다. 그러나 LaTeX 구문은 HTML 및 전자 책과 같은 다른 출력 형식으로 이식할 수 없습니다. 그렇기 때문에 레이블에는 (\\#label) 구문을, 상호 참조에는 \\@ref(label)구문을 도입한 것입니다. LaTeX 출력에 적용될 최상위 수준 YAML 옵션이 있습니다. 책의 경우 기본 문서 클래스를 book(기본값은 article)으로 변경하고 발행인이 요구하는 참고 문헌 스타일을 지정할 수 있습니다. 간단한 YAML 예는 다음과 같습니다 : --- documentclass: book bibliography: [book.bib, packages.bib] biblio-style: apalike --- 용지 크기, 글꼴 크기, 페이지 여백, 줄 간격, 글꼴 모음 등과 같이 LaTeX 출력에 지정할 수있는 다른 많은 YAML 옵션이 있습니다. 전체 옵션 목록은 http://pandoc.org/MANUAL.html#variables-for-latex를 참조하십시오. pdf_book() 형식은 html_book()과 같은 일반적인 형식이며 base_format 인수도 포함합니다. pdf_book(toc = TRUE, number_sections = TRUE, fig_caption = TRUE, pandoc_args = NULL, ..., base_format = rmarkdown::pdf_document, toc_unnumbered = TRUE, toc_appendix = FALSE, toc_bib = FALSE, quote_footer = NULL, highlight_bw = FALSE) base_format 함수를 다른 출력 형식 함수로 변경할 수 있으며 bookdown은 Tufte PDF 스타일을 사용하는 PDF 책 (tufte 패키지 참조)을 만들기 위해 기본적으로 pdf_book(base_format = tufte::tufte_book)인 간단한 래퍼 함수 tufte_book2()를 제공합니다. "],["EbookFormat.html", "3.3 E-Books", " 3.3 E-Books 현재 bookdown은 EPUB 및 MOBI의 두 가지 전자 책 형식을 제공합니다. 이러한 형식의 책은 스마트 폰, 태블릿 또는 Kindle과 같은 특수 전자 책과 같은 장치에서 읽을 수 있습니다. 3.3.1 EPUB EPUB 책을 만들려면 epub_book() 형식을 사용할 수 있습니다. rmarkdown::html_document()와 공통된 몇 가지 옵션이 있습니다. epub_book(fig_width = 5, fig_height = 4, dev = &quot;png&quot;, fig_caption = TRUE, number_sections = TRUE, toc = FALSE, toc_depth = 3, stylesheet = NULL, cover_image = NULL, metadata = NULL, chapter_level = 1, epub_version = c(&quot;epub3&quot;, &quot;epub&quot;), md_extensions = NULL, pandoc_args = NULL, template = &quot;default&quot;) e-book 리더가 책에서 목차를 자동으로 알아낼 수 있기 때문에 toc 옵션이 꺼져 있으므로 목차에 몇 페이지를 추가 할 필요가 없습니다. EPUB에 특정한 몇 가지 옵션이 있습니다. stylesheet : HTML 출력 형식의 css 옵션과 유사하며 CSS를 사용하여 요소의 모양을 사용자가 지정할 수 있습니다. cover_image : 책 표지의 이미지 경로입니다. metadata : 책의 메타 데이터에 대한 XML 파일의 경로입니다 (자세한 내용은 Pandoc 문서 참조). chapter_level : 내부적으로 EPUB 책은 일련의 “chapter” 파일이며, 이 옵션은 책이 이러한 파일로 분할되는 수준을 결정합니다. 이는 섹션 3.1에서 언급한 HTML 출력 형식의 split_by 인수와 유사하지만 EPUB 책은 단일 파일이며 이러한 “chapter” 파일은 직접 볼 수 없습니다. 기본 수준은 첫 번째 수준이며 2로 설정하면 책이 내부적으로 섹션 파일 별로 구성되어 독자가 책을 더 빨리 로드할 수 있음을 의미합니다. epub_version : EPUB의 버전 3 또는 2입니다. EPUB 책은 본질적으로 HTML 페이지의 모음입니다. 예를 들어 CSS 규칙을 해당 요소에 적용하고, 이미지를 포함하고, (MathML이 부분적으로 지원되기 때문에) 수식을 삽입할 수 있습니다. 2에 언급된 그림/표 캡션, 상호 참조, 맞춤 블록 및 인용도 EPUB에서 작동합니다. 이 책의 EPUB 출력을 HTML 출력과 비교할 수 있으며 유일한 차이점은 시각적인 모양이라는 것을 알 수 있습니다. Calibre(https://www.calibre-ebook.com), Apple의 iBooks, Google Play Books를 비롯한 여러 종류의 EPUB 리더를 사용할 수 있습니다. 3.3.2 MOBI MOBI 전자 책은 Amazon의 Kindle 기기에서 읽을 수 있습니다. Pandoc은 기본적으로 MOBI 출력을 지원하지 않지만 타사 도구를 사용하여 EPUB를 MOBI로 변환할 수 있습니다. 가능한 도구 중 하나는 Calibre입니다. Calibre는 오픈 소스로 무료이며 더 많은 형식 간의 변환을 지원합니다. 예를 들어 HTML을 EPUB으로, Word 문서를 MOBI로 변환할 수 있습니다. bookdown의 함수 calibre()는 Calibre의 명령 줄 유틸리티 ebook-convert의 래퍼 함수입니다. 환경 변수 PATH를 통해 실행 가능한 ebook-convert를 찾을 수 있는지 확인해야 합니다. macOS를 사용하는 경우 brew cask install calibre 명령을 통해 Homebrew(https://brew.sh)와 함께 Calibre를 설치할 수 있으므로 PATH와 관련되는 부분은 걱정할 필요가 없습니다. "],["a-single-document.html", "3.4 단일 문서", " 3.4 단일 문서 때로는 책 대신에 하나의 긴 기사나 보고서를 쓰고 싶을 수도 있습니다. 일반적으로 특정 출력 형식으로 rmarkdown::render()를 호출합니다. 누락된 주요 기능은 그림/표/방정식 등의 자동 번호 매기기와 그림/표/방정식/섹션 상호 참조 등입니다. bookdown에서 이러한 기능을 추출하여 여러 Rmd 파일 책을 준비하지 않고도 사용할 수 있습니다. 이를 위해 html_document2(), tufte_html2(), pdf_document2(), word_document2(), tufte_handout2()그리고 tufte_book2() 함수가 설계되어 있습니다. bookdown::html_document2와 같은 출력 형식으로 R Markdown 문서를 렌더링하면 그림/표 번호를 얻고 2에 설명된 구문을 사용하여 단일 HTML 페이지에서 상호 참조할 수 있습니다. 다음은 단일 Rmd 파일의 YAML 메타 데이터에 있는 이러한 출력 형식의 몇 가지 예입니다 (이 형식 을_output.yml 파일에 추가할 수도 있습니다다). output: bookdown::html_document2: default bookdown::pdf_document2: keep_tex: true bookdown::word_document2: toc: true 위의 HTML 및 PDF 출력 형식 함수는 기본적으로 base_format 인수를 변경했다는 의미에서 출력 형식 bookdown::html_book과 bookdown::pdf_book의 래퍼입니다. 예를 들어 pdf_document2의 소스 코드를 살펴볼 수 있습니다. bookdown::pdf_document2 ## function (...) ## { ## pdf_book(..., base_format = rmarkdown::pdf_document) ## } ## &lt;bytecode: 0x7f92f3dcc0a8&gt; ## &lt;environment: namespace:bookdown&gt; 이 사실을 알고 나면 적절한 base_format을 사용하여 동일한 아이디어를 다른 출력 형식에 적용할 수 있습니다. 예를 들어 YAML 메타 데이터를 사용하여 bookdown 기능을 rticles 패키지 (Allaire, Xie, Foundation, et al. 2020)의 jss_article 형식으로 이식할 수 있습니다. : output: bookdown::pdf_book: base_format: rticles::jss_article 그러면 2 장에서 소개한 모든 기능을 사용할 수 있습니다. gitbook () 형식은 주로 책용으로 설계되었지만 실제로는 단일 R Markdown 문서에도 적용할 수 있습니다. 유일한 차이점은 단일 페이지 출력에는 검색 버튼이 없다는 것입니다. 웹 브라우저의 검색 도구를 사용하여 텍스트를 찾을 수 있기 때문입니다 (예 : ‘Ctrl + F’ 또는 ‘Command + F’ 누르기). 단일 출력 페이지만 생성하도록 split_by 옵션을 none으로 설정할 수도 있습니다. 이 경우 탐색할 다른 페이지가 없기 때문에 탐색 버튼이 없습니다. 원하는 경우 여러 페이지로 된 HTML 파일을 생성할 수도 있습니다. 사용할 수 있는 또 다른 옵션은 단일 출력 페이지 일 때 self_contained = TRUE입니다. References "],["Customization.html", "4 맞춤화", " 4 맞춤화 이 책의 시작 부분에서 언급했듯이 R Markdown에 대한 기본 지식이 있어야하며 rmarkdown 대신 bookdown 기능을 소개하는 데 집중하고 있습니다. 실제로 R Markdown은 사용자 정의가 가능하며 출력 문서를 사용자가 정의하는 데 사용할 수 있는 많은 옵션이 있습니다. 출력을 사용자가 정의하려는 정도에 따라 YAML 메타 데이터에서 몇 가지 간단한 옵션을 사용하거나 전체 Pandoc 템플릿을 대체할 수 있습니다. "],["yaml-options.html", "4.1 YAML 옵션", " 4.1 YAML 옵션 대부분의 출력 형식 유형의 경우 특정 형식의 highlight 옵션을 사용하여 구문 강조 스타일을 맞춤 설정할 수 있습니다. 현재 가능한 스타일은default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, 그리고 breezedark 등이 있습니다. 예를 들어gitbook 형식으로tango 스타일을 선택할 수 있습니다. --- output: bookdown::gitbook: highlight: tango --- HTML 출력 형식의 경우 css 옵션을 사용하여 HTML 요소의 모양을 사용자가 정의하기 위한 자체 CSS 스타일 시트를 제공하고 싶어할 것입니다. HTML 및 LaTeX를 포함한 더 많은 형식에 적용되는 includes 옵션이 있습니다. includes 옵션을 사용하면 출력 본문 앞뒤에 임의의 맞춤 콘텐츠를 삽입할 수 있습니다. in_header, before_body, after_body 등의 세 가지 하위 옵션이 있습니다. 이러한 옵션을 이해하려면 HTML 또는 LaTeX 문서의 기본 구조를 알아야합니다. HTML 문서의 소스는 다음과 같습니다. &lt;html&gt; &lt;head&gt; &lt;!-- head content here, e.g. CSS and JS --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body content here --&gt; &lt;/body&gt; &lt;/html&gt; in_header 옵션은 파일 경로를 가져 와서 &lt;head&gt;태그에 삽입합니다. before_body 파일은 여는 &lt;body&gt;태그 바로 아래에 삽입되고 after_body는 닫는 태그 &lt;/body&gt;앞에 삽입됩니다. LaTeX 소스 문서는 유사한 구조를 가지고 있습니다. \\documentclass{book} % LaTeX preamble % insert in_header here \\begin{document} % insert before_body here % body content here % insert after_body here \\end{document} includes 옵션은 매우 유용하고 유연합니다. HTML 출력의 경우 임의의 HTML 코드를 출력에 삽입할 수 있습니다. 예를 들어 HTML 출력에서 MathJax 라이브러리를 통해 렌더링된 LaTeX 수학 표현식이 있고, 방정식 번호를 왼쪽에 표시하려는 경우 (기본값은 오른쪽에 있음) 다음 코드를 포함하는 텍스트 파일을 만들 수 있습니다. &lt;script type=&quot;text/x-mathjax-config&quot;&gt; MathJax.Hub.Config({ TeX: { TagSide: &quot;left&quot; } }); &lt;/script&gt; 파일 이름이 mathjax-number.html이고 책의 루트 디렉토리 (모든 Rmd 파일이 포함 된 디렉토리)에 있다고 가정해 보겠습니다. 이 파일은 in_header 옵션을 통해 HTML 헤드에 삽입 할 수 있습니다. --- output: bookdown::gitbook: includes: in_header: mathjax-number.html --- 또 다른 예는 HTML 페이지에서 댓글이나 토론을 활성화하는 것입니다. Disqus (https://disqus.com) 또는 Hypothesis (https://hypothes.is) 등과 같은 여러 대안이 있습니다. 이러한 서비스는includes 옵션을 통해 HTML 책에 쉽게 삽입할 수 있습니다(자세한 내용은 섹션 5.5 참조). 마찬가지로 LaTeX에 익숙하다면 임의의 LaTeX 코드를 프리앰블에 추가할 수 있습니다. 즉, LaTeX 패키지를 사용하고 책에 대한 패키지 옵션을 설정할 수 있습니다. 예를 들어,이 책은 in_header 옵션을 사용하여 booktabs (더보기 좋은 테이블 용)과 longtable (여러 페이지에 걸쳐있는 테이블 용)과 같은 몇 가지 LaTeX 패키지를 더 사용하고 그래픽의 링크가 작동하지 않는 XeLaTeX 문제를 수정하는데 적용하였습니다 : \\usepackage{booktabs} \\usepackage{longtable} \\ifxetex \\usepackage{letltxmacro} \\setlength{\\XeTeXLinkMargin}{1pt} \\LetLtxMacro\\SavedIncludeGraphics\\includegraphics \\def\\includegraphics#1#{% #1 catches optional stuff (star/opt. arg.) \\IncludeGraphicsAux{#1}% }% \\newcommand*{\\IncludeGraphicsAux}[2]{% \\XeTeXLinkBox{% \\SavedIncludeGraphics#1{#2}% }% }% \\fi 위의 LaTeX 코드는 preamble.tex 파일에 저장되며 YAML 메타 데이터는 다음과 같습니다. --- output: bookdown::pdf_book: includes: in_header: preamble.tex --- "],["themes.html", "4.2 테마 설정", " 4.2 테마 설정 때로는 출력의 전체 테마를 변경하고 싶을 수 있으며 일반적으로 이전 섹션에서 설명한 in_header 옵션을 통해 수행하거나 출력이 HTML 인 경우 css 옵션을 통해 수행할 수 있습니다. 일부 출력 형식에는 gitbook, tufte_html_book 그리고 tufte_book2 등과 같은 고유한 테마가 있으며 이러한 테마를 너무 많이 사용자 정의하고 싶지 않을 수 있습니다. 이에 비해 출력 형식 html_book()과 pdf_book()은 특정 테마와 관련이 없으며 더 맞춤 설정할 수 있습니다. 섹션 3.1.2에서 언급했듯이html_book()의 기본 스타일은 Bootstrap 스타일입니다. Bootstrap 스타일에는 실제로 사용할 수있는 몇 가지 기본 제공 테마가 있습니다. 여기에는 default, cerulean, journal, flatly, darkly, Readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex,yeti 등을 들 수 있다. theme 옵션을 통해 이러한 테마를 설정할 수 있습니다. --- output: bookdown::html_book: theme: united --- 이러한 Bootstrap 스타일이 마음에 들지 않으면theme를null로 설정하고css 또는includes 옵션을 통해 자신의 CSS를 적용할 수 있습니다. pdf_book ()의 경우 이전 섹션에서 언급한 in_header 옵션 외에 문서 클래스를 변경하는 것도 가능합니다. memoir (https://www.ctan.org/pkg/memoir), amsbook (https://www.ctan.org/pkg/) 등과 같이 책에 대한 가능한 LaTeX 수업이 많이 있습니다. amsbook), KOMA-Script (https://www.ctan.org/pkg/koma-script) 등이 있습니다. 다음은 KOMA-Script 패키지의scrbook 클래스를 지정하는 YAML 메타 데이터의 간단한 샘플입니다. --- documentclass: scrbook output: bookdown::pdf_book: template: null --- 일부 출판사(예 : Springer 및 Chapman &amp; Hall / CRC)에는 자체 LaTeX 스타일 또는 클래스 파일이 있습니다. 일반적으로 그렇게 간단하지는 않지만 documentclass옵션을 변경하여 문서 클래스를 사용할 수 있습니다. 결국in_header를 사용하거나 이러한 문서 클래스를 수용하기 위해 맞춤형 Pandoc LaTeX 템플릿을 디자인할 수도 있습니다. documentclass를 변경할 때 추가적인 Pandoc 인수--top-level-division = chapter를 지정하여 Pandoc이 첫 번째 수준 헤더가 섹션 대신 장(chapter)으로 처리되어야 한다(documentclass가book 인 경우 기본값)는 것을 알 수 있습니다. 예를 들면, documentclass: krantz output: bookdown::pdf_book: pandoc_args: --top-level-division=chapter "],["template.html", "4.3 템플릿", " 4.3 템플릿 Pandoc은 Markdown을 다른 출력 형식으로 변환할 때 내부적으로 템플릿을 사용합니다. 템플릿은$variable$형식의 일부 변수를 포함하는 일반 텍스트 파일입니다. 이러한 변수는 Pandoc에서 생성한 값으로 대체됩니다. 다음은 HTML 출력을 위한 매우 간단한 템플릿입니다. &lt;html&gt; &lt;head&gt; &lt;title&gt;$title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $body$ &lt;/body&gt; &lt;/html&gt; 두 개의 변수 title과 body가 있습니다. title의 값은 YAML 메타 데이터의title 필드에서 가져오고body는 Markdown 입력 문서의 본문에서 생성된 HTML 코드입니다. 예를 들어 Markdown 문서가 있다고 가정합니다. --- title: A Nice Book --- # Introduction This is a **nice** book! 위 템플릿을 사용하여 HTML 문서를 생성하면 소스 코드는 다음과 같습니다. &lt;html&gt; &lt;head&gt; &lt;title&gt;A Nice Book&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Introduction&lt;/h1&gt; &lt;p&gt;This is a &lt;strong&gt;nice&lt;/strong&gt; book!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 실제 HTML, LaTeX 및 EPUB 템플릿은 더 복잡하지만 아이디어는 동일합니다. 사용 가능한 변수를 알아야 합니다. 일부 변수는 내장 Pandoc 변수이고 일부는 YAML 메타 데이터에서 사용자가 정의하거나 명령 줄 옵션-V 또는--variable에서 전달될 수 있습니다. 일부 변수는 특정 출력 형식에서만 의미가 있습니다. 예를 들어documentclass 변수는 LaTeX 출력에서만 사용됩니다. 이러한 변수에 대한 자세한 내용은 Pandoc 설명서를 참조하십시오. 모든 기본 Pandoc 템플릿은 GitHub 저장소 https://github.com/jgm/pandoc-templates에서 찾을 수 있습니다. HTML 출력의 경우 bookdown에는 템플릿에 추가 주석 토큰이 필요하며 섹션 3.1.2에서 설명했습니다. "],["configuration.html", "4.4 설정", " 4.4 설정 섹션 (usage)에서rmd_files에 대해 언급했으며_bookdown.yml에서 책에 대해 구성할 수있는 더 많은 (선택 사항) 설정이 있습니다: book_filename : 기본 Rmd 파일의 파일 이름, 즉 모든 장에서 병합된 Rmd 파일. 기본적으로 이름은_main.Rmd입니다. delete_merged_file : 책이 성공적으로 렌더링된 후 메인 Rmd 파일을 삭제할지 여부. before_chapter_script : 각 장 앞에서 실행되는 하나 또는 여러 R 스크립트, 예를 들어 각 장을 컴파일하기 전에 작업 공간을 지우고 싶을 수 있습니다.이 경우 R 스크립트에서 rm(list = ls(all = TRUE))를 사용할 수 있습니다. after_chapter_script :before_chapter_script와 유사하며 R 스크립트는 각 장 다음에 실행됩니다. edit : 공동 작업자가 현재 페이지의 Rmd 소스 문서를 편집하기 위해 클릭할 수있는 링크입니다. 다른 사람의 리포지토리에서도 GitHub의 임의의 일반 텍스트 파일을 편집하기 쉽기 때문에 주로 GitHub 리포지토리 용으로 설계되었습니다 (리포지토리에 대한 쓰기 액세스 권한이 없는 경우 파일 편집을 마친 후 GitHub에서 자동으로 포크하고 풀 요청을 제출할 수 있습니다). 이 링크에는%s가 있어야 하며 각 페이지의 실제 Rmd 파일 이름으로 대체됩니다. history : edit와 유사하며 현재 페이지의 편집 / 커밋 히스토리에 대한 링크입니다. view : edit와 유사하며 현재 페이지의 소스 코드에 대한 링크입니다. rmd_subdir : 하위 디렉토리에서 책 소스 Rmd 파일을 검색할 지 여부 (기본적으로 루트 디렉토리 만 검색 됨). 부울 (예 :true는 프로젝트 디렉토리 및 모든 하위 디렉토리에서 책 소스 Rmd 파일을 검색 함)이거나 하위 디렉토리 하위 집합에서 책 소스 Rmd 파일을 검색하려는 경우 경로 목록일 수 있습니다. output_dir : 책의 출력 디렉토리 (기본적으로_book); 이 설정은render_book()에서 읽고 사용합니다. clean :clean_book()함수로 정리할 파일과 디렉토리의 벡터. _bookdown.yml의 예를 들면 다음과 같다 : book_filename: &quot;my-book.Rmd&quot; delete_merged_file: true before_chapter_script: [&quot;script1.R&quot;, &quot;script2.R&quot;] after_chapter_script: &quot;script3.R&quot; view: https://github.com/rstudio/bookdown-demo/blob/master/%s edit: https://github.com/rstudio/bookdown-demo/edit/master/%s output_dir: &quot;book-output&quot; clean: [&quot;my-book.bbl&quot;, &quot;R-packages.bib&quot;] "],["internationalization.html", "4.5 국제화", " 4.5 국제화 책의 언어가 영어가 아닌 경우 그림/표가 HTML 출력에서 자동으로 번호가 매겨질 때 “Figure”와 “Table”와 같은 특정 영어 단어와 구를 해당 언어로 번역해야 합니다. 일부 LaTeX 패키지는 이러한 용어를 중국어 용 ctexcap 패키지와 같은 현지 언어로 자동 번역 할 수 있기 때문에 국제화는 LaTeX 출력에 문제가 되지 않을 수 있습니다. LaTeX가 아닌 출력의 경우 구성 파일_bookdown.yml에서language 필드를 설정할 수 있습니다. 현재 기본 설정은 다음과 같습니다. language: label: fig: &#39;Figure &#39; tab: &#39;Table &#39; eq: &#39;Equation &#39; thm: &#39;Theorem &#39; lem: &#39;Lemma &#39; cor: &#39;Corollary &#39; prp: &#39;Proposition &#39; cnj: &#39;Conjecture &#39; def: &#39;Definition &#39; exm: &#39;Example &#39; exr: &#39;Exercise &#39; proof: &#39;Proof. &#39; remark: &#39;Remark. &#39; solution: &#39;Solution. &#39; ui: edit: Edit chapter_name: &#39;&#39; appendix_name: &#39;&#39; 예를 들어Figure x.x 대신FIGURE x.x를 원하는 경우fig를\"FIGURE\"로 변경할 수 있습니다. language: label: fig: &quot;FIGURE &quot; ui아래의 필드는 사용자 인터페이스에서 일부 용어를 지정하는 데 사용됩니다. edit 필드는_bookdown.yml의edit 링크와 관련된 텍스트를 지정합니다(섹션 4.4). chapter_name 필드는 장 제목의 장 번호 앞에 추가 할 문자열 (예 :'CHAPTER')이거나 장 번호를 입력으로 받아 새 장의 번호로 숫자 (예 :!expr function(i) paste('Chapter', i)) 문자열을 반환하는 R 함수일 수 있습니다. 길이가 2 인 문자형 벡터인 경우 장 제목 접두사는paste0(chapter_name[1], i, chapter_name[2])이 됩니다. 여기서 i는 장 번호입니다. 마찬가지로appendix_name 필드는 부록 제목의 부록 카운터 앞에 추가됩니다 (예 :'Appendix'). 다시 말하지만, 함수를 사용할 수도 있습니다. 중국어, 일본어 그리고 한국어(CJK)와 같은 멀티 바이트 문자를 사용하는 언어로 작성할 때 한 가지주의 사항이 있습니다. Pandoc은 순수 CJK 문자인 섹션 머리글에서 식별자를 생성할 수 없으므로, 섹션 제목에{#identifier}를 추가하여 식별자를 수동으로 할당하지 않는 한, 상호 참조할 수 없습니다(라벨이 없음). 여기서identifier는 사용자가 선택한 식별자입니다. "],["editing.html", "5 편집", " 5 편집 이 장에서는 책을 로컬에서 편집, 빌드, 미리보기 그리고 제공하는 방법에 대해 설명합니다. 텍스트 편집기를 사용하여 책을 편집할 수 있으며 RStudio IDE 사용에 대한 몇 가지 팁을 보여줍니다. 편집기를 소개하기 전에 책을 빌드, 미리보기 그리고 제공하기위한 기본 R 함수를 소개하여 RStudio IDE에서 특정 버튼을 클릭할 때 발생하는 상황을 실제로 이해하고 이러한 함수들을 호출하는 다른 편집기를 호출하여 사용자 정의할 수도 있습니다. "],["BuildBook.html", "5.1 책 빌드", " 5.1 책 빌드 To build all Rmd files into a book, you can call the render_book() function in bookdown. Below are the arguments of render_book(): render_book(input = &quot;.&quot;, output_format = NULL, ..., clean = TRUE, envir = parent.frame(), clean_envir = !interactive(), output_dir = NULL, new_session = NA, preview = FALSE, config_file = &quot;_bookdown.yml&quot;) 가장 중요한 인수는output_format으로, 출력 형식의 문자열 (예 :'bookdown::gitbook')을 사용할 수 있습니다. 이 인수를 비워 둘 수 있으며, 기본 출력 형식은 첫번째 Rmd 파일의 YAML 메타 데이터 또는 섹션 4.4에서 살펴본 대로 별도의 YAML 파일인 _output.yml 에 지정된 첫번째 output 형식이 될 것이다. 모든 형식이_output.yml에 지정되면 R 또는 Shell 스크립트 또는 Makefile을 작성하여 책을 컴파일하는 것이 쉽습니다. 다음은 쉘 스크립트를 사용하여 책을 HTML (GitBook 스타일 사용)과 PDF로 컴파일하는 간단한 예입니다. #!/usr/bin/env Rscript bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::pdf_book&quot;) Shell 스크립트는 Windows에서 작동하지 않지만 (엄격하게 사실은 아니지만) 아이디어를 얻을 수 있기를 바랍니다. ...인수는 출력 형식 함수에 전달됩니다. 인수clean과envir는rmarkdown::render()에 전달되어 중간 파일을 정리할지 여부를 결정하고 각각 R 코드를 평가할 환경을 지정합니다. 책의 출력 디렉토리는output_dir 인수를 통해 지정할 수 있습니다. 기본적으로 책은_book 디렉토리에 생성됩니다. 구성 파일_bookdown.yml의output_dir 필드를 통해 변경할 수도 있으므로 책을 여러 출력 형식으로 렌더링하기 위해 여러 번 지정할 필요가 없습니다. new_session 인수는 섹션 1.4에 설명되어 있습니다. preview = TRUE를 설정하면input 인수에 지정된 Rmd 파일만 렌더링됩니다. 이는 전체 책을 다시 컴파일하지 않기 때문에 특정 장을 미리 볼 때 편리할 수 있지만 책을 출판할 때는이 인수는 반드시 ’FALSE’로 설정해야합니다. 많은 출력 파일이render_book()에 의해 생성됩니다. 때로는 책 디렉토리를 정리하고 다시 시작하고 싶을 수 있습니다. 예를 들어 knitr에서 자동으로 생성된 Figure 및 캐시 파일을 제거합니다. 이를 위해clean_book()함수가 설계되었습니다. 기본적으로 삭제할 수 있는 출력 파일을 알려줍니다. 이 파일 목록을 보고 출력 파일로 잘못 식별된 파일이 없는 것이 확실한 경우 (수작업으로 생성한 입력 파일을 삭제하고 싶지 않음) bookdown::clean_book(TRUE)를 사용하여 모든 파일을 삭제할 수 있습니다. 파일 삭제는 비교적 위험한 작업이므로 GIT와 같은 버전 관리 도구 또는 백업 및 복원을 지원하는 서비스를 통해 책을 유지 관리하는 것이 좋습니다. 따라서 실수로 삭제하더라도 특정 파일을 영원히 잃지 않을 것입니다. "],["PreviewChapter.html", "5.2 장 미리보기", " 5.2 장 미리보기 책의 크기가 크면 전체 책을 만드는 속도가 느려질 수 있습니다. 책을 만드는 속도에 영향을 미칠 수 있는 두 가지 요소는 R 코드 청크의 계산과 Pandoc을 통해 Markdown에서 다른 형식으로 변환하는 것입니다. 전자는 청크 옵션 cache = TRUE를 사용하여 knitr에서 캐싱을 활성화하여 개선할 수 있으며 후자를 더 빠르게 만들기 위해 할 수 있는 일은 많지 않습니다. 그러나 bookdown에서 preview_chapter() 함수를 사용하여 한 번에 한 장만 렌더링하도록 선택할 수 있으며 일반적으로 전체 책을 렌더링하는 것보다 훨씬 빠릅니다. preview_chapter()에 전달된 Rmd 파일만 렌더링될 것입니다. 현재 장을 미리 보는 것은 해당 장에만 집중할 때 유용합니다. 내용을 더 추가하거나 장을 수정할 때 실제 출력을 빠르게 볼 수 있기 때문입니다. 미리보기는 모든 출력 형식에서 작동하지만 HTML 출력을 미리 보는 것이 좋습니다. 장 미리보기의 한 가지 단점은 bookdown이 이 경우 다른 장에 대해 아무것도 모르기 때문에 다른 장에 대한 상호 참조가 작동하지 않는다는 것입니다. 속도 향상을 위해 지불하는 합리적으로 작은 희생인 것입니다. 장 미리보기는 특정 장에 대한 출력만 렌더링하므로 다른 장의 내용도 올바르게 렌더링될 것이라고 기대해서는 안됩니다. 예를 들어, 다른 장으로 이동하면 실제로 해당 장의 이전 출력(존재하지 않을 수도 있음)이 표시됩니다. "],["ServeBook.html", "5.3 책 만들기", " 5.3 책 만들기 render_book() 또는 preview_chapter()를 반복해서 실행하는 대신 실제로 웹 브라우저에서 책을 실시간으로 미리 볼 수 있으며 필요한 것은 Rmd 파일을 저장하는 것뿐입니다. bookdown의 serve_book()함수는 servr 패키지를 기반으로 HTML 출력을 제공하기 위해 로컬 웹 서버를 시작할 수 있습니다 (Xie 2020c). serve_book(dir = &quot;.&quot;, output_dir = &quot;_book&quot;, preview = TRUE, in_session = TRUE, quiet = FALSE, ...) 책의 루트 디렉토리를 dir 인수에 전달하면 이 함수는 로컬 웹 서버를 시작하므로 서버를 사용하여 책 출력을 볼 수 있습니다. 책 출력에 액세스하기 위한 기본 URL은 ’http://127.0.0.1:4321'입니다. 대화형 R 세션에서 이 기능을 실행하면 이 URL이 웹 브라우저에서 자동으로 열립니다. RStudio IDE를 사용하는 경우 RStudio Viewer가 기본 웹 브라우저로 사용되므로 동일한 환경에서 Rmd 소스 파일을 작성하고 출력을 미리 볼 수 있습니다(예 : 왼쪽에 소스와 오른쪽에 출력) 서버는 책 루트 디렉토리의 변경 사항을 수신합니다. 책 디렉토리의 파일을 수정할 때마다 serve_book()은 변경 사항을 감지하고 Rmd 파일을 다시 컴파일하며 웹 브라우저를 자동으로 새로 고칠 수 있습니다. 수정된 파일에 Rmd 파일이 포함되지 않은 경우 브라우저를 새로 고칩니다 (예 : 특정 CSS 파일 만 업데이트 한 경우). 즉, 서버가 시작되면 다음에 해야 할 일은 단순히 책을 쓰고 파일을 저장하는 것입니다. 파일을 저장하면 편집과 미리보기가 자동으로 수행됩니다. 책 전체를 다시 컴파일하는 데 시간이 너무 많이 걸리지 않으면 preview = FALSE 인수를 설정하여 책을 업데이트 할 때마다 전체 책이 다시 컴파일되고 그렇지 않으면 수정 된 장만 preview_chapter()를 통해 다시 컴파일됩니다. ...의 인수는 servr::httw()로 전달되며 daemon과 port와 같은 가능한 모든 옵션을 보려면 도움말 페이지를 참조하십시오. in_session = TRUE 또는 FALSE를 사용하는 데에는 장단점이 있습니다. in_session = TRUE의 경우 현재 R 세션에서 책에 생성된 모든 객체에 액세스 할 수 있습니다. 데몬화 된 서버를 사용하는 경우 (daemon = TRUE 인수를 통해) 언제든지 객체를 확인할 수 있습니다. 현재 R 세션이 사용 중이 아닐 때; 그렇지 않으면 개체를 확인하기 전에 서버를 중지해야 합니다. 이것은 책에서 R 객체를 대화식으로 탐색해야 할 때 유용 할 수 있습니다. in_session = TRUE의 단점은 현재 R 세션의 상태가 깨끗하지 않을 수 있기 때문에 새로운 R 세션에서 컴파일된 책과 출력이 다를 수 있다는 것입니다. in_session = FALSE의 경우 현재 R 세션에서 책의 개체에 액세스할 수 없지만 모든 것이 새 R 세션에서 생성되므로 출력이 재현될 가능성이 더 큽니다. 이 기능은 미리보기 목적으로만 사용되므로 R 세션의 청결성은 큰 문제가 되지 않을 수 있습니다. 특정 사용 사례에 따라 in_session = TRUE 또는 FALSE를 선택할 수 있습니다. 결국 새로운 R 세션에서 신뢰할 수 있는 책 출력을 생성하기 위해서는 render_book()을 실행해야 합니다. References "],["RStudioIDE.html", "5.4 RStudio 통합개발환경", " 5.4 RStudio 통합개발환경 버전이 1.0.0 미만인 경우 RStudio IDE를 업그레이드하는 것이 좋습니다. 섹션 1.3에서 언급했듯이 모든 R Markdown 파일은 UTF-8로 인코딩되어야 합니다. 이는 특히 파일에 멀티 바이트 문자가 포함된 경우 중요합니다. UTF-8 인코딩으로 파일을 저장하려면 메뉴File-&gt; Save with Encoding을 사용하고UTF-8을 선택합니다. RStudio IDE에서 R Markdown 문서를 컴파일하기 위해Knit 버튼을 클릭할 때 RStudio에서 호출하는 기본 함수는rmarkdown::render()이며 이는 책에서 원하는 것이 아닙니다. 대신bookdown::render_book()함수를 호출하려면 R Markdown 문서index.Rmd의 YAML 메타 데이터에서site 필드를bookdown::bookdown_site로 설정할 수 있습니다. 예를 들면 다음과 같습니다 : --- title: &quot;A Nice Book&quot; site: bookdown::bookdown_site output: bookdown::gitbook: default --- index.Rmd에site:bookdown::bookdown_site를 설정하면 RStudio는이 디렉토리를 책 소스 디렉토리12로 검색할 수 있습니다. Build창에 Build Book 버튼이 표시됩니다. 버튼을 클릭하여 책 전체를 다른 형식으로 빌드할 수 있으며, 툴바에서Knit 버튼을 클릭하면 RStudio가 자동으로 현재 장을 미리 볼 수 있으며preview_chapter()를 명시적으로 사용할 필요가 없습니다. bookdown 패키지에는 RStudio 용 몇 가지 추가 기능이 포함되어 있습니다. RStudio 추가 기능에 익숙하지 않은 경우 http://rstudio.github.io/rstudioaddins/에서 문서를 확인할 수 있습니다. bookdown 패키지를 설치하고 RStudio v0.99.878 이상을 사용하면 도구 모음에 “Addins”이라는 드롭 다운 메뉴와 메뉴를 연 다음에는 “Preview Book”및 “Input LaTeX Math”와 같은 메뉴 항목이 표시됩니다. 추가 기능 “Preview Book”은 bookdown::serve_book()을 호출하여 책을 컴파일하고 제공합니다. 그러면 현재의 R 세션을 차단할 것입니다. 즉 serve_book )이 실행 중일 때 R 콘솔에서 더 이상 아무것도 할 수 없습니다. R 세션을 차단하지 않으려면 bookdown::serve_book(daemon = TRUE)를 사용하여 서버를 데몬화할 수 있습니다. 이 추가 기능은 RStudio에서 연 현재 문서가 책의 루트 디렉토리에 있을 때 사용해야 합니다. 그렇지 않으면 serve_book()이 책 소스를 찾지 못할 수 있습니다. “Input LaTeX Math” 추가 기능은 기본적으로 LaTeX 수학 표현식을 입력하는 데 도움이 되는 텍스트 상자를 제공하는 작은 Shiny 애플리케이션입니다 (그림 5.1 참고). 입력할 때 수학 표현식과 LaTeX 소스 코드의 미리보기가 표시됩니다. 이렇게 하면 수학 표현식을 입력 할 때 오류가 훨씬 덜 발생합니다. 미리보기없이 긴 LaTeX 수학 표현식을 입력하면X_{ij}를 의미 할 때X_ij와 같은 실수를 하거나 닫는 부분을 생략하기 쉽습니다. 추가 기능을 클릭하기 전에 RStudio 편집기에서 LaTeX 수학 표현식을 선택한 경우 표현식이 자동으로 로드되고 텍스트 상자에 렌더링됩니다. 이 추가 기능은 MathQuill 라이브러리 (http://mathquill.com) 위에 구축되었습니다. 수학 표현식에 대한 모든 LaTeX 명령을 완벽하게 지원하는 것은 아니지만 몇 가지 일반적인 수학 표현식을 입력하는 데 도움이됩니다. Figure 5.1: LaTex 수식 입력을 돕기 위한 RStudio 애드인 책을 작성하는 데 도움이 되는 추가 기능을 제공하는 다른 R 패키지도 있습니다. citr 패키지는 R Markdown 문서에 인용을 쉽게 삽입 할 수있는 “인용문 삽입(insert citations)”이라는 추가 기능을 제공합니다. 참고 문헌 데이터베이스를 검색하고 모든 인용 항목을 드롭 다운 메뉴에 표시하므로 인용 항목에 해당하는 인용 키를 기억하지 않고도 목록에서 선택할 수 있습니다 (그림 5.2 참고) Figure 5.2: 인용 삽입을 돕기 위한 RStudio 애드인 이 디렉토리는 RStudio 프로젝트여야 한다. "],["collaboration.html", "5.5 협업", " 5.5 협업 책을 쓰는 것은 거의 한 사람 이상을 포함합니다. 공동 저자는 물론 때때로 피드백을 제공하는 독자가 있을 수 있습니다. 모든 책의 장은 일반 텍스트 파일이기 때문에 버전 관리 도구에 적합합니다. 즉, 모든 공동 저자와 공동 작업자가 GIT와 같은 버전 관리 도구에 대한 기본 지식을 가지고 있다면 이러한 도구들을 사용하여 책 콘텐츠에 대해 공동 작업할 수 있습니다. 실제로 GIT 사용 방법을 모르더라도 GIT와의 협업은 가능합니다. GitHub를 통해 웹 브라우저에서 바로 온라인으로 파일을 만들고 편집할 수 있기 때문입니다. 한 사람만이라도 GIT에 익숙해야 하며 그 사람이 책 저장소를 설정할 수 있습니다. 나머지 공동 작업자는 온라인으로 콘텐츠를 제공할 수 있지만 로컬에서 작업하는 GIT의 기본 사용법을 알고 있으면 더 많은 자유를 갖게 됩니다. 독자는 두 가지 방법으로 기여할 수 있습니다. 한 가지 방법은 콘텐츠를 직접 제공하는 것이며 가장 쉬운 방법은 책 출처가 GitHub에서 호스팅되는 경우 GitHub pull requests를 이용하는 것입니다. 기본적으로 모든 GitHub 사용자는 Rmd 소스 파일 페이지에서 편집 버튼을 클릭하고 콘텐츠를 편집하고 승인을 위해 변경 사항을 제출할 수 있습니다. 제안된 변경 사항에 만족하면 (정확하게 변경된 사항을 명확하게 확인할 수 있음) “병합(Merge)”버튼을 클릭하여 변경 사항을 병합할 수 있습니다. 만족스럽지 않은 경우 풀 요청에 피드백을 제공하여 독자가 요구 사항에 따라 추가로 수정할 수 있습니다. 섹션 3.1.1에서 GitBook 스타일의 수정 버튼에 대해 언급했습니다. 이 버튼은 각 페이지의 Rmd 소스에 링크되어 있으며 풀 요청을 생성하도록 안내할 수 있습니다. 오타 수정과 같은 간단한 변경 사항을 전달하기 위해 이메일을 주고 받을 필요가 없습니다. 독자가 책에 기여하는 또 다른 방법은 댓글을 남기는 것입니다. 댓글은 이메일, GitHub 문제 또는 HTML 페이지 댓글과 같은 여러 형식으로 남길 수 있습니다. 여기에서는 Disqus를 예로 사용합니다 (섹션 4.1 참고). Disqus는 웹 페이지에 토론 영역을 포함하는 서비스이며 JavaScript를 통해 로드할 수 있습니다. 다음과 같이 Disqus에 새 포럼을 등록하고 생성한 후 JavaScript 코드를 찾을 수 있습니다. &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt; &lt;script&gt; (function() { // DON&#39;T EDIT BELOW THIS LINE var d = document, s = d.createElement(&#39;script&#39;); s.src = &#39;//yihui.disqus.com/embed.js&#39;; s.setAttribute(&#39;data-timestamp&#39;, +new Date()); (d.head || d.body).appendChild(s); })(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt; comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; yihui라는 이름을 자신의 포럼 이름으로 바꿔야 합니다 (이 이름은 새 Disqus 포럼을 만들 때 제공해야 함). 코드를 disqus.html과 같은 이름의 HTML 파일에 저장할 수 있습니다. 그런 다음 after_body 옵션을 통해 모든 페이지 끝에 삽입할 수 있습니다 (그림 5.3는 토론 영역의 모양을 보여줍니다) : --- output: bookdown::gitbook: includes: after_body: disqus.html --- Figure 5.3: 게시판이 있는 책 페이지 "],["Publishing.html", "6 출판", " 6 출판 책을 개발할 때 초안을 일반인이 사용할 수 있도록 하여 독자로부터 초기 피드백을 얻습니다(예 : 웹 사이트에 게시). 책을 다 쓴 후에는 인쇄본이나 전자 책 등의 공식적으로 출판할 수있는 옵션에 대해 생각해야 합니다. "],["RStudioConnect.html", "6.1 RStudio 연결", " 6.1 RStudio 연결 이론적으로는 책을 직접 렌더링하고 원하는 곳에 출력을 출판할 수 있습니다. 예를 들어 자체 웹 서버에서 HTML 파일을 호스팅 할 수 있습니다. bookdown에 publish_book()함수를 제공하여 책을 무료로 호스팅하기 위해 RStudio에서 제공하는 웹 사이트 https://bookdown.org에 책을 매우 간단하게 업로드 할 수 있습니다. 이 웹 사이트는 R Markdown 문서, Shiny 애플리케이션, R 플롯 등과 같은 다양한 R 관련 애플리케이션을 서버에 배포할 수있는 RStudio 제품인 “RStudio Connect” 위에 구축되었습니다. bookdown.org에 책을 게시하기 위해 RStudio Connect에 대해 많이 알 필요는 없습니다. 기본적으로 https://bookdown.org/connect/에 가입하고 bookdown::publish_book()을 처음 실행하려고 하면 bookdown이 귀하의 bookdown에 게시하도록 승인하라는 메시지가 표시됩니다. 그 이후로는 publish_book()을 다시 호출하면 bookdown이 더 이상 아무것도 요구하지 않습니다. publish_book(name = NULL, account = NULL, server = NULL, render = c(&quot;none&quot;, &quot;local&quot;, &quot;server&quot;)) 다루고 싶은 publish_book()의 유일한 인수는 render입니다. 출판하기 전에 책을 렌더링할 지 여부를 결정합니다. 이전에 render_book()을 실행했다면 이 인수를 변경할 필요가 없습니다. 그렇지 않으면'local'로 설정할 수 있습니다. bookdown::publish_book(render = &quot;local&quot;) 만일 여러분이 자체 RStudio Connect 서버를 설정한 경우 bookdown.org 대신 해당 서버에 책을 게시할 수 있습니다. "],["GitHub.html", "6.2 GitHub", " 6.2 GitHub GitHub 페이지 (https://pages.github.com)를 통해 무료로 GitHub에 책을 호스팅할 수 있습니다. GitHub는 정적 웹 사이트 빌더인 Jekyll (http://jekyllrb.com)을 지원하여 Markdown 파일에서 웹 사이트를 구축합니다. 이는 GitHub 페이지의 더 일반적인 사용 사례 일 수 있지만 GitHub는 임의의 정적 HTML 파일도 지원하므로 GitHub에서 책의 HTML 출력 파일을 호스팅할 수 있습니다. 핵심은 bookdown HTML 출력이 이미 독립형 웹 사이트이므로 GitHub에 웹 사이트가 Jekyll을 통해 빌드되지 않는다는 것을 알려주는 숨겨진 파일 .nojekyll을 만드는 것입니다. # assume you have initialized the git repository, # and are under the directory of the book repository now # create a hidden file .nojekyll touch .nojekyll # add to git here because will not show up in RStudio git add .nojekyll Windows를 사용하는 경우 touch 명령이 없을 수 있으며 file.create('.nojekyll')를 사용하여 R에서 파일을 만들 수 있습니다. 한 가지 방법은 GitHub 도움말에 설명된대로 master 브랜치의 /docs 폴더에서 책을 GitHub 페이지 사이트로 게시하는 것입니다. 먼저 출력 디렉토리를 설정합니다. 구성 파일 _bookdown.yml에 output_dir: \"docs\"줄을 추가하여 책의 /docs가 되도록 합니다. 그런 다음 변경 사항을 GitHub에 푸시한 후 저장소 설정으로 이동하여 “GitHub 페이지”에서 “소스”를 ’master branch/docs 폴더’로 변경합니다. 이 경우 .nojekyll 파일은 /docs 폴더에 있어야 합니다. 다른 방법은 저장소에 gh-pages 브랜치를 만들고 책을 만들어 이 브랜치에 HTML 출력 (이미지, CSS, 자바 스크립트 파일과 같은 모든 외부 리소스 포함)을 넣은 다음 브랜치를 원격 저장소로 푸시하는 것입니다. 책 저장소에gh-pages 브랜치가 없는 경우 다음 명령을 사용하여 만들 수 있습니다. # assume you have initialized the git repository, # and are under the directory of the book repository now # create a branch named gh-pages and clean up everything git checkout --orphan gh-pages git rm -rf . # create a hidden file .nojekyll touch .nojekyll git add .nojekyll git commit -m&quot;Initial commit&quot; git push origin gh-pages GIT를 설정 한 후에는 스크립트 (기본 설정에 따라 쉘, R 또는 Makefile)를 통해 나머지 작업을 자동화할 수 있습니다. 기본적으로 책을 HTML로 컴파일한 다음 git 명령을 실행하여 파일을 GitHub에 푸시하지만 수동 및 로컬에서 이 작업을 반복하고 싶지 않을 것입니다. 클라우드에서 출판 프로세스를 완전히 자동화하는 것은 매우 편리할 수 있으므로 올바르게 설정되면 책을 작성하고 Rmd 소스 파일을 GitHub에 푸시하기만 하면 책이 항상 자동으로 빌드되어 서버 측에 출판이 됩니다. 활용할 수 있는 서비스 중 하나는 Travis CI (https://travis-ci.org)입니다. GitHub의 공용 저장소에 대해 무료이며 소프트웨어 패키지의 CI (지속적 통합, continuous integration)를 위해 설계되었습니다. Travis CI는 GitHub에 푸시할 때마다 최신 버전의 저장소에서 특정 명령/스크립트를 실행하도록 Travis를 트리거할 수 있다는 점에서 GitHub에 연결할 수 있습니다 ^[먼저 GitHub에서 저장소에 대한 Travis CI 서비스를 승인해야합니다. Travis CI를 시작하는 방법은 https://docs.travis-ci.com/user/getting-started/를 참조하십시오.]. 이 명령은 저장소의 루트 디렉토리에있는.travis.yml이라는 YAML 파일에 지정되며 일반적으로 소프트웨어 테스트 목적이지만 실제로는 상당히 개방적입니다. 즉, Travis (가상) 컴퓨터에서 임의의 명령을 실행할 수 있습니다. 즉, Travis에서 책을 만들기 위해 자신의 스크립트를 확실히 실행할 수 있습니다. Travis는 현재 Ubuntu 및 Mac OS X 만 지원하므로 Linux/Unix 명령에 대한 기본 지식이 있어야합니다. 다음 질문은 Travis를 기반으로 한 책을 GitHub에 게시하는 방법입니다. 기본적으로 Travis에게 GitHub 저장소에 대한 쓰기 액세스 권한을 부여해야 합니다. 이 인증은 여러 가지 방법으로 수행 할 수 있으며 초보자에게 가장 쉬운 방법은 개인 액세스 토큰일 수 있습니다. 수행해야 하는 단계는 다음과 같습니다. GitHub에서 계정에 대한 개인 액세스 토큰을 만듭니다 (이 토큰을 사용하여 GitHub 저장소에 쓸 수 있도록 “repo”범위를 활성화해야 합니다). travis encrypt 명령 줄을 통해 환경 변수 GITHUB_PAT에 암호화하고 .travis.yml에 저장합니다 (예 :travis encrypt GITHUB_PAT = TOKEN). Travis 명령 줄 도구를 설치하거나 사용하는 방법을 모르는 경우 https://travis-ci.org/user/repo/settings를 통해 이 환경 변수를 저장하기만 하면 됩니다. 여기서 user는 GitHub ID이고 repo는 저장소의 이름입니다. GitHub 토큰을 사용하여 Travis에서 이 gh-pages 브랜치를 복제하고 R Markdown에서 HTML 출력 파일을 추가하고 (그림과 CSS 스타일 파일도 추가하는 것을 잊지 마세요) 원격 저장소로 푸시할 수 있습니다. 지금 (Rmd 소스 파일을 넣은) master 브랜치에 있고 책을 _book 디렉토리에 컴파일했다고 가정하자. Travis에서 다음으로 할 수 있는 작업은 다음과 같습니다. # configure your name and email if you have not done so git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot; # clone the repository to the book-output directory git clone -b gh-pages \\ https://${GITHUB_PAT}@github.com/${TRAVIS_REPO_SLUG}.git \\ book-output cd book-output git rm -rf * cp -r ../_book/* ./ git add --all * git commit -m&quot;Update the book&quot; git push -q origin gh-pages 변수 이름 GITHUB_PAT와 디렉토리 이름 book-output은 임의적이며 이름이 기존 환경 변수 이름 또는 디렉토리 이름과 충돌하지 않는 한 원하는 이름을 사용할 수 있습니다. 이 스크립트는 섹션 5.1에서 언급한 빌드 스크립트와 함께 master 셸 스크립트로 분기합니다. 예를 들어 _build.sh와 _deploy.sh로 이름을 지정할 수 있습니다. 그러면 .travis.yml이 다음과 같이 보일 수 있습니다. language: r pandoc_version: 1.19.2.1 env: global: - secure: A_LONG_ENCRYPTED_STRING before_script: - chmod +x ./_build.sh - chmod +x ./_deploy.sh script: - ./_build.sh - ./_deploy.sh language 키는 Travis에게 R이 설치된 가상 머신을 사용하도록 지시합니다. secure 키는 암호화된 개인 액세스 토큰입니다. 명령 줄 도구인 travis encrypt 대신 Travis의 웹 인터페이스를 사용하여 GITHUB_PAT 변수를 이미 저장한 경우이 키를 생략할 수 있습니다. 이 Travis 서비스는 주로 R 패키지를 확인하기 위한 것이므로 책 저장소가 R 패키지인 것처럼 (가짜) DESCRIPTION 파일도 필요합니다. 이 파일에서 정말로 중요한 것은 종속성(dependencies)의 사양입니다. 모든 종속성은 devtools 패키지를 통해 설치됩니다. 종속성이 CRAN 또는 BioConductor에 있는 경우 DESCRIPTION 파일의 Imports 필드에 간단히 나열할 수 있습니다. GitHub에 있는 경우Remotes 필드를 사용하여 저장소 이름을 나열할 수 있습니다. 다음은 하나의 예입니다. Package: placeholder Type: Book Title: Does not matter. Version: 0.0.1 Imports: bookdown, ggplot2 Remotes: rstudio/bookdown Travis에서 컨테이너 기반 인프라를 사용하는 경우 .travis.yml에 sudo: false를 사용하여 캐싱을 활성화할 수 있습니다. 일반적으로 Figure 디렉토리 (예 :_main_files)와 캐시 디렉토리 (예 :_main_cache)의 두 가지 유형 이상의 디렉토리를 캐시해야 합니다. knitr 청크 옵션 fig.path와 cache.path를 지정한 경우에도 이러한 디렉토리 이름이 다를 수 있지만 이러한 옵션을 변경하지 않는 것이 좋습니다. 그림과 캐시 디렉토리는 책 루트 디렉토리의 _bookdown_files 디렉토리에 저장됩니다. knitr 그림과 캐시 디렉토리의 캐싱을 활성화한 .travis.yml 파일에는 다음과 같은 추가 구성 sudo와 cache가 있을 수 있습니다. sudo: false cache: packages: yes directories: - $TRAVIS_BUILD_DIR/_bookdown_files 책을 만드는 데 시간이 많이 걸리는 경우 Travis에서 위의 구성을 사용하여 시간을 절약 할 수 있습니다. packages: yes는 Travis에 설치된 R 패키지도 캐시됨을 의미합니다. 위의 모든 스크립트와 구성은 bookdown-demo 저장소(https://github.com/rstudio/bookdown-demo/)에서 찾을 수 있습니다. 자신의 저장소에 복사하는 경우 자신의 암호화된 변수 GITHUB_PAT를 사용하여 .travis.yml의 secure 키를 변경해야 합니다. GitHub와 Travis CI가 책을 만들고 출판하는 유일한 선택은 아닙니다. 자신의 서버에 책을 자유롭게 저장하고 출판할 수도 있습니다. "],["출판사.html", "6.3 출판사", " 6.3 출판사 책을 온라인으로 출판하는 것 외에도 출판사와 함께 출판하는 것도 고려할 수 있습니다. 예를 들어, 이 책은 Chapman &amp; Hall/CRC에서 출판되었으며, https://bookdown.org/yihui/bookdown/ (출판사와의 계약에 따라)에 무료 온라인 버전도 있습니다. 고려할 수있는 또 다른 옵션은 기존 출판사와 작업하지 않으려는 경우 자체 출판 (https://en.wikipedia.org/wiki/Self-publishing)입니다. Pablo Casas는 유용할 수 있는 두 개의 블로그 게시물을 작성했습니다 : “책을 자체 출판하는 방법”과 ‘책 자체 출판 방법 : 북 다운 맞춤 설정’입니다. 선택한 출판사가 LaTeX를 지원하는 경우 bookdown으로 작성된 책을 출판하는 것이 훨씬 쉽습니다. 예를 들어 Chapman &amp; Hall은 krantz.cls라는 LaTeX 클래스를 제공하고 Springer는 svmono.cls를 제공합니다. 이러한 LaTeX 클래스를 PDF 책에 적용하려면 index.Rmd의 YAML 메타 데이터에서 documentclass를 클래스 파일 이름 (.cls 확장자 없이)으로 설정하십시오. LaTeX 클래스는 YAML 메타 데이터에서 가장 중요한 설정입니다. PDF 책의 전체 스타일을 제어합니다. 조정하고 싶은 다른 설정이 있는 경우가 많으며 아래에 이 책에 대한 세부 정보가 표시됩니다. 이 책의 YAML 메타 데이터에는 다음 설정이 포함됩니다. documentclass: krantz lot: yes lof: yes fontsize: 12pt monofont: &quot;Source Code Pro&quot; monofontoptions: &quot;Scale=0.7&quot; lot: yes 필드는 테이블 목록이 필요함을 의미하고, 마찬가지로 lof는 그림 목록을 의미합니다. 기본 글꼴 크기는 12pt이며, monospaced (고정 너비) 글꼴로 Source Code Pro를 사용하였는데, 이는 이 책의 모든 프로그램 코드에 적용되었습니다. LaTeX 서문 (섹션 4)에는 몇 가지 설정이 더 있습니다. 먼저 기본 글꼴을 Alegreya로 설정하고 이 글꼴에는 Small Capitals 기능이 없으므로 Alegreya SC 글꼴을 사용했습니다. \\setmainfont[ UprightFeatures={SmallCapsFont=AlegreyaSC-Regular} ]{Alegreya} 다음 명령은 부동(floating) 환경이 부동없이 페이지의 더 많은 부분을 차지할 수 있도록 허용하여 부동 환경을 개선하고자 하였습니다. \\renewcommand{\\textfraction}{0.05} \\renewcommand{\\topfraction}{0.8} \\renewcommand{\\bottomfraction}{0.8} \\renewcommand{\\floatpagefraction}{0.75} krantz.cls는 따옴표를 위한 VF 환경을 제공했기 때문에 표준 quote 환경을 VF로 재정의합니다. 섹션 2.1에서 스타일을 확인할 수 있습니다. \\renewenvironment{quote}{\\begin{VF}}{\\end{VF}} 그런 다음 하이퍼 링크를 각주로 재정의합니다. 책이 종이에 인쇄되면 독자가 텍스트의 링크를 클릭할 수 없기 때문입니다. 각주는 실제 링크가 무엇인지 알려줍니다. \\let\\oldhref\\href \\renewcommand{\\href}[2]{#2\\footnote{\\url{#1}}} _output.yml에 bookdown::pdf_book 형식에 대한 몇 가지 설정도 있습니다. bookdown::pdf_book: includes: in_header: latex/preamble.tex before_body: latex/before_body.tex after_body: latex/after_body.tex keep_tex: yes dev: &quot;cairo_pdf&quot; latex_engine: xelatex citation_package: natbib template: null pandoc_args: --top-level-division=chapter toc_unnumbered: no toc_appendix: yes quote_footer: [&quot;\\\\VA{&quot;, &quot;}{}&quot;] highlight_bw: yes 위에서 언급한 모든 서문(preamble) 설정은 latex/preamble.tex 파일에 있으며, 여기에서 머리말(front matter)이 시작되도록 지정했습니다. \\frontmatter latex/before_body.tex에는 출판사가 요구하는 빈 페이지 몇 개를 삽입하고 헌정 페이지(dedication page)를 작성했습니다. 책의 첫 번째 장 전에 우리는 다음의 내용을 삽입했는데, 그래서 LaTeX는 페이지 번호 매기기 스타일을 로마 숫자 (머리말의 경우)에서 아라비아 숫자(책 본문의 경우)로 변경하는 것을 알고 있습니다. \\mainmatter 색인은 latex/after_body.tex (섹션 2.9 참고)에 인쇄했습니다. 플롯 저장을 위한 그래픽 장치 (dev)는 글꼴이 플롯에 내장되도록 cairo_pdf로 설정되었습니다. 기본 장치 pdf는 글꼴을 내장하지 않기 때문입니다. 카피 에디터는 PDF에 사용된 모든 글꼴을 포함하도록 요구할 수 있으므로 책을 보이는 그대로 정확하게 인쇄할 수 있습니다. 그렇지 않으면 특정 글꼴이 대체되고 서체를 예측할 수 없습니다. quote_footer 필드는 인용 각주가 오른쪽으로 정렬되었는지 확인하는 것입니다. LaTeX 명령 \\VA{}는 인용 각주를 포함하기 위해 krantz.cls에서 제공했습니다. 이 책은 흑백으로 인쇄되므로 highlight_bw 옵션이 true로 설정되어 구문 강조 코드 블록의 색상이 회색조로 변환되었습니다. 이 책은 사용자 정의 글꼴을 더 쉽게 사용할 수 있도록 xelatex를 통해 PDF로 컴파일되었습니다. VF 환경과 \\VA{}명령을 제외한 위의 모든 설정은 다른 LaTeX 문서 클래스에 적용할 수 있습니다. Chapman &amp; Hall 과도 함께 작업하고 싶다면 편집자로부터 받은 사본 대신에 우리 저장소 (https://github.com/rstudio/bookdown/tree/master/inst/examples)에 있는 krantz.cls 복사본으로 시작할 수 있습니다. 우리는 LaTeX 헬프 데스크와 협력하여이 LaTeX 클래스와 관련된 몇 가지 문제를 해결 으므로 bookdown을 사용하는 경우 책에서 잘 작동할 것이라고 생각합니다. "],["소프트웨어-도구.html", "부록 A 소프트웨어 도구", " 부록 A 소프트웨어 도구 R Markdown을 사용하는 데 필요한 소프트웨어 패키지에 익숙하지 않은 사용자를 위해 이러한 패키지의 설치 및 유지 관리에 대해 간략하게 소개합니다. "],["r-and-r-패키지.html", "A.1 R and R 패키지", " A.1 R and R 패키지 R은 모든 CRAN (Comprehensive R Archive Network) 미러에서 다운로드하여 설치할 수 있습니다(예 : https://cran.rstudio.com). 매년 R의 몇 가지 새 릴리스가 있을 예정이며 가끔 R을 업그레이드 할 수 있습니다. bookdown 패키지를 설치하려면 R에 다음을 입력하면 됩니다. install.packages(&quot;bookdown&quot;) 이렇게 하면 필요한 모든 R 패키지가 설치됩니다. 또한 이러한 패키지가 실제로 책을 컴파일하는 데 사용되는지 여부에 대해 너무 신경쓰지 않는다면 모든 선택적 패키지도 설치하도록 선택할 수 있습니다 (예 : htmlwidgets) : install.packages(&quot;bookdown&quot;, dependencies = TRUE) GitHub에서 bookdown의 개발 버전을 테스트하려면 먼저 devtools를 설치해야 합니다. if (!requireNamespace(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;rstudio/bookdown&quot;) R 패키지는 종종 CRAN 또는 GitHub에서 지속적으로 업데이트되므로 가끔 업데이트하는 것이 좋습니다. update.packages(ask = FALSE) 필수는 아니지만 RStudio IDE를 사용하면 R 관련 프로젝트에서 작업할 때 많은 작업을 훨씬 쉽게 수행할 수 있습니다. RStudio IDE는 https://www.rstudio.com에서 다운로드할 수 있습니다. "],["pandoc.html", "A.2 Pandoc", " A.2 Pandoc R Markdown 문서 (*.Rmd)는 먼저 knitr 패키지를 통해 Markdown (*.md)으로 컴파일된 다음, Markdown은 Pandoc을 통해 LaTeX 또는 HTML과 같은 다른 출력 형식으로 컴파일됩니다. 이 프로세스는 rmarkdown 패키지에 의해 자동화됩니다. knitr 또는 rmarkdown은 bookdown의 필수 패키지이며 bookdown을 설치할 때 자동으로 설치되므로 별도로 설치할 필요가 없습니다. 그러나 Pandoc은 R 패키지가 아니므로 bookdown을 설치할 때 자동으로 설치되지 않습니다. Pandoc 홈페이지 (http://pandoc.org)의 설치 지침에 따라 Pandoc을 설치할 수 있지만 RStudio IDE를 사용하는 경우 실제로 설치할 필요가 없습니다. RStudio에는 Pandoc 사본이 포함되어 있으므로 Pandoc은 별도로 제공됩니다. Pandoc 버전 번호는 다음을 통해 얻을 수 있습니다. rmarkdown::pandoc_version() ## [1] &#39;2.11.2&#39; 이 버전이 너무 낮고 최신 버전에만 Pandoc 기능이 있는 경우 최신 버전의 Pandoc을 설치할 수 있으며 rmarkdown은 기본 제공 버전 대신 최신 버전을 호출합니다. "],["latex.html", "A.3 LaTeX", " A.3 LaTeX LaTeX는 책을 PDF로 변환하려는 경우에만 필요합니다. LaTeX와 설치에 대한 자세한 내용은 https://www.latex-project.org/get/에서 확인할 수 있지만 TeX Live를 기반으로 하는 TinyTeX라는 이름의 경량 크로스 플랫폼 LaTeX 배포를 설치하는 것이 좋습니다. TinyTeX는 R 패키지 tinytex (bookdown을 설치할 때 자동으로 설치되어야 함)를 통해 쉽게 설치할 수 있습니다. tinytex::install_tinytex() TinyTeX를 사용하면 다음과 같은 오류 메시지가 표시되지 않습니다. ! LaTeX Error: File `titling.sty&#39; not found. Type X to quit or &lt;RETURN&gt; to proceed, or enter new name. (Default extension: sty) Enter file name: ! Emergency stop. &lt;read *&gt; l.107 ^^M pandoc: Error producing PDF Error: pandoc document conversion failed with error 43 Execution halted 위의 오류는 titling.sty가 포함된 패키지를 사용했지만 설치되지 않았음을 의미합니다. LaTeX 패키지 이름은 종종 *.sty 파일 이름과 동일하므로 이 경우 titling 패키지를 설치할 수 있습니다. R Markdown과 함께 TinyTeX를 사용하면 누락된 LaTeX 패키지가 자동으로 설치되므로 이러한 문제에 대해 걱정할 필요가 없습니다. LaTeX 배포 및 패키지도 수시로 업데이트되며 특히 LaTeX 문제가 발생할 때 업데이트를 고려할 수 있습니다. LaTeX 배포 버전은 다음을 통해 확인할 수 있습니다. system(&quot;pdflatex --version&quot;) ## pdfTeX 3.14159265-2.6-1.40.21 (TeX Live 2020) ## kpathsea version 6.3.2 ## Copyright 2020 Han The Thanh (pdfTeX) et al. ## There is NO warranty. Redistribution of this software is ## covered by the terms of both the pdfTeX copyright and ## the Lesser GNU General Public License. ## For more information about these matters, see the file ## named COPYING and the pdfTeX source. ## Primary author of pdfTeX: Han The Thanh (pdfTeX) et al. ## Compiled with libpng 1.6.37; using libpng 1.6.37 ## Compiled with zlib 1.2.11; using zlib 1.2.11 ## Compiled with xpdf version 4.02 TinyTeX를 업데이트하려면 다음과 같이 하면 됩니다. tinytex::tlmgr_update() 해마다 TinyTeX도 업그레이드해야 할 수 있습니다(그렇지 않으면 LaTeX 패키지를 설치하거나 업데이트 할 수 없음).이 경우 TinyTeX를 다시 설치할 수 있습니다. tinytex::reinstall_tinytex() "],["소프트웨어-사용.html", "부록 B 소프트웨어 사용", " 부록 B 소프트웨어 사용 1에서 언급했듯이 이 책은 knitr 또는 rmarkdown에 대한 포괄적인 가이드가 아닙니다. 이 장에서는 knitr과 rmarkdown의 몇 가지 기본 개념과 구문을 간략하게 설명하고자 합니다. 추가 질문이 있는 경우 StackOverflow (https://stackoverflow.com)에 게시하되, 질문에 r, knitr, rmarkdown 그리고 bookdown 태그 등을 적절히 추가하면 좋습니다. "],["knitr.html", "B.1 knitr", " B.1 knitr knitr 패키지는 “Literate Programming”(Knuth 1984)이라는 아이디어를 기반으로 설계되었습니다. 소스 문서의 텍스트와 프로그램 코드를 혼합합니다. knitr가 문서를 컴파일할 때 프로그램 코드(코드 청크)가 추출되어 실행되고 프로그램 출력이 출력 문서의 원본 텍스트와 함께 표시됩니다. 섹션 2.3에서 기본 구문을 소개한 바 있습니다. R Markdown은 knitr에서 지원하는 유일한 소스 형식이 아닙니다. 기본 아이디어는 다른 컴퓨팅과 저작 언어에 적용될 수 있습니다. 예를 들어 knitr은 R과 LaTeX (*.Rnw 문서), R + HTML (*.Rhtml) 등의 조합도 지원합니다. C++, Python, SQL 등과 같은 다른 컴퓨팅 언어들도 knit를 사용할 수 있습니다. 뿐만 아니라, 아래는 간단한 예로, http://rmarkdown.rstudio.com/authoring_knitr_engines.html에서 자세한 내용을 확인할 수 있습니다. ```{python} x = &#39;Hello, Python World!&#39; print(x.split(&#39; &#39;)) ``` Python 사용자는 IPython 또는 Jupyter 노트북 (https://jupyter.org)에 익숙할 수 있습니다. 실제로 R Markdown은 Jupiter Notebook으로도 사용할 수 있으며 몇 가지 추가 이점이 있습니다. 자세한 내용은 다음 블로그 게시물을 참조하십시오 : https://blog.rstudio.org/2016/10/05/r-notebooks/. 문서에 리터럴 청크를 표시하려면 청크 헤더 앞에 빈 문자열 (``)을 생성하는 인라인 표현식을 추가하고 코드 청크를 네 개의 백틱으로 래핑하면됩니다.13 예를 들면 다음과 같습니다: ```` ```{r} # a literal code chunk ``` ```` 문서가 컴파일되면 인라인 표현식이 사라지고 다음이 표시됩니다. ```{r} # a literal code chunk ``` 일반적으로 문서를 컴파일할 때 knitr 함수를 직접 호출할 필요가 없습니다. rmarkdown이 knitr을 호출하기 때문입니다. 소스 문서를 다른 형식으로 더 이상 변환하지 않고 컴파일하려면 knitr::knit() 함수를 사용할 수 있습니다. References "],["r-markdown.html", "B.2 R Markdown", " B.2 R Markdown R과 Pandoc의 강력한 기능 덕분에 R Markdown 문서에서 쉽게 컴퓨팅을 수행하고 HTML / PDF / Word 문서, HTML5 / Beamer 슬라이드, 대시 보드 그리고 웹 사이트 등을 포함한 다양한 출력 형식으로 변환할 수 있습니다. R Markdown 문서는 일반적으로 YAML 메타 데이터 (선택 사항)와 문서 본문으로 구성됩니다. 2 장에서 문서 본문의 다양한 구성 요소를 작성하는 구문을 소개했으며 이 섹션에서는 YAML 메타 데이터에 대해 자세히 설명합니다. R Markdown의 메타 데이터는 문서의 맨 처음에 작성될 수 있으며, 각각 세 개의 대시 ---로 시작하고 끝납니다. YAML 메타 데이터는 일반적으로 콜론(:)으로 구분된 tag-value 쌍으로 구성됩니다. 예를 들면 다음과 같습니다. --- title: &quot;An R Markdown Document&quot; author: &quot;Yihui Xie&quot; --- 문자 값의 경우 값에 특수 문자가 포함되지 않으면 따옴표를 생략할 수 있지만 문자 값으로 예상되는 경우 그것들을 따옴표로 묶는 것이 더 안전합니다. 문자 외에 또 다른 일반적인 유형의 값은 논리 값입니다. yes와 true는 모두 참을 의미하고 no/false는 거짓을 의미합니다. link-citations: yes 값은 벡터가 될 수 있으며 벡터를 작성하는 두 가지 방법이 있습니다. 다음의 두 가지 방법은 동일합니다. output: [&quot;html_document&quot;, &quot;word_document&quot;] output: - &quot;html_document&quot; - &quot;word_document&quot; 값은 값 목록일 수도 있습니다. 두 개의 공백으로 값을 들여 쓰기만 하면 됩니다. output: bookdown::gitbook: split_by: &quot;section&quot; split_bib: no 값을 들여 쓰는 것을 잊는 것은 흔한 실수입니다. 예를 들어, 다음의 데이터는 output: html_document: toc: yes 다음과 같을 것으로 기대할 수 있지만 output: html_document: toc: yes 사실상 다음을 의미합니다. output: null html_document: null toc: yes R Markdown 출력 형식은 YAML 메타 데이터의 output 필드에 지정되어 있으며 가능한 옵션(예 :? rmarkdown::html_document 또는 ? bookdown::gitbook)에 대해서는 R 도움말 페이지를 참조해야 합니다. YAML에 있는 대부분의 다른 필드의 의미는 Pandoc 문서에서 찾을 수 있습니다. rmarkdown 패키지는 다음과 같은 R Markdown 출력 형식을 제공합니다. beamer_presentation context_document github_document html_document ioslides_presentation latex_document md_document odt_document pdf_document powerpoint_presentation rtf_document slidy_presentation word_document bookdown, tufte, articles, flexdashboard, revealjs 그리고 rmdformats 등을 포함한 다른 R 패키지에는 더 많은 가능한 출력 형식이 있습니다. "],["faq.html", "부록 C FAQ", " 부록 C FAQ 아래는 자주 묻는 질문 (FAQ)의 전체 목록입니다. 예, 여기에는 하나의 질문만 있습니다. 개인적으로 나는 FAQ를 좋아하지 않습니다. 그들은 종종 놀라움을 의미하며 놀라움은 소프트웨어 사용자에게 좋지 않습니다. Q : bookdown에 X, Y, Z 기능이 있나요? A : 짧은 대답은 ’아니요’입니다. 그러나 “정말 필요합니까?”라는 질문을 세 번했는데 여전히 “예”라고 대답했다면 https://github.com/rstudio/bookdown/issues에 기능 요청을 제출해 주십시오. 더 많은 기능을 요구하는 사용자는 종종 LaTeX 세계에서 왔습니다. 이 경우 Pandoc의 Markdown이 원시 LaTeX 코드를 지원하기 때문에 이 질문에 대한 대답은 ’예’입니다. Markdown이 당신을 위해 일을 할 수 없다고 느낄 때마다 Markdown 문서에 원시 LaTeX 코드를 적용할 수있는 옵션이 있습니다. 예를 들어, glossaries 패키지를 사용하여 용어집을 만들거나 LaTeX 구문을 알고 있는 한 복잡한 LaTeX 테이블을 포함할 수 있습니다. 그러나 LaTeX 콘텐츠는 이식할 수 없습니다. LaTeX/PDF 출력에서만 작동하며 다른 유형의 출력에서는 무시됩니다. 요청에 따라 향후 몇 가지 LaTeX 기능을 bookdown에 추가할 수 있지만 일반적인 철학은 Markdown을 가능한 한 단순하게 유지해야 한다는 것입니다. 세상에서 가장 도전적인 것은 멋진 기술을 배우는 것이 아니라 자신의 거친 마음을 제어하는 것입니다. "],["references.html", "References", " References "]]
