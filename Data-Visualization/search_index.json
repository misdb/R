[["index.html", "Data Visualization with R 서문", " Data Visualization with R Dae Ho Kim 2021-02-07 서문 Creative Commons License The online version of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["데이터-시각화.html", "0.1 데이터 시각화", " 0.1 데이터 시각화 0.1.1 강의 소개 0.1.2 강의 일정 주 내용 비고 1 강의소개, 강의일정, 강의평가 방법 등Part 1 : 1 R 왜 그래프/시각화인가?Part 1 : 2 R 그래프 패키지 소개 LIVE 강의 (3시간) 2 Part 2 : 1.1 일변량 연속형 데이터 그래프Part 2 : 1.2 일변량 범주형 자료 그래프Part 2 : 1.3 이변량 연속형변수 그래프 LIVE 강의 (1시간)사이버 강의(2시간) 3 Part 2 : 2.1 그래프 모수 설정하는 2가지 방법Part 2 : 2.2 기호의 모양/크기, 선 유형/두께Part 2 : 2.2 선 유형/두께 LIVE 강의 (1시간)사이버 강의(2시간) 4 Part 2 : 2.3 색깔 (colors)Part 2 : 2.4 그래프 영역Part 2 : 2.5.1 제목 및 XY축 라벨 추가 LIVE 강의 (1시간)사이버 강의(2시간) 5 Part 2 : 2.5.4 점 추가Part 2 : 2.5.5 문자 추가Part 2 : 2.5.6 범례 추가 LIVE 강의 (1시간)사이버 강의(2시간)[과제 #1] 6 Part 3 : 1.1.1 히스토그램Part 3 : 1.1.2 커널 밀도 곡선Part 3 : 1.1.3 히스토그램과 커널 밀도 곡선 겹쳐 그리기 LIVE 강의 (2시간)사이버 강의(1시간) 7 Part 3 : 1.3 범주형 축 그룹(요인) 순서 바꾸기Part 3 : 2.1.1 막대그림Part 3 : 2.1.2 누적 막대 그래프 (stacked bar chart) LIVE 강의 (2시간)사이버 강의(1시간) 8 중간고사 [과제 #2] 9 Part 3 : 2.2 원그림Part 3 : 3.1 모자이크 그림Part 3 : 4.1 산포도 LIVE 강의 (2시간)사이버 강의(1시간) 10 Part 3 : 4.2.1 집단간 비교를 위한 면 분할Part 3 : 4.3 산포도 꾸미기 (1)Part 3 : 4.3 산포도 꾸미기 (2) LIVE 강의 (2시간)사이버 강의(1시간) 11 Part 3 : 4.4 선그래프, 시계열그래프Part 3 : 4.5 이차원 밀도 그래프Part 3 : 4.6 클리브랜드 점 그래프 LIVE 강의 (2시간)사이버 강의(1시간) 12 Part 3 : 4.7 누적 영역 그래프Part 3 : 4.8 corrplot 상관계수 행렬 그래프Part 3 : 4.10 히트맵(Heat map) 그리기 LIVE 강의 (2시간)사이버 강의(1시간)[과제 #3] 13 Part 4 : 1.1 레이더 차트 or 거미줄 그림Part 4 : 1.2 별 그래프Part 4 : 1.2.4 나이팅게일 차트 LIVE 강의 (1시간)사이버 강의(2시간) 13(Option) Part 4 : 1.1 sf 개체 생성Part 4 : 1.4 sp 개체 정보의 확인 Part 4 : 1.7 속성 데이터 준비 14 Part 4 : 1.4 3차원 산점도Part 4 : 1.5 체르노프 얼굴그림Part 4 : 2 연속확률분포 곡선 LIVE 강의 (1시간)사이버 강의(2시간) 14(Option) Part 5 : 1 R에서의 지리공간 데이터 조작Part 5 : 2 정적 지도 생성Part 5 : 3 공간 데이터 서브세팅 15 기말고사 [과제 #4] 0.1.3 강의평가 방법 중간 고사 : 40% 기말 고사 : 40% 출석 점수 : 15% (결석 1회 : -1점, 지각 1회 : -0.5점) 자기주도학습 점수: 5% 0.1.4 강의 비중 LIVE 강의 : 21시간 사이버 강의 : 18시간 중간고사, 기말고사 : 각 3시간, 총 6시간 "],["part-1-서론.html", "Part 1 : 서론", " Part 1 : 서론 "],["r-왜-그래프시각화인가-why-graphsvisualization.html", "1 R 왜 그래프/시각화인가? (Why Graphs/Visualization?)", " 1 R 왜 그래프/시각화인가? (Why Graphs/Visualization?) 출처: https://rfriend.tistory.com/65?category=605866 library(ggplot2) 데이터 분석을 시작할 때 가장 처음 하는 일이 탐색적 데이터 분석(EDA, Exploratory Data Analysis) 입니다. 탐색적 데이터 분석을 할 때 데이터 형태와 구조를 파악하고, 많은 요약/기술 통계량도 뽑아보고, 그래프도 그려보면서 데이터의 형태와 특성, 분포 등을 파악하곤 합니다. 즉, 데이터 분석의 시작은 그래프라고 해도 관언이 아니겠습니다. R의 장점 중에 하나가 바로 출판물에 사용해도 좋을 만큼 미적으로도 아름다우면서도 어떤 모양, 조건으로도 그래프를 그려서 인사이트를 뽑아내기에 유용한 다양한 그래프/시각화를 지원한다는 점입니다. R의 강력한 그래프/시각화 기능 때문에 R을 이용한다고 하는 사용자도 있을 정도니깐요. 왜 그래프/시각화가 중요할까요? 그래프/시각화는 숫자나 표보다 직관적으로 이해하기가 쉽습니다.** 그래프/시각화가 이해하기 쉬우므로 의사소통하기에도 쉽고 효과적입니다. 마치 몇 페이지의 호소문이나 사설보다 한 장의 역사 사진이 사람들에게 울림이 더 큰 경우가 있듯이요. 자칫 통계량만을 뽑아보고 의사결정했을 때 자칫 오류를 범할 수 있는데요, 이때 그래프/시각화를 통해 데이터의 분포, 형태나 변수간의 관계에 대해서 중요한 통찰을 얻을 수 있습니다. 영국의 통계학자 Francis Anscombe 가 “Graphs in Statistical Analysis”(1973년)라는 논문 (링크를 클릭하면 pdf 다운로드 가능)에서 왜 통계분석을 할 때 반드시 통계량 뿐만 아니라 그래프 분석을 병행해야 하는지를 보여주는 데이터 예를 듭니다. (x1, y1), (x2, y2), (x3, y3), (x4, y4) 변수들로 구성된 4개 그룹이 있는데요, x1~x4, y1~y4 끼리 평균, 표준편차가 같고, (x1, y1), (x2, y2), (x3, y3), (x4, y4) 변수들 간의 상관계수와 회귀모형이 같습니다. 이정도면 같은 모집단에서 뽑은 같은 성격/특징/형태를 보이는 4개의 표본이라고 지레짐작하기 쉬운데요, 그래프를 그려보면 4개의 표본이 날라도 너무 달라서 깜짝 놀라게 됩니다. He later became interested in statistical computing, and stressed that *“a computer should make both calculations and graphs”*, and illustrated the importance of graphing data with four data sets now known as Anscombe’s quartet * source: https://en.wikipedia.org/wiki/Frank_Anscombe R에 base패키지인 datasets 패키지에 ’anscombe’라는 데이터 프레임이 기본 탑재되어 있는 데이터 셋이어서 쉽게 불러다가 예시를 들어보겠습니다. str()함수로 데이터 구조를 보니 8개 변수에 11개 관측치로 구성되어있는 데이터 프레임이고, x1, x2, x3, x4, y1, y2, y3, y4 모두 숫자형(numeric) 변수들이군요. ## Anscombe&#39;s Quartet of ‘Identical’ Simple Linear Regressions # Four x-y datasets which have the same traditional statistical properties # (mean, variance, correlation, regression line, etc.), # yet are quite different. # 데이터 구조 str(anscombe) ## &#39;data.frame&#39;: 11 obs. of 8 variables: ## $ x1: num 10 8 13 9 11 14 6 4 12 7 ... ## $ x2: num 10 8 13 9 11 14 6 4 12 7 ... ## $ x3: num 10 8 13 9 11 14 6 4 12 7 ... ## $ x4: num 8 8 8 8 8 8 8 19 8 8 ... ## $ y1: num 8.04 6.95 7.58 8.81 8.33 ... ## $ y2: num 9.14 8.14 8.74 8.77 9.26 8.1 6.13 3.1 9.13 7.26 ... ## $ y3: num 7.46 6.77 12.74 7.11 7.81 ... ## $ y4: num 6.58 5.76 7.71 8.84 8.47 7.04 5.25 12.5 5.56 7.91 ... 관측치가 11개 밖에 안되므로 모두 불어와 보면 아래와 같습니다. 이처럼 숫자만 봐서는 데이터 분포, 특성, 변수간 관계가 어떠한지 한눈에 안들어오고 이해가 잘 안되지요? # 데이터 View View(anscombe) 이럴때 보통 기술통계량을 보곤 하지요. 중심화 경향을 나타내는 평균과 퍼짐 정도를 나타내는 표준편차를 살펴보겠습니다. x1~x4 의 평균과 표준편차가 같고, y1~y4의 평균과 표준편차가 같게 나왔습니다. # 변수별 평균, 표준편차 options(digits = 2) # 소수점 자리 설정 sapply(anscombe, mean) ## x1 x2 x3 x4 y1 y2 y3 y4 ## 9.0 9.0 9.0 9.0 7.5 7.5 7.5 7.5 sapply(anscombe, sd) ## x1 x2 x3 x4 y1 y2 y3 y4 ## 3.3 3.3 3.3 3.3 2.0 2.0 2.0 2.0 이번에는 (x1, y1), (x2, y2), (x3, y3), (x4, y4)변수들 간의 상관계수를 살펴보겠습니다. 4개 집단 모두 상관계수가 0.82로 동일하게 나왔습니다. # x, y 상관계수 (x, y correlation) attach(anscombe) cor(x1, y1) ## [1] 0.82 cor(x2, y2) ## [1] 0.82 cor(x3, y3) ## [1] 0.82 cor(x4, y4) ## [1] 0.82 detach(anscombe) 다음으로 4개의 각 집단별로 종속변수 y, 독립변수 x 로 해서 단순회귀모형을 적합시켜보겠습니다. 결과는 4개 집단 모두 y = 3.0 + 0.5*x 로 나왔습니다. (y절편 3.0, 변수 x의 계수 0.5) # Simple Linear Regrassions by 4 groups ` attach(anscombe) # The following objects are masked from anscombe (pos = 3): # x1, x2, x3, x4, y1, y2, y3, y4 ` lm(y1 ~ x1) ## ## Call: ## lm(formula = y1 ~ x1) ## ## Coefficients: ## (Intercept) x1 ## 3.0 0.5 lm(y2 ~ x2) ## ## Call: ## lm(formula = y2 ~ x2) ## ## Coefficients: ## (Intercept) x2 ## 3.0 0.5 lm(y3 ~ x3) ## ## Call: ## lm(formula = y3 ~ x3) ## ## Coefficients: ## (Intercept) x3 ## 3.0 0.5 lm(y4 ~ x4) ## ## Call: ## lm(formula = y4 ~ x4) ## ## Coefficients: ## (Intercept) x4 ## 3.0 0.5 위에 살펴본 바를 종합해보면, 4개 집단의 x변수들의 평균, 표준편차가 같고, y변수들의 평균, 표준편차가 같습니다. 4개 집단의 x변수와 y변수들 간의 상관계수가 동일합니다. 4개 집단의 x독립변수와 y종속변수간 단순회귀모형 적합결과 x변수 계수와 y절편 값이 같은 동일 모델로 적합되었습니다. 이쯤되면 4개 집단의 x, y 변수 데이트들이 동일한 모집단에서 랜덤하게 추출된 동일한 형태/분포/특성을 지닌 데이터라고 믿어도 되지않겠습니까? 그런데, 그게 아닙니다. 아래의 4개 그룹별 x변수, y변수 산포도를 살펴보시지요. 그래프를 그려서 눈으로 보니 4개 집단이 다르지요? 통계량들은 이 4개의 집단이 같다고 말하고 있지만, 그래프는 이 4개 집단이 다르다고 말하고 있습니다. 이래서 서양 표현에 “One Look Is Worth A Thousand Words” 말이 있는 거지요. # Scatter Plot &amp; Simple Linear Regression Line par(mfrow = c(2,2)) # 2 x 2 layout attach(anscombe) ## The following objects are masked from anscombe (pos = 3): ## ## x1, x2, x3, x4, y1, y2, y3, y4 # The following objects are masked from anscombe (pos = 3): x1, x2, x3, x4, y1, y2, y3, y4 plot(x1, y1); abline(lm(y1~x1), col = &quot;blue&quot;, lty = 3) plot(x2, y2); abline(lm(y2~x2), col = &quot;blue&quot;, lty = 3) plot(x3, y3); abline(lm(y3~x3), col = &quot;blue&quot;, lty = 3) plot(x4, y4); abline(lm(y4~x4), col = &quot;blue&quot;, lty = 3) Figure 1.1: 데이터 세트 보기 : View detach(anscombe) 시각화가 왜 중요한지, 왜 인사이트를 뽑아내는데 효과적인지, 왜 그동안 몰랐던 사실을 발견하는데 큰 역할을 하는지에 대한 사례를 하나 더 들자면, TED에서 유명인사가 된 한스 로즐링(Hans Rosling)의 Dynamic Visualization을 들고 싶습니다. Youtube에서 “TED &amp; Hans Rosling” 이라는 키워드로 검색을 해보면 많은 동영상이 검색이 될거예요. 그중에 하나를 아래에 링크를 걸어놓습니다. 연도별로 그래프가 움직이면서 변화하는데요, 시간이라는 차원을 그래프에 녹여낸 아주 기가 막힌 시각화 방법이 되겠습니다. 거기다가 한스 로즐링의 열정적인 설명까지 곁들여져서 한편의 인상적인 통계학 공연이 완성이 됩니다. ^^ 마음 편하게 한번 감상해 보시지요. (아래 동영상 말고도 한스 로즐링거 많습니다) 이밖에도 구글 지도에 매쉬업을 해서 시각화를 한다든지, 소셜 네트워크 분석을 한다든지, 워드 크라우드 분석을 한다든지, 타이타닉 생존자에 대한 모자이크 그림 분석을 한다든지, 회귀분석을 하기 전 변수들 간 산포도 행렬 그래프 분석을 한다든지, 정규성 가정 검증을 위해 Q-Q plot을 그려본다든지, 분포 형태를 파악하기 위해 히스토그램이나 박스그림을 그려본다든지, 등, 등, 등 … 그래프/시각화가 얼마나 중요한지, 왜 필요한지를 알 수 있는 사례, 예시는 무수히 많습니다. 앞으로 하나씩 차근차근 포스팅을 해나가도록 하겠습니다. 오늘 포스팅의 결론은, “반드시 그래프/시각화를 병행하라!” 가 되겠습니다. "],["r-그래프-패키지-소개-graphics-lattice-ggplot2.html", "2 R 그래프 패키지 소개 (Graphics, Lattice, ggplot2)", " 2 R 그래프 패키지 소개 (Graphics, Lattice, ggplot2) 출처: https://rfriend.tistory.com/66?category=605866 R에는 다양한 그래프 패키지들이 있는데요, 그 중에서도 가장 많이 사용되는 패키지 3개를 들자면 Base Graphics package(Base package로서 별도 설치 필요 없음), Lattice package(별도 설치/호출 필요), ggplot2 package(별도 설치/호출 필요) 를 꼽을 수 있습니다. 시중에 나와있는 많은 수의 R 관련 책에서는 Base Graphics package를 가지고 R 그래프 소개를 많이 하고 있는 편이구요, R 그래프/시각화 전문 책에서는 ggplot2에 무게중심을 두고 쓰여진 책이 많은 편인데요, 저는 ggplot2를 중심으로 ‘R 그래프/시각화’ 카테고리에 포스팅을 해보려고 합니다. (ggplot2를 주로 쓰고, 부수적으로 Base Graphics package, Lattice package 의 그래프 R script를 참고용으로 간략히 소개하는 식으로 글을 써나갈까 합니다.) [ R 그래프 패키지 ] Figure 2.1: R 그래프 패키지 일단 Base Graphics, Lattice, ggplot2에 대해 간략히 장단점을 짚어보고, 그 다음으로 ggplot2의 문법에 대해도 간략히 소개하겠습니다. package author 장점 단점 Base Graphics R Core Team and contributors worldwide - 별도 설치/호출 필요 없음- 쉽고 편함- 사람이 생각하는 방식처럼 순차적으로 그래프를 쌓아감 - 한번 실행하면 취소 못함- 미리 계획 필요 (예: 세로 축 scale) Lattice Deepayan Sarkar - 전체 데이터를 보고 세로축, 마진, 여백 자동 계산 편리- 여러개 그래프를 동시에 하나의 화면에 그릴때 편리 - 순차적으로 그래프 쌓아가는 것 안됨- 직관적이지 못함 ggplot2 Hadley Wickham - Base Graphics 와 Lattice의 장점만 골라놨음- 그래프 문법에 따라 체계적, 통계적 조건 등 부여하여 고급 그래프 생성 가능 - 처음 배우기가 상대적으로 어려움 (단, 일단 문법이 익으면 그때부터는 생산성 더 높음) 위 표에서 언급했듯이 ggplot2가 Base Graphics의 interactive하게 하나씩 생각하고, 그려보고, 눈으로 확인하고, 그래프 위에 하나 더 쌓아서 그려보고…하는 직관적인 방식의 장점과, Lattice의 여러 개의 집단 전체 데이터의 범위를 보고 축/마진/여백 등을 자동 설정해주는 등의 편리함의 장점을 따다가 ’그래프 문법(Grammer of Graphics)’이라는 체계적인 방식으로 만들어진 패키지이다 보니 ggplot2를 추천하는 바입니다. (ps. 그냥 R로 그래프 몇 개 그리다 말거면, 그냥 일회성으로 쉽게 뚝딱 그래프 그리고 말거면 편하게 Base Graphics 패키지 활용하는게 견적이 더 좋을 수도 있겠습니다. 하지만 그래프 많이 쓰는 사용자라면 Base Graphics는 예외 케이스가 많아서 나중에는 생산성이 ggplot2에 비해 떨어집니다.) 그래프의 문법(Grammer of Graphics)라고 말씀드렸는데요, 그래프를 그리는데에도 “동사(Verb),” “명사(Noun),” “형용사(Adjective)”라는 체계를 갖추어 문법을 만들었다고 보면 되겠습니다. [ R ggplot2 Components ] Figure 2.2: ggplot2 구성요소 lattice와 ggplot2패키지 설치 및 패키지 호출은 아래와 같이 하면 됩니다. ## lattice 패키지 설치/호출 # install.packages(&quot;lattice&quot;) library(lattice) ## ggplot2 패키지 설치/호출 # install.packages(&quot;ggplot2&quot;) library(ggplot2) 참고자료 https://rfriend.tistory.com/66?category=605866 "],["part-2-base-graphics-plotting-system.html", "Part 2 :Base Graphics plotting system", " Part 2 :Base Graphics plotting system Base Graphics의 주요 함수들 : - hist() - boxplot() - stem() - barplot() - dotchart() - pie() - plot() 각 함수에 대한 사용방법은 ? 함수명으로 확인할 수 있다. R의 plotting system에는 크게 (1) Base Graphics, (2) Lattice, (3) ggplot2 의 3가지가 있습니다. 이전 포스팅에서 ggplot2 plotting system을 활용한 그래프 그리기를 소개하였다면, 이제부터는 쉽고 빠르게, 대화형으로 직관적으로 그래프를 단계적으로 그려나갈 수 있는 Base Graphics plotting system에 대해서 알아보겠습니다. Base Graphics system 은 기본 뼈대에 해당하는 (1) 높은 수준의 그래프 함수 (High Level Graphics facilities), 여기에 살을 하나, 둘씩 차근 차근 더해가는 (2) 낮은 수준의 그래프 함수 (Low Level Graphics facilities), 색깔이나 모양, 선 형태, 마진 등의 다양한 그래프 특성에 해당하는 옵션을 설정하는 (3) 그래픽 모수 (Graphic Parameters) 를 조합하여 단계적으로 (step by step) 그래프를 대화형으로 그려나가게 됩니다. Figure 2.3: Base Graphics system 아래에 산포도(scatter plot)을 가지고 위에서 소개한 용어들이 의미하는 바를 예를 들어 설명해보도록 하겠습니다. library(MASS) attach(Cars93) # 1. high level graphics facility : plot() # graphics parameters : type, pch, col, etc. plot(MPG.highway ~ Weight, type = &quot;p&quot;, pch = 19, col = &quot;black&quot;) # 2. low level graphics facility : abline(), title(), text() # 3. graphics parameters : labels, cex, pos, col, etc. abline(lm(MPG.highway ~ Weight)) text(Weight, MPG.highway, labels = abbreviate(Manufacturer, minlength = 5), cex = 0.6, pos = 2, col = &quot;blue&quot;) Figure 2.4: base Graphics의 그래프 예 detach(Cars93) 위 그래프의 R함수에서 높은 수준의 그래프 함수, 낮은 수준의 그래프 함수, 그래프 모수에 해당하는 부분을 각 각 표기하면 아래와 같습니다. 높은 수준의 그래프 함수 plot()으로 먼저 뼈대를 잡아놓고, 낮은 수준의 그래프 함수 abline()로 차의 무게(Weight)와 고속도로연비(MPG.highway) 간 회귀선을 적합시킨 선을 추가하고 text()로 차 제조사 이름(Manufacturer)을 명기하였습니다. 이때 그래프 모수(parameters)로 그래프의 형태(type), 점의 형태(pch), 색깔(col), 레이블(labels), default 대비 확대 배수(cex), 다른 축과 교차되는 좌표(pos) 등을 옵션으로 설정하게 됩니다. Figure 2.5: R 스크립트의 그래프 구성 요소 높은 수준의 그래프 함수 (High Level Graphics facilities) 들을 표로 정리해보면 아래와 같습니다. Graph High Level GraphicsFunctions of Base Graphics system histogram hist() Box-and-Whiskers Plot boxplot() Stem and Leaf Plot stem() Bar Plot barplot() Cleveland Dot Plot dotchart() Pie Plot pie() Scatter Plot plot(x, y) Scatter Plot Matrix plot(dataframe), cf) other package: scatterplotMatrx() Line Plot plot(x, y, type=“l”) High Density Needle Plot plot(x, y, type=“h”) Both Dot and Line Plot plot(x, y, type=“b”) Overlapped Dot and Line Plot plot(x, y, type=“o”) Step Plot plot(x, y, type=“s”) Empty Plot plot(x, y, type=“n”) "],["높은-수준의-그래프-함수.html", "3 높은 수준의 그래프 함수", " 3 높은 수준의 그래프 함수 디폴트 모수로 해서 간단하게 그래프를 예로 들어보겠습니다. 그래프를 그릴 때 우리가 그래프로 표현하고자 하는 변수의 갯수와 그 변수의 데이터 유형(Data Type)을 먼저 잘 확인해야 합니니다. 변수의 갯수 1개 : 1변량 2개 이상 : 다변량 변수의 데이터 유형 범주형(factor) 연속형(numeric) Figure 3.1: 변수의 갯수와 데이터 유형별 그래프 종류 위의 그림에서 보듯이, 변수의 갯수와 변수의 데이터 타입에 따라 적용하여 시각화할 수 있는 그래프의 형태가 달라짐을 알 수 있습니다. "],["데이터-세트.html", "데이터 세트", " 데이터 세트 데이터의 시각화를 위한 예제로 MASS 패키지에 수록되어 있는 Cars93 데이터 세트를 사용합니다. 항상 데이터의 분석 또는 시각화에 앞서 데이터의 구조를 확인하는 것이 첫 번째 작업입니다. 다음은 Cars93 데이터 세트의 구조를 확인하는 스크립트입니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 27개의 변수와 93개의 관측치 데이터로 구성됩니다 $ 다음에 변수명, 데이터 타입, 그리고 데이터 예를 보여주고 있습니다. 자세한 사항은 ? Cars93으로 출력되는 도움말을 확인합니다. (각 변수에 대한 설명 : Metadata) "],["일변량-연속형-데이터-그래프.html", "3.1 일변량 연속형 데이터 그래프", " 3.1 일변량 연속형 데이터 그래프 연속형 변수 1개를 그래프로 표시해 보겠습니다다. 사용하는 변수는 Cars93$MPG.highway 컬럼 1(일변량)개로, 이 변수는 int의 연속형 변수임을 알 수 있습니다. 3.1.1 히스토그램(Histogram) : hist() 히스토그램은 이 변수의 최소값(min) ~ 최대값(max) 사이를 적당한 구간(bin 또는 class라고 함)으로 나누고, 각 구간에 속하는 데이터의 갯수를 그래프로 표시한 것입니다. # histogram : hist() hist(Cars93$MPG.highway, main = &quot;histogram : hist()&quot;) Figure 3.2: 일변량 연속형 데이터 그래프 : 히스토그램 히스토그램에서는 X축을 구성하는 구간을 결정하는 것이 매우 중요합니다. : breaks = 인수로 지정. 기본값은 Sturges 공식으로 구해진 구간을 사용합니다. 3.1.2 박스 플롯(box-and-whisker plot) : boxplot() 박스 플롯을 사용하는 이유는 많은 데이터를 눈으로 확인하기 어려울 때 그림을 이용해 데이터 집합의 범위와 중앙값을 빠르게 확인할 수 있는 목적으로 사용합니다. 또한 통계적으로 이상치(outlier)가 있는지도 확인이 가능합니다. 박스 플롯은 수치적 자료를 표현하는 그래프입니다. 이 그래프는 자료에서 얻은 다섯 수치 요약(five number summary)을 가지고 그립니다. 다섯 수치 요약은 아래와 같습니다. 최솟값 : 제 1사분위에서 1.5 IQR1을 뺀 위치입니다. min(x) 제1사분위(Q1) : 25%의 위치를 의미합니다. 제2사분위(Q2) : 50%의 위치로 중앙값(median)을 의미합니다. 제3사분위(Q3) : 75%의 위치를 의미합니다. 최댓값 : 제3사분위에서 1.5 IQR을 더한 위치입니다. max(x) 최솟값과 최댓값을 넘어가는 위치에 있는 값을 이상치(Outlier)라고 부릅니다. # box-and-whisker plot : boxplot() boxplot(Cars93$MPG.highway, main = &quot;box-and-whisker plot : boxplot()&quot;) Figure 3.3: 일변량 연속형 데이터 그래프 : 박스 플롯 3.1.3 줄기 잎 그래프(stem and leaf plot) : stem() 줄기 잎 그림(Stem-and-leaf plot 또는 stem-and-leaf display)이란 통계학에서 통계적 자료를 표 형태와 그래프 형태의 혼합된 방법으로 나타내는 것을 말합니다. 표에서의 줄기(Stem)는 자료들의 공통되는 부분을 모아놓게 되며, 잎(leaf)은 줄기 부분의 나머지 부분을 모아둡니다. 도수(Frequency 또는 Count는 한 줄기에 속하는 자료의 개수를 의미합니다. # stem and leaf plot : stem() stem(Cars93$MPG.highway) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 2 | 00112233334444 ## 2 | 55555555666666666667777778888888888999999 ## 3 | 000000000111111123333333444 ## 3 | 6667778 ## 4 | 13 ## 4 | 6 ## 5 | 0 위의 그림에서 최소값이 20, 최대값이 50임을 알 수 있습니다. 자세한 사항은 ? stem으로 확인할 수 있습니다. "],["일변량-범주형-자료-그래프.html", "3.2 일변량 범주형 자료 그래프", " 3.2 일변량 범주형 자료 그래프 범주형의 변수 1개에 대한 그래프를 그려 보겠습니다. 사용하는 변수는 Cars93$Cylinders 컬럼 1개(일변량)로, 이 변수는 6개의 수준을 갖는 Factor 형 변수 즉, 범주형 변수임을 알 수 있습니다. 특히 여기에서 사용되는 함수들의 첫 번째 인수는 모두 table() 함수를 이용한 도수분포표가 된다는 것을 주의하기 바랍니다. 3.2.1 막대 그래프(bar plot) : barplot() 막대 그래프(bar graph)는 바 차트(bar chart), 바 그래프(bar graph) 등으로도 불립니다. 명목형 변수 X를 값에 비례하여 높이와 길이를 지닌 직사각형 막대로 표현하는 차트나 그래프를 말합니다. 막대는 수직으로나 수평으로 그릴 수 있습니다. barplot() 함수의 첫 번째 인수는 명목형 변수의 도수분포표입니다. 변수의 도수분포표는 table() 함수로 구할 수 있습니다. ##-------- plot for one variable, categorical data # bar plot : barplot() table_cyl &lt;- table(Cars93$Cylinders) # Cylinder 컬럼의 도수분포료 barplot(table_cyl, main = &quot;bar plot : barplot()&quot;) Figure 3.4: 일변량 범주형 데이터 그래프 : 막대 그래프 3.2.2 클리브랜드 점 그래프(Cleveland dot plot) : dotchart() Cleveland 라는 사람이 제안한 형식의 그래프로 Base Graphics 패키지의 dotchart() 함수를 이용하여 그릴 수 있습니다. 이 그래프는 x축을 연속형 변수로, 그리고 y축을 명목형 변수로 표현한다. 그런데, 이 그래프에서 주요 변수는 Y축을 이루는 명목형 변수입니다. 앞에서 살펴본 막대 그래프의 X축과 Y축을 바꿔 놓고, 그림을 막대가 아닌 점으로 표현한 것이 클리브랜드 점 그래프입니다. Y축의 변수를 reorder() 함수 또는 sort() 함수를 이용하여 발생도수의 오름차순/내림차순으로 정렬할 수 있습니다. # cleveland dot plot : dotchart() # frequency table table_cyl &lt;- table(Cars93$Cylinders) # names for label Cylinders &lt;- names(table_cyl) dotchart(as.numeric(table_cyl), labels = Cylinders, main = &quot;cleveland dot plot&quot;) Figure 3.5: 일변량 범주형 데이터 그래프 : 클리브랜드 점 그래프 as.numeric(table_cyl)은 도수분포표의 발생 도수만을 벡터로 추출합니다. [참고사항] Cars93$Cylinders 컬럼의 도수분포표를 sort() 함수를 이용하여 발생 도수를 오름차순으로 정렬하고, 이를 인수로 하여 클리브랜드 점 그래프를 그려 보겠습니다. # cleveland dot plot : dotchart() # frequency table table_cyl_inc &lt;- sort(table(Cars93$Cylinders)) # 발생 도수의 오름차순 정렬 # names for label Cylinders &lt;- names(table_cyl_inc) dotchart(as.numeric(table_cyl_inc), labels = Cylinders, main = &quot;cleveland dot plot&quot;) Figure 3.6: 일변량 범주형 데이터 그래프 : 클리브랜드 점 그래프 (Sort) Y축은 순서가 중요하지 않은 범주형 데이터이기 때문에 X축의 발생 도수로 정렬하는 것도 의미가 있습니다. 3.2.3 파이 차트(pie chart) : pie() 파이 차트는 도수분포표를 비율로 나타낼 때 사용합니다. 전체를 100%라고 했을 때, 각각이 차지하는 비율을 한 눈에 볼 수 있게 시각화하는 것입니다. 역시 이 파이 차트를 그릴 떄도 기본적으로 범주형 변수를 인수로 하여 table() 함수로 구한 도수분포표가 됩니다. # pie chart : pie() table_cyl &lt;- table(Cars93$Cylinders) # frequency table Cylinders &lt;- names(table_cyl) # names for label pie(table_cyl, labels = Cylinders, main = &quot;pie chart&quot;) Figure 3.7: 일변량 범주형 데이터 그래프 : 파이 차트 자세한 사용방법은 ? pie로 확인할 수 있습니다. "],["이변량-연속형변수-그래프.html", "3.3 이변량 연속형변수 그래프", " 3.3 이변량 연속형변수 그래프 연속형 변수 2개를 그래프로 표시해 보겠습니다. 사용하는 변수는 Cars93$Weight 컬럼과 Cars93$MPG.highway 컬럼 등 2(이변량)개로, 이 두 변수 모두 int 횽의 연속형 변수임을 알 수 있습니다. 3.3.1 산포도 (scatter plot) 산포도 또는 산점도라고도 합니다. 산포도는 x축과 y축으로 이루어진 그래프에 두 변수의 값을 점으로 나타낸 그래프입니다. 산포도를 이용하면 두 변수의 관계를 파악하는데 용이합니다. ##----- plot for 2 variables, continuous data # scatter plot : plot(x, y) with(Cars93, plot(Weight, MPG.highway, main = &quot;scatter plot : plot(x, y)&quot;)) Figure 3.8: 이변량 연속형 데이터 그래프 : 산포도 3.3.2 산포도 행렬 : plot(dataframe), pairs(), scatterplotMatrix(dataframe) 산포도 행렬은 3개 이상의 변수들간의 관계를 행렬 형태의 그래프로 시각화하는 것입니다. 아래의 예는 Cars93 데이터 세트 중 4개의 변수 간의 산포도를 행렬 형태로 보여주고 있습니다. Base Graphics 패키지의 plot() 함수와 car 패키지의 scatterplotMatrix() 함수의 사용을 예로 들어 보겠습니다. # scatter plot matrix : plot(dataframe) Cars93_subset &lt;- Cars93[,c(&quot;Weight&quot;, &quot;Horsepower&quot;, &quot;MPG.highway&quot;, &quot;MPG.city&quot;)] plot(Cars93_subset, main = &quot;scatter plot matrix : plot(dataframe)&quot;) Figure 3.9: 이변량 연속형 데이터 그래프 : 산포도 행렬 # scatter plot matrix : scatterplotMatrix(dataframe) # install.packages(&quot;car&quot;) library(car) ## Loading required package: carData scatterplotMatrix(Cars93_subset, main = &quot;scatter plot matrix : scatterplotMatrx(dataframe)&quot;) Figure 3.10: 이변량 연속형 데이터 그래프 : 산포도 행렬 3.3.2.1 그래프의 모양양 변경 : plot(x, y, type = \"l, h, b, o, s, n\") 그런데 plot() 함수는 기본적으로 데이터를 점(type = \"p\")으로 표현합니다. ##-------- # plot by various type : l, h, b, o, s, n # order by Weight Cars93_1 &lt;- Cars93[order(Cars93$Weight),] # dividing window frame par(mfrow = c(3, 2)) # plots by type attach(Cars93_1) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders # default plot plot(MPG.highway ~ Weight, main = &quot;type = default&quot;) # point plot plot(MPG.highway ~ Weight, type = &quot;p&quot;, main = &quot;type = p&quot;) # line plot plot(MPG.highway ~ Weight, type = &quot;l&quot;, main = &quot;type = l&quot;) # high density needle plot plot(MPG.highway ~ Weight, type = &quot;h&quot;, main = &quot;type = h&quot;) # both dot and line plot plot(MPG.highway ~ Weight, type = &quot;b&quot;, main = &quot;type = b&quot;) # overlapped dot and line plot plot(MPG.highway ~ Weight, type = &quot;o&quot;, main = &quot;type = o&quot;) Figure 3.11: 이변량 연속형 데이터 그래프 : 산포도 - 모양 변경 # step plot plot(MPG.highway ~ Weight, type = &quot;s&quot;, main = &quot;type = s&quot;) # empty plot plot(MPG.highway ~ Weight, type = &quot;n&quot;, main = &quot;type = n&quot;) detach(Cars93_1) Figure 3.12: 이변량 연속형 데이터 그래프 : 산포도 - 모양 변경 위의 그래프들은 높은 수준의 그래프 함수에 대해서 간략하게 소개하기 위해서 모수를 거의 손대지 않고 그린 그래프들입니다. 낮은 수준의 그래프 함수와 주요 모수 (parameter) 설정하는 방법에 대해서는 다음번 포스팅에서 소개하도록 하겠습니다. "],["이변량-범주형-변수-그래프.html", "3.4 이변량 범주형 변수 그래프", " 3.4 이변량 범주형 변수 그래프 3.4.1 모자이크 그래프 그리기 : mosaicplot() 모자이크 플랏(mosaic plot)은 2원, 3원 교차표를 시각화한 그래프입니다. 모자이크 플랏에는 사각형들이 그래프에 나열되고 각 사각형의 넓이는 각 범주에 속한 데이터의 수 또는 상대적인 크기를 의미합니다. 따라서 x축과 y축의 제목을 보고 데이터를 추론할 수 있습니다. R의 Basic Graphics 패키지에 모자이크 플랏을 그리는 함수는 mosaicplot() 함수입니다. 첫 번쨰 인수인 formula =는 범주형 변수들의 분할표를 구하는 변수의 목록입니다. 두 번째 인수인 data =는 데이터 세트를 지정해야 합니다. 이 두 개의 인수는 기본적으로 지정이 되어야 합니다. 사용할 data =는 MASS 패키지가 제공하는 Cars93으로 다음은 자동차 생산국을 나타내는 Origin과 생산국가별 에어백의 설치(AirBags)와 관련한 모자이크 그래프를 보여 주고 있습니다. mosaicplot(formula = ~ Origin + AirBags, data = Cars93, color = c(&quot;yellow&quot;, &quot;green&quot;, &quot;red&quot;), cex = 0.8) Figure 3.13: 이변량 연속형 데이터 그래프 : 모자이크 그래프 formula = ~ Origin + AirBags : X 축에는 ~ Origin에 의해 Origin 변수가 그리고 Y 축에는 + AirBags의 AirBags가 그래프에 표시됩니다. color = : Y 축에 표시되는 사각형의 색깔을 지정합니다. cex = : X 축과 Y 축의 데이터 글자의 크기를 지정합니다. 참고로 Cars93의 Origin 변수와 AirBags 변수의 분할표(Cross Tables)는 table() 함수로 그리고 분할표의 상대적 비율은 prop.table() 함수로 구할 수 있습니다. # Crosstabs of Orgin and AirBags tab &lt;- table(Cars93$Origin, Cars93$AirBags); tab # 분할표 생성 ## ## Driver &amp; Passenger Driver only None ## USA 9 23 16 ## non-USA 7 20 18 tab1 &lt;- proportions(tab, margin = 1) ; tab1 # 비율분할표 생성 (1 = 행 단위, 2 = 열 단위) ## ## Driver &amp; Passenger Driver only None ## USA 0.19 0.48 0.33 ## non-USA 0.16 0.44 0.40 table() : Origin과 AirBags 두 범주형 변수의 분할표를 구합니다. prop.table() 또는 proportions() : 분할표 tab을 인수로 해서 상대적 비율을 구합니다. 이때, 두번째 인수 margin =이 1이면 행 단위로, 2면 열단위의 비율을 구합니다. 추가적으로 base datasets에서 제공하고 있는 Titanic 데이터 세트를 모자이크 그래프로 표시해 보겠습니다. 참고로 Titanic 데이터 세트는 2,201 승객을 4개의 범주형 변수(Class, Sex, Age, Survived 등)로 분할하여 정리해 놓은 4차원 배열형태의 분할표입니다. (? Titanic으로 데이터 세트에 대한 내용을 확인해 보기 바랍니다.) mosaicplot(Titanic, # 데이터 입력 main = &quot;Survival on the Titanic&quot;, # 제목 설정 color = c(&quot;red&quot;,&quot;green&quot;), # 색 지정 off = 1) # 블럭들 사이의 간격 지정 Figure 3.14: 이변량 연속형 데이터 그래프 : 모자이크 그래프 - Titanic 한편 vcd 패키지가 제공하는 mosaic() 함수를 이용해서도 모자이크 그래프를 그릴 수 있으며, 또한 labelling = labelling_values 인수를 지정해서 사각형에 데이터 라벨을 표시할 수 있습니다. library(vcd) ## Loading required package: grid library(MASS) data(&quot;Titanic&quot;) mosaic(Titanic, labeling = labeling_values) Figure 3.15: 모자이크 그래프 - 데이터 라벨링 1 좀 더 깔끔하게 데이터 라벨링을 해 보겠습니다. library(vcd) tab &lt;- ifelse(Titanic &lt; 6, NA, Titanic) # 데이터 수정 : 6보다 작으면 `NA`처리 mosaic(Titanic, pop = FALSE) # 모자이크 그래프 그리기 labeling_cells(text = tab, margin = 0)(Titanic) # 데이터 라벨 표시하기 Figure 3.16: 모자이크 그래프 - 데이터 라벨링 2 상대적 비율의 모자이크 그래프를 그려 보겠습니다. mosaic(Titanic, pop = FALSE) labs &lt;- round(prop.table(Titanic), 2) # 상대적 비율로 데이터 라벨링 labeling_cells(text = labs, margin = 0, cex = 0.6)(Titanic) # 상대적 비율 표시 Figure 3.17: 모자이크 그래프 - 데이터 라벨링 3 "],["r-그래프-모수-graphical-parameters.html", "4 R 그래프 모수 (Graphical Parameters) ", " 4 R 그래프 모수 (Graphical Parameters) "],["그래프-모수-설정하는-2가지-방법.html", "4.1 그래프 모수 설정하는 2가지 방법", " 4.1 그래프 모수 설정하는 2가지 방법 이전 포스팅에서 Base Graphics plotting system에서 그래프의 기본 골격을 생성하는 높은 수준의 그래프 함수 (High Level Graphics Function)에 대해서 알아보았습니다. 이번 포스팅에서는 그래프의 기호, 선, 색깔, 마진, 영역 분할 등 그래프의 세부적인 옵션들을 설정하는 방법으로 ‘그래프 모수 (Graphical Parameters)’ 에 대해서 소개하겠습니다. 그래프 모수에는 약 70여가지가 있는데요, 포스팅에서 전부 다루기에는 무리가 있어서 활용 빈도가 높다고 생각하는 항목들만을 선별해서 소개하겠습니다. R의 콘솔 창에 ‘**?par**’ 라고 입력하면 graphical parameter setting 관련한 도움말을 참고할 수 있습니다. Figure 4.1: 그래프 모수 그래프 모수를 설정하는 방법에는 2가지가 있습니다. 첫번째 방법은 par() 함수를 이용해서 이후에 생성하는 그래프 전체에 일괄적으로 동일하게 모수를 적용하는 방법입니다 (global environment). 동일한 모수 설정치로 다수의 그래프를 그려야 하는 상황이라면 편리하게 사용할 수 있는 방법입니다. 일부 그래프 모수는 이 첫번째 방법으로만 설정할 수 있습니다. (예: 영역분할 mfrow 등) 두번째 방법은 그래프를 그릴 때마다 매번 함수 내에서 그래프 모수를 일일이 지정해 주는 방법입니다. 그래프를 한두개 그리고 말거라거나, 다수의 그래프를 그려야하기는 하는데 모수 설정치가 매번 다르다면 두번째 방법을 사용하는게 편하겠습니다. [ 그래프 모수를 설정하는 2가지 방법 ] Figure 4.2: 그래프 모수를 설정하는 2가지 방법 "],["par-함수에-의한-글로벌-환경-설정.html", "4.2 par() 함수에 의한 글로벌 환경 설정", " 4.2 par() 함수에 의한 글로벌 환경 설정 아래에 첫번째 방법으로 par() 함수를 이용해서 그래프 모수를 설정하는 예를 살펴보겠습니다. 4.2.1 데이터 세트 MASS 패키지에 내장되어 있는 Cars93 데이터프레임의 차무게(Weight)와 마력(Horsepower)과 고속도로연비(MPG.highway) 간의 관계를 알아보기 위해 산포도를 그려본 예제입니다. 4.2.2 par() 함수 도움말 보기 ##----------------------- ## Graphical Parameters # help on par() function ? par 4.2.3 글로벌 환경의 설정 par() 함수를 사용해서 global environment에 그래프 모수를 설정할 때는 나중에 디폴트 그래프 모수로 돌아와야 하는 상황에서 편리하게 사용할 수 있도록 par(no.readonly = TRUE) 를 par_origin 이라는 객체에 할당해서 저장해 둡니다. # method 1 : par() # saving original graphical parameters setting par_origin &lt;- par(no.readonly = TRUE) # setting new graphical parameters par(pch = 15, col = &quot;blue&quot;) plot(MPG.highway ~ Weight, type = &quot;p&quot;, Cars93) Figure 4.3: 그래프 모수의 설정 : 글로벌 환경 설정 plot(MPG.highway ~ Horsepower, type = &quot;p&quot;, Cars93) Figure 4.4: 그래프 모수의 설정 : 글로벌 환경 설정 4.2.4 글로벌 환경의 해제 그래프 다 그리고 나서 par(par_origin)을 이용하면 원래 기본값의 그래프 모수로 되돌아 오게 됩니다. # returning to original parameter setting par(par_origin) plot(MPG.highway ~ Weight, type = &quot;p&quot;, Cars93) Figure 4.5: 그래프 모수의 설정 : 글로벌 환경 해제 "],["개별-그래프마다-그래프-모수를-설정하는-방법-로컬-환경-설정.html", "4.3 개별 그래프마다 그래프 모수를 설정하는 방법 (로컬 환경 설정)", " 4.3 개별 그래프마다 그래프 모수를 설정하는 방법 (로컬 환경 설정) 두번째로 개별 그래프마다 그래프 모수를 설정하는 방법을 예로 들어보겠습니다. 그래프 결과는 위에서 par()로 그래프 모수 설정했을 때와 동일함을 알 수 있습니다. 이 방법은 높은 수준의 그래프 함수를 이용하여 그래프를 그려야 하는 상황에서, 각 함수의 인수로 그래프 모수를 지정해서 사용하는 방법입니다. 4.3.1 로컬 환경 설정 예 ## method 2 : setting graphical parameters seperately plot(MPG.highway ~ Horsepower, type = &quot;p&quot;, # scatter plot with point + pch = 15, # point character + col = &quot;blue&quot;, # color + data = Cars93) Figure 4.6: 그래프 모수의 설정 : 로컬 환경 설정 예 plot(MPG.highway ~ Weight, type = &quot;p&quot;, # scatter plot with point + pch = 21, # point character + col = &quot;black&quot;, # color + data = Cars93) Figure 4.7: 그래프 모수의 설정 : 로컬 환경 설정 예 위의 예에서는 점의 종류(type =), 점의 모양(pch =), 그리고, 색깔(col =) 등을 지정하고 있습니다. 4.3.2 기호 모양 pch, 크기 cex, 선 유형 lty, 선 두께 lwd 지난번 포스팅에서 R 그래프 모수 (Graphical Parameters)를 설정하는 2가지 방법(par(), arguments)에 대해서 소개하였습니다. 이번 포스팅에서는 그래프 모수의 기호, 선 모수 설정에 대해서 하나씩 예를 들어보면서 자세히 설명해보겠습니다. (그래프 모수가 70여 가지가 되므로 모두를 설명하기에는 무리가 있으며, 자주 사용하는 것들 위주로 선별해서 소개합니다. ? par 로 도움말을 찾아보시면 모든 그래프 모수에 대한 도움말을 검색할 수 있습니다) 4.3.2.1 기호 모향 (plotting symbols, characters) : pch = 그래픽 모수 pch 를 사용해서 다양한 모양의 기호, 상징을 그릴 수 있습니다. 디폴트는 pch=1 로서 속이 빈 원 모양이며, 아래의 pch 그래픽 모수 숫자별 모양을 참고해서 원하는 모양의 숫자를 pch = '숫자' 로 입력하면 되겠습니다. Figure 4.8: 기호 모양 MASS 패키지 내 Cars93 데이터프레임의 차 무게(Weight)와 고속도로연비(MPG.highway) 변수를 가지고 산포도 그래프를 아래와 같이 그려보았습니다. pch=1 ~ pch=6 까지 6개만 예로 들어보았습니다. ## symbol and character of plotting : pch= library(MASS) par(mfrow = c(3,2)) plot(MPG.highway ~ Weight, data = Cars93, pch = 1, main = &quot;pch = 1&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 2, main = &quot;pch = 2&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 3, main = &quot;pch = 3&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 4, main = &quot;pch = 4&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 5, main = &quot;pch = 5&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 6, main = &quot;pch = 6&quot;) Figure 4.9: 그래프 모수의 설정 : 기호 모양 : pch par(mfrow = c(1,1)) 4.3.2.2 기호 직접 입력하는 방법 (specifying character directly) pch = 1 처럼 숫자를 입력하는 방법 말고도 pch = '$', pch = '%', pch = '*'처럼 기호를 직접 pch 다음에 직접 입력해도 됩니다. ## specifying character directly par(mfrow = c(1,3)) plot(MPG.highway ~ Weight, data = Cars93, pch = &#39;$&#39;, main = &quot;pch = &#39;$&#39; &quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = &#39;%&#39;, main = &quot;pch = &#39;%&#39; &quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = &#39;*&#39;, main = &quot;pch = &#39;*&#39; &quot;) Figure 4.10: 그래프 모수의 설정 : 기호 모양 : 직접 지정 4.3.2.3 기호의 크기 : cex cex는 기호의 크기를 지정할 때 사용합니다. cex=1 이 디폴트 크기이며, cex 다음에 입력하는 숫자는 디폴트 대비 상대적인 크기를 나타냅니다. ## symbol size : cex par(mfrow = c(2, 3)) # plot display by 2 row and 3 column plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 0.5, main = &quot;cex = 0.5&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 1, main = &quot;cex = 1 (default)&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 1.5, main = &quot;cex = 1.5&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 2, main = &quot;cex = 2&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 3, main = &quot;cex = 3&quot;) plot(MPG.highway ~ Weight, data = Cars93, pch = 19, cex = 4, main = &quot;cex = 4&quot;) Figure 4.11: 그래프 모수의 설정 : 기호 크기 : cex 4.3.2.4 선 유형 (line types) : lty R 그래프 모수에서 제공하는 선 유형에는 아래과 같이 6개가 있습니다. Figure 4.12: 선 유형 ## line types : lty # ordering by Weight Cars93_order &lt;- Cars93[order(Cars93$Weight),] par(mfrow = c(2, 3)) # plot layout by 2 row and 3 column plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lty = 1, main = &quot;lty = 1&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lty = 2, main = &quot;lty = 2&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lty = 3, main = &quot;lty = 3&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lty = 4, main = &quot;lty = 4&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lty = 5, main = &quot;lty = 5&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lty = 6, main = &quot;lty = 6&quot;) Figure 4.13: 그래프 모수의 설정 : 선 유형 : lty 4.3.2.5 선 두께 (line width) : lwd 선 두께를 조절하는 그래프 모수는 lwd 입니다. lwd = 1 이 디폴트 값이며, 이 숫자를 기준으로 숫자만큼 선 두께가 배수가 됩니다. 아래에 lwd = 0.5, 1, 2, 3, 4, 5 별로 선 두께가 어떻게 변화하는지 예를 들어보았습니다. 참고로, plot(x, y, dataset, **type = \"l\"**) 로 하면 선 그래프 (line plot)를 그릴 수 있습니다. ## line width : lwd # ordering by Weight Cars93_order &lt;- Cars93[order(Cars93$Weight),] par(mfrow = c(2, 3)) # plot display by 2 row and 3 column plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lwd = 0.5, main = &quot;lwd = 0.5&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lwd = 1, main = &quot;lwd = 1 (default)&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lwd = 2, main = &quot;lwd = 2&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lwd = 3, main = &quot;lwd = 3&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lwd = 4, main = &quot;lwd = 4&quot;) plot(MPG.highway ~ Weight, data = Cars93_order, type = &quot;l&quot;, lwd = 5, main = &quot;lwd = 5&quot;) Figure 4.14: 그래프 모수의 설정 : 선 두께 : lty 4.3.3 현재 그래프 모수 확인 (checking current graphical parameter settings) : par() 참고로, par() 함수를 쓰면 현재의 그래프 모수를 확인해볼 수 있습니다. 갯수를 세어보니 총 72개 graphical parameter 가 있네요. # to see current graphical parameter settings par() 다음 번 포스팅에서는 색깔과 관련된 그래프 모수에 대해서 알아보도록 하겠습니다. 4.3.4 색깔 (colors), col, col.axis, col.lab, col.main, col.sub, fg, bg 지난번 포스팅에서는 R 그래프 모수(Graphical Parameters)를 설정하는 2가지 방법, 선의 유형(Line Type, lty)과 선의 두께(Line Width, lwd), 기호의 크기(Size of Character, cex) 옵션에 대해서 알아보았습니다. 이번 포스팅에서는 그래프 모수 중에서 색깔(color) 설정하는 방법에 대해서 알아보겠습니다. [ 색 관련 모수 별 기능 설명 ] 색 관련 모수(parameters of color) 기능 설명 (description) col 기호, 선, 문자 등의 색깔을 디폴트로 지정 (default plotting color) col.axis 축의 색 지정 (color for axis annotation) col.lab x축과 y축의 Label 색 지정 (color for x and y labels) col.main 제목 색 지정 (color for main title) col.sub 부제목의 색 지정 (color for sub titles) fg 그래프 전경 색 지정 (color for foreground) bg 그래프 배경 색 지정 (color for background) 아마도 대부분은 col 모수를 주로 사용하고 나머지 색상 관련 모수는 거의 사용하지 않을 듯 합니다만, R에서는 사용자가 원하면 거의 모든 부분의 색상을 원하는대로 설정할 수 있는 극강의 자유도를 제공합니다. R이 그래픽의 절대강자인 이유가 이처럼 다양한 모수를 제공해주는데 있습니다. 초보자라면 그냥 디폴트 옵션 사용하시면 되구요, 그래프에 욕심이 있는 분이라면 R의 색상 모수에 대해서 차근차근 공부해두시면 유용할 것입니다. 하나씩 차례대로 살펴보도록 하겠습니다. 4.3.5 기호, 선, 문자 등의 디폴트 색 지정 (default plotting color) : col R에서 지원하는 색의 종류에는 657개가 있습니다. **colors() 함수**를 사용하면 657개 전체 색 리스트를 볼 수 있습니다. ##------------------------------- ## Graphical parameters : color ##------------------------------- length(colors()) ## [1] 657 colors() 위처럼 text로 색깔 이름만 있으면 알기 어려울 수도 있는데요, Earl F. Glynn 가 657개 색을 각 숫자별로 그리드에 색을 보기에 좋도록 정리를 해놓았습니다. [ Color Chart by Earl F. Glynn, Stowers Institute for Medical Research, 24 May 2005 ] Figure 4.15: 색상 표 * 출처 : http://research.stowers-institute.org/efg/R/Color/Chart/index.htm R에서 색을 지정하는 방법에는 (1) 색 식별 숫자 (index), (2) 색 이름 (color name), (3) 16진수 (hexadecimal), (4) RGB 색상표의 4가지 방법이 있습니다. 숫자 (index) 색 이름 (color name) 16진수 (hexadecimal) RGB triple 4 (26번) blue #0000FF 0 0 255 NA (62번) comflowerblue #6495ED 100 149 237 NA (73번) darkblue #00008B 0 0 139 먼저 (1) 숫자(index)로 지정하는 방법은 편하긴 한데요, 선택할 수 있는 색은 아래와 같이 8가지가 있어서 매우 제한적입니다. index 0 1 2 3 4 5 6 7 8 color 흰색(white) 검정색(black) 빨강색(red) 초록색(green) 파랑색(blue) 청록색 (turquoise) 자홍색(magenta) 노란색(yellow) 회색(gray) # color by index 1~8 par(mfrow=c(1,2)) pie(rep(1, 8), col = 1:8) pie(rep(1, 16), col = 1:16) Figure 4.16: 색 지정 : 색 식별 번호 반면, (2) 이름(color name), (3) 16진법 표기 (hexadecimal), (4) RGB 색상표 (RGB triple) 은 매우 다양한 색상을 선택할 수 있는 장점이 있습니다. 아래는 Earl F. Glynn가 작성한 색상표에서 일부를 화면캡쳐한 내용인데요, 모든 색상표는 아래의 출처에 있는 pdf url에 있습니다. Figure 4.17: Earl F. Glynn가 작성한 색상표 * 출처 : http://research.stowers-institute.org/efg/R/Color/Chart/ColorChart.pdf 파란색(blue)에 대해서 위의 4가지 방법, 즉 (1) 숫자 (index), (2) 색 이름 (color name), (3) 16진수 (hexadecimal), (4) RGB 색상표를 사용해서 R 함수 예를 들어보겠습니다. 파란색(blue)으로 모두 똑같은 결과가 나았습니다. ## 4 methods of color &#39;blue&#39; exmaple : index, color name, hexadecimal, RGB # to use Cars933 dataframe par(mfrow = c(2,2)) # method 1 : index plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 19, col = 4, main = &quot;col = 4 (index)&quot;) # method 2 : color name plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 19, col = &quot;blue&quot;, main = &quot;col = blue (name)&quot;) # method 3 : hexadecimal plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 19, col = &quot;#0000FF&quot;, main = &quot;col = #0000FF (hexadecimal)&quot;) # method 4 : RGB triple rgb_1 &lt;- rgb(0, 0, 255, maxColorValue=255) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 19, col = rgb_1, main = &quot;col = RGB(0, 0, 255)(RGB triple)&quot;) Figure 4.18: 색 지정 : 색 이름 R에서는 색상 관련해서 서로 보완(complementing)되거나 대조를 이루는(contrasting) 색상들을 미리 파레트 형식으로 정의(defined palettes of colors)해 놓은 것이 있습니다. rainbow(n), heat.colors(n), terrain.colors(n), topo.colors(n), cm.colors(n) 등이 있는데요, example(rainbow) 함수를 이용해서 이들 색상표 palettes 를 살펴보겠습니다. 계속 Enter 치면 다음 화면으로 넘어갑니다. [ 색상 파레트 (defined palattes of colors) ] ## example of rainbow palette&#39;s colors example(rainbow) 4.3.6 축 색 지정 (color for axis annotation) : col.axis x축과 y축의 척도 표기 색상을 지정할 때 col.axis 모수 옵션을 사용합니다. 아래에 x축과 y축 척도 표기 색상으로 파랑색, 빨강색, 노랑색, 회색으로 바꿔가면서 그래프를 그려보았습니다. ## color for axis annotation : col.axis # to use Cars93 dataframe par(mfrow = c(2,2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.axis = &quot;blue&quot;, main = &quot;col.axis = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.axis = &quot;red&quot;, main = &quot;col.axis = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.axis = &quot;yellow&quot;, main = &quot;col.axis = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.axis = &quot;gray&quot;, main = &quot;col.axis = gray&quot;) Figure 4.19: 색 지정 : 축 척도의 색 4.3.7 x축과 y축 Label 지정 (color for x and y labels) : col.lab 이번에는 x축과 y의 Lable 색을 지정하는 방법으로 col.lab 모수 옵션을 사용하면 됩니다. 파랑색, 빨강색, 노랑색, 회색으로 x축과 y축의 Lable 색을 설정하는 예를 들어보겠습니다. ## color for x and y labels : col.lab par(mfrow = c(2,2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.lab = &quot;blue&quot;, main = &quot;col.lab = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.lab = &quot;red&quot;, main = &quot;col.lab = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.lab = &quot;yellow&quot;, main = &quot;col.lab = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.lab = &quot;gray&quot;, main = &quot;col.lab = gray&quot;) Figure 4.20: 색 지정 : 축의 제목 색 4.3.8 제목 색 지정 (color for main title) : col.main ## color for main title : col.main par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.main = &quot;blue&quot;, main = &quot;col.main = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.main = &quot;red&quot;, main = &quot;col.main = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.main = &quot;yellow&quot;, main = &quot;col.main = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.main = &quot;gray&quot;, main = &quot;col.main = gray&quot;) Figure 4.21: 색 지정 : 제목 4.3.9 부제목 색 지정 (color for sub title) : col.sub ## color for sub title : col.sub par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.sub = &quot;blue&quot;, sub = &quot;col.sub = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.sub = &quot;red&quot;, sub = &quot;col.sub = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.sub = &quot;yellow&quot;, sub = &quot;col.sub = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, col.sub = &quot;gray&quot;, sub = &quot;col.sub = gray&quot;) Figure 4.22: 색 지정 : 부제목 색 4.3.10 그래프 전경 색 지정 (color for foreground) : fg ## color for foreground : fg par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, fg = &quot;blue&quot;, main = &quot;fg (foreground) = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, fg = &quot;red&quot;, main = &quot;fg (foreground) = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, fg = &quot;yellow&quot;, main = &quot;fg (foreground) = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 1, pch = 21, fg = &quot;gray&quot;, main = &quot;fg(foreground) = gray&quot;) Figure 4.23: 색 지정 : 전경색 4.3.11 그래프 배경 색 지정 (color for background) : bg bg는 그래프 기호의 배경색을 채울 때 사용합니다. 아래에 기호 모양 21번 (원)에 파랑색, 빨강색, 노랑색, 회색을 채워보았습니다. ## color for background :bg par(mfrow = c(2, 2)) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;blue&quot;, main = &quot;bg (background) = blue&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;red&quot;, main = &quot;bg (background) = red&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;yellow&quot;, main = &quot;bg (background) = yellow&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;gray&quot;, main = &quot;bg (background) = gray&quot;) Figure 4.24: 색 지정 : 배경색 bg (background color)는 속이 비어있는 pch 21번부터 25번 까지만 사용가능하며, 그 외에는 적용이 안됩니다. 아래에 pch =1 일 때 bg 옵션이 적용이 안된 것을 확인할 수 있습니다. ## bg (background color) only works with pch from 21 to 25 par(mfrow=c(3,2)) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 1, bg = &quot;blue&quot;, main = &quot;pch = 1, bg is not working&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 21, bg = &quot;blue&quot;, main = &quot;pch = 21, bg is working&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 22, bg = &quot;blue&quot;, main = &quot;pch = 22, bg is working&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 23, bg = &quot;blue&quot;, main = &quot;pch = 23, bg is working&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 24, bg = &quot;blue&quot;, main = &quot;pch = 24, bg is working&quot;) plot(MPG.highway ~ Weight, Cars93, cex = 2, pch = 25, bg = &quot;blue&quot;, main = &quot;pch = 25, bg is working&quot;) Figure 4.25: 색 지정 : 배경색 미적용 다음번 포스팅에서는 그래프 영역과 내/외부 마진 모수 설정하는 방법에 대해서 알아보도록 하겠습니다. "],["그래프-영역-mar-oma-mfrow-mfcol-layout.html", "5 그래프 영역 (mar, oma, , mfrow, mfcol, layout)", " 5 그래프 영역 (mar, oma, , mfrow, mfcol, layout) 지난번 포스팅에서는 R Base Package의 Graphics plotting system의 높은 수준의 그래프 함수 (high level graphic functions) 그래프 모수를 설정하는 2가지 방법 (2 methods of setting graphic parameters) 그래프 모수 : 기호(symbol), 선(line) 그래프 모수 : 색깔(color) 에 대해서 알아보았습니다. 이번 포스팅에서는 그래프 모수 : 그래프 영역 (plot area, inner margin area, outer margin area, multiple plot layout) 에 대해서 소개하도록 하겠습니다. 그래프 영역은 크게 (1) 그래프 영역 (plot area), (2) 내부 마진 영역 (inner margin area), (3) 외부 마진 영역(outer margin area) 로 구분할 수 있습니다. 아래의 예시 그래프에 각 영역의 위치에 text 로 표기를 해보았습니다. [ 그래프 영역 및 내부/외부 마진 영역 (plot area and inner/outer margin area) ] Figure 5.1: 그래프 영역 "],["그래프-영역-plot-area-내부-마진-영역-inner-margin-area.html", "5.1 그래프 영역 (plot area), 내부 마진 영역 (inner margin area)", " 5.1 그래프 영역 (plot area), 내부 마진 영역 (inner margin area) 그래프 영역 (plot area)는 점이든 선이든 기호가 그려지는 영역입니다. 내부 마진 영역 (inner margin area)는 plot area를 감싸고 있는 4개 모서리 부분의 마진입니다. 하단 부분이 1번, 왼쪽 부분이 2번, 상단부분이 3번, 오른쪽 부분이 4번이며, 순서대로 내부 마진 영역의 디폴트 값은 c(5.1, 4.1, 4.1, 2.1) 입니다. 하단은 x축 label, 왼쪽은 y축 label, 상단은 제목이 들어가는 영역이다 보니 디폴트 값의 마진 숫자가 큰 반면에, 오른쪽은 보통은 label이 없으므로 디폴트 마진 값이 타 영역의 반절밖에 안됩니다. ##------------------------------------------- ## Graph Area and Outer/Inner Margin ##------------------------------------------- # to use Cars93 dataframe # plotting by default par setting of plot area and inner margin area # default inner margin area : c(5.1, 4.1, 4.1, 2.1) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, xlab = &quot;Inner Margin Area 1&quot;, ylab = &quot;Inner Margin Area 2&quot;, main = &quot;Inner Margin Area 3&quot;) mtext(&quot;Inner Margin Area 4&quot;, side = 4) text(3000, 35, cex = 3, labels = &quot;Plot Area&quot;, pos = 3) Figure 5.2: 그래프 영역과 내부 마진 영역 "],["외부-마진-영역-outer-margin-area.html", "5.2 외부 마진 영역 (outer margin area)", " 5.2 외부 마진 영역 (outer margin area) 외부 마진 영역은 내부 마진 영역의 바깥 쪽을 둘러싸는 마진 영역이며, 내부 마진 영역과 위치 순서는 똑같이 하단 부분이 1번, 왼쪽 부분이 2번, 상단 부분이 3번, 오른쪽 부분이 4번입니다. 1번, 2번, 3번, 4번 별로 디폴트 마진 값은 c(0, 0, 0, 0) 입니다. 즉 위의 예의 경우 외부 마진(outer margin) 을 별도로 지정해주지 않았으므로 디폴트 값이 적용되어 외부 마진(outer margin)은 모두 ‘0’ 으로 없는 셈입니다. 외부 마진 영역은 위의 예처럼 1개짜리 그래프에서는 별 쓸모가 없습니다만 (그냥 내부 마진 영역으로 cover 되기 때문입니다), 그래프 영역을 분할해서 2개 이상의 그래프를 하나의 그래프에 결합할 경우 유용하게 사용할 수 있습니다. 개별 그래프에서는 내부 마진 영역에 제목, x축 label, y축 label을 적고, 2개 이상의 개별 그래프들을 모두 아우리는 대제목 (mega title)을 적고자 할 때 외부 마진 영역에 적으면 딱 좋습니다. 아래에 1개의 row, 2개의 column으로 영역을 분할(mfrow = )한 경우 외부 마진 영역 설정(oma = ), 내부 마진 영역 설정(mar = ) 함수의 예를 들어보겠습니다. 외부 마진 부분은 파란색으로 알아보기 쉽게 위치 표시를 했습니다. 참고로, op &lt;- par(no.readonly = TRUE)로 디폴트 par 값을 미리 할당해두면 나중에 par값 조정 다 끝나고 원래의 디폴트 값으로 되돌아오고자 할 때 par(op)를 실행시키면 되므로 매우 편리합니다. ## -- inner margin area, outer margin area # Save default par values, for resetting later op &lt;- par(no.readonly = TRUE) # Change par() function options par(mfrow=c(1,2), # make frame by 1 row, 2 columns mar=c(4, 3, 3, 1), # inner margin oma=c(0.5, 0.5, 2, 0.5)) # outer margin # plot area, inner margin area, outer margin area plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, xlab = &quot;Inner Margin Area&quot;, main = &quot;Inner Margin Area&quot;) plot(MPG.highway ~ Horsepower, Cars93, type=&quot;p&quot;, xlab = &quot;Inner Margin Area&quot;, main = &quot;Inner Margin Area&quot;) mtext(&quot;Outer Margin Area&quot;, outer = TRUE, cex = 2, col = &quot;blue&quot;) # outer = TRUE : outer margin area Figure 5.3: 외부 마진 영역 # Reset par to the default values at startup par(op) "],["영역-분할결합-방법-1-parmfrow-parmfcol.html", "5.3 영역 분할/결합 방법 1 : par(mfrow = ), par(mfcol = )", " 5.3 영역 분할/결합 방법 1 : par(mfrow = ), par(mfcol = ) 2개 이상의 다수의 그래프를 결합하는 방법에는 par() 함수와 layout() 함수의 2가지 방법이 있습니다. 먼저 par() 방법을 살펴보면, par(mfrow = ), par(mfcol = ) 의 2가지 모수 설정 방법이 있습니다. mfrow와 mfcol 은 아래의 말을 줄여 쓴 말입니다. mfrow : number of Multiple Figures (use ROW-wise) mfcol : number of Multiple Figures (use COLUMN-wise) 어렵지 않은 개념이므로 아래에 실제 예를 보면 바로 이해가 될 것이라고 봅니다. par(mfrow = c(4, 2)) 로 해서 4개 row, 2개 column으로 창을 분할해서 총 8개의 그래프를 결합한 예입니다. 그래프가 그려지는 순서를 화살표로 표시를 해두었는데요, 상단 왼쪽에서 시작해서 오른쪽으로 지그재그로 하단으로 내려가면서 그래프가 순차적으로 그려집니다. ##-- par(mfrow = ): multiple figures (use ROW-wise) par(mfrow=c(4, 2), # make window by 4 row, 2 columns + mar=c(4, 3, 3, 1), # inner margin + oma=c(0.5, 0.5, 2, 0.5)) # outer margin &gt; plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 2&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 3&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 4&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 5&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 6&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 7&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 8&quot;) mtext(&quot;par(mfrow = c(4, 2)&quot;, outer = TRUE, cex = 2, col = &quot;blue&quot;) Figure 5.4: 그래프 영역의 창 분할과 그래프 결합 - 1 이번에는 par(mfcol = c(4, 2)) 설정된 예를 아래에 들어보았습니다. 위의 par(mfrow = c(4,2))처럼 4개의 row, 2개의 column 창이 만들어진 것은 동일합니다만, 그래프가 그려지는 순서는 다름에 유의하시기 바랍니다. par(mfcol = )은 column-wise 기준이어서 위에서 아래로 열이 다 찰 때까지 먼저 그래프가 그려지고, 그 다음에서야 오른쪽으로 넘어가서 다시 위에서부터 아래로 열을 채워가는 식으로 그래프가 순차적으로 그려지는 식입니다. 그래프를 그리고자 하는 순서, 형태에 대해서 먼저 생각을 해보시고, 원하는 순서/형태에 맞게 mfrow와 mfcol 을 선택하면 되겠습니다. ##-- par(mfcol = ) : multiple figures (use COLUMN-wise) par(mfcol=c(4, 2), # make frame by 1 row, 2 columns + mar=c(4, 3, 3, 1), # inner margin + oma=c(0.5, 0.5, 2, 0.5)) # outer margin plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 1&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 2&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 3&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 4&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 5&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 6&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 7&quot;) plot(MPG.highway ~ Weight, Cars93, type=&quot;p&quot;, main = &quot;plot 8&quot;) mtext(&quot;par(mfcol = c(4, 2)&quot;, outer = TRUE, cex = 2, col = &quot;blue&quot;) Figure 5.5: 그래프 영역의 창 분할과 그래프 결합 - 2 "],["영역-분할결합-방법-2-layout.html", "5.4 영역 분할/결합 방법 2 : layout()", " 5.4 영역 분할/결합 방법 2 : layout() layout() 함수를 사용하면 행렬(matrix,mat)로 분할하려는 그래프 영역의 순서(sequence)와 열의 폭과 행의 높이(widths of column, heights of row), 영역 나누기/합치기(divide/combine)를 자유롭게 조절할 수 있으므로 위에서 소개한 par(mfrow = ), par(mfcol = ) 보다 사용자에게 보다 높은 자유도를 제공하므로, 매우 유용하고 강력한 함수라고 하겠습니다. layout() 함수는 par(mfrow = )나 par(mfcol = ) 함수와는 병행해서 사용할 수 없으므로 그래프 분석을 시작하기 전에 무슨 함수를 사용할 것인지 결정을 하고 하나를 선택해야만 합니다. layout.show(n)은 현재의 layout에 대한 외곽선을 n 만큼의 그래프 갯수만큼 볼 수 있게 해주는 함수입니다. 아래에 layout()과 layout.show(n) 함수 예를 하나 들어보겠습니다. matrix() arguments 안의 숫자가 그래프가 그려지는 순서인데요, byrow=TRUE 로 했으므로 상단 왼쪽부터 시작해서 지그재그로 4개의 그래프를 그릴 수 있는 영역을 만들어보았습니다. byrow= FALSE 로 지정하면 왼쪽 위에서 왼쪽 아래로, 다시 오른쪽 위에서 오른쪽 아래 방향으로 그래프 생성 순서가 설정됩니다. ##----------------------------------- ## layout ##----------------------------------- # Save default par values op &lt;- par(no.readonly = TRUE) # divide the divice into 2 rows and 2 columns # allocate figure 1, 2, 3, 4 from upper left to lower right layout(matrix(c(1,2,3, 4), 2, 2, byrow = TRUE)) # show the current layout layout.show(4) Figure 5.6: 그래프 영역의 창 분할과 그래프 결합 - 3 layout() 함수를 활용하면 그래프 영역을 합칠 수도 있습니다. 이게 par(mfrow = )또는 par(mfcol = ) 대비 꽤 유용한 기능 중의 하나입니다. 2 by 2 로 나눈 영역에서 1행 1열에만 그래프 영역 1개를 남겨놓고, 2행의 1열과 2행의 2열은 합쳐보는 예제를 아래에 들어보겠습니다. 숫자 ’0’은 비어있는 그래프 영역이 되겠으며, 동일한 숫자를 행렬(matrix) 안에 나란히 입력하면 그 영역을 합쳐서 제시하라는 뜻입니다. 아래 예에서는 1행2열에 ’0’이 입력되었으므로 비어있고, 2행1열과 2행 2열에 나란히 ’2’가 기입되었으므로 2행1열과 2행2열이 합쳐져서 1개의 그래프 영역으로 표시가 되었습니다. ## divide the device into two rows and two columns ## allocate figure 1 the intersection of column 1 and row 1 ## allocate figure 2 all of row 2 layout(matrix(c(1,0,2,2), 2, 2, byrow = TRUE)) ## show the current layout layout.show(2) 이해를 돕기위해서 이번에는 1행 1열과 1행 2열을 하나로 합치고, 2행 1열은 비워놓고 2행2열만 남겨놓는 layout을 만들어보는 예제를 아래에 들어보겠습니다. ## divide the device into two rows and two columns ## allocate figure 1 all of row 1 ## allocate figure 2 the intersection of column 2 and row 2 layout(matrix(c(1, 1, 0, 2), 2, 2, byrow = TRUE)) ## show the current layout layout.show(2) 이번에는 10cm 정사각형 모양의 그래프 영역을 생성해보겠습니다. 폭은 widths = lcm( ) 으로, 높이는 heights = lcm( ) 으로 설정을 해주면 되겠습니다. ## create single figure of 10cm square layout_1 &lt;- layout(matrix(1), widths = lcm(10), heights = lcm(10)) layout.show(layout_1) 이번에는 그래프 생성 순서(sequence)의 위, 아래를 바꾸어 보고, 그래프의 넓이(widths)와 높이(heights)를 서로 다르게 하는 그래프 영역을 만들어보겠습니다. 가운데에 산포도를 그려놓고 상단과 우측에 작은 크기의 히스토그램이나 박스플롯을 병행해서 그릴 때 유용하게 사용할 수 있습니다. 참고로, respect = TRUE 는 가로 넓이와 세로 높이의 비율을 고려해서 그래프 영역을 설정하라는 옵션입니다. # divide device into two rows and two columns # allocate figure 1 the intersection of column 1 and row 2 # allocate figure 2 the intersection of column 1 and row 1 # allocate figure 3 the intersection of column 2 and row 2 # no plot the intersection of column 2 and row 1 # widths 8cm and 4cm respectively # heights 4cm and 8cm respectively # respect relations between widths and heights layout_2 &lt;- layout(matrix(c(2, 0, 1, 3), 2, 2, byrow = TRUE), widths = lcm(c(6, 4)), heights = lcm(c(4, 6)), respect = TRUE) layout.show(layout_2) # Reset par to the default values at startup par(op) 다음번 포스팅에서는 ’낮은 수준의 그래프 함수 (Low Level Graphics Functions)’에 대해서 알아보도록 하겠습니다. 앞서의 ’높은 수준의 그래프 함수’와 ’그래프 모수’에 대해서 예를 들 때 이미 ’낮은 수준의 그래프 함수’를 곁들여서 사용하기는 했습니다만, 일목요연하게 한번 더 정리하고 개념을 확실하게 다잡는 다는 의미에서 다음번에 포스팅하도록 하겠습니다. "],["낮은-수준의-그래프-함수.html", "6 낮은 수준의 그래프 함수", " 6 낮은 수준의 그래프 함수 [ 낮은 수준의 그래프 함수 (Low level graphic function) ] Figure 6.1: 낮은 수준의 그래프 함수 "],["제목-및-xy축-라벨-추가-title.html", "6.1 제목 및 XY축 라벨 추가 :title()", " 6.1 제목 및 XY축 라벨 추가 :title() 높은 수준의 그래프 함수로 그래프의 골격을 만들수 있고, 그래픽 모수로 기호 모양이나 색, 크기 등을 설정할 수 있는데요, 이것 만으로는 원하는 그래프를 만드는데 부족함이 있습니다. 가령 그래프 제목을 추가하고 싶거나, 선이나 점을 추가하고 싶거나, 문자나 범례를 추가하고 싶다거나, XY축을 변경하고 싶을 때가 있는데요, 이때 추가적인 정보를 입력하기 위해 사용하는 것이 ’낮은 수준의 그래프 함수 (Low level graphic functions)’가 되겠습니다. 높은 수준의 그래프 함수로 만약 plot(x, y, **type = \"n\"**) 으로 하면 그래프 창만 열리고 plot area 안에는 빈 공간만 있게 되는데요, 여기에 낮은 수준의 그래프 함수로 그래프 기호, 선, 점, 범례 등을 추가해나갈 수도 있습니다. 이번 포스팅부터 수차례로 나누어서 낮은 수준의 그래프 함수(Low level graphic functions)에 대해서 차례대로 알아보도록 하겠습니다. [ 낮은 수준의 그래프 함수 (Low level graphic functions) ] Figure 6.2: 낮은 수준의 그래프 함수 : 제목과 XY축 라벨 먼저 (1) 그래프 제목(main/sub title) 및 XY축 라벨(XY axis label) 추가하는 방법으로 title() 함수에 대해서 소개해보겠습니다. title() 함수에 사용하는 옵션으로는 주 제목 main, 부 제목 sub, X축 라벨 xlab, Y축 라벨 ylab 등이 있습니다. title(main = &quot;main title to the top of plot in a large font&quot;, sub = &quot;sub-title sub at the bottom in a smaller font&quot;, xlab = &quot;x axis label&quot;, ylab = &quot;y axis label&quot;) 이전 포스팅에서 소개했던 높은 수준의 그래프 함수, 즉 hist(), boxplot(), barplot(), plot() 등의 함수 안에서도 주 제목, 부 제목, X축 라벨, Y축 라벨을 직접 지정할 수 있는데요, 아래 예가 높은 수준읙 그래프 함수로 그린 그래프입니다. ##---------------------------------------------- ## adding main/sub title, XY axis label ##---------------------------------------------- library(MASS) # to use Cars93 dataframe # method (1) high level graphic functions : plot() plot(MPG.highway ~ Weight, Cars93, main = &quot;main title : scatter plot of Weight, MPG.highway&quot;, sub = &quot;sub title : plotting with high level graphic functions&quot;, xlab = &quot;x label : Weight&quot;, ylab = &quot;y label : MPG.highway&quot;) 위의 그래프와 똑같은 그래프를 낮은 수준의 그래프 함수를 사용해서 그려보겠습니다. 먼저 높은 수준의 그래프 함수로는 “ann = FALSE” 옵션을 추가해서 기본 뼈대만 그려보겠습니다. 아래 그래프를 보시면 주 제목, 부 제목, X축 라벨, Y축 라벨이 하나도 없음을 알 수 있습니다. # tmheod (2) low level graphic functions : title() # deleting X and Y labels : ann = FALSE plot(MPG.highway ~ Weight, Cars93, ann = FALSE) 위의 기본 뼈대만 있는 그래프에 낮은 수준의 그래프 함수(Low level graphic function)를 사용해서 부가정보를 더해보도록 하겠습니다. plot(MPG.highway ~ Weight, Cars93, ann = FALSE) # adding main title, sub title, x label, y label title(main = &quot;main title : scatter plot of Weight, MPG.highway&quot;, sub = &quot;sub title : plotting with low level graphic functions&quot;, xlab = &quot;x label : Weight&quot;, ylab = &quot;y label : MPG.highway&quot;) 높은 수준의 그래프 함수에서도 주 제목, 부 제목, XY축 Label 등을 설정할 수 있는데 왜 굳이 낮은 수준의 그래프 함수 title() 을 가지고 추가 정보를 입력하는지 의아할 수도 있겠습니다. 높은 수준의 그래프 함수 중에 부가정보를 입력할 수 없는 그래프 함수도 있으며, R의 장점 중에 하나가 대화형으로 그래프의 부가 정보를 차곡 차곡 쌓아가면서, 눈으로 확인해가면서 그릴 수 있어서 굉장히 직관적으로 탐색적 데이터 분석을 할 수 있다는 점입니다. 참고로, 지난번 포스팅에서 소개한 그래프 모수 (graphics parameters) 중에서 기호의 크기를 설정하는 “cex.main =,” “cex.sub =,” “cex.lab =” 옵션을 사용해서 주 제목, 부 제목, XY축 Label의 크기를 변경해보겠습니다. # modification of font size : cex.main, cex.sub, cex.lab # deleting X and Y labels : ann = FALSE plot(MPG.highway ~ Weight, Cars93, ann = FALSE) # adding main title, sub title, x label, y label title(main = &quot;main title with cex 2.2&quot;, sub = &quot;sub title with cex 1.5&quot;, ylab = &quot;y label with cex 1&quot;, cex.main = 2.2, # main title size cex.sub = 1.5, # sub title size cex.lab = 1) # x and y label size 다음 포스팅에서는 낮은 수준의 그래프 함수 - (2) XY축 형태 변환 : axis(side, …) 에 대해서 알아보도록 하겠습니다. "],["xy축-형태-변환-axisside-.html", "6.2 XY축 형태 변환 : axis(side, ...)", " 6.2 XY축 형태 변환 : axis(side, ...) 지난번 포스팅에서는 그래프에 추가적인 정보를 입력하는 낮은 수준의 그래프 함수(low level graphic functions) 중에서 첫번째로 제목, XY축 Label 추가하는 title()에 대해서 알아보았습니다. 이번 포스팅에서는 낮은 수준의 그래프 함수 두번째로 (2) XY축 형태 변환 : axis(side, …) 에 대해서 소개하겠습니다. [ 낮은 수준의 그래프 함수 (Low level graphic function) ] Figure 6.3: 낮은 수준의 그래프 함수 : XY축 형태 XY축 형태를 변경하는 axis() 함수의 기본 사용법은 아래와 같습니다. axaxis(side, at = NULL, labels = TRUE, tick = TRUE, line = NA, pos = NA, outer = FALSE, font = NA, lty = &quot;solid&quot;, lwd = 1, lwd.ticks = lwd, col = NULL, col.ticks = NULL, hadj = NA, padj = NA, ...) 위의 axis() 함수의 모수 중엣서 사용빈도가 높은 주요 모수에 대해서 기능 설명과 예를 들어보겠습니다. arguments description side 그래프의 어느 쪽에 축을 그릴지 지정하는 정수(an integer specifying which side of the plot the axis is to be drawn on) 1 = 아래쪽 (below side) 2 = 왼쪽 (left side) 3 = 위쪽 (above side) 4 = 오른쪽 (right side) at 축의 눈금이 그려질 곳의 위치를 지정하는 점들 (the points at which tick-marks are to be drawn) labels 축 눈금에 라벨 데이터를 입력하는 숫자형 벡터, 혹은 문자형 벡터(numerical or a character or expression vector of labels to be placed at the tick-points) tick 축의 눈금과 축의 선을 그릴지를 설정하는 논리형 값(a logical value specifying whether tickmarks and an axis line should be drawn) pos 해당 축이 다른 축과 교차하는 좌표(the coordinate at which the axis line is to be drawn) lty 축과 눈금의 선의 유형(line type for both the axis line and the tick marks) lwd 축의 눈금의 선의 두께(line widths for the axis line and the tick marks) col 축과 눈금 선의 색깔(colors for the axis line and the tick marks respectively) tck 눈금의 방향과 길이 설정(direction and length of tick marks) - 양수 : 그래프 안쪽으로 눈금 생성 - 음수 : 그래프 바깥쪽으로 눈금 생성 hadj 수평 라벨에 대한 수정(adjustment for all labels parallel (‘horizontal’) to the reading direction) padj 수직 라벨에 대한 수정(adjustment for each tick label perpendicular to the reading direction) X축과 Y축을 변경하려면 먼저 “axes = FALSE” 옵션을 사용해서 X축과 Y축을 제거해야 합니다. X축만 선별적으로 제거하려면 xaxt = \"n\", Y축만 선별적으로 제거하려면 yaxt = \"n\" 옵션을 사용하면 되겠습니다. 아래에 각각의 예를 들어보았습니다. ##--------------------------------------------- ## low level graphic functions : axis(side, ...) ##--------------------------------------------- library(MASS) # to use Cars93 dataframe # Save default par values op &lt;- par(no.readonly = TRUE) # Change par() function options par(mfrow=c(2, 2)) # make frame by 2 row, 2 columns # plot with X and Y axis plot(MPG.highway ~ Weight, Cars93, main = &quot;plot with X and Y axis&quot;) # deleting X and Y axes : axes = FALSE plot(MPG.highway ~ Weight, Cars93, axes = FALSE, main = &quot;axes = FALSE&quot;) # deleting X axis : xaxt = &quot;n&quot; plot(MPG.highway ~ Weight, Cars93, xaxt = &quot;n&quot;, main = &quot;xaxt = n&quot;) # deleting Y axis : yaxt = &quot;n&quot; plot(MPG.highway ~ Weight, Cars93, yaxt = &quot;n&quot;, main = &quot;yaxt = n&quot;) # Reset par to the default values at startup par(op) X축과 Y축의 범위를 알아보기 위해 summary() 함수로 기술통계량을 알아보겠습니다. # summary statistics summary(Cars93$Weight) # X axis ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1695 2620 3040 3073 3525 4105 summary(Cars93$MPG.highway) # Y axis ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 20 26 28 29 31 50 X축으로 Weight (차의 무게)를, Y축으로는 MPG.highway (고속도로 연비)으로 하는 산포도를 그린다고 했을 때, X축은 1600~4200까지의 범위로 100씩 증가하는 눈금을, Y축은 18~52까지의 범위로 2씩 증가하는 눈금으로 그려보겠습니다. # X axis (1600 ~ 4200, by 100) # Y axis (18 ~ 52 range, by 2) plot(MPG.highway ~ Weight, Cars93, axes = FALSE, xlim = c(1600, 4200), ylim = c(18, 52), main = &quot;scatter plot of Weight and MPG.highway&quot;) x &lt;- seq(1600, 4200, by = 100) y &lt;- seq(18, 52, by = 2) axis(side = 1, # bottom side at = x, labels = TRUE, pos = 18, # coordinate of X axis starting point tck = 0.02) # tick marks at vertical direction with 0.02 length axis(side = 2, # left side at = y, labels = TRUE, pos = 1600, # coordinate of Y axis starting point + tck = -0.02) # tick marks at horizontal direction with 0.02 length 다음번 포스팅에서는 직선 연결, 직선 추가하는 낮은 수준은 그래프 함수 lines(), abline() 에 대해서 알아보도록 하겠습니다. "],["직선-연결-추가-linesx-y-ablinea-b-ablinehy-ablinevx.html", "6.3 직선 연결, 추가 : lines(x, y), abline(a, b), abline(h=y), abline(v=x)", " 6.3 직선 연결, 추가 : lines(x, y), abline(a, b), abline(h=y), abline(v=x) 지난번 포스팅에서는 그래프에 추가적인 정보를 입력하는 낮은 수준의 그래프 함수(low level graphic functions) 중에서 (1) 제목, XY축 Label 추가하는 title(), (2) XY축의 형태를 변환하는 axis(side, ...)에 대해서 알아보았습니다. 이번 포스팅에서는 낮은 수준의 그래프 함수 두번째로 (3) 직선 연결, 추가 : lines(x, y), abline(a, b), abline(h=y), abline(v=x) 에 대해서 소개하겠습니다. [ 낮은 수준의 그래프 함수 (Low level graphic function) ] Figure 6.4: 낮은 수준의 그래프 함수 : 직선 MASS 패키지에 들어있는 Cars93 데이터프레임의 **Weight (차의 무게)**와 **MPG.highway (고속도로 연비)** 두 개의 변수를 가지고 산포도를 그린 후에, **lines() 함수로 선형 회귀식을 추가해보고, abline() 함수로 x축과 y축의 평균으로 수직선과 수평선을 추가**하여 보겠습니다. line()함수의 일반적인 사용법은 다음과 같습니다. lines(x, y = NULL, type = &quot;l&quot;, ...) 구분 기능 설명 x, y x, y 좌표 벡터 (coordinate vectors of points to join) type = “l” 선(line) 그래프라는 뜻임 (character indicating the type of plotting) … 선 유형 (lty), 선 색깔 (col), 선 두께(lwd) 등의 그래프 모수 입력 (Further graphical parameters) abline() 함수의 사용법은 다음과 같습니다. abline(a = NULL, b = NULL, h = NULL, v = NULL, reg = NULL, coef = NULL, untf = FALSE, ...) 구분 기능 설명 a, b 절편과 기울기, 단일 값 (the intercept and slope, single values) h y값을 지나는 수평인 직선 (the y-value(s) for horizontal line(s).) v x값을 지나는 수직인 직선 (the x-value(s) for vertical line(s).) reg 회귀직선 추가 (an object with a coef method) coef 절편과 기울기로 이루어진 벡터 (a vector of length two giving the intercept and slope) untf 변환 안된 값을 쓸지를 묻는 옵션. 만약 y값을 로그변환한 경우 untf = TRUE 라고 설정하면 로그변환 전의 원래값 기준으로 좌표에 그래프가 그려짐 (logical asking whether to untransform.If untf is true, and one or both axes are log-transformed, then a curve is drawn corresponding to a line in original coordinates, otherwise a line is drawn in the transformed coordinate system. The h and v parameters always refer to original coordinates) * 출처 : http://sites.stat.psu.edu/~dhunter/R/html/graphics/html/abline.html 먼저 lm() 함수를 사용해서 y = MPG.highway (고속도로 연비), x = Weight (차의 무게) 변수 간의 선형 회귀모형을 만들면 아래와 같습니다. ##------------------------------------ ## adding lines to a plot ##------------------------------------ # fitting regression model fit_1 &lt;- lm(MPG.highway ~ Weight, data = Cars93) 다음으로, Weight (무게)와 MPG.highway (고속도로 연비)의 두 변수 산포도를 그리고, 위에서 만든 선형 회귀선을 추가해보겠습니다. 세가지 방법이 있는데요, lines() 를 사용하는 방법, abline(reg = ) abline(a = coef[1], b = coef[2])를 사용하는 방법은 아래와 같습니다. 참고로, 그래프 모수(parameters)로서 색깔 지정은 col, 선 유형 지정은 lty, 선 두께 지정은 lwd 를 사용하면 됩니다. ## adding regression line to the current plot # (1) lines() with(Cars93, plot(MPG.highway ~ Weight)) # scatter plot of MPG.highway~Weight lines(Cars93$Weight, fit_1$fitted.values, col = &quot;blue&quot;) title(&quot;adding regression line : lines()&quot;) # (2) abline(reg = regression_model) with(Cars93, plot(MPG.highway ~ Weight)) abline(reg = fit_1, col = &quot;red&quot;, lwd = 3) title(&quot;adding regression line : abline(reg = )&quot;) # (3) abline(a = fit_1$coef[1], b = fit_1$coef[2]) with(Cars93, plot(MPG.highway ~ Weight)) abline(a = fit_1$coef[1], b = fit_1$coef[2], col = &quot;black&quot;, lwd = 3) title(&quot;adding regression line : abline(a = coef[1], b = coef[2])&quot;) fit_1$coef # coefficients of regression model ## (Intercept) Weight ## 51.6014 -0.0073 fit_1$coef[1] # intercept ## (Intercept) ## 52 fit_1$coef[2] # slope ## Weight ## -0.0073 이번에는 loess.smooth() 함수로 비모수 회귀곡선을 적합시키고, lines() 함수로 smoothed regression line을 현재 그래프에 추가해보는 방법을 소개하겠습니다. ## adding smoothed regression line to the current plot : lines(), loess.smooth() # (1) fitting non-parametric regression model fit_2 &lt;- loess.smooth(x = Cars93$Weight, y = Cars93$MPG.highway) names(fit_2) ## [1] &quot;x&quot; &quot;y&quot; fit_2 $x ## [1] 1695 1744 1793 1843 1892 1941 1990 2039 2088 2138 2187 2236 2285 2334 2384 ## [16] 2433 2482 2531 2580 2629 2679 2728 2777 2826 2875 2925 2974 3023 3072 3121 ## [31] 3171 3220 3269 3318 3367 3416 3466 3515 3564 3613 3662 3712 3761 3810 3859 ## [46] 3908 3957 4007 4056 4105 # (2) scatter plot, adding smoothed regression line with(Cars93, plot(MPG.highway ~ Weight)) lines(fit_2$x, fit_2$y, col = &quot;blue&quot;, lwd = 3) title(&quot;adding smoothed regression line: lines(), loess.smooth()&quot;) ## drawing horizontal or vertical straight lines : abline() with(Cars93, plot(MPG.highway ~ Weight)) # (1) vertical line abline(v = mean(Cars93$Weight), col = &quot;black&quot;, lty = 3, lwd = 2) # (2) horizontal line abline(h = mean(Cars93$MPG.highway), col = &quot;blue&quot;, lty = 3, lwd = 2) title(&quot;drawing horizontal or vertical straight lines : abline()&quot;) 다음번 포스팅에서는 points() 함수로 점을 추가하는 방법을 소개하겠습니다. "],["점-추가-pointsx-y.html", "6.4 점 추가 : points(x, y)", " 6.4 점 추가 : points(x, y) 지난번 포스팅에서는 그래프에 추가적인 정보를 입력하는 낮은 수준의 그래프 함수(low level graphic functions) 중에서 제목, XY축 Label 추가하는 title() XY축의 형태를 변환하는 axis(side, ...) 직선 연결, 추가 : lines(x, y), abline(a, b), abline(h=y), abline(v=x) 에 대해서 알아보았습니다. 이번 포스팅에서는 낮은 수준의 그래프 함수 네번째로 (4) 점 추가 : points(x, y)에 대해서 소개하겠습니다. [ 낮은 수준의 그래프 함수 (Low level graphic function) ] Figure 6.5: 낮은 수준의 그래프 함수 : 점 추가 points() 함수의 일반적인 사용법은 다음과 같습니다. points(x, y = NULL, type = &quot;p&quot;, ...) 구분 기능 설명 x, y x, y 좌표 벡터 (coordinate vectors of points to plot) type = “p” 그래프 유형 = “점 그래프” … 기호 모양(pch), 색깔(col), 크기(cex) 등의 그래프 모수 (parameters) 사용 MASS 패키지에 내장되어 있는 Cars93 데이터프레임의 차량 무게(Weight), 고속도로 연비 (MPG.highway), 차종 (Type) 변수를 사용해서 점을 추가하는 그래프를 실습해보겠습니다. 높은 수준의 그래프 함수 중에서 plot(x, y, type = 'p') 로 하면 점 그래프 (points plot)을 그릴 수 있습니다. 아래에 plot(x, y, type = 'p')로 그린 산포도와 points(x, y) 함수로 점을 추가한 그래프 예시를 들어보았습니다. 정확히 두 개 그래프가 일치합니다. ##----------------------------------------- ## adding points() : point(x, y) ##----------------------------------------- # to use Cars93 dataframe # scatter plot attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders plot(Weight, MPG.highway, type = &#39;p&#39;) # points plot # adding points to the current plot plot(Weight, MPG.highway, type = &#39;n&#39;) # blank plot points(Weight, MPG.highway) # exactly the same with the upper points plot 그러면 왜 굳이 points() 라는 낮은 수준의 함수를 가지고 점을 추가하려고 하는 것인지 의문이 들것입니다. 그 이유는 points() 함수를 가지고 필요에 따라서 순차적으로 점을 추가할 수 있고, 조건을 부여하고 그래프 모수 중에 색깔이나 기호 모양 등을 다르게 해서 탐색적 분석을 진행하는데 유용하기 때문입니다. 물론 plot(x, y, type = 'p')로 원하는 그래프를 그릴 수 있다면 points()함수를 사용할 필요는 없겠지요. 아래에 points()의 몇 가지 사용 형태를 보시고 필요한 상황에 맞게 골라 쓰면 되겠습니다. 아래에는 차종(Type)별로 기호 모양과 색깔을 달리하면서 무게(Weight)와 고속도로 연비(MPG.highway) 산포도를 그려보겠습니다. 2차원의 x, y 공간에 차종(Type)이라는 제3의 차원을 추가해서 볼 수 있는 매우 유용한 방법입니다. 대신 Base Graphics 에서는 조건의 갯수만큼 손이 참 많이 가는 단점이 있습니다 (참고로, ggplot2 plotting system을 사용하면 조건에 따른 색이나 기호를 달리하도록 지정하는게 한 줄이면 끝나고, 범례(legend)도 알아서 추가해주므로 편합니다). # adding points to the current plot with pch, col, cex parameters plot(Weight, MPG.highway, type = &#39;n&#39;) # blank plot points(Weight, MPG.highway, pch = 15, col = &quot;blue&quot;, cex = 1.5) # adding points with different characters by condition plot(Weight, MPG.highway, type = &#39;n&#39;) # blank plot table(Cars93$Type) ## ## Compact Large Midsize Small Sporty Van ## 16 11 22 21 14 9 # Type = Compact points(Weight[Type == &quot;Compact&quot;], MPG.highway[Type == &quot;Compact&quot;], pch = 0) # Type = Large points(Weight[Type == &quot;Large&quot;], MPG.highway[Type == &quot;Large&quot;], pch = 1) # Type = Midsize points(Weight[Type == &quot;Midsize&quot;], MPG.highway[Type == &quot;Midsize&quot;], pch = 17, col = &quot;yellow&quot;) # Type = Small points(Weight[Type == &quot;Small&quot;], MPG.highway[Type == &quot;Small&quot;], pch = 3) # Type = Sporty points(Weight[Type == &quot;Sporty&quot;], MPG.highway[Type == &quot;Sporty&quot;], pch = 9) # Type = Van points(Weight[Type == &quot;Van&quot;], MPG.highway[Type == &quot;Van&quot;], pch = 15, col = &quot;blue&quot;) title(&quot;adding points with different characters by Car Types&quot;) # adding legend to topright side legend(&quot;topright&quot;, c(&quot;Compact&quot;, &quot;Large&quot;, &quot;Midsize&quot;, &quot;Small&quot;, &quot;Sporty&quot;, &quot;Van&quot;), col = c(&quot;black&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;black&quot;, &quot;blue&quot;), pch = c(0, 1, 17, 3, 9, 15) ) 다음번 포스팅에서는 text(), mtext() 함수로 문자(text)를 추가하는 방법에 대해서 알아보겠습니다. "],["문자-추가-textx-y-labels-mtext.html", "6.5 문자 추가 : text(x, y, labels, ...), mtext()", " 6.5 문자 추가 : text(x, y, labels, ...), mtext() 지난번 포스팅에서는 그래프에 추가적인 정보를 입력하는 낮은 수준의 그래프 함수(low level graphic functions) 중에서 제목, XY축 Label 추가하는 title() XY축의 형태를 변환하는 axis(side, ...) 직선 연결, 추가 : lines(x, y), abline(a, b), abline(h=y),abline(v=x) 점 추가 : points(x, y) 에 대해서 알아보았습니다. 이번 포스팅에서는 낮은 수준의 그래프 함수 네번째로 (5) 문자 추가 : text(x, y, labels, ...), mtext() 에 대해서 소개하겠습니다. [ 낮은 수준의 그래프 함수 (Low level graphic function) ] Figure 6.6: 낮은 수준의 그래프 함수 : 문자 추가 그래프에 문자를 추가할 때 text() 함수와 mtext() 함수를 사용합니다. 차이점은 text()가 그래프 내에 문자를 추가할 때 사용하는 반면, mtext()는 외부 마진 영역(1 하단, 2 좌측, 3 상단, 4 우측)에 문자를 추가할 때 사용한다는 것입니다. text() 함수와 mtext() 함수의 일반적인 사용법은 아래와 같습니다. 함수 (function) 사용법 (usage) text() text(x, y, labels = , pos = , … ) mtext() mtext(“text to place,” side = , line = , adj, outer = , … ) 함수 옵션 기능 설명 text() x, y 문자를 추가할 위치의 x, y좌표. 단, x, y 좌표 대신에 locator(1) 을 입력하면 커서로 지적하는 곳에 문자를 추가함 labels = \" \" 추가할 문자 pos = 좌표를 기준으로 문자를 입력할 상대적인 위치 : 1=below, 2=left, 3=above(default), 4=right … 폰트, 색깔, 크기 등의 그래프 모수 지정 mtext() “text to place” 추가할 문자 side = 문자를 추가할 위치 : 1=bottom, 2=left, 3=top(default), 4=right line = 문자와 그래프와의 마진 거리 (to indicate the line in the margin starting with 0 and moving out) adj = adj=0 : 왼쪽/아래쪽 정렬, adj=1 : 위쪽/오른쪽 정렬, 생략 : 중앙 정렬 (adj=0 for left/bottom alignment or adj=1 for top/right alignment) outer = outer=TRUE : 외부마진에 문자 추가 outer=FALSE : 내부마진에 문자 추가 … 폰트, 색깔, 크기 등의 그래프 모수 지정 MASS 패키지에 내장되어있는 Cars93 데이터프레임의 차 무게 (Weight), 고속도로 연비 (MPG.highway) 변수를 활용해서 산포도를 그리고, 모델명(Model) 변수를 가지고 text를 추가해보겠습니다. ##------------------------------------------- ## adding text to the plot : text(), mtext() ##------------------------------------------- ## adding text within a plot : text() attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders ## The following objects are masked from Cars93 (pos = 3): ## ## AirBags, Cylinders, DriveTrain, EngineSize, Fuel.tank.capacity, ## Horsepower, Length, Luggage.room, Make, Man.trans.avail, ## Manufacturer, Max.Price, Min.Price, Model, MPG.city, MPG.highway, ## Origin, Passengers, Price, Rear.seat.room, Rev.per.mile, RPM, ## Turn.circle, Type, Weight, Wheelbase, Width plot(Weight, MPG.highway, main = &quot;scatter plot of MPG.highway ~ Weight&quot;) text(x = Weight, y = MPG.highway, labels = Model, pos = 3, cex = 0.5) text(x, y, ) 좌표 대신에 text(**locator(1)**, ) 옵션을 사용하면 커서로 문자가 들어갈 위치를 콕 찍어서 지정할 수 있습니다. reproducible research 관점에서 보면 추천할 만한 방법은 아닌데요, x, y 좌표를 정확히 모르거나, 한번만 간편하게 그래프 그려서 볼 목적이라면 큰 문제는 없겠습니다. # placing text at the point of cursor : locator(1) plot(Weight, MPG.highway, main = &quot;scatter plot of MPG.highway ~ Weight&quot;) text(locator(1), labels = &quot;Low Mileage Per Gallon&quot;) ## Error in text.default(locator(1), labels = &quot;Low Mileage Per Gallon&quot;): 좌표가 제공되지 않았습니다 detach(Cars93) 다음으로 mtext() 를 사용해서 그래프 외부 마진 영역에 문자를 추가해보는 예제입니다. title() 함수로 제목을 추가하는 것과 유사한 측면이 있는데요, mtext()의 경우 여러 개의 그래프를 결합했을 때 외부마진에 그래프 전체를 아우리는 제목을 자유롭게 추가할 수 있다는 유용한 장점이 있습니다. ## places text in one of the four margins : mtext() # Save default par values op &lt;- par(no.readonly = TRUE) # combining 2 graphs in 1 row par(mfrow = c(1,2), # 1 row, 2 windows + oma = c(2, 2, 4, 1)) # outer margin attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders ## The following objects are masked from Cars93 (pos = 3): ## ## AirBags, Cylinders, DriveTrain, EngineSize, Fuel.tank.capacity, ## Horsepower, Length, Luggage.room, Make, Man.trans.avail, ## Manufacturer, Max.Price, Min.Price, Model, MPG.city, MPG.highway, ## Origin, Passengers, Price, Rear.seat.room, Rev.per.mile, RPM, ## Turn.circle, Type, Weight, Wheelbase, Width plot(Weight, MPG.highway, main = &quot;MPG.highway ~ Weight&quot;) # plot 1 plot(Horsepower, MPG.highway, main = &quot;MPG.highway ~ Horsepower&quot;) # plot 2 mtext(&quot;MPG.highway by Weight, Horsepower&quot;, side = 3, # which margin to place text. 1=bottom, 2=left, 3=top, 4=right line = 1, # to indicate the line in the margin starting with 0 and moving out adj = 2, # adj=0 for left/bottom alignment or adj=1 for top/right alignment cex = 2, # font size outer = TRUE) # outer = TRUE : to place text at outer margin detach(Cars93) # Reset par to the default values at startup par(op) 다음번 포스팅에서는 범례(legend) 추가하는 방법에 대해서 알아보겠습니다. "],["범례-추가-legendx-y-legend-.html", "6.6 범례 추가 : legend(x, y, legend, ...)", " 6.6 범례 추가 : legend(x, y, legend, ...) 지난번 포스팅에서는 그래프에 추가적인 정보를 입력하는 낮은 수준의 그래프 함수(low level graphic functions) 중에서 제목, XY축 Label 추가하는 title() XY축의 형태를 변환하는 axis(side, ...) 직선 연결, 추가 : lines(x, y), abline(a, b), abline(h=y), abline(v=x) 점 추가 : points(x, y) 문자 추가 : text(x, y, labels, ...), mtext() 에 대해서 알아보았습니다. 이번 포스팅에서는 낮은 수준의 그래프 함수 네번째로 **(6) 범례 추가 : legend(x, y, legend, ...)** 에 대해서 소개하겠습니다. [ 낮은 수준의 그래프 함수 (Low level graphic function) ] Figure 6.7: 낮은 수준의 그래프 함수 : 범례 추가 범례를 추가하는 legend()함수의 일반적인 사용법은 아래와 같습니다. legend(x, y = NULL, legend, fill = NULL, col = par(&quot;col&quot;), border = &quot;black&quot;, lty, lwd, pch, angle = 45, density = NULL, bty = &quot;o&quot;, bg = par(&quot;bg&quot;), box.lwd = par(&quot;lwd&quot;), box.lty = par(&quot;lty&quot;), box.col = par(&quot;fg&quot;), pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd, xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1, adj = c(0, 0.5), text.width = NULL, text.col = par(&quot;col&quot;), text.font = NULL, merge = do.lines &amp;&amp; has.pch, trace = FALSE, plot = TRUE, ncol = 1, horiz = FALSE, title = NULL, inset = 0, xpd, title.col = text.col, title.adj = 0.5, seg.len = 2) 옵션이 굉장히 많지요? ^^; 그래프에 관한한 R 가지고 못하는게 거의 없다는게 바로 이런 겁니다. 그런데 이걸 다 설명하자니 시간이 너무 오래걸릴것 같기도 하고 대부분은 아마 거의 사용할 일이 없을 것 같기도 합니다. 그래서 많이 사용하는 옵션 위주로 몇 개만 선별해서 어려움없이 사용할 수 있는 정도로만 설명하겠습니다. 구분 옵션 기능 x, y 범례를 추가할 위치를 설정하는 3가지 방법 (1) x, y 좌표를 입력하면 범례 사각형의 왼쪽 상단이 그 지점에 위치함 (2) locator(1)을 입력하면 커서를 가리키는 지점에 범례 생성 (3) 위치를 나타내는 아래의 9개 단어 중 하나를 선택해서 입력 : “bottomright,” “bottom,” “bottomleft,” “left,” “topleft,” “top,” “topright,” “right” and “center” legend 길이가 1보다 큰 문자(character) 혹은 범례를 담은 벡터(expression vector) col 색깔 지정 벡터 lty 선 유형 지정 벡터 lwd 선 두께 지정 벡터 pch 기호 지정 벡터 … 그래픽 모수 추가 설정 가능 MASS 패키지에 내장된 Cars93데이터프레임의 차종(Type) 별로 차 무게(Weight)와 고속도로 연비 (MPG.highway) 변수를 사용해서 산포도를 그려보겠습니다. 그리고 차종(Type) 그룹에 대한 범례(legend)를 추가해보겠습니다. 6.6.1 x, y 좌표를 직접 입력하여 범례 위치 설정 # scatter plot attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders ## The following objects are masked from Cars93 (pos = 3): ## ## AirBags, Cylinders, DriveTrain, EngineSize, Fuel.tank.capacity, ## Horsepower, Length, Luggage.room, Make, Man.trans.avail, ## Manufacturer, Max.Price, Min.Price, Model, MPG.city, MPG.highway, ## Origin, Passengers, Price, Rear.seat.room, Rev.per.mile, RPM, ## Turn.circle, Type, Weight, Wheelbase, Width # adding points with different characters by condition plot(Weight, MPG.highway, type = &#39;n&#39;) # blank plot # Type = Compact points(Weight[Type == &quot;Compact&quot;], MPG.highway[Type == &quot;Compact&quot;], pch = 0) # Type = Large points(Weight[Type == &quot;Large&quot;], MPG.highway[Type == &quot;Large&quot;], pch = 1) # Type = Midsize points(Weight[Type == &quot;Midsize&quot;], MPG.highway[Type == &quot;Midsize&quot;], pch = 17, col = &quot;yellow&quot;) # Type = Small points(Weight[Type == &quot;Small&quot;], MPG.highway[Type == &quot;Small&quot;], pch = 3) # Type = Sporty points(Weight[Type == &quot;Sporty&quot;], MPG.highway[Type == &quot;Sporty&quot;], pch = 9) # Type = Van points(Weight[Type == &quot;Van&quot;], MPG.highway[Type == &quot;Van&quot;], pch = 15, col = &quot;blue&quot;) title(&quot;adding legend to the plot&quot;) # adding legend to topright side legend(x = 3500, y = 50, c(&quot;Compact&quot;, &quot;Large&quot;, &quot;Midsize&quot;, &quot;Small&quot;, &quot;Sporty&quot;, &quot;Van&quot;), col = c(&quot;black&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;black&quot;, &quot;blue&quot;), pch = c(0, 1, 17, 3, 9, 15) ) detach(Cars93) 6.6.2 위치 키워드로 범례 위치 설정 legend() 함수의 첫 번째 인수로 \"bottomright\", \"bottom\", \"bottomleft\", \"left\", \"topleft\", \"top\", \"topright\", \"right\" 그리고 \"center\" 등으로 범례의 위치를 지정할 수 있습니다. 다음의 예는 “topright”로 위치를 지정하고 있습니다. # scatter plot attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders ## The following objects are masked from Cars93 (pos = 3): ## ## AirBags, Cylinders, DriveTrain, EngineSize, Fuel.tank.capacity, ## Horsepower, Length, Luggage.room, Make, Man.trans.avail, ## Manufacturer, Max.Price, Min.Price, Model, MPG.city, MPG.highway, ## Origin, Passengers, Price, Rear.seat.room, Rev.per.mile, RPM, ## Turn.circle, Type, Weight, Wheelbase, Width # adding points with different characters by condition plot(Weight, MPG.highway, type = &#39;n&#39;) # blank plot # Type = Compact points(Weight[Type == &quot;Compact&quot;], MPG.highway[Type == &quot;Compact&quot;], pch = 0) # Type = Large points(Weight[Type == &quot;Large&quot;], MPG.highway[Type == &quot;Large&quot;], pch = 1) # Type = Midsize points(Weight[Type == &quot;Midsize&quot;], MPG.highway[Type == &quot;Midsize&quot;], pch = 17, col = &quot;yellow&quot;) # Type = Small points(Weight[Type == &quot;Small&quot;], MPG.highway[Type == &quot;Small&quot;], pch = 3) # Type = Sporty points(Weight[Type == &quot;Sporty&quot;], MPG.highway[Type == &quot;Sporty&quot;], pch = 9) # Type = Van points(Weight[Type == &quot;Van&quot;], MPG.highway[Type == &quot;Van&quot;], pch = 15, col = &quot;blue&quot;) title(&quot;adding points with different characters by Car Types&quot;) # adding legend to topright side legend(&quot;topright&quot;, c(&quot;Compact&quot;, &quot;Large&quot;, &quot;Midsize&quot;, &quot;Small&quot;, &quot;Sporty&quot;, &quot;Van&quot;), col = c(&quot;black&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;black&quot;, &quot;blue&quot;), pch = c(0, 1, 17, 3, 9, 15)) detach(Cars93) 다음번 포스팅에서는 다각형(polygon)을 추가하는 방법에 대해서 소개하겠습니다. "],["다각형-추가-polygonx-y.html", "6.7 다각형 추가 : polygon(x, y, …)", " 6.7 다각형 추가 : polygon(x, y, …) 지난번 포스팅에서는 그래프에 추가적인 정보를 입력하는 낮은 수준의 그래프 함수(low level graphic functions) 중에서 제목, XY축 Label 추가하는 title() XY축의 형태를 변환하는 axis(side, ...) 직선 연결, 추가 : lines(x, y), abline(a, b), abline(h=y), abline(v=x) 점 추가 : points(x, y) 문자 추가 : text(x, y, labels, ...), mtext() 범례 추가 : legend(x, y, legend, ...) 에 대해서 알아보았습니다. 이번 포스팅에서는 낮은 수준의 그래프 함수 네번째로 (7) 다각형 추가 : polygon(x, y, …) 에 대해서 소개하겠습니다. [ 낮은 수준의 그래프 함수 (Low level graphic function) ] Figure 6.8: 낮은 수준의 그래프 함수 : 다각형 추가 다각형을 그리는 polygon()함수의 일반적인 사용법은 다음과 같습니다. polygon(x, y = NULL, density = NULL, angle = 45, border = NULL, col = NA, lty = par(&quot;lty&quot;), ..., fillOddEven = FALSE) 구분 기능 설명 x, y 다각형의 좌표의 벡터 density 다각형 안을 채우는 음영 선의 밀도 (default 는 NULL) angle 음영있는 선의 각도 (수평선을 기준으로 해서 반시계방향) border 다각형 테두리의 색깔 col 다각형을 채우는 색깔 (default 는 NA) lty par() 에서 사용하는 선 유형 : 0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash … 추가로 그래프 모수 사용 가능 fillOddEven 다각형의 음영을 논리적으로 조절하는 모드 (default 는 FALSE) 두 개의 삼각형을 테두리의 색깔(border)과 선 유형(lty), 다각형을 채우는 색깔(col), 다각형을 채우는 선의 밀도(density)와 각도(angle), 색깔(col)을 달리해서 그려보겠습니다. x와 y의 좌표값의 중간에 “NA” value가 들어갔음에 주의해서 보시기 바랍니다. ##------------------------------------- ## polygon : polygon(x, y, ...) ##------------------------------------- # Multiple polygons from NA values plot(c(1, 6), c(-3.5, 3.5), type = &quot;n&quot;) x &lt;- c(1, 2, 3, NA, 4, 4, 6) y &lt;- c(1, -3, 2, NA, -3, 3, -3) polygon(x, y, col = c(&quot;yellow&quot;, &quot;blue&quot;), border = c(&quot;black&quot;, &quot;red&quot;), lwd = 2, lty = c(&quot;dotted&quot;, &quot;solid&quot;)) title(&quot;Multiple polygons from NA values&quot;) 아래의 다각형은 위와 R script가 거의 동일한데요, 단 한가지 차이점이라면 x, y의 좌표값에 “NA” value가 없다는 점입니다. “NA” value가 없다보니 R은 중간에 다각형을 분리하지를 못하고, 그냥 하나의 색깔, 선 유형, 다각형 채우는 색을 계속 사용하고 있습니다. ## what if no NA value plot(c(1, 6), c(-3.5, 3.5), type = &quot;n&quot;) x &lt;- c(1, 2, 3, 4, 4, 6) y &lt;- c(1, -3, 2, -3, 3, -3) polygon(x, y, col = c(&quot;yellow&quot;, &quot;blue&quot;), border = c(&quot;black&quot;, &quot;red&quot;), lwd = 2, lty = c(&quot;dotted&quot;, &quot;solid&quot;)) title(&quot;Multiple polygons without NA value&quot;) 이번에는 다각형 안의 음영을 선으로 채우는 방법을 소개하겠습니다. density 로 선의 밀도(숫자가 클 수록 촘촘해짐)를 지정하고, angle 로 선의 각도(수평선을 기준으로 반시계방향)를 지정하면 됩니다. # Line-shaded polygons plot(c(1, 6), c(-3.5, 3.5), type = &quot;n&quot;) x &lt;- c(1, 2, 3, NA, 4, 4, 6) y &lt;- c(1, -3, 2, NA, -3, 3, -3) polygon(x, y, col = c(&quot;yellow&quot;, &quot;blue&quot;), border = c(&quot;black&quot;, &quot;red&quot;), lwd = 2, lty = c(&quot;dotted&quot;, &quot;solid&quot;), density = c(10, 20), angle = c(45, -45)) title(&quot;Multiple polygons with Line-shaded density&quot;) 아래 다각형은 x, y 좌표값이 위에서 든 예시와는 좀 다르지요? 두개의 좌표값들 간의 거리에 색깔을 채워넣은 형태의 그래프인데요, polygon() 함수로 이런 그래프도 그릴 수 있다는 예시로 보면 좋겠다 싶어서 www.math.cula.edu 사이트에서 참조하였습니다. ## Color-shaded polygon # exmaple source:http://www.math.ucla.edu/~anderson/rw1001/library/base/html/polygon.html n &lt;- 100 xx &lt;- c(0:n, n:0) yy &lt;- c(c(0, cumsum(rnorm(n))), rev(c(0, cumsum(rnorm(n))))) plot(xx, yy, type=&quot;n&quot;, xlab=&quot;Time&quot;, ylab=&quot;Distance&quot;) polygon(xx, yy, col=&quot;gray&quot;, border = &quot;red&quot;) title(&quot;Distance Between Brownian Motions&quot;) * R script source : http://www.math.ucla.edu/~anderson/rw1001/library/base/html/polygon.html 참고자료 https://rfriend.tistory.com/147?category=605866 https://rfriend.tistory.com/148 https://rfriend.tistory.com/149?category=605866 https://rfriend.tistory.com/150?category=605866 https://rfriend.tistory.com/151?category=605866 https://rfriend.tistory.com/152?category=605866 https://rfriend.tistory.com/153?category=605866 https://rfriend.tistory.com/155?category=605866 https://rfriend.tistory.com/156?category=605866 https://rfriend.tistory.com/157?category=605866 https://rfriend.tistory.com/158?category=605866 https://rfriend.tistory.com/159?category=605866 "],["part-3-ggplot2-그래픽.html", "Part 3 : ggplot2 그래픽", " Part 3 : ggplot2 그래픽 "],["일변량-변수-연속형-데이터.html", "7 일변량 변수 - 연속형 데이터", " 7 일변량 변수 - 연속형 데이터 [ 변수 개수별 형태별 그래프 종류 ] 하나의 연속형 변수에 대한 퍼진 정도/분포 모양와 이상치 여부를 쉽고 빠르게 파악할 수 있는 그래프로 히스토그램(Histogram), 커널 밀도 곡선 (Kernel Density Curve)과 박스그림(Box Plot), 바이올린 그래프 (Vilon Plot) 등이 있습니다. "],["r-ggplot2-히스토그램-goem-histogram-커널-밀도-곡선-kernel-density-curve.html", "7.1 R ggplot2 히스토그램 (goem_histogram()), 커널 밀도 곡선 (Kernel Density Curve)", " 7.1 R ggplot2 히스토그램 (goem_histogram()), 커널 밀도 곡선 (Kernel Density Curve) 데이터셋을 받으면 제일 먼저 하는 일이 데이트의 구조를 파악하고, 변수명, 변수별 데이터 유형(숫자형, 문자형, 논리형), 결측값 여부, 이상치/영향치 여부, 데이터의 퍼진 정도/분포 모양 등을 탐색하게 됩니다. 하나의 연속형 변수에 대한 퍼진 정도/분포 모양와 이상치 여부를 쉽고 빠르게 파악할 수 있는 그래프로 히스토그램(Histogram), 커널 밀도 곡선 (Kernel Density Curve)과 박스그림(Box Plot), 바이올린 그래프 (Vilon Plot) 등 이 있습니다. [ 변수 개수별 형태별 그래프 종류 ] 7.1.1 히스토그램 히스토그램(Histogram)은 연속형 변수를 일정한 구간(binwidth)으로 나누어서 빈도수를 구한 후에 이를 막대그래프로 그린 그래프입니다. 이번 포스팅에서는 먼저 ggplot2 패키지의 geom_histogram() 를 활용해서 히스토그램을 그리는 방법에 대해서 알아보겠습니다. 데이터는 MASS 패키지에 들어있는 Cars93 데이터 프레임 데이터 셋에서 가격(Price)과 자동차유형(Type) 변수를 활용하여 히스토그램을 그려보겠습니다. # Cars93 데이터 프레임 library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... ggplot2 패키지를 library()로 호출한 후에 ggplot() 함수의 + geom_histogram() 함수를 사용하여 default 옵션으로 히스토그램을 그리면 아래와 같습니다. ## 히스토그램 (Histogram) # install.packages(&quot;ggplot2&quot;) # ggplot2 패키지 설치 library(ggplot2) # binwidth defaulted to range/30 ggplot(Cars93, aes(x=Price)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 위에 실행결과 콘솔창의 메시지를 보면 “stat_bin: binwidth defaulted to range/30. Use ‘binwidth = x’ to adjust this.”이라는 메시지가 아래 보이는데요, 이는 binwidth를 설정하지 않아서 range/30 디폴트 기준으로 binwidth를 계산해서 그렸다는 뜻입니다. 아래에 실제 범위(range)를 구해서 30으로 나누었더니 1.816 이었고, 이 값을 geom_histogram(binwidth = 1.816) 옵션값이 입력해서 히스토그램을 그려보았더니 위와 같음을 알 수 있습니다. range(Cars93$Price) ## [1] 7.4 61.9 diff(range(Cars93$Price)) ## [1] 54 diff(range(Cars93$Price))/30 ## [1] 1.8 ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=1.816) + ggtitle(&quot;Binwidth=1.816 ; Default, range/30&quot;) 히스토그램에서 중요하면서 어려운 문제 중의 하나가 bin 개수를 몇 개로 할 것인가, 다른 말로 binwidth를 몇 으로 할 것인가 입니다. bin 개수가 너무 많으면 (즉, binwidth가 너무 좁으면) 이빨빠진 머리빗처럼 데이터의 분포 모양을 보기에 부적할 수가 있습니다. 반면에 bin 개수가 너무 적으면 (즉, binwidth가 너무 넓으면) 너무 많은 도수가 하나의 bin에 퉁쳐져서 막대기둥 한두개만 덩그라니 서있게 되어 이 또한 데이터의 분포 모양을 파악하는데 도움이 안되게 됩니다. 적절한 bin 개수를 선정하는게 중요한데요, 아래에 binwidth 를 조절해가면서 히스토그램을 그려봤습니다. # histograms by various binwidths h1 &lt;- ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=1.816) + ggtitle(&quot;Binwidth=1.816 ; Default, range/30&quot;) h2 &lt;- ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=5) + ggtitle(&quot;Binwidth=5&quot;) h3 &lt;- ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=10) + ggtitle(&quot;Binwidth=10&quot;) h4 &lt;- ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=20) + ggtitle(&quot;Binwidth=20&quot;) h5 &lt;- ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=30) + ggtitle(&quot;Binwidth=30&quot;) h6 &lt;- ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=40) + ggtitle(&quot;Binwidth=40&quot;) ##----------------- ## multiplot function by knitr and Jekyll (author of Cookbook for R) ## 아래 사용자정의 함수를 그대로 카피해서 사용하면 됨 # install.packages(&quot;grid&quot;) multiplot &lt;- function(..., plotlist=NULL, file, cols=1, layout=NULL) { library(grid) # Make a list from the ... arguments and plotlist plots &lt;- c(list(...), plotlist) numPlots = length(plots) # If layout is NULL, then use &#39;cols&#39; to determine layout if (is.null(layout)) { # Make the panel # ncol: Number of columns of plots # nrow: Number of rows needed, calculated from # of cols layout &lt;- matrix(seq(1, cols * ceiling(numPlots/cols)), ncol = cols, nrow = ceiling(numPlots/cols)) } if (numPlots==1) { print(plots[[1]]) } else { # Set up the page grid.newpage() pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout)))) # Make each plot, in the correct location for (i in 1:numPlots) { # Get the i,j matrix positions of the regions that contain this subplot matchidx &lt;- as.data.frame(which(layout == i, arr.ind = TRUE)) print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row, layout.pos.col = matchidx$col)) } } } ##----------------- # Multiple graphs on one page : multiplot multiplot(h1, h2, h3, h4, h5, h6, cols=2) 참고로, 위처럼 한개의 화면에 여러개의 그래프를 배열하기 위해서 multiplot() 함수(by knitr and Jekyll)를 사용하였습니다. binwidth = 5 일 때가 위의 6개 그래프 중에서는 상대적으로 가장 적합해 보이므로 아래 예제부터는 binwidth = 5 를 사용하겠습니다. 위의 히스토그램을 보면 거무튀튀하니 그다지 색깔이 아름답지는 않지요? 그러면 이번에는 색 채우기, 경계선 색 지정하기를 해보겠습니다. # 채우기 색, 경계선 색 : geom_histogram(binwidth, fill, colour) ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=5, fill = &quot;blue&quot;, colour = &quot;black&quot;) + ggtitle(&quot;Binwidth=5, fill = blue, colour = black&quot;) 마지막으로, facet_grid() 를 써서 요인(factor)/집단/그룹별로 히스토그램을 구분해서 그려보도록 하겠습니다. 단, facet_grid()에 들어가는 변수는 요인(factor)형 변수이어야 합니다. # 요인(factor) 여부 확인, levels 확인 class(Cars93$Type); levels(Cars93$Type) ## [1] &quot;factor&quot; ## [1] &quot;Compact&quot; &quot;Large&quot; &quot;Midsize&quot; &quot;Small&quot; &quot;Sporty&quot; &quot;Van&quot; # 요인/집단/그룹(factor)별로 나누어서 히스토그램 그리기 ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=5, fill = &quot;blue&quot;, colour = &quot;black&quot;) + ggtitle(&quot;Binwidth=5, fill = blue, colour = black, group by Type&quot;) + facet_grid(Type ~ .) 위의 히스토그램처럼 자동차의 유형(Type)인 ‘Compact,’ ‘Large,’ ‘Midsize,’ ‘Small,’ ‘Sporty,’ ‘Van’ 의 6개 유형별로 가격(Price)의 히스토그램을 그려보면 서로 한눈에 비교가 가능하니 매우 유용하다고 하겠습니다. 참고로, 위처럼 가로로 비교를 하는 것이 아니라 세로로 세워서 그래프를 그린 후에 비교를 하려면 + facet_grid(. ~ Type) 처럼 괄호안의 기입 순서를 바꾸어주면 됩니다. 단, 아래에 예시 그래프를 보면 알겠지만, 차종별로 가격의 분포를 비교하기에는 아래 처럼 그래프를 그려서는 안되겠지요? 분석 목적에 맞게 가로로 비교할지, 세로로 비교할지 잘 선택해서 사용하시기 바랍니다. # 요인/집단/그룹(factor)별로 나누어서 히스토그램 그리기 ggplot(Cars93, aes(x=Price)) + geom_histogram(binwidth=5, fill = &quot;blue&quot;, colour = &quot;black&quot;) + ggtitle(&quot;Binwidth=5, fill = blue, colour = black, group by Type&quot;) + facet_grid(. ~ Type) # 수직 7.1.2 커널 밀도 곡선 다음으로, 커널 밀도 추정함수를 가지고 그린 커널 밀도 곡선(kernel density curve)를 그려보겠습니다. 히스토그램은 빈도를 가지고 그리며, geom_histogram()함수를 사용하며, 계단식으로 각이 져 있는데요, 커널 밀도 곡선(kernel density curve)은 확률(모두 더하면 1)을 가지고 그리고, geom_density() 함수를 사용하며, smoothing 된 곡선으로 되어 있습니다. # 가격 커널 밀도 곡선(Kernel Density Curve) ggplot(Cars93, aes(x=Price)) + geom_density(fill = &quot;yellow&quot;, colour=NA, alpha=.5) + # alpha 반투명 geom_line(stat=&quot;density&quot;) + expand_limits(y=0) + ggtitle(&quot;Kernel Density Curve&quot;) # 차종별 가격 커널 밀도 곡선(Kernel Density Curve)_중복 ggplot(Cars93, aes(x=Price, colour = Type)) + geom_density(fill = NA) + geom_line(stat = &quot;density&quot;) + expand_limits(y = 0) + ggtitle(&quot;Kernel Density Curve by Car Type_overlap&quot;) # 차종별 가격 커널 밀도 곡선(Kernel Density Curve)_수평 ggplot(Cars93, aes(x=Price)) + geom_density(fill = &quot;yellow&quot;, colour=NA, alpha=.5) + geom_line(stat=&quot;density&quot;) + expand_limits(y=0) + ggtitle(&quot;Kernel Density Curve by Car Type&quot;) + facet_grid(Type ~ .) + xlim(10, 40) # X축 범위를 지정해줬더니 40 초과하는 값 짤렸다고 경고메시지 뜸 ## Warning: Removed 13 rows containing non-finite values (stat_density). ## Warning: Removed 13 rows containing non-finite values (stat_density). *R ggplot2의 커널밀도곡선에서 최대 피크값 좌표를 구하고 수직선을 추가하는 방법은 https://rfriend.tistory.com/485 를 참고*하세요. 7.1.3 히스토그램과 커널 밀도 곡선 겹쳐 그리기 히스토그램과 커널 밀도 곡선을 겹쳐서 그려보도록 하겠습니다. # Histogram + Kernel Density Curve ggplot(Cars93, aes(x=Price, y=..density..)) + geom_histogram(binwidth=5, fill = &quot;blue&quot;, colour=&quot;white&quot;, alpha=0.5) + geom_density(fill = NA, colour=NA, alpha=0.8) + geom_line(stat=&quot;density&quot;) + expand_limits(y=0) + ggtitle(&quot;Histogram + Kernel Density Curve&quot;) 히스토그램의 bin width를 수동으로 설정해주고, bin별로 색깔을 다르게 해서 히스토그램을 그려보겠습니다. #---------------- # histogram with variable size of bin width and different colors per bins using ggplot2 #---------------- # sample data frame mydf &lt;- data.frame(var = c(1100, 10000, 100000, 190000, 110000, 220000, 550000, 701000, 790000)) # numeric notation for large numbers options(scipen = 30) library(&quot;ggplot2&quot;) # fill color with different colors per bins mydf $group &lt;- ifelse(mydf $var &lt; 10000, 1, ifelse(mydf $var &lt; 100000, 2, ifelse(mydf $var &lt; 200000, 3, ifelse(mydf $var &lt; 500000, 4, 5)))) # breaks of bin bins &lt;- c(1000, 10000, 100000, 200000, 500000, 800000) # draw histogram with variable size of bin width and different colors per bins ggplot(mydf, aes(x= var)) + geom_histogram(data=subset(mydf, group==1), breaks = c(1000, 10000), fill=&quot;black&quot;) + geom_histogram(data=subset(mydf, group==2), breaks = c(10000, 100000), fill=&quot;yellow&quot;) + geom_histogram(data=subset(mydf, group==3), breaks = c(100000, 200000), fill=&quot;green&quot;) + geom_histogram(data=subset(mydf, group==4), breaks = c(200000, 500000), fill=&quot;blue&quot;) + geom_histogram(data=subset(mydf, group==5), breaks = c(500000, 800000), fill=&quot;red&quot;) + scale_x_continuous(breaks = bins, limits = c(1000, 800000)) + xlab(&quot;variable 1&quot;) + ylab(&quot;count&quot;) + ggtitle(&quot;Histogram with different size of bin width and colors&quot;) + theme(plot.title = element_text(hjust = 0.5, size = 14)) 다음번 포스팅에서는 Box Plot 을 소개하겠습니다. "],["r-ggplot2-박스-그래프-geom-boxplot-바이올린-그래프geom-violin.html", "7.2 R ggplot2 박스 그래프 (geom_boxplot()), 바이올린 그래프(geom_violin())", " 7.2 R ggplot2 박스 그래프 (geom_boxplot()), 바이올린 그래프(geom_violin()) 데이터셋을 받으면 제일 먼저 하는 일이 데이트의 구조를 파악하고, 변수명, 변수별 데이터 유형(숫자형, 문자형, 논리형), 결측값 여부, 이상치/영향치 여부, 데이터의 퍼진 정도/분포 모양 등을 탐색하게 됩니다. 하나의 연속형 변수에 대한 퍼진 정도/분포 모양와 이상치 여부를 쉽고 빠르게 파악할 수 있는 그래프로 - 히스토그램(Histogram) - 커널 밀도 곡선 (Kernel Density Curve) - 박스그림(Box Plot) - 바이올린 그래프 (Violin Plot) 등 이 있습니다. [ 변수 개수 및 형태별 그래프 종류 ] 7.2.1 박스 그래프 박스 그래프(Box Plot)는 Box-and-Whiskers Plot 이라고도 하는데요, 연속형 변수에 대해 min, Q1, median, Q3, max, lower whisker, upper whisker, outlier(*IQR(Inter-Quartile Range)의 1.5배 초과 시) 등을 한눈에 볼 수 있게 그린 그래프입니다. 연속형 한 변수의 분포의 중심, 퍼짐 정도(variance), 치우침 정도(skewness), 이상치/특이값(outlier) 존재 여부, 대칭성(symmetry) 등을 알 수 있는 매우, 매우, 매우 유용한 그래프라고 하겠습니다. 특히 박스 그래프는 이상치에 덜 민감한(robust) 중앙값, IQR 값을 사용한다는 점에서 이상치에 민감한 평균, 표준편차 대비 중심 경향과 퍼짐 정도를 파악하는데 있어 상대적으로 더 믿을 만 하다고 말할 수 있습니다. 상당히 유용하겠지요?! [ 박스 그래프(Box-Whiskers Plot) 이해 ] 이번 포스팅에서는 먼저 ggplot2 패키지의 geom_boxplot() 를 활용해서 박스그래프(상자그림)을 그리는 방법에 대해서 알아보겠습니다. 데이터는 MASS 패키지에 들어있는 Cars93 데이터 프레임 데이터 셋에서 가격(Price)과 자동차유형(Type) 변수를 활용하여 히스토그램을 그려보겠습니다. # Cars93 데이터 프레임 library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 그럼, 먼저 Cars93 데이터 프레임 내 가격(Price) 변수 하나를 가지고 geom_boxplot()을 사용하여 박스 그래프(Box Plot)을 그려보겠습니다. ggplot(Cars93, aes(x = 1, y = Price)) + # x=1 (임의의 값) 지정해줘야 함 geom_boxplot(width=0.8, outlier.size=3, outlier.shape=16, outlier.colour=&quot;red&quot;) + scale_x_continuous(breaks = NULL) + # x축 이름 생략 theme(axis.title.x = element_blank()) + # x축 구분자 생략 ggtitle(&quot;Box Plot&quot;) 다음으로, 차종별(Type)로 가격(Price) 변수에 대해 박스 그래프를 그려보겠습니다. aes(x = factor variable) 을 입력해주면 되겠습니다. 여기서 주의할 점은 x 에다가 요인(factor)형 변수를 입력해줘야 합니다. 차종(Type)은 이미 요인형 변수이므로 그대로 입력하면 되겠구요, 만약 요인형 변수가 아니라면 x=factor(variable name) 이런 식으로 입력해주거나, 아니면 transform() 함수로 as.factor()로 데이터 형태를 요인형 변수로 아예 만든 후에 ggplot2 그래프를 그려도 되겠습니다. # 박스그림(Box Plot) - 차종별(Type) ggplot(Cars93, aes(x = Type, y = Price)) + geom_boxplot(width=0.8, outlier.size=3, outlier.shape=16, outlier.colour=&quot;red&quot;) + ggtitle(&quot;Box Plot by Car Type&quot;) 위의 차종(Type)별 박스그림의 박스 가운데 선은 중앙값(Median)을 나타낸다고 했는데요, 이번에는 평균을 추가해 보도록 하겠습니다. 평균은 이상치에 민감하므로 아래 예제처럼 이상치가 있는 경우에는 중심화 경향을 나타내는 통계량으로 부적합하며, 박스 그림의 박스 가운데에 쳐진 선이 의미하는 중앙값(Median) 이 더 적합한 중심화 경향 지표라고 하겠습니다. # box plot with mean ggplot(Cars93, aes(x = Type, y = Price)) + geom_boxplot(width=0.8, outlier.size=3, outlier.shape=16, outlier.colour=&quot;red&quot;) + stat_summary(fun.y=&quot;mean&quot;, geom=&quot;point&quot;, shape=21, size=3, fill=&quot;blue&quot;) + ggtitle(&quot;Box Plot by Car Type, adding mean&quot;) ## Warning: `fun.y` is deprecated. Use `fun` instead. 만약 차종(Type)과 생산지(Origin)의 두 기준/그룹으로 구분해서 박스 그래프를 그리고 싶다면 aes(fill = Origin) 을 추가해주면 됩니다. ggplot(Cars93, aes(x = Type, y = Price, fill = Origin)) + geom_boxplot(width=0.8, outlier.size=3, outlier.shape=16, outlier.colour=&quot;red&quot;) + ggtitle(&quot;Box Plot by Car Type and Origin&quot;) 7.2.2 바이올린 그래프 다음으로 박스 그래프(Box Plot)와 커널 밀도 곡선(Kernel Density Curve)을 짬뽕해놓은 바이올린 그래프(Violin Plot)를 geom_violin()을 사용해 그려보겠습니다. 제공해주는 정보량이 많아서 바이올린 그래프(Violin Plot) 또한 유용한 편인데요, 실전에서는 별로 사용하지 않게 되는 그래프이기도 합니다. ^^; 7.2.2.1 데이터 세트 library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 7.2.2.2 기본적인 바이올린 그래프 그리기 ggplot(Cars93, aes(x = Type, y = Price)) + geom_violin() 7.2.2.3 그림에 색칠하기 : group = ggplot(Cars93, aes(x = Type, y = Price, color =Type)) + geom_violin() 7.2.2.4 수평으로 그리기 coord_flip() 함수를 이용한 수평 violin chart 그리기. ggplot(Cars93, aes(x = Type, y = Price, color = Type)) + geom_violin() + coord_flip() 7.2.2.5 개별 데이터 표시하기 geom_jitter()를 이용하여 바이올린 그래프에 개별 데이터를 표시할 수 있다. ggplot(Cars93, aes(x = Type, y = Price, color = Type)) + geom_violin() + geom_jitter(height = 0, width = 0.1) #### 평균 추가하기 stat_summary()을 이용해서 평균을 표시할 수 있다. ggplot(Cars93, aes(x = Type, y = Price, color = Type)) + geom_violin() + geom_jitter(height = 0, width = 0.1) + stat_summary(fun.y=mean, geom=&quot;point&quot;, size=2, color=&quot;red&quot;) ## Warning: `fun.y` is deprecated. Use `fun` instead. 7.2.2.6 박스 플롯 겹쳐 그리기 box_plot() 함수를 이용하여 평균과 IQR을 표시할 수 있다. ggplot(Cars93, aes(x = Type, y = Price, color = Type)) + geom_violin() + geom_jitter(height = 0, width = 0.1) + geom_boxplot(width=0.1) 7.2.2.7 면 분할하기 facet_wrap(vars(AirBags))를 추가하여 면 분할할 수 있다. 면 분할에 사용하는 함수는 범주형 변수를 이용하면 된다. 여기서는 AirBags 변수를 이용한다. ggplot(Cars93, aes(x = Type, y = Price, color = Type)) + geom_violin() + geom_jitter(height = 0, width = 0.1) + geom_boxplot(width=0.1) + facet_wrap(vars(AirBags)) 한편 Type 변수로도 면 분할을 해 보면 다음과 같다. ggplot(Cars93, aes(x = Type, y = Price, color = Type)) + geom_violin() + geom_jitter(height = 0, width = 0.1) + geom_boxplot(width=0.1) + facet_wrap(vars(Type)) 참고자료 : ggplot2 violin plot : http://www.sthda.com/english/wiki/ggplot2-violin-plot-quick-start-guide-r-software-and-data-visualization "],["r-ggplot2-범주형-축-그룹요인-순서-바꾸기-scale-x-discretelimits-.html", "7.3 R ggplot2 범주형 축 그룹(요인) 순서 바꾸기 : scale_x_discrete(limits=...)", " 7.3 R ggplot2 범주형 축 그룹(요인) 순서 바꾸기 : scale_x_discrete(limits=...) 범주형 변수의 그룹(요인)을 x 축으로 한 그래프를 그리면 디폴트는 알파벳 순서대로 그룹이 제시가 됩니다. 만약 순서형 요인(ordered factor)으로 범주형 변수를 만들었다면 그 순서에 따라서 그래프가 그려질 겁니다. 그런데 분석가가 범주형 변수의 그룹의 순서를 ggplot2가 디폴트로 그려준 것과는 달리 바꾸고 싶어할 수 있습니다. 이때 scale_x_discrete(limits=c(...) 함수를 사용해서 그룹의 순서를 바꿀 수 있습니다. 아래의 예제에 사용할 데이터는 iris 데이터프레임의 Petal.Length 와 Species두 개의 변수입니다. Species 가 요인(Factor)형 변수이며, “setosa,” “versicolor,” “virginica” 의 3개 Levels 로 구성이 되어있습니다. str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ggplot2 패키지를 사용해서 Species를 x축으로 Petal.Length 를 y축으로 해서 Box plot을 그려보겠습니다. 이를 위해서 먼저 데이터셋을 ggplot2에서 사용할 수 있는 형태로 변환이 필요합니다. 가로로 옆으로 늘어서있는 원래의 iris 데이터셋을 reshape 패키지를 사용해서 melt() 함수를 적용하여 세로로 길게 세워보겠습니다. ( reshape 패키지 melt(), cast() 함수 사용법 둘러보기) # dataset preparation library(reshape) iris_melt_petal.length &lt;- melt(data=iris, id.vars = c(&quot;Species&quot;), measure.vars = c(&quot;Petal.Length&quot;)) iris_melt_petal.length ## Species variable value ## 1 setosa Petal.Length 1.4 ## 2 setosa Petal.Length 1.4 ## 3 setosa Petal.Length 1.3 ## 4 setosa Petal.Length 1.5 ## 5 setosa Petal.Length 1.4 ## 6 setosa Petal.Length 1.7 ## 7 setosa Petal.Length 1.4 ## 8 setosa Petal.Length 1.5 ## 9 setosa Petal.Length 1.4 ## 10 setosa Petal.Length 1.5 ## 11 setosa Petal.Length 1.5 ## 12 setosa Petal.Length 1.6 ## 13 setosa Petal.Length 1.4 ## 14 setosa Petal.Length 1.1 ## 15 setosa Petal.Length 1.2 ## 16 setosa Petal.Length 1.5 ## 17 setosa Petal.Length 1.3 ## 18 setosa Petal.Length 1.4 ## 19 setosa Petal.Length 1.7 ## 20 setosa Petal.Length 1.5 ## 21 setosa Petal.Length 1.7 ## 22 setosa Petal.Length 1.5 ## 23 setosa Petal.Length 1.0 ## 24 setosa Petal.Length 1.7 ## 25 setosa Petal.Length 1.9 ## 26 setosa Petal.Length 1.6 ## 27 setosa Petal.Length 1.6 ## 28 setosa Petal.Length 1.5 ## 29 setosa Petal.Length 1.4 ## 30 setosa Petal.Length 1.6 ## 31 setosa Petal.Length 1.6 ## 32 setosa Petal.Length 1.5 ## 33 setosa Petal.Length 1.5 ## 34 setosa Petal.Length 1.4 ## 35 setosa Petal.Length 1.5 ## 36 setosa Petal.Length 1.2 ## 37 setosa Petal.Length 1.3 ## 38 setosa Petal.Length 1.4 ## 39 setosa Petal.Length 1.3 ## 40 setosa Petal.Length 1.5 ## 41 setosa Petal.Length 1.3 ## 42 setosa Petal.Length 1.3 ## 43 setosa Petal.Length 1.3 ## 44 setosa Petal.Length 1.6 ## 45 setosa Petal.Length 1.9 ## 46 setosa Petal.Length 1.4 ## 47 setosa Petal.Length 1.6 ## 48 setosa Petal.Length 1.4 ## 49 setosa Petal.Length 1.5 ## 50 setosa Petal.Length 1.4 ## 51 versicolor Petal.Length 4.7 ## 52 versicolor Petal.Length 4.5 ## 53 versicolor Petal.Length 4.9 ## 54 versicolor Petal.Length 4.0 ## 55 versicolor Petal.Length 4.6 ## 56 versicolor Petal.Length 4.5 ## 57 versicolor Petal.Length 4.7 ## 58 versicolor Petal.Length 3.3 ## 59 versicolor Petal.Length 4.6 ## 60 versicolor Petal.Length 3.9 ## 61 versicolor Petal.Length 3.5 ## 62 versicolor Petal.Length 4.2 ## 63 versicolor Petal.Length 4.0 ## 64 versicolor Petal.Length 4.7 ## 65 versicolor Petal.Length 3.6 ## 66 versicolor Petal.Length 4.4 ## 67 versicolor Petal.Length 4.5 ## 68 versicolor Petal.Length 4.1 ## 69 versicolor Petal.Length 4.5 ## 70 versicolor Petal.Length 3.9 ## 71 versicolor Petal.Length 4.8 ## 72 versicolor Petal.Length 4.0 ## 73 versicolor Petal.Length 4.9 ## 74 versicolor Petal.Length 4.7 ## 75 versicolor Petal.Length 4.3 ## 76 versicolor Petal.Length 4.4 ## 77 versicolor Petal.Length 4.8 ## 78 versicolor Petal.Length 5.0 ## 79 versicolor Petal.Length 4.5 ## 80 versicolor Petal.Length 3.5 ## 81 versicolor Petal.Length 3.8 ## 82 versicolor Petal.Length 3.7 ## 83 versicolor Petal.Length 3.9 ## 84 versicolor Petal.Length 5.1 ## 85 versicolor Petal.Length 4.5 ## 86 versicolor Petal.Length 4.5 ## 87 versicolor Petal.Length 4.7 ## 88 versicolor Petal.Length 4.4 ## 89 versicolor Petal.Length 4.1 ## 90 versicolor Petal.Length 4.0 ## 91 versicolor Petal.Length 4.4 ## 92 versicolor Petal.Length 4.6 ## 93 versicolor Petal.Length 4.0 ## 94 versicolor Petal.Length 3.3 ## 95 versicolor Petal.Length 4.2 ## 96 versicolor Petal.Length 4.2 ## 97 versicolor Petal.Length 4.2 ## 98 versicolor Petal.Length 4.3 ## 99 versicolor Petal.Length 3.0 ## 100 versicolor Petal.Length 4.1 ## 101 virginica Petal.Length 6.0 ## 102 virginica Petal.Length 5.1 ## 103 virginica Petal.Length 5.9 ## 104 virginica Petal.Length 5.6 ## 105 virginica Petal.Length 5.8 ## 106 virginica Petal.Length 6.6 ## 107 virginica Petal.Length 4.5 ## 108 virginica Petal.Length 6.3 ## 109 virginica Petal.Length 5.8 ## 110 virginica Petal.Length 6.1 ## 111 virginica Petal.Length 5.1 ## 112 virginica Petal.Length 5.3 ## 113 virginica Petal.Length 5.5 ## 114 virginica Petal.Length 5.0 ## 115 virginica Petal.Length 5.1 ## 116 virginica Petal.Length 5.3 ## 117 virginica Petal.Length 5.5 ## 118 virginica Petal.Length 6.7 ## 119 virginica Petal.Length 6.9 ## 120 virginica Petal.Length 5.0 ## 121 virginica Petal.Length 5.7 ## 122 virginica Petal.Length 4.9 ## 123 virginica Petal.Length 6.7 ## 124 virginica Petal.Length 4.9 ## 125 virginica Petal.Length 5.7 ## 126 virginica Petal.Length 6.0 ## 127 virginica Petal.Length 4.8 ## 128 virginica Petal.Length 4.9 ## 129 virginica Petal.Length 5.6 ## 130 virginica Petal.Length 5.8 ## 131 virginica Petal.Length 6.1 ## 132 virginica Petal.Length 6.4 ## 133 virginica Petal.Length 5.6 ## 134 virginica Petal.Length 5.1 ## 135 virginica Petal.Length 5.6 ## 136 virginica Petal.Length 6.1 ## 137 virginica Petal.Length 5.6 ## 138 virginica Petal.Length 5.5 ## 139 virginica Petal.Length 4.8 ## 140 virginica Petal.Length 5.4 ## 141 virginica Petal.Length 5.6 ## 142 virginica Petal.Length 5.1 ## 143 virginica Petal.Length 5.1 ## 144 virginica Petal.Length 5.9 ## 145 virginica Petal.Length 5.7 ## 146 virginica Petal.Length 5.2 ## 147 virginica Petal.Length 5.0 ## 148 virginica Petal.Length 5.2 ## 149 virginica Petal.Length 5.4 ## 150 virginica Petal.Length 5.1 데이터셋 준비가 되었으므로, 디폴트 설정으로 해서 x축에 Species, y축에 Petal.Length로 Box plot 을 그려보겠습니다. ggplot2는 별도의 설치 및 호출이 필요하므로 install.packages(\"ggplot2\")와 library(ggplot2)를 먼저 실행 후 그래프를 그립니다. x축의 요인(factor)의 순서가 위에서 살펴본것처럼 “setosa,” “versicolor,” “virginica” 의 알파벳 순서로 되어있습니다. # install.packages(&quot;ggplot2&quot;) library(ggplot2) # Boxplot of Petal.Length f1 &lt;- ggplot(iris_melt_petal.length, aes(x=Species, y=value)) + geom_boxplot() + ggtitle((&quot;Boxplot of Petal.Length&quot;)) f1 이것을 분석가가 필요에 따라서 순서를 “virginica,” “versicolor,” “setosa” 처럼 바꾸고 싶다고 해봅시다. 이때 사용하는 것이 scale_x_discrete(limit=...)함수입니다. f2 &lt;- f1 + scale_x_discrete(limits=c(&quot;virginica&quot;, &quot;versicolor&quot;, &quot;setosa&quot;)) + ggtitle(&quot;Changed Order of x axis by scale_x_discrete(limit=...)&quot;) f2 첫번째에 디폴트로 그린 박스그림과 두번째에 범주형 축 그룹 순서를 바꾼 그래프의 차이를 아시겠지요? 많은 도움 되었기를 바랍니다. "],["일변량-변수-범주형-데이터.html", "8 일변량 변수 - 범주형 데이터 ", " 8 일변량 변수 - 범주형 데이터 "],["r-ggplot2-막대그림geom-bar.html", "8.1 R ggplot2 막대그림(geom_bar())", " 8.1 R ggplot2 막대그림(geom_bar()) 변수의 개수 및 데이터의 형태에 따라서 그래프, 시각화 방법이 달라지는데요, 지난번 포스팅에서는 일변량 연속형 데이터의 시각화 방법으로 히스토그램(Histogram) : geom_histogram() 커널 밀도 곡선(Kernel Density Curve) : geom_density() 박스 그래프(Box Plot) : geom_boxplot() 바이올린 그래프(Violin Plot) : geom_violin() 에 대해서 알아보았습니다. 이번 포스팅에서는 일변량 범주형 데이터의 시각화 방법으로서 막대그림(Bar Chart): geom_bar() 원그림(Pie Chart): geom_bar() + coord_polar() 에 대해서 소개해드리겠습니다. [ 변수 개수 및 데이터 형태에 따른 그래프 ] 8.1.1 막대그림 먼저, 범주별 도수를 구하고 이를 막대 형태로 나타낸 막대 그래프 (Bar Chart)를 ggplot2의 geom_bar() 로 그려보겠습니다. 사용할 데이터는 MASS 패키지에 있는 Cars93 데이터 프레임에서 자동차 유형(Type), 제조국(Origin) 등의 범주형/요인(factor)형 변수를 사용하겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 자동차 유형(Type)별 도수를 가지고 막대그림을 그려보겠습니다. ggplot(Cars93, aes(x=Type)) + geom_bar(fill=&quot;white&quot;, colour=&quot;black&quot;) + ggtitle(&quot;Bar Chart of Frequency by Car Type&quot;) 위와 똑같은 그래프를 그려볼건데요, 이번에는 aes(x, y)의 x변수와 도수에 해당하는 y변수로 된 데이터프레임을 만들어서 이를 직접 x, y에 입력해서 그래프를 그려보겠습니다 (간편하게는 위의 방식 사용하면 되구요, 아래 처럼 데이터가 구성이 되어있다면 이번 방식을 이용하면 되겠습니다). 아래 예제에서는 자동차 유형(Type)별로 도수를 집계(aggregation)할 때 sqldf 패키지를 사용하였습니다. # install.packages(&quot;sqldf&quot;) library(sqldf) ## Loading required package: gsubfn ## Loading required package: proto ## Loading required package: RSQLite Car_Type_cnt &lt;- sqldf( &#39;select Type, count(*) as Type_cnt from Cars93 group by Type order by Type &#39;) Car_Type_cnt ## Type Type_cnt ## 1 Compact 16 ## 2 Large 11 ## 3 Midsize 22 ## 4 Small 21 ## 5 Sporty 14 ## 6 Van 9 sapply(Car_Type_cnt, class) ## Type Type_cnt ## &quot;factor&quot; &quot;integer&quot; 다음으로 자동차 유형(Type)별로 geom_bar()를 이용하여 막대그림을 그려보도록 하겠습니다. y에 직접 입력해주고, geom_bar()에 stat=\"identity\"를 설정해주어야 합니다. # 자동차 유형별 도수 막대 그림 library(ggplot2) ggplot(Car_Type_cnt, aes(x=Type, y=Type_cnt)) + geom_bar(stat=&quot;identity&quot;, fill=&quot;white&quot;, colour=&quot;black&quot;) + ggtitle(&quot;Bar Chart of Frequency by Car Type&quot;) 일변량에 더해서, 이번에는 2개의 변수를 사용한 막대그림도 살펴보도록 하겠습니다. 차종(Type) 별 제조국(Origin) 별 자동차 수를 가지고 막대그림을 그려보도록 하겠습니다. # Origin별 구분 추가하기 ggplot(Cars93, aes(x=Type, fill=Origin)) + geom_bar(position=&quot;dodge&quot;, colour=&quot;black&quot;) + scale_fill_brewer(palette=1) + ggtitle(&quot;Bar Chart of Frequency by Car Type &amp; Origin&quot;) 이번에는 위와 동일한 그래프를 그릴건데요, sqldf()로 차종(Type)별 &amp; Origin 별 자동차 도수를 집계를 해서 데이터프레임을 만들어서 막대그림을 그려보겠습니다. # 차종(Type) 별 실린더개수(Cylinders) 별 자동차 개수 library(sqldf) Car_Type_Origin_cnt &lt;- sqldf( &#39;select Type, Origin, count(*) as Type_Origin_cnt from Cars93 group by Type, Origin order by Type, Origin &#39;) Car_Type_Origin_cnt ## Type Origin Type_Origin_cnt ## 1 Compact USA 7 ## 2 Compact non-USA 9 ## 3 Large USA 11 ## 4 Midsize USA 10 ## 5 Midsize non-USA 12 ## 6 Small USA 7 ## 7 Small non-USA 14 ## 8 Sporty USA 8 ## 9 Sporty non-USA 6 ## 10 Van USA 5 ## 11 Van non-USA 4 geom_bar()로 막대그림을 그리되, 처음의 일변량 때와는 다르게 fill=Origin 로 하여서 제조국별로 구분을 해보겠습니다. position=\"dodge\" 를 하면 수평으로 나란히 Origin별로 그려집니다. ggplot(Car_Type_Origin_cnt, aes(x=Type, y=Type_Origin_cnt, fill=Origin)) + geom_bar(stat=&quot;identity&quot;, position=&quot;dodge&quot;, colour=&quot;black&quot;) + scale_fill_brewer(palette=1) + ggtitle(&quot;Bar Chart of Frequency by Car Type &amp; Origin_1&quot;) 만약 position=\"dodge\" 옵션을 지정하지 않으면 아래와 같이 세로로 올라탄 그래프 형식으로 제시됩니다. # without position=&quot;dodge&quot; ggplot(Car_Type_Origin_cnt, aes(x=Type, y=Type_Origin_cnt, fill=Origin)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;black&quot;) + # position=&quot;dodge&quot; 미지정 scale_fill_brewer(palette=1) + ggtitle(&quot;Bar Chart of Frequency by Car Type &amp; Origin, without podge option&quot;) 8.1.2 누적 막대 그래프 (stacked bar chart) 아래와 같이 생긴 데이터프레임에서 ‘id’ 그룹별로 ‘bin_val’ 값을 이용해서 누적 막대그래프 (stacked bar chart)를 그려보겠습니다. 이때 막대그래프의 색깔은 ‘color’ 칼럼의 색으로 지정해서 그려보겠습니다. parsed.txt df &lt;- read.table(&#39;data/parsed.txt&#39;, sep=&#39;,&#39;, header=T) df &lt;- transform(df, bin_val = bin_end - bin_start) df ## id color_cd color bin_start bin_end bin_range bin_val ## 1 AAA a red 0 100 [0,100) 100 ## 2 AAA b blue 100 200 [100,200) 100 ## 3 AAA a red 200 300 [200,300) 100 ## 4 AAA b blue 300 400 [300,400) 100 ## 5 BBB a red 0 250 [0,250) 250 ## 6 BBB b blue 250 350 [250,350) 100 ## 7 BBB a red 350 450 [350,450) 100 ## 8 BBB b blue 450 550 [450,550) 100 ## 9 BBB a red 550 650 [550,650) 100 ## 10 BBB b blue 650 750 [650,750) 100 ## 11 BBB a red 750 800 [750,800) 50 ## 12 BBB b blue 800 910 [800,910) 110 library(ggplot2) ggplot(df, aes(x=id, y=bin_val, fill=color, group=id)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_manual(&quot;legend&quot;, values = c(&quot;red&quot; = &quot;red&quot;, &quot;blue&quot; = &quot;blue&quot;)) 다음번 포스팅에서는 막대 그래프(Bar Chart)에서 양수와 음수의 색상을 다르게 표현하는 방법을 알아보겠습니다. 8.1.3 R ggplot2 막대그래프(Bar Chart) : 양수, 음수 색상 다르게 하기 (geom_bar()) ggplot2로 막대그래프를 그렸는데 데이터가 양수와 음수로 구분이 되는 경우 그래프의 가독성을 높이기 위해서 양수냐, 음수냐에 따라 색상을 다르게 하고 싶을 때가 있습니다. 이번 포스팅에서는 R에 내장되어 있는 airquaility 데이터셋 (뉴욕의 1973년 5월~9월까지의 daily air quality measurements) 에서 5월달 온도(Temp) 만을 가져온 후에, 5월달 daily 온도의 1차 차분 데이터를 만들어서 막대그래프를 그려보도록 하겠습니다. str(airquality) ## &#39;data.frame&#39;: 153 obs. of 6 variables: ## $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... ## $ Solar.R: int 190 118 149 313 NA NA 299 99 19 194 ... ## $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... ## $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... ## $ Month : int 5 5 5 5 5 5 5 5 5 5 ... ## $ Day : int 1 2 3 4 5 6 7 8 9 10 ... sum(is.na(airquality$Temp)) ## [1] 0 # 5월 온도만 선택 May &lt;- subset(airquality, select = c(Month, Day, Temp), subset = (Month == &quot;5&quot;)) head(May) ## Month Day Temp ## 1 5 1 67 ## 2 5 2 72 ## 3 5 3 74 ## 4 5 4 62 ## 5 5 5 56 ## 6 5 6 66 온도의 1차 차분은 **diff(변수, lag=차수)** 함수를 사용합니다. 아래는 1차 차분을 하였으므로 5월1일은 빼고, 5월2일부터 5월31일까지의 날짜만 가져온 후에, 날짜와 온도 1차 차분한 값을 data frame으로 묶었습니다. 그 후에 **ifelse()** 함수를 사용해서 온도 1차 차분 값이 0 이상이면 “PLUS,” 0 미만이면 “MINUS”라는 구분자 변수를 새로 생성하였습니다. # 온도의 1차 차분 May_Temp_Diff &lt;- diff(May$Temp, lag=1) May_Temp_Diff ## [1] 5 2 -12 -6 10 -1 -6 2 8 5 -5 -3 2 -10 6 2 -9 11 -6 ## [20] -3 14 -12 0 -4 1 -1 10 14 -2 -3 # 5월2일 ~ 5월31일 날짜 변수 May_Day &lt;- May[c(2:31), c(&quot;Day&quot;)] May_Day ## [1] 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ## [26] 27 28 29 30 31 May_Temp_Diff.df &lt;- data.frame(May_Day, May_Temp_Diff) May_Temp_Diff.df ## May_Day May_Temp_Diff ## 1 2 5 ## 2 3 2 ## 3 4 -12 ## 4 5 -6 ## 5 6 10 ## 6 7 -1 ## 7 8 -6 ## 8 9 2 ## 9 10 8 ## 10 11 5 ## 11 12 -5 ## 12 13 -3 ## 13 14 2 ## 14 15 -10 ## 15 16 6 ## 16 17 2 ## 17 18 -9 ## 18 19 11 ## 19 20 -6 ## 20 21 -3 ## 21 22 14 ## 22 23 -12 ## 23 24 0 ## 24 25 -4 ## 25 26 1 ## 26 27 -1 ## 27 28 10 ## 28 29 14 ## 29 30 -2 ## 30 31 -3 # 온도 차분 plus, minus 여부 구분자 변수 생성 attach(May_Temp_Diff.df) ## The following objects are masked _by_ .GlobalEnv: ## ## May_Day, May_Temp_Diff May_Temp_Diff.df$plus_minus &lt;- ifelse(May_Temp_Diff &gt;= 0, &quot;PLUS&quot;, &quot;MINUS&quot;) May_Temp_Diff.df ## May_Day May_Temp_Diff plus_minus ## 1 2 5 PLUS ## 2 3 2 PLUS ## 3 4 -12 MINUS ## 4 5 -6 MINUS ## 5 6 10 PLUS ## 6 7 -1 MINUS ## 7 8 -6 MINUS ## 8 9 2 PLUS ## 9 10 8 PLUS ## 10 11 5 PLUS ## 11 12 -5 MINUS ## 12 13 -3 MINUS ## 13 14 2 PLUS ## 14 15 -10 MINUS ## 15 16 6 PLUS ## 16 17 2 PLUS ## 17 18 -9 MINUS ## 18 19 11 PLUS ## 19 20 -6 MINUS ## 20 21 -3 MINUS ## 21 22 14 PLUS ## 22 23 -12 MINUS ## 23 24 0 PLUS ## 24 25 -4 MINUS ## 25 26 1 PLUS ## 26 27 -1 MINUS ## 27 28 10 PLUS ## 28 29 14 PLUS ## 29 30 -2 MINUS ## 30 31 -3 MINUS detach(May_Temp_Diff.df) ggplot2 패키지는 사용자가 추가로 설치해야 합니다. intall.packages()함수로 설치하고 library() 함수로 호출해보겠습니다. # install.packages(&quot;ggplot2&quot;) library(ggplot2) 이제 준비가 다 되었습니다. 1차 차분한 5월달의 온도에 대해서 양수(전날 보다 온도 상승)는 빨간색, 음수(전날보다 온도 하락)는 파란색으로 막대 그래프를 그려보겠습니다. aes(fill=구분자 변수) 함수를 사용하고, 색깔지정은 scale_fill_manual(values=c(색깔1, 색깔2)) 로 지정해주면 됩니다. # 양수는 빨간색, 음수는 파란색으로 막대 색 구분 ggplot(data=May_Temp_Diff.df, aes(x=May_Day, y=May_Temp_Diff, fill=plus_minus)) + geom_bar(stat=&quot;identity&quot;, position=&quot;identity&quot;, colour=&quot;white&quot;, width=0.2) + # width 막대 폭 좁게 scale_fill_manual(values=c(&quot;blue&quot;, &quot;red&quot;), guide=FALSE) + # guide=F 범례 생략 ggtitle(&quot;1st order differenced Temp of May&quot;) 막대 폭이 너무 가늘어서 보기 싫다면, 막대 폭을 좀더 넓히고 싶다면 geom_bar(width=숫자) 함수를 사용하면 됩니다. # width 막대 폭 넓게 ggplot(data=May_Temp_Diff.df, aes(x=May_Day, y=May_Temp_Diff, fill=plus_minus)) + geom_bar(stat=&quot;identity&quot;, position=&quot;identity&quot;, colour=&quot;white&quot;, width=1) + # width 막대 폭 넓게 scale_fill_manual(values=c(&quot;blue&quot;, &quot;red&quot;), guide=FALSE) + # guide=F 범례 생략 ggtitle(&quot;1st order differenced Temp of May&quot;) 다음으로, 위의 그래프에서 보면 ggplot2 가 알아서 x축을 10, 20, 30으로 해서 10일 간격으로 설정해서 그래프를 그렸는데요, 이를 좀더 세분화하고 싶다면 scale_x_continuous(breaks=c(숫자, 숫자...)) 로 지정해주면 됩니다. # x축 세분화 ggplot(data=May_Temp_Diff.df, aes(x=May_Day, y=May_Temp_Diff, fill=plus_minus)) + geom_bar(stat=&quot;identity&quot;, position=&quot;identity&quot;, colour=&quot;white&quot;, width=0.5) + scale_fill_manual(values=c(&quot;blue&quot;, &quot;red&quot;), guide=FALSE) + ggtitle(&quot;1st order differenced Temp of May&quot;) + scale_x_continuous(breaks=c(5, 10, 15, 20, 25, 30)) # x축 세분화 마지막으로, x축과 y축의 라벨 이름이 위에 보면 변수명이 그래도 들어가 있는데요, 좀더 이해하기 쉽도록 xlab(), ylab() 함수를 추가하여 x축, y축 라벨을 변경해보도록 하겠습니다. # modification of x label, y label ggplot(data=May_Temp_Diff.df, aes(x=May_Day, y=May_Temp_Diff, fill=plus_minus)) + geom_bar(stat=&quot;identity&quot;, position=&quot;identity&quot;, colour=&quot;white&quot;, width=0.5) + scale_fill_manual(values=c(&quot;blue&quot;, &quot;red&quot;), guide=FALSE) + ggtitle(&quot;1st order differenced Temp of May&quot;) + scale_x_continuous(breaks=c(5, 10, 15, 20, 25, 30)) + xlab(&quot;Day of May, 1973&quot;) + ylab(&quot;Temp difference from previous day&quot;) 다음번 포스팅에서는 원그림(Pie Chart)를 알아보겠습니다. "],["r-ggplot2-원그림geom-bar-coord-polar.html", "8.2 R ggplot2 원그림(geom_bar() + coord_polar())", " 8.2 R ggplot2 원그림(geom_bar() + coord_polar()) 변수의 개수 및 데이터의 형태에 따라서 그래프, 시각화 방법이 달라지는데요, 이번 포스팅에서는 범주형 데이터의 시각화 방법으로서 막대그림(Bar Chart): geom_bar() 원그림(Pie Chart): geom_bar() + coord_polar()** 모자이크 그림(Mosaic Chart): vcd 패키지 mosaic() 에 대해서 소개해드리겠습니다. [ 변수 개수 및 데이터 형태에 따른 그래프 ] 데이터는 MASS 패키지에 들어있는 Cars93 데이터 프레임의 차종(Type)과 제조국(Origin) 데이터를 활용해서 차종별 제조국별 도수를 구한 후에, 원그림을 그려보겠습니다. 원그림은 세로로 쌓아올린(stacked) 막대그림을 먼저 geom_bar()로 먼저 그린 후에 ==&gt;coord_polar(\"y\")로 해서 표현 형식을 원형(polar coordinates)으로 바꾸어 주는 절차를 따릅니다. (절차 1) 바로 아래에 있는 그래프가 누적 막대그림 (stacked bar chart) 이구요, ## 원그림(Pie Chart) library(ggplot2) library(MASS) # 막대그림 먼저 그린 후 =&gt; 원그림 library(sqldf) Car_Type_Origin_cnt &lt;- sqldf( &#39;select Type, Origin, count(*) as Type_Origin_cnt from Cars93 group by Type, Origin order by Type, Origin &#39;) Car_Type_Origin_cnt ## Type Origin Type_Origin_cnt ## 1 Compact USA 7 ## 2 Compact non-USA 9 ## 3 Large USA 11 ## 4 Midsize USA 10 ## 5 Midsize non-USA 12 ## 6 Small USA 7 ## 7 Small non-USA 14 ## 8 Sporty USA 8 ## 9 Sporty non-USA 6 ## 10 Van USA 5 ## 11 Van non-USA 4 sapply(Car_Type_Origin_cnt, class) ## Type Origin Type_Origin_cnt ## &quot;factor&quot; &quot;factor&quot; &quot;integer&quot; ggplot(data=Car_Type_Origin_cnt, aes(x=&quot;&quot;, y=Type_Origin_cnt, fill=Type)) + facet_grid(facets=. ~ Origin) + geom_bar(stat=&quot;identity&quot;, width=1) + ggtitle(&quot;Bar Chart of Frequency by Car Type &amp; Origin&quot;) (절차 2) 그 다음 표현형식을 coord_polar(\"y\") 를 써서 원형으로 바꾸어 본 것이 아래 script 가 되겠습니다. # 원그림(Pie Chart) : geom_bar() + coord_ploar(theta=&quot;y&quot;) ggplot(data=Car_Type_Origin_cnt, aes(x=&quot;&quot;, y=Type_Origin_cnt, fill=Type)) + facet_grid(facets=. ~ Origin) + geom_bar(stat=&quot;identity&quot;, width=1) + coord_polar(theta=&quot;y&quot;) + ggtitle(&quot;Pie Chart of Car Type by Origin, theta=y&quot;) 이번 포스팅에서 원그림(Pie Chart)를 소개하기는 했습니다만, 저는 원그림은 그다지 추천하지 않습니다. 일단 눈으로 보고 해석하기에, 범주간 비교하기에 그다지 용이하지가 않습니다. 파이 조각의 면적을 눈으로 가늠해서 비교하기가 쉽지 않거든요. 막대그림으로 높이를 비교하는 것이 범주 간 차이를 단박에 보여주는 것과 비교하면 원그림은 그래프를 봐야하는 이에게는 불친절한 그래프입니다. (단, 두 집단(가령 USA, non-USA) 간에 과반을 넘는 특정 segment를 비교해서 강조하고 싶은 경우는 원그림이 효과적일 수 있음) 신문이나 잡지에서 보면 원그림을 많이 사용하고 있고, 더 나아가서는 입체 원그림을 그리고, 또 나아가서는 입체 원그림의 한 조각을 확대하거나 원그림을 살짝 눕히기도 하는데요, 이건 정말 최악 중의 최악입니다. 일단, 시각적으로 해석하기에 어렵구요, 더 나아가서는 악의를 가지고 시각의 불완전성을 이용해서 정보를 왜곡/오도하기 위한 것일 수도 있으니 주의가 필요합니다. 웬만하면 원그림은 사용하지 말기를 권하며, 누가 원그림 사용하거든 그만 사용하라고 권해주기를 권합니다. 그냥 쉽고 편한 막대그림 사용하세요. 참고용으로, 막대그림으로 나타내면 아래와 같은데요, 위의 원그림과 비교해보시기 바랍니다. 뭐가 더 쉽고 해석하기 편한지요. # 막대그림 ggplot(data=Car_Type_Origin_cnt, aes(x=Type, y=Type_Origin_cnt)) + facet_grid(facets=. ~ Origin) + geom_bar(stat=&quot;identity&quot;, width=1, fill=&quot;white&quot;, colour=&quot;black&quot;) + ggtitle(&quot;Bar Chart of Frequency by Car Type &amp; Origin&quot;) 원그림 소개한다고 해놓고는, 막대그림으로 끝을 맺네요. ^^’ "],["다변량-범주형-데이터.html", "9 다변량 - 범주형 데이터 ", " 9 다변량 - 범주형 데이터 "],["r-모자이크-그림-vcd패키지-mosaic-함수.html", "9.1 R 모자이크 그림: vcd패키지 mosaic() 함수", " 9.1 R 모자이크 그림: vcd패키지 mosaic() 함수 변수의 개수 및 데이터의 형태에 따라서 그래프, 시각화 방법이 달라지는데요, 지난번 포스팅에서는 연속형 데이터의 시각화 방법으로 히스토그램(Histogram) : geom_histogram() 널 밀도 곡선(Kernel Density Curve) : geom_density() 박스 그래프(Box Plot) : geom_boxplot() 바이올린 그래프(Violin Plot) : geom_violin() 에 대해서 알아보았습니다. 이번 포스팅에서는 범주형 데이터의 시각화 방법으로서 막대그림(Bar Chart): geom_bar() 원그림(Pie Chart): geom_bar() + coord_polar() 모자이크 그림(Mosaic Chart): vcd 패키지 mosaic() 에 대해서 소개해드리겠습니다. [ 변수 개수 및 데이터 형태에 따른 그래프 ] 모자이크 그림(Mosaic Chart)은 Marimekko chart, Eikosogram 이라고도 하는데요, 특히 2개 이상의 다변량 변수를 한꺼번에 그림으로 나타내어 탐색적 분석을 할 때 아주 유용합니다. 모자이크 그림은 vcd 패키지의 mosaic() 함수를 이용하겠으며, 데이터는 MASS 패키지의 cars93데이터 프레임 내에 있는 차종(Type), 제조국(Origin), DriveTrain(Rear, Front, 4WD) 의 3개 변수를 모자이크 그림으로 표현해 보겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... (절차 1) vcd 패키지 설치, 호출 후에 차종(Type)과 제조국(Origin) 2개의 변수를 가지고, 세로 방향(direction=\"v\") 으로 모자이크 그림을 그려보겠습니다. table() 함수를 써서 분할표를 먼저 만들고, 이걸 가져다가 모자이크 그림을 그리게 됩니다. # vcd package installation # install.packages(&quot;vcd&quot;) library(vcd) # 모자이크 그림 : 차종(Type) &amp; 제조국(Origin) # 세로 방향 table_1 &lt;- with(Cars93, table(Type, Origin)) table_1 ## Origin ## Type USA non-USA ## Compact 7 9 ## Large 11 0 ## Midsize 10 12 ## Small 7 14 ## Sporty 8 6 ## Van 5 4 mosaic(table_1, gp=gpar(fill=c(&quot;yellow&quot;, &quot;blue&quot;)), direction=&quot;v&quot;, # 세로 main=&quot;Mosaic Chart by Car Type and Origin, using vcd package&quot;) (절차 2) 차종(Type)과 제조국(Origin) 2개의 변수를 가지고, 모자이크 그림을 가로 방향 (direction=“h”) 으로 그리면 아래와 같습니다. Origin이 y축에 있던 것이 x축으로 바뀌었습니다. # 가로 방향 mosaic(table_1, gp=gpar(fill=c(&quot;yellow&quot;, &quot;blue&quot;)), direction=&quot;h&quot;, # 가로 main=&quot;Mosaic Chart by Car Type and Origin, direction=horizontal&quot;) (절차 3) 이번에는 변수를 하나 더 추가해서 차종(Type), 제조국(Origin), DriveTrain 의 3개의 변수를 가지고 모자이크 그림을 그려보겠습니다. 먼저 table()함수를 써서 3개 변수에 대한 분할표를 만들고, 이를 가져다가 모자이크 그림을 그리게 됩니다. # 모자이크 그림 : 차종(Type) &amp; 제조국(Origin) &amp; DriveTrain(Rear, Front, 4WD) # 세로 방향 # 3개 변수별 범주 확인 levels(Cars93$Type) ## [1] &quot;Compact&quot; &quot;Large&quot; &quot;Midsize&quot; &quot;Small&quot; &quot;Sporty&quot; &quot;Van&quot; levels(Cars93$Origin) ## [1] &quot;USA&quot; &quot;non-USA&quot; levels(Cars93$DriveTrain) ## [1] &quot;4WD&quot; &quot;Front&quot; &quot;Rear&quot; table_2 &lt;- with(Cars93, table(Type, Origin, DriveTrain)) table_2 ## , , DriveTrain = 4WD ## ## Origin ## Type USA non-USA ## Compact 0 1 ## Large 0 0 ## Midsize 0 0 ## Small 0 2 ## Sporty 2 0 ## Van 3 2 ## ## , , DriveTrain = Front ## ## Origin ## Type USA non-USA ## Compact 7 6 ## Large 7 0 ## Midsize 9 8 ## Small 7 12 ## Sporty 2 5 ## Van 2 2 ## ## , , DriveTrain = Rear ## ## Origin ## Type USA non-USA ## Compact 0 2 ## Large 4 0 ## Midsize 1 4 ## Small 0 0 ## Sporty 4 1 ## Van 0 0 mosaic(table_2, gp=gpar(fill=c(&quot;yellow&quot;, &quot;blue&quot;, &quot;red&quot;)), direction=&quot;v&quot;, main=&quot;Mosaic Chart by Car Type, Origin and DriveTrain, direction=v&quot;) 마지막으로, 모자이크 그림에 비율 라벨(Mosaic Chart with Percentage Label)을 추가해보겠습니다. # 비율 라벨 추가 (Mosaic Chart with Percentage Labels) table_1 &lt;- with(Cars93, table(Type, Origin)) proportions &lt;- round(prop.table(table_1)*100, 1) # 백분율, 소수점 첫째자리 반올림 proportions ## Origin ## Type USA non-USA ## Compact 7.5 9.7 ## Large 11.8 0.0 ## Midsize 10.8 12.9 ## Small 7.5 15.1 ## Sporty 8.6 6.5 ## Van 5.4 4.3 values &lt;- c(table_1) rowvarcat &lt;- c(&quot;USA&quot;,&quot;non_USA&quot;) columnvarcat &lt;- c(&quot;Compact&quot;,&quot;Large&quot;, &quot;Midsize&quot;, &quot;Small&quot;, &quot;Sporty&quot;, &quot;Van&quot;) names=c(&quot;Origin&quot;, &quot;Type&quot;) dims &lt;- c(2,6) TABS &lt;- structure( c(values), .Dim = as.integer(dims), .Dimnames = structure( list(rowvarcat, columnvarcat ), .Names = c(names) ) , class = &quot;table&quot;) PROPORTIONS &lt;- structure( c(proportions), .Dim = as.integer(dims), .Dimnames = structure( list(rowvarcat,columnvarcat ), .Names = c(names) ) , class = &quot;table&quot;) TABSPROPORTIONS &lt;- structure( c(paste(proportions,&quot;%&quot;,&quot;\\n&quot;, &quot;(&quot;,values,&quot;)&quot;,sep=&quot;&quot;)), .Dim = as.integer(dims), .Dimnames = structure( list(rowvarcat,columnvarcat ), .Names = c(names) ) , class = &quot;table&quot;) mosaic(TABS, pop=FALSE, main=&quot;Mosaic Chart by Car Type and Origin, with Percentage Labels&quot;) labeling_cells(text=TABSPROPORTIONS, clip_cells=FALSE)(TABS) Michael Friendly’s book “Visualizing Categorical Data” 예제 참고 "],["다변량-변수-연속형-데이터.html", "10 다변량 변수 - 연속형 데이터 ", " 10 다변량 변수 - 연속형 데이터 "],["r-ggplot2-산포도scatter-plot-geom-point.html", "10.1 R ggplot2 산포도(Scatter Plot) (geom_point())", " 10.1 R ggplot2 산포도(Scatter Plot) (geom_point()) 이번에는 두 개 이상의 연속형 변수를 시각화하는 방법으로 산포도 (Scatter Plot): geom_point() 선 그래프(Line Plot): geom_line() 시계열 그래프(Time Series Plot): geom_line() 에 대해서 알아보겠습니다. 참고로  ggplot2의 geom_point() 산포도 그리기  Base Graphics 패키지의 pairs() 함수를 사용한 산포도 행렬 그리기 [ 변수 개수 및 형태에 따른 그래프 종류 ] 산포도(Scatter Plot)는 x축과 y축에 연속형인 두 변수의 값을 점으로 뿌려준 그래프로서, 연속형인 두 변수 간의 관계를 파악하는데 유용합니다. 다중회귀분석을 할 때 제일 처음 하는 일이 바로 산포도 (행렬)을 그려보고 두 변수간의 선형성 여부를 탐색해보는 일입니다. MASS패키지 내 Cars93 데이터 프레임의 고속도로연비(MPG.highway)와 엔진크기(EngineSize), 무게(Weight), 길이(Length) 와의 관계를 ggplot2 패키지의 geom_point() 함수를 가지고 산포도를 그려서 알아보도록 하겠습니다. 그리고 차종(Type)별로 고속도로연비(MPG.highway) 는 어떻게 되는지도 산포도를 가지고 점의 색깔과 모양을 달리해서 보는 방법을 알아보겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 상관계수를 가지고 고속도로연비(MPG.highway)와 엔진크기(EngineSize), 무게(Weight), 길이(Length)와의 상관도를 먼저 살펴보면, 고속도로연비와 엔진크기, 무게, 길이가 모두 역의 상관관계가 있는 걸로 나왔고, 특히 무게가 역의 상관관계가 크게 나왔습니다. Cars93_MPG &lt;- Cars93[,c(&quot;MPG.highway&quot;, &quot;EngineSize&quot;, &quot;Weight&quot;, &quot;Length&quot;)] cor(Cars93_MPG) ## MPG.highway EngineSize Weight Length ## MPG.highway 1.00 -0.63 -0.81 -0.54 ## EngineSize -0.63 1.00 0.85 0.78 ## Weight -0.81 0.85 1.00 0.81 ## Length -0.54 0.78 0.81 1.00 이제 산포도를 그려서 고속도로연비(MPG.highway)와 엔진크기(EngineSize), 무게(Weight), 길이(Length) 관계를 살펴보겠습니다. Cars93_MPG &lt;- Cars93[,c(&quot;MPG.highway&quot;, &quot;EngineSize&quot;, &quot;Weight&quot;, &quot;Length&quot;)] cor(Cars93_MPG) ## MPG.highway EngineSize Weight Length ## MPG.highway 1.00 -0.63 -0.81 -0.54 ## EngineSize -0.63 1.00 0.85 0.78 ## Weight -0.81 0.85 1.00 0.81 ## Length -0.54 0.78 0.81 1.00 제일 쉬운 방법은 Base graphics 패키지에 있는 plot()함수를 사용하는 방법입니다. 위에서 분석하려는 변수만 따로 선별해놓은 Cars93_MPG 데이터 프레임을 가지고 한번 산포도 행렬을 그려보겠습니다. plot(Cars93_MPG, main=&quot;Scatter Plot Matrix&quot;) ggplot2로는 산포도 행렬(Scatter Plot matrix)를 그리는 것이 힘듭니다. 대신 여러 조건을 주어서 두 변수 간 산포도 행렬을 다양하게 그려보는데는 아주 강력합니다 우선 ggplot2의 geom_point()함수를 가지고 색깔(colour)과 모양(shape)을 달리하면서 산포도를 그려보겠습니다. # Scatter Plot: MPG.highway vs. EngineSize, Weight, Length library(ggplot2) ggplot(data=Cars93, aes(x=EngineSize, y=MPG.highway)) + geom_point(shape=15, size=3, colour=&quot;blue&quot;) + # shape 15: solid square ggtitle(&quot;Scatter Plot: MPG.highway vs. EngineSize&quot;) ggplot(data=Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=19, size=3, colour=&quot;red&quot;) + # shape 19: solid circle ggtitle(&quot;Scatter Plot: MPG.highway vs. Weight&quot;) ggplot(data=Cars93, aes(x=Length, y=MPG.highway)) + geom_point(shape=24, size=3, colour=&quot;black&quot;) + # shape 24: filled triangle point-up ggtitle(&quot;Scatter Plot: MPG.highway vs. Length&quot;) 참고로, R plot의 숫자별 모양은 다음과 같습니다. # R plot symbols: points help(pch) ## starting httpd help server ... done 이번에는 두 변수의 산포도에 모델명 라벨을 geom_text(label=) 함수를 이용하여 입혀보겠습니다. # Scatter Plot with Label (Model Name) ggplot(data=Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=19, size=3, colour=&quot;red&quot;) + # shape 19: solid circle ggtitle(&quot;Scatter Plot: MPG.highway vs. Weight with Model Label&quot;) + geom_text(aes(label=Model, size=2, vjust=-1, hjust=0)) # vjust=-1 위로, hjust=1 오른쪽 다음으로 차종(Type)별로 구분하여서 무게(Weight)와 고속도로연비(MPG.highway) 간의 관계를 3가지 방법을 사용하여 산포도로 그려보도록 하겠습니다. 차종(Type)별로 색깔(colour)을 달리해서 차종(Type)별로 모양(shape)을 달리해서 차종(Type)별로 층(facet_grid)을 나누어서 산포도를 그려보겠습니다. 차종(Type)별로 색깔(colour)을 달리했을 때 # Scatter Plot by Type, using different Colours ggplot(data=Cars93, aes(x=Weight, y=MPG.highway, colour=Type)) + geom_point(shape=19, size=3) + ggtitle(&quot;Scatter Plot by Type, using different Colours&quot;) 차종(Type)별로 모양(shape)을 달리했을 때 # Scatter Plot by Type, differenct Shapes ggplot(data=Cars93, aes(x=Weight, y=MPG.highway, shape=Type)) + geom_point(size=3) + ggtitle(&quot;Scatter Plot by Type, differenct Shapes&quot;) 차종(Type)별로 층(facet_grid)을 나누어서 산포도를 그릴 때 # Scatter Plot by Type, using facet_grid ggplot(data=Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(size=3, shape=19) + facet_grid(Type ~.) + ggtitle(&quot;Scatter Plot by Type, using facet_grid&quot;) 다음으로, 산포도에 선형 회귀선 (신뢰구간 95%)을 적합시켜보겠습니다. # Scatter Plot with linear regression line ggplot(data=Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=19, size=3, colour=&quot;red&quot;) + # shape 19: solid circle stat_smooth(method=lm, level=0.95) + ggtitle(&quot;Scatter Plot: Linear Regression Line with Confidence Level 95%&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; 아래는 산포도에 회귀선을 적합시켰는데, 위와는 다르게 신뢰구간은 뺀 경우입니다. ggplot(data=Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=19, size=3, colour=&quot;red&quot;) + # shape 19: solid circle stat_smooth(method=lm, se=FALSE) + ggtitle(&quot;Scatter Plot: Linear Regression Line without Confidence Level&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; 산포도에 선을 적합시킬 때 선형회귀선말고도 loess(locally weighted polynomial) 를 써서 비모수 회귀(Nonparametric regression) 선을 적합시킬 수도 있습니다. # Scatter Plot with loess(locally weighted polynomial) ggplot(data=Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=19, size=3, colour=&quot;red&quot;) + # shape 19: solid circle stat_smooth(method=loess, level=0.95) + ggtitle(&quot;Scatter Plot: loess Line with Confidence Level 95%&quot;) ## `geom_smooth()` using formula &#39;y ~ x&#39; "],["r-ggplot2-버블-그래프-bubble-chart-geom-point-scale-size-area.html", "10.2 R ggplot2 버블 그래프 (Bubble Chart) : geom_point(), scale_size_area()", " 10.2 R ggplot2 버블 그래프 (Bubble Chart) : geom_point(), scale_size_area() 이전 포스팅에서 x축과 y축의 값에 따라산포도 그리는 방법을 알아보았다면, 이번 포스팅에서는 여기에 더해서 z라는 제 3의 변수에 비례해서 점의 크기를 변화시켜서 그린 그래프가 버블 그래프 (Bubble Chart) 입니다. 산포도가 2차원의 그래프(단, 색깔이나 모양 조건을 추가하면 3차원 정보 제공 가능)라면, 버블 그래프 (Bubble Chart)는 3차원의 그래프가 되어 지면에 보다 많은 정보량을 제공할 수 있는 장점이 있습니다. ggplot2에서는 산포도, 점 그래프를 그리는 **geom_point() 함수와 함께 scale_size_area() 함수**를 같이 사용하면 버블 그래프 (Bubble Chart)를 그릴 수가 있습니다. MASS 패키지의 Cars93 데이터 프레임 내에 차 모델명(Model), 차종(Type), 무게(Weight), 고속도로연비(MPG.highway), 가격(Price)의 5개 변수를 사용하여 버블 그래프를 그려보겠습니다. 데이터가 너무 많으면 버블 그래프를 그릴 때 겹쳐 보여서 보기 싫으므로 차종(Type)에서 “compact”와 “large”의 두 종만 선별해서 예를 들어보겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... levels(Cars93$Type) ## [1] &quot;Compact&quot; &quot;Large&quot; &quot;Midsize&quot; &quot;Small&quot; &quot;Sporty&quot; &quot;Van&quot; table(Cars93$Type) ## ## Compact Large Midsize Small Sporty Van ## 16 11 22 21 14 9 # dataset selection Cars93_sample &lt;- subset(Cars93, select = c(&quot;Model&quot;, &quot;Type&quot;, &quot;Weight&quot;, &quot;MPG.highway&quot;, &quot;Price&quot;), subset = (Type %in% c(&quot;Compact&quot;, &quot;Large&quot;))) Cars93_sample ## Model Type Weight MPG.highway Price ## 3 90 Compact 3375 26 29 ## 7 LeSabre Large 3470 28 21 ## 8 Roadmaster Large 4105 25 24 ## 10 DeVille Large 3620 25 35 ## 12 Cavalier Compact 2490 36 13 ## 13 Corsica Compact 2785 34 11 ## 18 Caprice Large 3910 26 19 ## 20 Concorde Large 3515 28 18 ## 21 LeBaron Compact 3085 28 16 ## 22 Imperial Large 3570 26 30 ## 25 Spirit Compact 2970 27 13 ## 30 Vision Large 3490 28 19 ## 33 Tempo Compact 2690 27 11 ## 38 Crown_Victoria Large 3950 26 21 ## 43 Accord Compact 3040 31 18 ## 52 Town_Car Large 4055 26 36 ## 55 626 Compact 2970 34 16 ## 58 190E Compact 2920 29 32 ## 65 Altima Compact 3050 30 16 ## 68 Achieva Compact 2910 31 14 ## 71 Eighty-Eight Large 3470 28 21 ## 74 Sunbird Compact 2575 31 11 ## 77 Bonneville Large 3495 28 24 ## 78 900 Compact 2775 26 29 ## 82 Legacy Compact 3085 30 20 ## 90 Passat Compact 2985 30 20 ## 92 240 Compact 2985 28 23 ggplot2의 geom_point()와 scale_size_area() 함수를 사용하여 버블 그래프 (bubble chart)를 그려보겠습니다. ggplot2는 별도의 설치와 호출이 필요한 패키지이므로 아래와 같이 install.packages()와 library()로 설치 및 호출을 먼저 해야 합니다. # install.packages(&quot;ggplot2&quot;) library(ggplot2) x축에는 무게(Weight)를, y축에는 고속도로연비(MPG.highway)를, 원의 크기는 가격(Price)를 설정하였습니다. 그리고 겹치는 부분이 있어서 alpha=0.5 로 해서 반투명하게 하였습니다. scale_size_area 에서 원의 크기의 최대값(max)을 15개 한정을 지었으며, geom_text() 함수를 활용해 vjust=1로 해서 x축 값에 align되고 y값은 MPG.highway값에 살짝 조정을 가해서 label로는 모델명(Model) 변수값을 가져다가 라벨링을 하였습니다. # Bubble chart with scale_size_area and label ggplot(Cars93_sample, aes(x=Weight, y=MPG.highway)) + geom_point(aes(size=Price), shape=21, colour=&quot;grey90&quot;, fill=&quot;yellow&quot;, , alpha=0.5) + scale_size_area(max_size = 15) + # 범례 없애려면 guide=FALSE geom_text(aes(y=as.numeric(MPG.highway)-sqrt(Price)/10, label=Model), vjust=1, colour=&quot;grey40&quot;, size=3) + ggtitle(&quot;Bubble chart with scale_size_area and label&quot;) 많은 도움이 되었기를 바랍니다. 10.2.1 R ggplot2 집단간 비교를 위한 면 분할(facet, Trellis) : facet_grid(), facet_wrap() 그룹(집단, 요인) 간의 데이터 분포 형태, 변화 추이 등을 비교 분석하기에 유용한 방법으로 비교하려는 축을 기준으로 면을 분할하여 그래프를 그룹 간 비교하는 방법이 있습니다. Lattice 패키지에서는 Trellis 를 사용하는데요, ggplot2 패키지에서는 facet_grid() 함수와 **facet_wrap() 함수**를 사용하여 면 분할을 구현할 수 있습니다. Base Graphics 패키지에서는 par() 함수를 사용해서 면 분할을 지정해줄 수 있습니다만, x축과 y축의 scale이 들쭉날쭉해서 직접적으로 서로 비교하기가 곤란하거나, y축의 min, max 값이 그룹 간 숫자를 모두 감안해서 자동 설정되는 것이 아니다보니 분석가가 미리 y축 값의 범위를 계산해보고, 혹은 그려보고 나서 y축 값을 세팅해줘야 하므로 lattice나 ggplot2 대비 불편합니다. 따라서 집단간 비교를 위한 면 분할이 필요한 경우 ggplot2나 lattice 패키지를 권합니다. MASS 패키지 내 무게(Weight), 고속도로연비(MPG.highway), 차종(Type, 범주형), 생산국가(Origin, 범주형) 의 4개 변수를 사용해서, x축에 무게(Weight), y축에 고속도로연비(MPG.highway), 그리고 면 분할의 기준으로 범주형 변수인 차종(Type)과 생산국가(Origin) 변수를 사용하겠습니다. facet_grid()를 먼저 예제를 보이고, 그 후에 facet_wrap()의 예제를 들겠습니다. 두 함수가 비슷하면서도 조금 다릅니다. 분석가가 필요로 하는 아웃풋 이미지에 맞게 골라서 사용하면 되겠습니다. 10.2.1.1 facet_grid() # facet_grid() ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;) + facet_grid(Type ~ .) ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;) + facet_grid(. ~ Type) ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;) + facet_grid(Origin ~ Type) 10.2.1.2 facet_wrap() facet_wrap() 함수는 ncol 또는 nrow 로 행 또는 열의 개수를 분석가가 지정할 수 있어서 좋은 점이 있습니다. # facet_wrap() ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;) + facet_wrap( ~ Type, ncol=3) ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;) + facet_wrap(Origin ~ Type, ncol=3) ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;) + facet_wrap(Origin ~ Type, ncol=2) 10.2.1.3 R ggplot2 분할 면에 각각 주석 넣기 : geom_text() 이전 포스팅에서 하나의 그래프에 텍스트, 선, 화살표, 음영있는 사각형 등으로 부연 설명을 추가하기 위해 annotate() 함수로 주석을 추가하는 방법을 소개하였습니다. 이번에는 facet_grid() 로 특정 범주형 변수에 의해 요인(factor)별로 면 분할된 그래프에 각각 주석을 넣는 넣기 위해 geom_text() 함수를 사용하는 방법에 대해 알아보겠습니다. 예제로 사용할 데이터는 iris 데이터프레임 내 Petal.Width, Petal.Length, Species 의 3개 변수를 사용하겠습니다. str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ggplot2는 별도의 설치 및 호출이 필요한 패키지이므로 아래의 절차를 먼저 따르기 바랍니다. # install.packages(&quot;ggplot2&quot;) library(ggplot2) 먼저, 지난번 포스팅에서 소개드렸던, 하나의 화면에 품종별로 색깔을 구분해서 그리고, annotate() 함수를 사용해서 텍스트 주석(text annotation) 하는 방법을 아래에 복습해 보겠습니다. # 하나의 화면에 품종별로 색깔 구분해서 그리기 : aes(fill=categorical var) a1 &lt;- ggplot(iris, aes(x=Petal.Width, y=Petal.Length, fill=Species)) + geom_point(colour=&quot;grey&quot;, shape=21, size=6) + scale_fill_brewer(palette=&quot;Reds&quot;) + annotate(&quot;text&quot;, x=0.25, y=2.4, label=&quot;Setosa&quot;, size=7) + # text annotation annotate(&quot;text&quot;, x=1.3, y=3.3, label=&quot;Versicolor&quot;, size=7) + annotate(&quot;text&quot;, x=1.7, y=6.8, label=&quot;Virginica&quot;, size=7) a1 이걸 품종(Species)을 기준으로 면 분할 (facet_grid(.~Species)) 하면 아래와 같습니다. 이번 포스팅에서는 아래 처럼 면 분할 된 상태의 그래프에 주석 추가하는 방법입니다. # 품종별로 면 분할하여 색깔 구분없이 그리기 : facet_grid(.~categorical var) g1 &lt;- ggplot(iris, aes(x=Petal.Width, y=Petal.Length)) + geom_point(colour=&quot;blue&quot;, shape=19, size=4) + facet_grid(.~Species) g1 범주형 변수의 요인(factor)별로 면 분할된 상태의 그래프에 텍스트 주석을 넣으려고 아래와 같이 하면 라벨 길이가 다르다면서 에러가 납니다. # 텍스트 라벨 넣으려면 에러 발생 # Error: Incompatible lengths for set aesthetics: label g1 + annotate(&quot;text&quot;, x=1, y=7, label=c(&quot;Setosa&quot;, &quot;Versicolor&quot;, &quot;Virginica&quot;)) ## Error: Aesthetics must be either length 1 or the same as the data (9): label 범주형 변수의 요인(factor)별로 면 분할된 상태의 그래프에 텍스트 주석을 넣으려고 하려면 annotate() 함수로는 안되구요, 라벨을 넣으려는 내용을 데이터프레임으로 미리 만들어놓고 geom_text()로 라벨을 집어넣어야 합니다. 아래 예제는 Species 이름을 각 각 텍스트로 넣어보는 예입니다. # 분할 면마다 각각 텍스트 주석 넣기 : geom_text() # dataframe of label iris_species_labels &lt;- data.frame(Species = c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;), label = c(&quot;Species=Setosa&quot;, &quot;Species=Versicolor&quot;, &quot;Species=Virginica&quot;)) g2 &lt;- g1 + geom_text(x=1, y=6.5, aes(label=label), data=iris_species_labels) g2 다음으로 각 품종(Species)별로 x축 Petal.Width와 y축 Petal.Length 평균을 구해서 중심 좌표 (centroid)를 텍스트로 주석을 추가해보겠습니다. 먼저, sqldf 패키지를 새로 설치해서 x축 Petal.Width와 y축 Petal.Length 평균을 구해보겠습니다. # install.packages(&quot;sqldf&quot;) library(sqldf) mean_iris &lt;- sqldf(&#39;select &quot;Species&quot;, avg(&quot;Petal.Width&quot;) as &quot;mean_Petal.Width&quot;, avg(&quot;Petal.Length&quot;) as &quot;mean_Petal.Length&quot; from iris group by Species order by Species&#39;) mean_iris ## Species mean_Petal.Width mean_Petal.Length ## 1 setosa 0.25 1.5 ## 2 versicolor 1.33 4.3 ## 3 virginica 2.03 5.6 label_mean_iris &lt;- transform(mean_iris, centroid=paste(c(&quot;centroid(&quot;), round(mean_Petal.Width, 2), c(&quot;, &quot;), round(mean_Petal.Length, 2), c(&quot;)&quot;), sep=&quot;&quot;)) label_mean_iris ## Species mean_Petal.Width mean_Petal.Length centroid ## 1 setosa 0.25 1.5 centroid(0.25, 1.46) ## 2 versicolor 1.33 4.3 centroid(1.33, 4.26) ## 3 virginica 2.03 5.6 centroid(2.03, 5.55) 다음으로 centroid 정보를 그래프에 분할된 면에 따라 각각 추가해보겠습니다. # x, y 평균 좌표 추가 : geom_text() g3 &lt;- g2 + geom_text(x=1, y=6, aes(label=centroid), data=label_mean_iris) g3 10.2.2 R ggplot2 x축, y축 설정 : coord_fixed(), scale_x_continuous(), scale_y_continuous() ggplot2 그래프를 그렸을 때 x축이나 y축의 디폴트 값을 사용해도 무리가 없는 경우가 많기는 합니다만, 분석가가 x축이나 y축을 좀더 사용하는 목적에 맞게 설정을 조정하고 싶을 때가 있습니다. 이때 사용할 수 있는 ggplot2의 함수 3가지를 알아보도록 하겠습니다. (1) 1:1 의 비율로 x축과 y축 설정 : coord_fixed() (2) 일정한 간격으로 x축, y축 설정 : scale_x_continuous(breaks=seq()) (3) 분석가 마음대로 x축, y축 설정 : scale_x_continuous(breaks=c()) 예제로 사용할 데이터는 MASS 패키지에 내장되어 있는 Cars93 데이터 프레임의 도시연비(MPG.city), 고속도로연비(MPG.highway)가 되겠습니다. scale이 연비로서 서로 같은 변수를 선택하였으며, 산포도를 그려보면서 x축, y축 설정을 바꿔보도록 하겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... ggplot2는 신규 설치 및 호출이 필요한 패키지이므로 아래와 같은 사전 절차가 필요합니다. # ggplot2 설치 및 호출 # install.packages(&quot;ggplot2&quot;) library(ggplot2) 순서대로 하나씩 살펴보겠습니다. 함수 옵션을 바꿔줌에 따라서 x축, y축 결과가 어떻게 바뀌는지 살펴보시고, 필요로 하는 함수 옵션을 선택해서 사용하시면 되겠습니다. 10.2.2.1 Default setting # default setting of x and y axis ggplot(Cars93, aes(x=MPG.city, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;, size=3) + ggtitle(&quot;default setting of x and y axis&quot;) 10.2.2.2 1:1 의 비율로 x축과 y축 설정 : coord_fixed() # 1:1 proportion of x and y axis : coord_fixed() ggplot(Cars93, aes(x=MPG.city, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;, size=3) + coord_fixed() + ggtitle(&quot;1:1 proportion of x and y axis : coord_fixed()&quot;) 10.2.2.3 일정한 간격으로 x축과 y축 설정 : scale_x_continuous(breaks=seq()) # manual setting with fixed interval of x and y axis : scale_x_continuous(breaks=seq()) ggplot(Cars93, aes(x=MPG.city, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;, size=3) + coord_fixed() + scale_x_continuous(breaks=seq(0, 80, 5)) + scale_y_continuous(breaks=seq(0, 80, 5)) + ggtitle(&quot;manual setting with fixed interval of x and y axis : scale_x_continuous(breaks=seq())&quot;) 10.2.2.4 분석가 마음대로 x축과 y축 설정 : scale_x_continuous(breaks=c()) # manual setting of x and y axis : scale_x_continuous(breaks=c()) ggplot(Cars93, aes(x=MPG.city, y=MPG.highway)) + geom_point(shape=21, colour=&quot;black&quot;, size=3) + coord_fixed() + scale_x_continuous(breaks=c(10, 15, 20, 25, 30, 40)) + scale_y_continuous(breaks=c(20, 25, 30, 40, 50)) + ggtitle(&quot;manual setting of x and y axis : scale_x_continuous(breaks=c())&quot;) 함수 옵션을 바꿔줌에 따라서 x축, y축 결과가 어떻게 바뀌는지 살펴보시고, 필요로 하는 함수 옵션을 선택해서 사용하시면 되겠습니다. 10.2.3 R ggplot2 그래프 색깔 설정 (colour setting) 이번 포스팅에서는 R ggplot2에서 그래프 색깔 설정 (colour setting), 조절하는 방법에 대해서 알아보겠습니다. 이전의 각 그래프 종류별로 소개한 내용에도 색깔 지정에 대한 내용이 조금씩 포함되어 있기는 합니다만, 이번 포스팅에서는 색깔 설정에 대한 경우의 수를 종합적으로 포괄해서 정리를 해보았습니다. 그래프에서 색깔을 특정 변수의 변화와 align하게 되면 x축과 y축의 2차원에 색깔이라는 차원을 추가함으로써 3차원의 정보를 제공할 수 있습니다. 회사 업무 보고서에 엑셀로 그린 그래프를 많이 사용하고는 하는데요, x축과 y축의 2차원을 넘어서는, 특정 조건에 따라서 색깔이나 모양을 달리해야 하는 경우라면 엑셀로 그래프를 그리는 것이 거의 불가능하게 됩니다. 이때 R이 데이터 전처리/변환부터 해서 인쇄용으로 바로 사용해도 좋을 만큼의 고품질의 그래프를 그리는데 아주 특출난 역할을 할 수 있습니다. R 그래프에서 색깔을 자유자재로 사용할 수 있다면 미적으로도 보기에 좋겠지요?! 이번 예제에서 사용할 데이터는 MASS 패키지에 내장되어 있는 Cars93 데이터 프레임의 차 무게(Weight)와 고속도로연비(MPG.highway), 차 가격(Price), 실린더 개수(Cylinders)의 4개 변수를 사용하겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... ggplot2 패키지는 별도의 설치 및 호출이 필요하므로 아래의 절차를 먼저 시행합니다. # install.packages(&quot;ggplot2&quot;) # 설치 library(ggplot2) 색상 변화를 잘 살펴볼 수 있도록 속이 빈 동그라미 모양인 shape=21 번의 도형을 사용해서 size=6 으로 큼지막하게 키워서 예를 들어보겠습니다. 10.2.3.1 색깔 설정을 별도로 하지 않은 경우 디폴트 테두리 검정색 (default colour) # default colour ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6) 10.2.3.2 테두리 선 색깔 지정 (colour : line colour setting) # 테두리 선 색깔 지정 (colour : line colour setting) ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6, colour=&quot;blue&quot;) 10.2.3.3 도형의 속 채우기 색깔 지정 (fill : innner colour fill-up) # 도형의 속 채우기 색깔 (fill : inner colour fill-up) ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6, fill=&quot;blue&quot;) 10.2.3.4 연속형 변수의 숫자에 따른 색깔 조절 : aes(fill=continuous variable) # 연속형 변수의 숫자에 따른 색깔 조절 # (fill : colour change aligned with continuous numeric variable) ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Price)) + geom_point(colour=&quot;grey&quot;, shape=21, size=6) 10.2.3.5 범주형 변수의 범주/요인(factor)에 따른 색깔 조절 : aes(fill=categorical variable) # 범주형 변수의 범주/요인(factor) 따른 색깔 조절 # (fill : colour change aligned with categorical variable) ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Cylinders)) + geom_point(colour=&quot;grey&quot;, shape=21, size=6) 10.2.3.6 Palette = Oranges 색 설정 (pallet colour setting) : scale_fill_brewer() palette 설정은 범주형 데이터 (categorical data)에만 해당됩니다. # Palette = Oranges 색 설정 (palette colour setting) : scale_fill_brewer() ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Cylinders)) + geom_point(colour=&quot;grey&quot;, shape=21, size=6) + scale_fill_brewer(palette=&quot;Oranges&quot;) # Oranges 10.2.3.7 Palette = Reds 색 설정 (pallet colour setting) : scale_fill_brewer() # Palette = Reds 색 설정 (palette colour setting) : scale_fill_brewer() ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Cylinders)) + geom_point(colour=&quot;grey&quot;, shape=21, size=6) + scale_fill_brewer(palette=&quot;Reds&quot;) # Reds 10.2.3.8 Palette = Blues 색 설정 (pallet colour setting) : scale_fill_brewer() # Palette = Blues 색 설정 (palette colour setting) : scale_fill_brewer() ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Cylinders)) + geom_point(colour=&quot;grey&quot;, shape=21, size=6) + scale_fill_brewer(palette=&quot;Blues&quot;) # Blues 10.2.4 R ggplot2 텍스트(text), 선(line), 화살표(arrow), 음영사각형(shadowed box), 제목(title) 주석달기 : annotate() R로 그래프를 그렸다면, 보는 이의 가독성, 해석의 용이성을 높여주기 위해서 그래프 위에 텍스트, 가로선/세로선/대각선, 화살표, 음영 사각형, 제목 등과 같이 추가로 정보를 제공하거나 강조를 하고 싶은 부분에 주석을 달고 싶을 때가 있습니다. 텍스트 : annotate(\"text\") 가로선/세로선/대각선 : geom_vline(), geom_hline(), geom_abline() 화살표 : annotate(\"segment\", arrow=arrow()) , with grid package 음영 사각형 : annotate(\"rect\") 제목 : ggtitle() 매번의 R 그래프/시각화 포스팅마다 주석 다는 방법을 간간이 곁들여서 소개해드리기는 했는데요, 이번 포스팅에서는 주석 다는 방법에 대해서 포괄적이고 종합적으로 정리를 해서 바로 찾아보기 편하도록 정리를 해보았습니다. 예제로 사용할 데이터는 Base Package에 내장되어 있는 iris 데이터 프레임의 Petal.Width, Petal.Length, Species의 세개 변수를 사용하겠습니다. (iris 데이터셋은 데이터 마이닝 실습에 아주 많이 사용되는 데이터셋으로서, iris 꽃 품종 중 setosa 50개, versicolor 50개, virginica50개를 꽃잎의 넓이와 길이를 측정해놓은 데이터셋입니다) str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ggplot2는 별도의 설치 및 호출이 필요한 패키지이므로 아래의 절차를 먼저 실행하시기 바랍니다. # install.packages(&quot;ggplot2&quot;) library(ggplot2) "],["산포도-꾸미지.html", "10.3 산포도 꾸미지", " 10.3 산포도 꾸미지 iris의 Petal.Width를 x축으로, Petal.Length를 y축으로 하고, 품종(Species)에 따라서 색깔을 달리해서 산포도(scatter plot)을 그려보겠습니다. # scatter plot of iris dataset a1 &lt;- ggplot(iris, aes(x=Petal.Width, y=Petal.Length, fill=Species)) + geom_point(colour=&quot;grey&quot;, shape=21, size=6) + scale_fill_brewer(palette=&quot;Reds&quot;) a1 10.3.1 텍스트(text) 추가 : annotate(\"text\") # 텍스트(text) 추가 : annotate(&quot;text&quot;) a2 &lt;- a1 + annotate(&quot;text&quot;, x=0.25, y=2.4, label=&quot;Setosa&quot;, size=7) + # text annotation annotate(&quot;text&quot;, x=1.3, y=3.3, label=&quot;Versicolor&quot;, size=7) + annotate(&quot;text&quot;, x=1.7, y=6.8, label=&quot;Virginica&quot;, size=7) a2 10.3.2 선(line) 추가 : geom_vline(), geom_hline(), geom_abline() # 선(line) 추가 : geom_vline(), geom_hline(), geom_abline() a3 &lt;- a2 + geom_hline(yintercept=2.6, colour=&quot;grey&quot;, lty=&quot;dashed&quot;, size=1) + # horizontal line geom_hline(yintercept=4.9, colour=&quot;grey&quot;, lty=&quot;dashed&quot;, size=1) + geom_vline(xintercept=0.8, colour=&quot;grey&quot;, lty=&quot;dashed&quot;, size=1) + # vertical line geom_vline(xintercept=1.75, colour=&quot;grey&quot;, lty=&quot;dashed&quot;, size=1) + geom_abline(intercept=8, slope=-2.1, colour=&quot;red&quot;, lty=&quot;dotted&quot;, size=1.5) # abline a3 10.3.3 화살표(arrow) 추가 : annotate(\"segment\") 단, grid 패키지를 호출해서 사용해야 합니다. # 화살표(arrow) 추가 : annotate(&quot;segment&quot;) library(grid) # grid 패키지 호출 a4 &lt;- a3 + annotate(&quot;segment&quot;, x=2, xend=2.1, y=2, yend=3.5, size=1.5, colour=&quot;red&quot;, arrow=arrow()) a4 # 텍스트 추가 : annotate(&quot;text&quot;) a5 &lt;- a4 + annotate(&quot;text&quot;, x=2, y=1.8, size=6, colour=&quot;red&quot;, label=&quot;y=8 - 2.1x&quot;) a5 10.3.4 음영 사각형(shadowed box) 추가 : annotate(\"rect\") # 음영 사각형(shadowed box) 추가 : annotate(&quot;rect&quot;) a6 &lt;- a5 + annotate(&quot;rect&quot;, xmin=0, xmax=0.8, ymin=0, ymax=2.6, alpha=0.1, fill=&quot;red&quot;) + annotate(&quot;rect&quot;, xmin=0.8, xmax=1.75, ymin=2.6, ymax=4.9, alpha=0.2, fill=&quot;red&quot;) + annotate(&quot;rect&quot;, xmin=1.3, xmax=2.7, ymin=4.3, ymax=7.2, alpha=0.3, fill=&quot;red&quot;) a6 10.3.5 제목(title) 추가 : ggtitle() # 제목 추가 : ggtitle() a7 &lt;- a6 + ggtitle(&quot;Annotation of Text, Line, Arrow, Shadowed Box, Title&quot;) a7 "],["r-ggpolt2-선그래프-시계열그래프-line-graph-geom-line.html", "10.4 R ggpolt2 선그래프, 시계열그래프 (Line Graph) (geom_line())", " 10.4 R ggpolt2 선그래프, 시계열그래프 (Line Graph) (geom_line()) 변수의 개수 및 데이터의 형태에 따라서 그래프, 시각화 방법이 달라지는데요, 지난번 포스팅에서는 한 변수의 연속형 데이터의 시각화 방법으로 히스토그램(Histogram) : geom_histogram() 커널 밀도 곡선(Kernel Density Curve) : geom_density() 박스 그래프(Box Plot) : geom_boxplot() 바이올린 그래프(Violin Plot) : geom_violin() 범주형 데이터에 대한 시각화 방법으로 막대그림(Bar Chart): geom_bar() 원그림(Pie Chart): geom_bar() + coord_polar() 모자이크 그림(Mosaic Chart): vcd 패키지 mosaic() 등에 대하여 알아보았습니다. 이번에는 두 개 이상의 연속형 변수를 시각화하는 방법으로 산포도 (Scatter Plot): geom_point() 선 그래프(Line Plot): geom_line() 시계열 그래프(Time Series Plot): geom_line() 에 대해서 알아보겠습니다. [ 변수 개수 및 형태에 따른 그래프 종류 ] 선 그래프(Line Graph)는 x축의 연속형 변수(또는 (순서나 크기가 있는 이산형 변수, ordered factor)의 변화에 따른 y축의 변화를 선으로 이어서 보여주는 그래프입니다. x축이 시간의 순서이면 시계열 그래프(Time Series Graph) 이구요. 10.4.1 데이터 세트 Base패키지에 들어있는 airquality 데이터 프레임을 가지고 시계열 그래프를 그려보도록 하겠습니다. airquality 데이터 프레임은 1973년 5월부터 9월달까지 뉴욕의 공기의 Ozone, Solar, Wind, Temp를 Daily 로 측정한 데이터 셋입니다. 결측값이 없는 Wind와 Temp를 가지고 시계열 그래프를 그려보겠습니다. str(airquality) ## &#39;data.frame&#39;: 153 obs. of 6 variables: ## $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... ## $ Solar.R: int 190 118 149 313 NA NA 299 99 19 194 ... ## $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... ## $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... ## $ Month : int 5 5 5 5 5 5 5 5 5 5 ... ## $ Day : int 1 2 3 4 5 6 7 8 9 10 ... head(airquality) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 # 결측값 여부 확인 sum(is.na(airquality$Ozone)) ## [1] 37 sum(is.na(airquality$Solar.R)) ## [1] 7 sum(is.na(airquality$Wind)) ## [1] 0 10.4.2 시계열 변수 생성하기 보기에 좋도록 Month 변수와 Day 변수를 합쳐서 Time이라는 새로운 변수를 만들어보겠습니다. # Time 변수 생성 airquality &lt;- transform(airquality, Month.ch_temp = as.character(Month), Day.ch_temp = as.character(Day)) airquality &lt;- transform(airquality, Month.ch = paste(&quot;0&quot;, Month.ch_temp, sep=&quot;&quot;), Day.ch = ifelse(Day.ch_temp == &quot;1&quot;, &quot;01&quot;, ifelse(Day.ch_temp == &quot;2&quot;, &quot;02&quot;, ifelse(Day.ch_temp == &quot;3&quot;, &quot;03&quot;, ifelse(Day.ch_temp == &quot;4&quot;, &quot;04&quot;, ifelse(Day.ch_temp == &quot;5&quot;, &quot;05&quot;, ifelse(Day.ch_temp == &quot;6&quot;, &quot;06&quot;, ifelse(Day.ch_temp == &quot;7&quot;, &quot;07&quot;, ifelse(Day.ch_temp == &quot;8&quot;, &quot;08&quot;, ifelse(Day.ch_temp == &quot;9&quot;, &quot;09&quot;, Day)))))))))) airquality &lt;- transform(airquality, Time = paste(Month.ch, Day.ch, sep=&quot;&quot;)) airquality_May &lt;- airquality[c(1:31), c(1:6, 11)] head(airquality_May) ## Ozone Solar.R Wind Temp Month Day Time ## 1 41 190 7.4 67 5 1 0501 ## 2 36 118 8.0 72 5 2 0502 ## 3 12 149 12.6 74 5 3 0503 ## 4 18 313 11.5 62 5 4 0504 ## 5 NA NA 14.3 56 5 5 0505 ## 6 28 NA 14.9 66 5 6 0506 10.4.3 group 지정 선그래프를 그릴 때 group 지정을 안해주면 아래처럼 경고메시지가 뜨고, 선그래프가 텅 비게 나옵니다. * 경고메시지: geom_path: Each group consist of only one observation. Do you need to adjust the group aesthetic? # 선그래프 library(ggplot2) # warning: geom_path: Each group consist of only one observation. Do you need to adjust the group aesthetic? ggplot(airquality_May, aes(x=Time, y=Wind)) + geom_line() + ggtitle(&quot;Line Graph, Wind from May.01 to May.31&quot;) ## geom_path: Each group consists of only one observation. Do you need to adjust ## the group aesthetic? 이 문제를 해결하기 위해 group = 1 을 지정해줍니다. # group=1 ggplot(airquality_May, aes(x=Time, y=Wind, group=1)) + geom_line() + ggtitle(&quot;Time Series Graph, Wind from May.01 to May.31&quot;) ggplot(airquality_May, aes(x=Time, y=Temp, group=1)) + geom_line() + ggtitle(&quot;Time Series Graph, Temp from May.01 to May.31&quot;) 10.4.4 ylim() 정하기 위의 두 개의 시계열 그래프를 보면 y축을 ggplot2가 자동으로 계산해서 적정 범위를 설정해주었습니다만, 경우에 따라서는 사용자가 강제로 특정 범위를 설정해주고 싶을 때가 있습니다. 아래는 ylim()을 이용해서 0~max(y) 값 까지 y축 범위를 설정한 예시입니다. # y축 범위 설정 0~max ggplot(airquality_May, aes(x=Time, y=Temp, group=1)) + geom_line() + ylim(0, max(airquality_May$Temp)) + ggtitle(&quot;Time Series Graph, Temp from May.01 to May.31, y axis from 0 to max&quot;) 10.4.5 선 모형 바꾸기 선그래프의 선 모양도 바꿔보고 싶고, 점도 덮입혀 보고 싶다면 아래 예제를 참고하세요. # 점선으로 변경, 점 추가 ggplot(airquality_May, aes(x=Time, y=Temp, group=1)) + geom_line(linetype=&quot;dotted&quot;, size=1, colour=&quot;blue&quot;) + geom_point(size=3, shape=19, colour=&quot;blue&quot;) + ggtitle(&quot;Time Series Graph, Temp from May.01 to May.31, with dotted line, dot&quot;) 참고로 R Line Type과 Shape 은 아래와 같습니다. [ R Line Type ] [ R Symbol Shape ] 다음은 aes() 내 group과 colour 를 사용하여 그룹별로 선그래프, 시계열그래프 그리는 방법입니다. # 집단별 시계열 그래프 : 월별(5월~9월) Temp 시계열 그래프 ggplot(data=airquality, aes(x=Day, y=Temp, colour=Month, group=Month)) + geom_line() + geom_point(size=3) + ggtitle(&quot;Time Seires Graph, Temp from May to Sep.&quot;) "],["r-ggplot2-이차원-밀도-그래프2d-density-plot-stat-density2d.html", "10.5 R ggplot2 이차원 밀도 그래프(2D Density Plot) (stat_density2d())", " 10.5 R ggplot2 이차원 밀도 그래프(2D Density Plot) (stat_density2d()) 2개의 연속형 변수를 가지고 그릴 수 있는 그래프 중에 이차원 밀도 그래프 (2D Density Plot) 을 ggplot2의 stat_density2d() 함수를 이용하여 그려보겠습니다. 이차원 밀도 그래프 (2D Density Plot)은 2D 커널 밀도 추정치를 구해서 같은 추정치를 선으로 연결한 그래프 입니다. 우리가 일상 생활 중에 자주 쉽게 접하는 이차원 밀도 그래프의 예로는 지도의 등고선이나 일기예보할 때 쓰는 등압선이 있습니다. [ 기상청 등압선 얘시 ] * 출처: 기상청, http://www.kma.go.kr/weather/images/analysischart.jsp 10.5.1 데이터 세트 이번에 R로 예를 들 데이터는 뉴욕의 기상을 1973년 5월부터 9월까지 매일 측정한 airquality 데이터 프레임에서 5월달과 7월달 두 달의 Wind, Temp를 사용하겠습니다. (airquality는 시계열 데이터이고, 이전 포스팅에서 airquality 데이터 프레임을 사용하여 ggplot2로 시계열 그래프 그래프 그리는 법을 설명하였으니 참고하시기 바랍니다) 먼저, airquality의 데이터 구조를 살펴보고, 5월달과 7월달 데이터만 선별해서 새로운 데이터 프레임을 만들어보겠습니다. # airquality 구조 str(airquality) ## &#39;data.frame&#39;: 153 obs. of 11 variables: ## $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... ## $ Solar.R : int 190 118 149 313 NA NA 299 99 19 194 ... ## $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... ## $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... ## $ Month : int 5 5 5 5 5 5 5 5 5 5 ... ## $ Day : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Month.ch_temp: chr &quot;5&quot; &quot;5&quot; &quot;5&quot; &quot;5&quot; ... ## $ Day.ch_temp : chr &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Month.ch : chr &quot;05&quot; &quot;05&quot; &quot;05&quot; &quot;05&quot; ... ## $ Day.ch : chr &quot;01&quot; &quot;02&quot; &quot;03&quot; &quot;04&quot; ... ## $ Time : chr &quot;0501&quot; &quot;0502&quot; &quot;0503&quot; &quot;0504&quot; ... # 5월과 7월만 선택 airquality_May_July &lt;- subset(airquality, select = c(Month, Day, Wind, Temp), subset = (Month %in% c(5, 7))) head(airquality_May_July) ## Month Day Wind Temp ## 1 5 1 7.4 67 ## 2 5 2 8.0 72 ## 3 5 3 12.6 74 ## 4 5 4 11.5 62 ## 5 5 5 14.3 56 ## 6 5 6 14.9 66 tail(airquality_May_July) ## Month Day Wind Temp ## 87 7 26 8.6 82 ## 88 7 27 12.0 86 ## 89 7 28 7.4 88 ## 90 7 29 7.4 86 ## 91 7 30 7.4 83 ## 92 7 31 9.2 81 이제 이차원 밀도 그래프 (2D Density Plot)을 그려보겠습니다. 그리고 5월과 7월달의 Month를 색깔로 구분하여 보겠습니다. 10.5.2 aes()에 범주형 변수 지정하기 이때 조심해야 할 것이 있습니다. aes() 에 shape이나 colour 에는 범주형 변수(factor)가 들어가야 합니다. 만약 연속형 변수가 들어가면 “Error: A continuous variable can not be mapped to shape” 라는 에러 메시지가 뜹니다. # 2차원 밀도 그래프 : 모양과 색깔로 구분 # 연속형 변수라서 error ggplot(data=airquality_May_July, aes(x=Wind, y=Temp, shape=Month)) + geom_point() + stat_density2d() + ggtitle(&quot;2D desity plot of Wind and Tmep, at May and July&quot;) ## Error: A continuous variable can not be mapped to shape Month를 Month.ch라는 새로운 문자형 변수로 변환해, 이를 사용해서 이차원 밀도 그래프를 Month별로 모양과 색깔을 구분해서 그려보겠습니다. # Month를 문자형 변수로 변환 airquality_May_July &lt;- transform(airquality_May_July, Month.ch = as.character(Month)) sapply(airquality_May_July, class) ## Month Day Wind Temp Month.ch ## &quot;integer&quot; &quot;integer&quot; &quot;numeric&quot; &quot;integer&quot; &quot;character&quot; head(airquality_May_July) ## Month Day Wind Temp Month.ch ## 1 5 1 7.4 67 5 ## 2 5 2 8.0 72 5 ## 3 5 3 12.6 74 5 ## 4 5 4 11.5 62 5 ## 5 5 5 14.3 56 5 ## 6 5 6 14.9 66 5 10.5.3 커널 밀도 추정치 계산 stat_density2d() 함수로 커널 밀도 추정치를 계산해서 2차원 밀도 그래프를 그리면, # 2차원 밀도 그래프 : Month를 모양으로 구분 ggplot(data=airquality_May_July, aes(x=Wind, y=Temp, shape=Month.ch)) + geom_point(size=4) + stat_density2d() + ggtitle(&quot;2D desity plot of Wind and Tmep, May/July by Shape&quot;) 10.5.4 라벨 추가 이번에는 (범례가 있기는 합니다만) 사용자의 가독성을 조금 더 높여주기 위해 2차원 밀도 그래프의 5월, 7월 두 집단의 중앙 부위에 “년/월”을 annotate()의 “text”로 라벨을 추가해 보겠습니다. # 2차원 밀도 그래프 : Month를 색깔로 구분, 년/월 라벨 추가 ggplot(data=airquality_May_July, aes(x=Wind, y=Temp, colour=Month.ch)) + geom_point(size=4) + stat_density2d() + ggtitle(&quot;2D desity plot of Wind and Tmep, at1973. May/July by Colour&quot;) + annotate(&quot;text&quot;, x=11, y=65, label=&quot;May, 1973&quot;, alpha=0.5) + annotate(&quot;text&quot;, x=9, y= 83, label=&quot;July, 1973&quot;, alpha=0.5) 10.5.5 등고선 효과 추가하기 그림이 조금 재미가 없네요… 등고선에 그래디언트 효과를 줘서 히트맵 형태로 표현을 해 보겠습니다. stat_density2d() 함수 내에 aes() 함수를 이용하여 등고선 효과를 추가합니다. 그리고, scale_fill_gradient() 함수와 scale_alpha() 함수도 추가해 줍니다. # 2차원 밀도 그래프 : Month를 색깔로 구분, 년/월 라벨 추가 ggplot(data=airquality_May_July, aes(x=Wind, y=Temp, colour=Month.ch)) + geom_point(size=4) + stat_density2d(aes( fill = ..level.., alpha = ..level..), size = 0.01, bins = 20, # 등고선 간격 조절 geom = &quot;polygon&quot;) + scale_fill_gradient(low = &quot;green&quot;, high = &quot;red&quot;) + scale_alpha(range = c(0, 0.5), guide = FALSE) + ggtitle(&quot;2D desity plot of Wind and Tmep, at1973. May/July by Colour&quot;) + annotate(&quot;text&quot;, x=11, y=65, label=&quot;May, 1973&quot;, alpha=1.5, color = &quot;blue&quot;) + annotate(&quot;text&quot;, x=9, y= 83, label=&quot;July, 1973&quot;, alpha=1.5, color = &quot;blue&quot;) 그래도 뭔가 불만이 있네요.. 등고선을 없애고 부드럽게 표현해 보겠습니다. ggplot() 함수 내의 colour = Month.ch을 제거하고 다시 한번 더 그려보지요… # 2차원 밀도 그래프 : Month를 색깔로 구분, 년/월 라벨 추가 ggplot(data=airquality_May_July, aes(x=Wind, y=Temp)) + geom_point(size=4) + stat_density2d( aes(fill = ..level.., alpha = ..level..), size = 0.01, bins = 20, # 등고선 간격 조절 geom = &quot;polygon&quot;) + scale_fill_gradient(low = &quot;green&quot;, high = &quot;red&quot;) + scale_alpha(range = c(0, 0.5), guide = FALSE) + ggtitle(&quot;2D desity plot of Wind and Tmep, at1973. May/July by Colour&quot;) + annotate(&quot;text&quot;, x=11, y=65, label=&quot;May, 1973&quot;, alpha=1.5, color = &quot;blue&quot;) + annotate(&quot;text&quot;, x=9, y= 83, label=&quot;July, 1973&quot;, alpha=1.5, color = &quot;blue&quot;) 참고로 aes() 함수 내의 bins는 등고선 간의 간격 갯수라고 이해하면 좋겠습니다. 간격의 갯수가 많아질수록 등고선의 간격이 좁아지겠지요…. bins의 값을 5, 10, 15, 20, 25, 30 등으로 수정하면서 다시 그려보기 바랍니다. 10.5.6 면 분할하기 한번 더 해 보지요… 이번에는 앞에서 제거한 Month.ch 변수를 facet_wrap() 함수 안에 추가해서 그림을 다시 그려보겠습니다. 그러면 5월과 7월의 지도가 따로 그려지겠지요… # 2차원 밀도 그래프 : Month를 색깔로 구분, 년/월 라벨 추가 ggplot(data=airquality_May_July, aes(x=Wind, y=Temp)) + # geom_point(size=4) + stat_density2d( aes(fill = ..level.., alpha = ..level..), size = 0.01, bins = 20, # 등고선 간격 조절 geom = &quot;polygon&quot;) + scale_fill_gradient(low = &quot;green&quot;, high = &quot;red&quot;) + scale_alpha(range = c(0, 0.5), guide = FALSE) + ggtitle(&quot;2D desity plot of Wind and Tmep, at1973. May/July by Colour&quot;) + annotate(&quot;text&quot;, x=11, y=65, label=&quot;May, 1973&quot;, alpha=1.5, color = &quot;blue&quot;) + annotate(&quot;text&quot;, x=9, y= 83, label=&quot;July, 1973&quot;, alpha=1.5, color = &quot;blue&quot;) + facet_wrap(vars(Month.ch)) "],["r-ggplot2-클리브랜드-점-그래프cleveland-dot-plot-geom-point.html", "10.6 R ggplot2 클리브랜드 점 그래프(Cleveland dot plot) (geom_point())", " 10.6 R ggplot2 클리브랜드 점 그래프(Cleveland dot plot) (geom_point()) 예전 포스팅 중에서 일변량 연속형 변수에 대해 ggplot2로 막대 그래프 그리는 법을 소개했었는데요, 막대 그래프의 훌륭한 대안으로서 점 그래프(Dot Plot)이 있습니다. Cleveland and McGill (1984) 이 “Graphical Methods for Data Presentation: Full Scale Breaks, Dot Charts, and Multibased Logging.” 이라는 논문에서 막대 그래프 대비 점 그래프가 데이터 해석, 가독성에서 가지는 우수성을 소개하면서 Cleveland Dot Plot 이라고도 많이 불리는 그래프입니다. 10.6.1 데이터 세트 분석에 활용할 데이터는 MASS 패키지 내 Cars93 데이터 프레임에서, 차종(Type), 모델(Model), Max.Price, Min.Price의 4개 변수를 사용하겠으며, 관측치 개수가 많아서 화면 하나에 전부 뿌리기에는 너무 많으므로 차종(Type)의 Level 중에서 “Large,” “Midsize,” “Small” 만 선별하고 “Compact,” “Sproty,” “Van”은 제외하도록 하겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... table(Cars93$Type) ## ## Compact Large Midsize Small Sporty Van ## 16 11 22 21 14 9 # Model, Type, Max.Price, Min.Price 변수만 선택 # Type 중에서 Large, Midsize, Small만 선택 (Compact, Sortry, Van은 제외) Cars93_P &lt;- subset(Cars93, select = c(Model, Type, Min.Price, Max.Price), subset = (Type %in% c(&quot;Large&quot;, &quot;Midsize&quot;, &quot;Small&quot;))) str(Cars93_P) ## &#39;data.frame&#39;: 54 obs. of 4 variables: ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 1 6 24 54 74 73 35 79 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 3 3 3 2 2 3 2 3 ... ## $ Min.Price: num 12.9 29.2 30.8 23.7 14.2 19.9 22.6 26.3 33 37.5 ... ## $ Max.Price: num 18.8 38.7 44.6 36.2 17.3 21.7 24.9 26.3 36.3 42.7 ... head(Cars93_P) ## Model Type Min.Price Max.Price ## 1 Integra Small 13 19 ## 2 Legend Midsize 29 39 ## 4 100 Midsize 31 45 ## 5 535i Midsize 24 36 ## 6 Century Midsize 14 17 ## 7 LeSabre Large 20 22 10.6.2 클리브랜드 점 그래프 그리기 geom_point() 함수를 사용하여 클리브랜드 점 그래프(Cleveland dot plot)을 그려보겠습니다. aes(y = reorder(Model, Max.Price)) 를 사용해서 y축에 사용할 Model 을 Max.Price 를 기준으로 정렬을 하였기 때문에 아래처럼 Max.Price가 높은 것부터 낮은 것으로 정렬이 된 채로 점 그래프가 제시되었습니다. aes(shape = Type) 을 적용하여서 Type(Large, Midsize, Small) 별로 모양(shape)을 달리해서 제시하였습니다. # Cleveland dot plot of Max Price of Models with different shape by Type library(ggplot2) ggplot(Cars93_P, aes(x = Max.Price, y = reorder(Model, Max.Price), shape = Type)) + geom_point(size = 3, colour = &quot;blue&quot;) + theme_bw() + # background 색 없애기 theme(panel.grid.major.x = element_blank(), # x축 선 없애기 panel.grid.minor.x = element_blank(), panel.grid.major.y = element_line(colour=&quot;grey90&quot;, linetype=&quot;dashed&quot;)) + ggtitle(&quot;Cleveland dot plot of Max.Price of Models with different shape by Type&quot;) 10.6.3 면 분할하기 다음으로, Type(Large, Midsize, Small) 별로 facet_grid(Type ~ ., scales=\"free_y\", space=\"free_y\") 을 적용하여 면을 분할을 한 클리브랜드 점 그래프(Cleveland dot plot)을 그려보겠습니다. 면 분할해서 그리려면 위의 예처럼 ggplot2 내 aes(reorder)로는 안되구요, 먼저 Type과 Max.Price 순서대로 데이터셋을 따로 정렬해서 요인(factor)으로 levels 를 지정해서 변환해주어야 합니다. 그래프는 상대적으로 쉬운데, 데이터셋 정렬/요인변환이 어려울 수 있겠습니다. # Type, Max.Price 순서대로 정렬 Model_Order &lt;- Cars93_P$Model[order(Cars93_P$Type, # Large, Midsize, Small 순서 -Cars93_P$Max.Price, # 높은것에서 낮은 순서 decreasing=TRUE)] # Model_Order를 요인(factor)으로 변환 Cars93_P$Model &lt;- factor(Cars93_P$Model, levels=Model_Order) # Type별로 면 분할, Max.Price 순서대로 정렬된 Cleveland dot plot ggplot(Cars93_P, aes(x = Max.Price, y = Model)) + geom_point(size = 3, aes(colour = Type)) + theme_bw() + theme(panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank()) + facet_grid(Type ~ ., scales=&quot;free_y&quot;, space=&quot;free_y&quot;) + ggtitle(&quot;Cleveland dot plot of Max.Price of Models with Facets of Type&quot;) 10.6.4 변수의 추가와 모양 변경하기 다음으로, 차종(Type)별로 면 분할은 유지하면서 위의 Max.Price 에 더해서 Min.Price 를 추가하고 모양(shape)을 다르게 제시해보겠습니다. 이것도 데이터 셋을 따로 미리 손을 봐줘야 합니다. reshape 패키지의 melt() 함수를 사용해서 Max.Price, Min.Price 두 값을 Price_cd (Max.Price, Min.Price)와 Price (value) 의 두개 변수로 녹여서 데이터 구조를 ggplot2의 geom_point()에 사용할 수 있도록 변경하여야 합니다. (reshape 패키지의 melt(), cast() 함수는 여기서 자세히 설명하기가 힘든데요, 따로 알아보시면 좋겠습니다) #-------- # Min.Price 추가 # melt # install.packages(&quot;reshape&quot;) library(reshape) Cars93_P_melt &lt;- melt(Cars93_P, idvars = c(&quot;Type&quot;, &quot;Model&quot;)) ## Using Model, Type as id variables head(Cars93_P_melt) ## Model Type variable value ## 1 Integra Small Min.Price 13 ## 2 Legend Midsize Min.Price 29 ## 3 100 Midsize Min.Price 31 ## 4 535i Midsize Min.Price 24 ## 5 Century Midsize Min.Price 14 ## 6 LeSabre Large Min.Price 20 # 변수명 변경 Cars93_P_melt &lt;- rename(Cars93_P_melt, c(variable = &quot;Price_cd&quot;, value = &quot;Price&quot;)) head(Cars93_P_melt) ## Model Type Price_cd Price ## 1 Integra Small Min.Price 13 ## 2 Legend Midsize Min.Price 29 ## 3 100 Midsize Min.Price 31 ## 4 535i Midsize Min.Price 24 ## 5 Century Midsize Min.Price 14 ## 6 LeSabre Large Min.Price 20 # Type별로 면 분할, Max.Price 순서대로 정렬, Min.Price추가된 Cleveland dot plot ggplot(Cars93_P_melt, aes(x = Price, y = Model)) + geom_segment(aes(yend=Model, xend=0)) + # 점까지만 선 그리기 geom_point(size=3, aes(shape = Price_cd)) + # Price_cd로 모양 구분 theme_bw() + # backgroud 색 없애기 theme(panel.grid.major.y = element_blank(), # y축 없애기 panel.grid.minor.y = element_blank()) + # y축 없애기 facet_grid(Type ~ ., scales=&quot;free_y&quot;, space=&quot;free_y&quot;) + # Type별로 면 분할 ggtitle(&quot;Cleveland dot plot of Max, Min Price of Models with Facets of Type&quot;) 위의 세번째 그래프처럼 Max.Price와 Min.Price를 같은 그래프에 그리는데, 만약 이것을 막대 그래프로 그린다고 상상해 보세요. 막대그래프로 그린다면 지저분하고 해석, 가독성이 클리브랜드 점 그래프 대비 떨어질겁니다. [Reference] Cleveland, William S. 1984. “Graphical Methods for Data Presentation: Full Scale Breaks, Dot Charts, and Multibased Logging.” The American Statistician, 38:270-280. Dot Plots: A Useful Alternative to Bar Charts, Naomi B. Robbins, Ph.D. March 7, 2006 "],["r-ggplot2-누적-영역-그래프-stacked-area-plot-geom-area.html", "10.7 R ggplot2 누적 영역 그래프 (Stacked Area Plot) (geom_area())", " 10.7 R ggplot2 누적 영역 그래프 (Stacked Area Plot) (geom_area()) 시간의 흐름에 따른 그룹/집단 별 관측값 혹은 비율의 변화를 누적해서 볼 수 있는 그래프가 누적 영역 그래프 (Stacked Area Plot) 입니다. 아마 엑셀에서 많이 보았을 법한 그래프일 것이라고 생각합니다. 2007년부터 2014년까지의 한국 수/출입 무역량 (단위: 1 B$) 데이터를 가지고 수출과 수입으로 구분하여서 ggplot2의 geom_area() 함수를 사용하여 누적 영역 그래프(Stacked Area Plot) 를 그려보도록 하겠습니다. 아래는 2007년부터 2014년까지의 한국 수/출입 무역량 (단위: 1 B$) 데이터를 링크해두었습니다. 10.7.1 데이터 전처리 ( 한국 수/출입 무역량 데이터 다운로드 trade_stat_07_14.csv) * 출처 : 국가무역통계 KOSIS, http://kosis.kr/statisticsList/statisticsList_01List.jsp?vwcd=MT_ZTITLE&amp;parmTabId=M_01_01#SubCont) 그래프를 그리기에 딱 맞는 형식이 아니므로 csv 데이터를 불러들인 다음에 -&gt; sqldf 패키지를 활용해 Year 단위로 수출입 실적을 집계 -&gt; 이때 단위를 1000$ -&gt; 1B$ 로 바꿔주기 위해 1,000,000 으로 나눠줌 을 써 데이터를 필요에 맞게 집계해보겠습니다. trade_stat &lt;- read.csv(&quot;data/trade_stat_07_14.csv&quot;, # 경로 설정 header = TRUE) trade_stat &lt;- transform(trade_stat, Year = substr(Time, 1, 4)) sapply(trade_stat, class) ## Time export_amt import_amt Year ## &quot;numeric&quot; &quot;integer&quot; &quot;integer&quot; &quot;character&quot; # install.packages(&quot;sqldf&quot;) library(sqldf) # 한국 수/출입 무역금액, 단위: 1B$ trade_stat_Year &lt;- sqldf(&#39;select Year, sum(export_amt)/100000 as exp_amt_Year, sum(import_amt)/100000 as imp_amt_Year from trade_stat group by Year order by Year &#39;) trade_stat_Year ## Year exp_amt_Year imp_amt_Year ## 1 2007 3714 3568 ## 2 2008 4220 4352 ## 3 2009 3635 3230 ## 4 2010 4663 4252 ## 5 2011 5552 5244 ## 6 2012 5478 5195 ## 7 2013 5596 5155 ## 8 2014 5726 5255 여기까지 했는데도 누적 영역 그래프를 그리기에 딱 맞는 데이터 형태가 아니라서 reshape 패키지의 melt() 함수를 사용하여 데이터를 현재의 가로로 늘어져있는 exp_amt_Year, imp_amt_Year 변수를 -&gt; 세로로 세워서 데이터 구조를 변경해보겠습니다. (wide form의 테이블을 long form의 테이블로 변환) 그 다음에 variable -&gt; trade_cd (수입, 수출 구분 코드), value -&gt; amount_B (무역금액, 단위 : 1B$) 로 변수명을 변경하였습니다. # 데이터 구조 녹이기(melt) - 세로로 세우기 (Long Form) library(reshape) trade_stat_Year_melt &lt;- melt(trade_stat_Year, idvars = c(&quot;Year&quot;)) ## Using Year as id variables trade_stat_Year_melt ## Year variable value ## 1 2007 exp_amt_Year 3714 ## 2 2008 exp_amt_Year 4220 ## 3 2009 exp_amt_Year 3635 ## 4 2010 exp_amt_Year 4663 ## 5 2011 exp_amt_Year 5552 ## 6 2012 exp_amt_Year 5478 ## 7 2013 exp_amt_Year 5596 ## 8 2014 exp_amt_Year 5726 ## 9 2007 imp_amt_Year 3568 ## 10 2008 imp_amt_Year 4352 ## 11 2009 imp_amt_Year 3230 ## 12 2010 imp_amt_Year 4252 ## 13 2011 imp_amt_Year 5244 ## 14 2012 imp_amt_Year 5195 ## 15 2013 imp_amt_Year 5155 ## 16 2014 imp_amt_Year 5255 # 변수명 변경 trade_stat_Year_melt &lt;- rename(trade_stat_Year_melt, c(variable=&quot;trade_cd&quot;, value=&quot;amount_B&quot;)) trade_stat_Year_melt ## Year trade_cd amount_B ## 1 2007 exp_amt_Year 3714 ## 2 2008 exp_amt_Year 4220 ## 3 2009 exp_amt_Year 3635 ## 4 2010 exp_amt_Year 4663 ## 5 2011 exp_amt_Year 5552 ## 6 2012 exp_amt_Year 5478 ## 7 2013 exp_amt_Year 5596 ## 8 2014 exp_amt_Year 5726 ## 9 2007 imp_amt_Year 3568 ## 10 2008 imp_amt_Year 4352 ## 11 2009 imp_amt_Year 3230 ## 12 2010 imp_amt_Year 4252 ## 13 2011 imp_amt_Year 5244 ## 14 2012 imp_amt_Year 5195 ## 15 2013 imp_amt_Year 5155 ## 16 2014 imp_amt_Year 5255 10.7.2 누적영역 그래프 그리기 이제 드디어 누적 영역 그래프를 그릴 데이터 셋 준비가 다 되었군요. ggplot2의 geom_area() 함수를 사용하여 우선 값 기준으로 그리고, 다음으로 비율 기준으로도 그려보겠습니다. geom_area(colour=NA)로 하고 geom_line(position=\"stack\")으로 해서 양 옆에 선은 트여주고, 영역 간 경계선은 그려주었습니다. # 누적 영역 그래프 그리기 ggplot(trade_stat_Year_melt, aes(x=Year, y=amount_B, fill=trade_cd, group=trade_cd)) + geom_area(colour=NA, alpha=0.5) + # alpha 투명도 scale_fill_brewer(palette=&quot;Blues&quot;) + geom_line(position=&quot;stack&quot;, size=0.3) + ggtitle(&quot;Stacked Area Plot of Trade (Import, Export) from 2007 to 2014&quot;) 10.7.3 누적영역 순서 바꾸기 aes(arder=desc()) 를 사용하여 위의 영역 구분 그룹의 순서를 바꿀 수도 있습니다. 위의 예제에서는 exp_amt_Year (수출액)이 아래에 위치했습니다만, 아래 예제에서는 exp_amt_Year(수출액)이 위로 위치가 바뀌었음을 알 수 있습니다. # 누적 영역 순서 바꾸기 library(plyr) # desc() 함수 사용 위해 필요 ## ## Attaching package: &#39;plyr&#39; ## The following objects are masked from &#39;package:reshape&#39;: ## ## rename, round_any ggplot(trade_stat_Year_melt, aes(x=Year, y=amount_B, fill=trade_cd, group=trade_cd, order=desc(trade_cd))) + # 누적 영역 순서 내림차순 정렬 geom_area(colour=NA, alpha=0.5) + # alpha 투명도 scale_fill_brewer(palette=&quot;Blues&quot;) + geom_line(position=&quot;stack&quot;, size=0.3) + ggtitle(&quot;Stacked Area Plot of Trade (Import, Export) from 2007 to 2014&quot;) 10.7.4 비율 기준의 누적영역 그래프 이번에는 비율 기준으로 해서 누적 영역 그래프를 그려보겠습니다. 이를 위해서는 데이터셋에서 Year 별로 비율을 계산해주어야 합니다. 데이터 프레임에서 사칙연산을 써가면서 transform() 함수로 step-by-step 해나갈 수도 있는데요, plyr패키지의 ddply() 함수를 사용하면 놀랍도록 간편하게 원하는 비율 값을 구할 수 있습니다. 10.7.4.1 비율 계산하기 #----- # 비율 누적 영역 그래프 그리기 # 비율 계산하기 # install.packages(&quot;plyr&quot;) library(plyr) trade_stat_Year_melt_prop &lt;- ddply(trade_stat_Year_melt, &quot;Year&quot;, transform, trade_prop = round(100*amount_B/sum(amount_B),1)) trade_stat_Year_melt_prop ## Year trade_cd amount_B trade_prop ## 1 2007 exp_amt_Year 3714 51 ## 2 2007 imp_amt_Year 3568 49 ## 3 2008 exp_amt_Year 4220 49 ## 4 2008 imp_amt_Year 4352 51 ## 5 2009 exp_amt_Year 3635 53 ## 6 2009 imp_amt_Year 3230 47 ## 7 2010 exp_amt_Year 4663 52 ## 8 2010 imp_amt_Year 4252 48 ## 9 2011 exp_amt_Year 5552 51 ## 10 2011 imp_amt_Year 5244 49 ## 11 2012 exp_amt_Year 5478 51 ## 12 2012 imp_amt_Year 5195 49 ## 13 2013 exp_amt_Year 5596 52 ## 14 2013 imp_amt_Year 5155 48 ## 15 2014 exp_amt_Year 5726 52 ## 16 2014 imp_amt_Year 5255 48 10.7.4.2 비율 누적 영역 그래프 위의 trade_prop 변수를 활용해서 비율 누적 영역 그래프(Propostion stacked area plot)을 그려보도록 하겠습니다. 값을 기준으로 했을 때와 script는 동일하며, y값 자리에 trade_prop (수출입 무역 비율) 변수로 바꾸어주기만 하면 됩니다. 그래프 뒤에 단위 격자가 보이도록 geom_area(alpha=0.5) 로 해서 약간 투명하게 처리했습니다. # 비율 누적 영역 그래프 그리기 library(plyr) # desc() 함수 사용 위해 필요 ggplot(trade_stat_Year_melt_prop, aes(x=Year, y=trade_prop, fill=trade_cd, group=trade_cd, order=desc(trade_cd))) + # 누적 영역 순서 내림차순 정렬 geom_area(colour=NA, alpha=0.5) + # alpha 투명도 scale_fill_brewer(palette=&quot;Blues&quot;) + geom_line(position=&quot;stack&quot;, size=0.3) + ggtitle(&quot;Stacked Area Plot of Trade Proportion (Import, Export) from 2007 to 2014&quot;) "],["r-corrplot-상관계수-행렬-그래프.html", "10.8 R corrplot 상관계수 행렬 그래프", " 10.8 R corrplot 상관계수 행렬 그래프 다수의 변수간 상관관계를 파악하려고 할 때, 회귀분석에서 종속변수와 독립변수간 선형관계를 파악하거나 독립변수간 다중공선성을 파악하려고 할 때 사용하는 분석 기법이 상관계수 행렬이며, 시각화 방법이 산포도 행렬과 상관계수 행렬 Plot (correlation matrix plot) 입니다. 이전 포스팅에서 ggplot2의 geom_point() 산포도를 다루었으며, 다음 포스팅에서는 Base Graphics 패키지의 pairs() 함수를 사용한 산포도 행렬을 소개하였고, 이번 포스팅에서는 상관계수 행렬 Plot을 중심으로 해서 corrplot 패키지 사용법을 알아보겠습니다. 10.8.1 데이터 세트 예제로 사용한 데이터는 뉴욕의 1973년도 공기의 질을 측정한 airquality 데이터셋의 Ozone, Solar.R, Wind, Temp 4개의 변수가 되겠습니다. str(airquality) ## &#39;data.frame&#39;: 153 obs. of 11 variables: ## $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... ## $ Solar.R : int 190 118 149 313 NA NA 299 99 19 194 ... ## $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... ## $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... ## $ Month : int 5 5 5 5 5 5 5 5 5 5 ... ## $ Day : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Month.ch_temp: chr &quot;5&quot; &quot;5&quot; &quot;5&quot; &quot;5&quot; ... ## $ Day.ch_temp : chr &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Month.ch : chr &quot;05&quot; &quot;05&quot; &quot;05&quot; &quot;05&quot; ... ## $ Day.ch : chr &quot;01&quot; &quot;02&quot; &quot;03&quot; &quot;04&quot; ... ## $ Time : chr &quot;0501&quot; &quot;0502&quot; &quot;0503&quot; &quot;0504&quot; ... 10.8.1.1 결측값 처리 상관계수 분석을 할 때 결측값이 있으면 NA 값이 나오게 되므로 사전에 결측값을 처리하는 것이 필요합니다. Ozone과 Solar.R이 결측값이 각각 37개, 7개 있다보니 아래처럼 상관계수가 NA가 나왔습니다. # Month, Day는 빼기 airquality_1 &lt;- airquality[,c(1:4)] # 결측값 확인 sum(is.na(airquality_1$Ozone)) # 37 ## [1] 37 sum(is.na(airquality_1$Solar.R)) # 7 ## [1] 7 sum(is.na(airquality_1$Wind)) # 0 ## [1] 0 sum(is.na(airquality_1$Temp)) # 0 ## [1] 0 # 결측값 있는 상태에서 상관계수 계산했을 때 cor(airquality_1) ## Ozone Solar.R Wind Temp ## Ozone 1 NA NA NA ## Solar.R NA 1 NA NA ## Wind NA NA 1.00 -0.46 ## Temp NA NA -0.46 1.00 na.omit() 함수를 사용하여 결측값이 있는 행 전체를 삭제한 후에 상관계수를 구해보면 아래와 같습니다. # 결측값 있는 행 전체 삭제 airquality_2 &lt;- na.omit(airquality_1) str(airquality_2) ## &#39;data.frame&#39;: 111 obs. of 4 variables: ## $ Ozone : int 41 36 12 18 23 19 8 16 11 14 ... ## $ Solar.R: int 190 118 149 313 299 99 19 256 290 274 ... ## $ Wind : num 7.4 8 12.6 11.5 8.6 13.8 20.1 9.7 9.2 10.9 ... ## $ Temp : int 67 72 74 62 65 59 61 69 66 68 ... ## - attr(*, &quot;na.action&quot;)= &#39;omit&#39; Named int [1:42] 5 6 10 11 25 26 27 32 33 34 ... ## ..- attr(*, &quot;names&quot;)= chr [1:42] &quot;5&quot; &quot;6&quot; &quot;10&quot; &quot;11&quot; ... sum(is.na(airquality_2$Ozone)) # 0 ## [1] 0 sum(is.na(airquality_2$Solar.R)) # 0 ## [1] 0 # 상관계수 계산 airquality_cor &lt;- cor(airquality_2) airquality_cor ## Ozone Solar.R Wind Temp ## Ozone 1.00 0.35 -0.61 0.70 ## Solar.R 0.35 1.00 -0.13 0.29 ## Wind -0.61 -0.13 1.00 -0.50 ## Temp 0.70 0.29 -0.50 1.00 10.8.2 상관계수 행렬 데이터 세트 구하기 corrplot 패키지의 corrplot() 함수는 상관계수 행렬 데이터셋을 가지고 그래프를 그리므로 아래처럼 결측값을 제거한 후의 데이터셋을 가지고 미리 상관계수 행렬을 계산해두어야 합니다. 10.8.2.1 패키지 설치 corrplot 패키지는 별도의 설치 및 호출이 필요한 패키지이므로 아래의 절차를 거칩니다. # install.packages(&quot;corrplot&quot;) library(corrplot) ## corrplot 0.84 loaded 10.8.3 상관계수 행렬 그리기 10.8.3.1 산포도 행렬 그림 산포도 행렬 그림 (scatter matrix plot)을 복습해보자면 아래와 같습니다. # scatter plot matrix plot(airquality_2) 10.8.3.2 상관계수 행렬 그리기 correlation plot의 method 에는 method = c(\"circle\", \"square\", \"ellipse\", \"number\", \"shade\", \"color\", \"pie\") 등이 있으며, method별로 하나씩 예를 들어보겠습니다. 10.8.3.2.1 method=\"circle\" corrplot(airquality_cor, method=&quot;circle&quot;) 10.8.3.2.2 method=\"square\" corrplot(airquality_cor, method=&quot;square&quot;) 10.8.3.2.3 method=\"ellipse\" corrplot(airquality_cor, method=&quot;ellipse&quot;) 10.8.3.2.4 method=\"number\" corrplot(airquality_cor, method=&quot;number&quot;) 10.8.3.2.5 method=\"shade\" corrplot(airquality_cor, method=&quot;shade&quot;) 10.8.3.2.6 method=\"color\" corrplot(airquality_cor, method=&quot;color&quot;) 10.8.3.2.7 method=\"pie\" corrplot(airquality_cor, method=&quot;pie&quot;) 마지막으로 method=\"shade\", 상관관계 방향성 제시, 대각선 값 미제시, 상관계수 숫지 검정색으로 해서 추가해서 corrplot을 그려보겠습니다. order 는 FPC(First Principle Component), hclust(hierarchical clustering), AOE(Angular Order of Engenvectors) 등이 있으며, 정렬 기준을 지정해주면 같은 색깔 끼리 뭉쳐서 보일 수 있도록 정렬을 시켜줘서 보기에, 해석하기에 더 좋게 보여줍니다. # corrplot corrplot(airquality_cor, method=&quot;shade&quot;, # 색 입힌 사각형 addshade=&quot;all&quot;, # 상관관계 방향선 제시 # shade.col=NA, # 상관관계 방향선 미제시 tl.col=&quot;red&quot;, # 라벨 색 지정 tl.srt=30, # 위쪽 라벨 회전 각도 diag=FALSE, # 대각선 값 미제시 addCoef.col=&quot;black&quot;, # 상관계수 숫자 색 order=&quot;FPC&quot; # &quot;FPC&quot;: First Principle Component # &quot;hclust&quot; : hierarchical clustering # &quot;AOE&quot; : Angular Order of Eigenvectors ) (참고)pairs() 함수를 활용한 ‘산포도 행렬 + 상관계수 행렬 + 히스토그램’ 그리기  http://rfriend.tistory.com/83 "],["r-graphics-패키지-pairs-함수를-사용한-산포도-행렬-그리기.html", "10.9 R Graphics 패키지 pairs() 함수를 사용한 산포도 행렬 그리기", " 10.9 R Graphics 패키지 pairs() 함수를 사용한 산포도 행렬 그리기 산포도는 두 변수간의 관계를 파악하는데 굉장히 유용한 시각화 방법입니다. 그리고 산포도 행렬은 다수의 변수들 간의 관계를 한눈에 파악하는데 유용한 시각화 방법이구요. 이전 포스팅에서 - ggplot2의 geom_point() 함수를 이용한 한개 변수의산포도 그리기 - corrplot 패키지를 이용한 상관계수 행렬 그림 그리기 를 소개했었습니다. ggplot2로 두 변수만 가지고 산포도는 유연하게 그릴 수 있는데요, 3개 이상의 변수를 가지고 산포도 행렬을 그리기는 매우 힘이 듭니다. (프로그래밍을 해야 합니다) 따라서 산포도 행렬은 plot() 함수를 써서 한방에 그리는 것이 제일 편하구요, 이번 포스팅에서는 Base Graphics 패키지 내에 pairs() 함수를 이용해서 산포도 행렬에 몇 가지 사용자 정의 함수를 추가하여 히스토그램도 집어 넣고 상관계수 숫자도 포함시키는 방법을 소개하겠습니다. 산포도 행렬에 많은 추가 정보를 담을 수 있어서 매우 보기에 좋고 유용합니다. 사용자 정의 함수는 pairs() 도움말(help)을 참조하였습니다. 10.9.1 데이터 세트 10.9.1.1 변수의 선택 예제로 사용한 데이터는 뉴욕의 1973년도 공기의 질을 측정한 airquality 데이터셋의 Ozone, Solar.R, Wind, Temp 4개의 변수가 되겠습니다. str(airquality) ## &#39;data.frame&#39;: 153 obs. of 11 variables: ## $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... ## $ Solar.R : int 190 118 149 313 NA NA 299 99 19 194 ... ## $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... ## $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... ## $ Month : int 5 5 5 5 5 5 5 5 5 5 ... ## $ Day : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Month.ch_temp: chr &quot;5&quot; &quot;5&quot; &quot;5&quot; &quot;5&quot; ... ## $ Day.ch_temp : chr &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ Month.ch : chr &quot;05&quot; &quot;05&quot; &quot;05&quot; &quot;05&quot; ... ## $ Day.ch : chr &quot;01&quot; &quot;02&quot; &quot;03&quot; &quot;04&quot; ... ## $ Time : chr &quot;0501&quot; &quot;0502&quot; &quot;0503&quot; &quot;0504&quot; ... # 1~4번째 변수만 선택 airquality_1 &lt;- airquality[,c(1:4)] str(airquality_1) ## &#39;data.frame&#39;: 153 obs. of 4 variables: ## $ Ozone : int 41 36 12 18 NA 28 23 19 8 NA ... ## $ Solar.R: int 190 118 149 313 NA NA 299 99 19 194 ... ## $ Wind : num 7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ... ## $ Temp : int 67 72 74 62 56 66 65 59 61 69 ... 10.9.1.2 결측치의 처리 결측값이 있으면 상관계수를 구할 때 NA 값이 나오므로, 결측값 여부 확인하고 결측값이 있는 행은 삭제한 후에 산포도 행렬을 그려보겠습니다. # 결측값 개수 확인 sum(is.na(airquality_1$Ozone)) # 37 ## [1] 37 sum(is.na(airquality_1$Solar.R)) # 7 ## [1] 7 sum(is.na(airquality_1$Wind)) # 0 ## [1] 0 sum(is.na(airquality_1$Temp)) # 0 ## [1] 0 # 결측값 있는 상태에서 상관계수 계산했을 때 cor(airquality_1) ## Ozone Solar.R Wind Temp ## Ozone 1 NA NA NA ## Solar.R NA 1 NA NA ## Wind NA NA 1.00 -0.46 ## Temp NA NA -0.46 1.00 # 결측값 있는 행 전체 삭제 airquality_2 &lt;- na.omit(airquality_1) str(airquality_2) ## &#39;data.frame&#39;: 111 obs. of 4 variables: ## $ Ozone : int 41 36 12 18 23 19 8 16 11 14 ... ## $ Solar.R: int 190 118 149 313 299 99 19 256 290 274 ... ## $ Wind : num 7.4 8 12.6 11.5 8.6 13.8 20.1 9.7 9.2 10.9 ... ## $ Temp : int 67 72 74 62 65 59 61 69 66 68 ... ## - attr(*, &quot;na.action&quot;)= &#39;omit&#39; Named int [1:42] 5 6 10 11 25 26 27 32 33 34 ... ## ..- attr(*, &quot;names&quot;)= chr [1:42] &quot;5&quot; &quot;6&quot; &quot;10&quot; &quot;11&quot; ... sum(is.na(airquality_2$Ozone)) # 0 ## [1] 0 sum(is.na(airquality_2$Solar.R)) # 0 ## [1] 0 10.9.2 사용자 정의 함수 만들기 10.9.2.1 대각선에 히스트그램 추가하는 함수 산포도 행렬의 대각선에 히스토그램을 추가하는 사용자 정의 함수입니다. pairs() 도움말(help)에 나와있는 사용자 정의함수 그대로 가져왔습니다. 아래 사용자 정의 함수를 복사해서 사용하시기 바랍니다. ## put histograms on the diagonal panel.hist &lt;- function(x, ...) { usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) par(usr = c(usr[1:2], 0, 1.5) ) h &lt;- hist(x, plot = FALSE) breaks &lt;- h$breaks; nB &lt;- length(breaks) y &lt;- h$counts; y &lt;- y/max(y) rect(breaks[-nB], 0, breaks[-1], y, col = &quot;cyan&quot;, ...) } # source: help(pairs) 10.9.2.2 산포도 행렬 위쪽에 상관계수 숫자 삽입하는 함수 정의 다음으로 산포도 행렬의 위쪽에 상관계수 숫자를 집어넣는 사용자 정의 함수입니다. 이 또한 pairs() 도움말(help)에 나와있는 사용자 정의함수 그대로 가져왔습니다. 아래 사용자 정의 함수를 카피해서 사용하시기 바랍니다. ## put (absolute) correlations on the upper panels, ## with size proportional to the correlations. panel.cor &lt;- function(x, y, digits = 2, prefix = &quot;&quot;, cex.cor, ...) { usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) par(usr = c(0, 1, 0, 1)) r &lt;- abs(cor(x, y)) txt &lt;- format(c(r, 0.123456789), digits = digits)[1] txt &lt;- paste0(prefix, txt) if(missing(cex.cor)) cex.cor &lt;- 0.8/strwidth(txt) text(0.5, 0.5, txt, cex = cex.cor * r) } # source : help(pairs) 10.9.2.3 산포도에 선형 회귀선 추가하는 사용자 정의 함수 다음으로 산포도에 선형 회귀선을 추가하는 사용자 정의 함수입니다. 이는 R Graphics Cookbook (원스턴 챙 지음, 이제원 옮김)을 참조하였습니다. 아래 사용자 정의 함수를 카피해서 사용하시기 바랍니다. ## put linear regression line on the scatter plot panel.lm &lt;- function(x, y, col=par(&quot;col&quot;), bg=NA, pch=par(&quot;pch&quot;), cex=1, col.smooth=&quot;black&quot;, ...) { points(x, y, pch=pch, col=col, bg=bg, cex=cex) abline(stats::lm(y~x), col=col.smooth, ...) } 10.9.3 산포도 행렬 그리기 이제 준비가 다 되었습니다. airquality의 4개 변수 간의 산포도 행렬, 상관계수 숫자, 히스토그램을 하나의 도표로 나타내보겠습니다. ## 산포도 행렬(scatter-plot matrix), 상관계수(correlation), 히스토그램(histogram) pairs(airquality_2, lower.panel = panel.lm, # 아래쪽 산포도에 선형 직선 추가 upper.panel = panel.cor, # 위쪽에는 상관계수 숫자 (상관계수에 크기 비례) diag.panel = panel.hist, # 대각선에는 히스토그램 pch=&quot;*&quot;, # 점 모양은 * 로 main = &quot;scatter-plot matrix, correlation coef., histogram&quot; ) 10.9.3.1 그룹별로 점의 색깔 달리하기 보너스로, pairs() 함수를 사용해서 범주(그룹)별로 점의 색깔을 달리하는 방법도 소개하겠습니다. 이 역시 pairs() 함수 도움말(help)에 있는 R script 를 가져왔습니다. 도움말(help)이 정말 도움이 많이 됩니다. ^^ 사용한 데이터는 그 유명한 Iris 데이터가 되겠습니다. # 범주(그룹)을 색깔로 구분하여 산포도 행렬 그리기 pairs(iris[1:4], main = &quot;Anderson&#39;s Iris Data -- 3 species&quot;, pch = 21, bg = c(&quot;red&quot;, &quot;green3&quot;, &quot;blue&quot;)[unclass(iris$Species)]) * R script source : help(pairs) "],["r-ggplot2-히트맵heat-map-그리기-geom-tile-geom-raster.html", "10.10 R ggplot2 히트맵(Heat map) 그리기 : geom_tile(), geom_raster()", " 10.10 R ggplot2 히트맵(Heat map) 그리기 : geom_tile(), geom_raster() x축과 y축으로 나타낸 그래프 혹은 2차원의 지도 위에 특정 연속형 변수의 값에 따라 색깔을 조금씩 다르게 하여 정보를 보여주는 시각화 방법으로 히트맵(Heat map)이 많이 사용됩니다. R ggplot2 패키지에서는 **geom_tile(), geom_raster() 함수를 사용해서 쉽고 편하게 히트맵(Heat map)**을 그릴 수 있습니다. 이번 포스팅에서는 히트맵(Heat map)을 그리고, 축의 항목 위치를 바꾸어 보는 것을 예를 들어보이겠습니다. 아래 보시는 것은 구글에 히트맵(Heat map) 이라는 키워드로 나온 이미지들인데요, 평소에 알게 모르게 히트맵을 우리가 많이 접하고 있었다는 것을 알 수 있을 것입니다. 10.10.1 히드맵의 예 [히트맵 (Heat map) 예시 ] * 이미지 출처 : 구글(www.google.co.kr) 10.10.2 데이터 세트 MASS 패키지에 내장되어 있는 Cars93 데이터 프레임이며, 차종(Type), 실린더(Cylinders) 별 고속도로연비(MPG.highway) 를 사용하여 히트맵(Heat map)을 그려보겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 10.10.3 히트맵 그리기 ggplot2는 별도의 설치 및 호출이 필요하므로 아래의 절차를 먼저 거치고 히트맵을 그려보겠습니다. 10.10.3.1 패키지 설치 library(ggplot2) 10.10.3.2 히트맵 그리기 x축에 차종(Type), y축에 실린더개수(Cylinders)별로 고속도로연비(MPG.highway)에 따라서 색을 달리하여 히트맵을 geom_tile() 함수를 사용해 그려보겠습니다. # Type, Cylinders 별 MPG.highway Heatmap : geom_tile() a1 &lt;- ggplot(Cars93, aes(x=Type, y=Cylinders, fill=MPG.highway)) + geom_tile() a1 10.10.3.3 차의 크기를 고려한 히트맵 위의 히트맵을 보면 x축에 차종(Type)이 차의 크기 순서가 아니라 알파벳 순서로 되어 있다보니 색깔이 경향성이 없이 무작위하게 채워져있어 보입니다. x축을 차의 크기를 감안한 순서대로, 즉, “Small,” “Compact,” “Midsize,” “Sporty,” “Large,” “Van” 의 순서대로 scale_x_discrete(limits=...) 를 사용해 바꾸어보겠습니다. # x축 순서 바꾸기 : scale_x_discrete(limits=...) a2 &lt;- a1 + scale_x_discrete(limits=c(&quot;Small&quot;, &quot;Compact&quot;, &quot;Midsize&quot;, &quot;Sporty&quot;, &quot;Large&quot;, &quot;Van&quot;)) a2 위의 히트맵을 보니 크기가 작을 수록, 실린더 개수가 작을 수록 고속도로 연비가 높으며, 그 반대는 고속도로 연비가 낮아짐을 한눈에 단박에 파악할 수 있게 되었습니다. 10.10.3.4 geom_raster() 함수를 이용한 히트맵 이번에는 geom_raster() 함수를 사용해 히트맵을 그려보겠습니다. 결과적으로 geom_tile()과 차이가 거의 없다는 것을 알 수 있습니다. # Type, Cylinders 별 MPG.highway Heatmap : geom_raster() ggplot(Cars93, aes(x=Type, y=Cylinders, fill=MPG.highway)) + geom_raster() + scale_x_discrete(limits=c(&quot;Small&quot;, &quot;Compact&quot;, &quot;Midsize&quot;, &quot;Sporty&quot;, &quot;Large&quot;, &quot;Van&quot;)) 10.10.3.5 연속형 숫자 데이터의 히트맵 연속형 숫자형 값을 가지는 히트맵의 색상을 scale_fill_gradient(low = \"colour 1\", high = \"colour 2\") 옵션을 사용해서 다르게 설정해보도록 하겠습니다. (kusscd 님, 댓글로 방법 공유해주셔서 감사합니다 ^^) ggplot(Cars93, aes(x=Type, y=Cylinders, fill=MPG.highway)) + # filling with numeric value geom_tile() + scale_x_discrete(limits = c(&quot;Small&quot;, &quot;Compact&quot;, &quot;Midsize&quot;, &quot;Sporty&quot;, &quot;Large&quot;, &quot;Van&quot;)) + scale_fill_gradient(low = &quot;yellow&quot;, high = &quot;red&quot;) + ggtitle(&quot;Heatmap of MPG.highway by Type &amp; Cylinders&quot;) 10.10.3.6 범주형 문자 데이터의 히트맵 다음으로, 범주형 자료로 히트맵의 색상을 채우는 경우에 scale_fill_manual(values = c(\"colour 1\", \"colour 2\", ...) 을 옵션을 사용해서 색상을 사용자가 직접 지정해주는 방법을 2개 범주를 가지는 간단한 예시를 들어서 설명하겠습니다. my.df &lt;- data.frame(XCoord = c(1, 1, 2, 3, 3, 4, 4, 5, 5, 5), YCoord = c(1, 4, 3, 1, 3, 1, 5, 2, 3, 5), Seg = c(&quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;)) ggplot(my.df, aes(x=XCoord, y=YCoord, fill=Seg)) + # filling with categorical value geom_tile(colour=&quot;white&quot;) + scale_fill_manual(values = c(&quot;blue&quot;, &quot;red&quot;)) + ggtitle(&quot;Heatmap with 2 categories with scale_fill_manual()&quot;) 참고자료 https://rfriend.tistory.com/67?category=605866 https://rfriend.tistory.com/68?category=605866 https://rfriend.tistory.com/93?category=605866 https://rfriend.tistory.com/69 https://rfriend.tistory.com/81?category=605866 https://rfriend.tistory.com/70?category=605866 https://rfriend.tistory.com/71 https://rfriend.tistory.com/72?category=605866 https://rfriend.tistory.com/84?category=605866 https://rfriend.tistory.com/85?category=605866 https://rfriend.tistory.com/92?category=605866 https://rfriend.tistory.com/86?category=605866 https://rfriend.tistory.com/87?category=605866 https://rfriend.tistory.com/88?category=605866 https://rfriend.tistory.com/73?category=605866 https://rfriend.tistory.com/74?category=605866 https://rfriend.tistory.com/75?category=605866 https://rfriend.tistory.com/76?category=605866 https://rfriend.tistory.com/82?category=605866 https://rfriend.tistory.com/83?category=605866 https://rfriend.tistory.com/94?category=605866 "],["part-4.html", "Part 4", " Part 4 "],["개-이상-변수의-다변량-그래프.html", "11 3개 이상 변수의 다변량 그래프", " 11 3개 이상 변수의 다변량 그래프 실전 업무에서는 다변량 데이터(multivariate data set)를 사용하는 경우가 다반사입니다. 그리고 분석업무 초반에 탐색적 분석을 수행할 때 시각화를 통해 변수들 간의 관계, 패턴을 탐색하는 분석 기법이 굉장히 유용합니다. 하지만 다변량 데이터 중에서도 특히 3개 이상의 변수를 가지는 다변량 데이터의 경우 그동안 소개해드렸던 히스토그램, 막대그림, 박스 그림, 산포도, 선그림/시계열 그림 등을 활용해서 2차원 평면에 나타낼 수 없는 한계가 있습니다. (물론, 색깔이라든지 모양을 데이터 그룹 별로 달리하면 3차원, 4차원의 정보를 시각화할 수 있기는 합니다만…) 변수 3개 이상의 다변량 데이터를 2차원 평면에 효과적으로 시각화할 수 있는 방법으로 (1) 레이더 차트 (radar chart) or 거미줄 그림(spider plot) 별 그림 (star graph) (레이더 차트와 유사, 중심점 다름) 평행 좌표 그림 (parallel coordinate plot) 3차원 산포도 (3 dimensional scatter plot) 체르노프 얼굴그림 (Chernoff faces) 산포도 행렬(scatter plot matrix) 모자이크 그림(mosaic plot) "],["레이더-차트radar-chart-or-거미줄-그림spider-plot.html", "11.1 레이더 차트(radar chart), or 거미줄 그림(spider plot)", " 11.1 레이더 차트(radar chart), or 거미줄 그림(spider plot) 이번 포스팅에서는 (1) 레이더 차트 (radar chart)에 대해서 소개하겠습니다. 방사형의 레이더 차트가 마치 거미줄을 닮아서 거미줄 그림 (spider plot)이라고도 부릅니다. 별 그림 (star plot) 도 레이더 차트와 형태는 거의 유사한데요, 약간 현태가 다른 점이 있고 stars 라는 R 패키지가 별도로 있고 해서 다음번에 따로 설명을 드리겠습니다. 11.1.1 데이터 세트 R 실습에 사용할 데이터는 MASS 패키지에 내장되어 있는 Cars93 데이터프레임입니다. 분석 대상 변수로는 차 유형(Type), 가격(Price), 고속도로연비(MPG.highway), 마력(Horsepower), 분당회전수RPM(RPM), 길이(Length), 무게(Weight) 등의 7개 변수입니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 11.1.2 데이터 전처리 11.1.2.1 차 유형별 분할표 작성 먼저 table() 함수를 사용하여 차 유형별 분할표를 만들어보았습니다. 6종류의 차 유형별로 10~20여대씩 분포하고 있음을 알 수 있습니다. # cross tabulation by car type table(Cars93$Type) ## ## Compact Large Midsize Small Sporty Van ## 16 11 22 21 14 9 11.1.2.2 차 유형별 평균 구하기 다음으로, 차 유형(Type)별로 가격(Price), 고속도로연비(MPG.highway), 마력(Housepower), 분당회전수RPM(RPM), 길이(Length), 무게(Weight) 등 6개 변수별 평균(mean)을 구해보겠습니다. doBy package 의 summaryBy() 함수를 사용하면 연속형변수의 다변량 데이터에 일괄적으로 요약통계량을 편리하게 계산할 수 있습니다. Base package가 아니므로 install.packages(\"doBy\")로 설치하시고, library(doBy)로 호출한 후에 summaryBy() 함수의 FUN = c(mean, min, max, sd, ...) 처럼 원하는 통계량 함수를 입력하면 됩니다. 이번에는 평균만 사용할 것이므로 아래 예에서는 FUN = c(mean) 만 입력하였습니다. # mean of multivariates by Car Type # install.packages(&quot;doBy&quot;) library(doBy) mean_by_Type &lt;- summaryBy(MPG.highway + RPM + Horsepower + Weight + Length + Price ~ Type, data=Cars93, FUN = c(mean)) mean_by_Type ## Type MPG.highway.mean RPM.mean Horsepower.mean Weight.mean Length.mean ## 1 Compact 30 5362 131 2918 182 ## 2 Large 27 4673 179 3695 205 ## 3 Midsize 27 5336 173 3400 193 ## 4 Small 35 5633 91 2313 167 ## 5 Sporty 29 5393 160 2900 175 ## 6 Van 22 4744 149 3831 186 ## Price.mean ## 1 18 ## 2 24 ## 3 27 ## 4 10 ## 5 19 ## 6 19 11.1.3 레이더 차트 그리기 11.1.3.1 패키지 설치 다음으로, 레이더 차트(radar chart)를 그리려면 fmsb Package 를 사용합니다. install.packages(\"fmsb\")로 설치하고, library(fmsb)로 호출해보겠습니다. # install.packages(&quot;fmsb&quot;) library(fmsb) ## ## Attaching package: &#39;fmsb&#39; ## The following object is masked from &#39;package:vcd&#39;: ## ## oddsratio 11.1.3.2 radarchart() 함수 fmsb Package의 radarchart() 함수를 사용하기 위한 데이터 형태는 데이터 구조는 Dataframe 첫번째 행(1st row)에 최대값(max value) 두번째 행(2nd row)에 최소값(min value) 세번째 행부터는 원래의 관측값 이 오도록 데이터를 전처리해주어야 합니다. 11.1.3.3 radrchart() 함수를 사용하기 위한 데이터 준비 [ fmsb Package의 radrchart() 함수 사용하기 위한 데이터 준비 ] 11.1.3.3.1 사용자 정의 함수 만들기 R 사용자정의함수로 첫번째 행에 최대값, 두번째 행에 최소값이 오도록 하여 Dataframe으로 묶는 명령어는 아래와 같습니다. # manipulating dataset for radar chart # data frame includes possible maximum values as row 1 # and possible minimum values as row 2 df_radarchart &lt;- function(df) { df &lt;- data.frame(df) dfmax &lt;- apply(df, 2, max) dfmin &lt;- apply(df, 2, min) as.data.frame(rbind(dfmax, dfmin, df)) } 11.1.3.3.2 변수의 표준화 사용자정의함수에 더하여 scale() 함수를 사용해서 6개의 변수를 표준화 하였습니다. # maximum value as row 1, minimum value as row 2 : user-defined function df_radarchart # standardization : scale() mean_by_Type_scale &lt;- df_radarchart(scale(mean_by_Type[,c(2:7)])) mean_by_Type_scale ## MPG.highway.mean RPM.mean Horsepower.mean Weight.mean Length.mean Price.mean ## 1 1.61 1.14 0.986 1.14 1.533 1.279 ## 2 -1.42 -1.33 -1.730 -1.51 -1.319 -1.634 ## 11 0.36 0.44 -0.502 -0.45 -0.187 -0.260 ## 21 -0.34 -1.33 0.986 0.91 1.533 0.781 ## 3 -0.34 0.38 0.790 0.39 0.603 1.279 ## 4 1.61 1.14 -1.730 -1.51 -1.319 -1.634 ## 5 0.12 0.52 0.393 -0.48 -0.711 -0.058 ## 6 -1.42 -1.15 0.064 1.14 0.081 -0.108 11.1.3.4 레이더 차트 그리기 드디어 radarchart() 함수를 사용해서 레이더 차트를 그려보겠습니다. 각 옵션에 대한 기능은 아래 R 명령어에 부가설명을 달아놓았습니다. 범례는 legend() 함수를 사용해서 왼쪽 상단에 추가하였습니다. # radar chart (or spider plot) radarchart(df = mean_by_Type_scale, # The data frame to be used to draw radarchart seg = 6, # The number of segments for each axis pty = 16, # A vector to specify point symbol: Default 16 (closed circle) pcol = 1:6, # A vector of color codes for plot data plty = 1:6, # A vector of line types for plot data plwd = 2, # A vector of line widths for plot data title = c(&quot;radar chart by Car Types&quot;) # putting title at the top-middle ) # adding legend legend(&quot;topleft&quot;, legend = mean_by_Type$Type, col = c(1:6), lty = c(1:6), lwd = 2) 선의 형태(plty)나 선의 색깔(pcol)을 프로그래밍 편하라고 1:6 이라고 했는데요, 원하는 선 모양이나 색깔을 순서대로 지정할 수 있습니다. 다음번 포스팅에서는 별 그림(star graph)에 대해서 알아보겠습니다. "],["별-그래프-star-graph-segment-diagrams.html", "11.2 별 그래프 (star graph, segment diagrams)", " 11.2 별 그래프 (star graph, segment diagrams) 이번 포스팅에서는 (2) 별 그래프 (star graph)에 대해서 소개하겠습니다. graphics Package의 stars() 함수를 사용하겠습니다. graphics Package는 base Package로서 R 설치할 때 기본으로 설치되므로 stars() 함수를 사용하기 위해 추가로 별도 패키지 설치는 필요하지 않습니다. stars() 함수는 dataframe 이나 matrix 형태의 데이터셋을 사용합니다. scale = TRUE 옵션을 사용하면 (minimum value) 0 ~ (maximum value) 1 사이의 값으로 다변량 변수들의 값을 표준화해줍니다. 별 그래프(star graph)의 기본 원리는 중심점(center point)으로 부터 각 관측치별/ 각 변수별로 거리(distance) 혹은 반지름(radius)이 얼마나 떨어져있는가를 시각화한 것입니다. 11.2.1 데이터 세트 실습을 위해서 MASS Package에 내장된 Cars93 dataframe을 사용하겠습니다. 이전 포스팅 레이더 차트(radar chart) 와 비교하기 쉽도록 이번에도 차종(Type), 가격(Price), 고속도로연비(MPG.highway), 마력(Horsepower), 분당회전수(RPM), 길이(Length), 무게(Weight) 의 7개 변수를 똑같이 사용하겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 11.2.2 데이터 처리 11.2.2.1 요약 통계량 구하기 93개의 차량 관측치가 있는데요, 이것을 6개의 차종(Type)을 기준으로 평균 통계량으로 요약한 후에, 차종별로 6개의 평균치 다변량 변수를 가지고 별 그래프를 그려보겠습니다. # cross tabulation by Car Type table(Cars93$Type) ## ## Compact Large Midsize Small Sporty Van ## 16 11 22 21 14 9 # mean of multivariates by Car Type # install.packages(&quot;doBy&quot;) library(doBy) mean_by_Type &lt;- summaryBy(MPG.highway + RPM + Horsepower + Weight + Length + Price ~ Type, data=Cars93, FUN = c(mean)) mean_by_Type ## Type MPG.highway.mean RPM.mean Horsepower.mean Weight.mean Length.mean ## 1 Compact 30 5362 131 2918 182 ## 2 Large 27 4673 179 3695 205 ## 3 Midsize 27 5336 173 3400 193 ## 4 Small 35 5633 91 2313 167 ## 5 Sporty 29 5393 160 2900 175 ## 6 Van 22 4744 149 3831 186 ## Price.mean ## 1 18 ## 2 24 ## 3 27 ## 4 10 ## 5 19 ## 6 19 11.2.2.2 라벨링하기 stars() 함수에서는rownames 를 가져다가 labeling 을 합니다. 현재 rownames 는 1, 2,…, 6 의 숫자로 되어있으므로, 이를 차종(Type) 이름으로 변경하도록 하겠습니다. # creating row names with Type rownames(mean_by_Type) &lt;- mean_by_Type$Type mean_by_Type ## Type MPG.highway.mean RPM.mean Horsepower.mean Weight.mean ## Compact Compact 30 5362 131 2918 ## Large Large 27 4673 179 3695 ## Midsize Midsize 27 5336 173 3400 ## Small Small 35 5633 91 2313 ## Sporty Sporty 29 5393 160 2900 ## Van Van 22 4744 149 3831 ## Length.mean Price.mean ## Compact 182 18 ## Large 205 24 ## Midsize 193 27 ## Small 167 10 ## Sporty 175 19 ## Van 186 19 위에서 rownames() 로 뭐가 바뀌었나 잘 모를수도 있는데요, 아래에 화면 캡쳐한 그래프를 참고하시기 바랍니다. 제일 왼쪽에 rowname 이 숫자에서 차종(Type)으로 바뀐게 보이지요? 11.2.2.3 변수명 바꾸기 doBy Package로 요약통계량을 생성하면 변수명 뒤에 자동으로 통계량 이름이 따라 붙습니다. 이번 예제의 경우에는 평균을 구했으므로 MPG.highway.mean, RPM.mean, … 이런 식으로요. 변수명이 너무 길다보니 나중에 labeling 할 때 옆으로 삐죽 튀어나가서 보기 싫어서요, 변수명을 좀더 짧게 변경해보겠습니다. 변수명 뒤에 .mean 을 생략하고 사용하겠습니다. 위에 rownames() 함수는 stars() 함수를 사용하려면 꼭 해줘야 하는 것이구요, 아래의 renames()는 필수사항은 아닙니다. # renaming of variables library(reshape) mean_by_Type &lt;- rename(mean_by_Type, c(MPG.highway.mean = &quot;MPG.highway&quot;, RPM.mean = &quot;RPM&quot;, Horsepower.mean = &quot;Horsepower&quot;, Weight.mean = &quot;Weight&quot;, Length.mean = &quot;Length&quot;, Price.mean = &quot;Price&quot; ) ) mean_by_Type ## Type MPG.highway RPM Horsepower Weight Length Price ## Compact Compact 30 5362 131 2918 182 18 ## Large Large 27 4673 179 3695 205 24 ## Midsize Midsize 27 5336 173 3400 193 27 ## Small Small 35 5633 91 2313 167 10 ## Sporty Sporty 29 5393 160 2900 175 19 ## Van Van 22 4744 149 3831 186 19 11.2.3 별 그래프 그리기 이제 드디어 데이터셋이 준비가 되었습니다. stars() 함수를 사용해서 별 그래프를 그려보겠습니다. 11.2.3.1 stars() 함수의 형식 stars(x, …) 의 x 자리에는 dataframe 이나 matrix 형태의 다변량 데이터셋 이름을 입력하면 됩니다. locations = NULL, nrow = 2, ncol = 4 옵션은 행이 2줄, 열이 4줄인 square layout 으로 배열하라는 뜻입니다. scale = TRUE 는 변수별로 단위(scale)가 달라서 들쭉날쭉한 값들을 변수별로 모두 최소값 0 ~ 최대값 1 사이로 변수별 값들을 표준화(standardization) 합니다. full = TRUE 로 지정하면 360도의 전체 원으로 그래프를 그립니다. full = FALSE 로 지정하면 1180도짜리 반원(semi-circle)으로 그래프가 그려집니다. radius = TRUE 로 지정하면 반지름 선이 그려집니다. 만약 radius = FALSE 로 하면 반지름 선이 안그려지는데요, 보기에 좀 휑~합니다. ^^’ frame.plot = TRUE 로 하면 그래프의 외곽에 네모 박스 선으로 테두리가 쳐집니다. main 은 제목을 입력하는 옵션입니다. sub 는 부제목 입력하는 옵션이구요. cex 는 글자 크기 지정하는 옵션인데요, default 가 1이고 숫자가 커질 수록 글자 크기가 커집니다. lwd 는 선 두께 (line width) 지정하는 옵션입니다. default 가 1이며, 숫자가 커질 수록 선이 두꺼워집니다. key.loc = c(7.5, 1.5) 는 x, y 좌표 위치에 각 변수들의 이름(unit key)을 범례로 집어넣습니다. 말로 설명해놓긴 했는데요, 잘 이해가 안갈수도 있겠습니다. 아래에 stars() 함수를 복사해놓고서 옵션마다 하나씩 ‘#’을 붙여가면서 실행을 해보시기 바랍니다. 그러면’#’을 붙이기 전과 비교가 될테고, 옵션별 기능을 바로 확인할 수 있습니다. # star plot stars(mean_by_Type[, 2:7], # dataframe or matrix locations = NULL, # locations = NULL, the segment plots will be placed in a rectangular grid nrow = 2, # number of rows at a square layout (w/locations = NULL) ncol = 4, # number of columns at a square layout (w/locations = NULL) scale = TRUE, # the columns are scaled independently (max in each column: 1, min: 0) full = TRUE, # TRUE: occupy a full circle, FALSE : semi-circle radius = TRUE, # the radii corresponding to each variable in the data will be drawn frame.plot = TRUE, # if TRUE, the plot region is framed main = &quot;Star plot - means of multivariate by Car Type&quot;, # a main title for the plot cex = 1, # size of label character (by default, cex = 1) # labels = NULL # if NULL, no attempt is made to construct labels lwd = 1, # line width (by default, lwd = 1) key.loc = c(7.5, 1.5) # vector with x and y coordinates of the unit key ) 11.2.3.2 stars() 함수로 레이터 차트 그리기 이전 포스팅에서 소개했던 레이더 차트 or 거미줄 그림(radar chart, or spider plot)도 stars() 함수로 그릴 수 있습니다. 별 그래프(star plot)이 개별 관측치마다 location을 부여하여 하나씩 다변량 그래프를 그린 것이라면, 레이더 차트(radar chart) or 거미줄 그림(spider plot)은 하나의 공통된 location을 중심점으로 하여 관측치들을 중첩하여 그린 다변량 그래프입니다. locations = c(0, 0)으로 중심점을 한개로 통일하였고, key.loc = c(0, 0) 으로 똑 같이 지정해주어서 이 중심점 좌표를 기준으로 변수명을 labeling 할 수 있게 하였습니다. radius = FALSE 로 바꾸어서 반지름 선은 표시하지 않게끔 하였습니다. 6개 차종(Type)의 그래프가 중첩이 되다 보니 radius = TRUE 로 했더니 선이 겹쳐서 아예 안보이는게 있어서요. 관측치들의 다변량 변수 간에 존재하는 패턴에 대해서 관심이 있는 분석가라면 아무래도 그룹별로 선 색깔을 달리하여 그린 레이더 차트 (or 거미줄 그림)가 별 그래프(star chart)보다는 좀더 유용한 편입니다. col.lines = c(1:6) 옵션으로 6개 차종(Type)별 색깔을 구분하였습니다. 범례(legend)는 legend(x= , y= , ...) 함수로 추가를 하였습니다. x, y 좌표는 몇 번 숫자를 넣어보고 시행착오를 거치면서 적당한 좌표를 찾아나가야 합니다. “topright,” “topleft” 이런 식으로 범례 좌표를 지정했더니 레이더 차트랑 자꾸 겹쳐서요. ^^; # radar chart (or spider chart) stars(mean_by_Type[, 2:7], locations = c(0, 0), key.loc = c(0, 0), scale = TRUE, radius = FALSE, cex = 1, lty = 2, col.lines = c(1:6), lwd = 2, main = &quot;radar chart - means of multivariate by Car Type&quot; ) legend(x=1, y=1, legend = mean_by_Type$Type, lty = 2, col = c(1:6), lwd = 2) 위에 stars() 함수로 레이더 차트를 그리기는 했는데요, 이전 포스팅에서 fmsb Package의 radarchart() 함수로 그린 radar chart 보다는 가독성이 좀 떨어져보입니다. 여러 개의 그룹을 레이더 차트 (radar chart)로 보려면 fmsb Package의 radarchart() 함수를 사용하고, 개별 그룹 단위로 분리해서 보려면 graphics Package의 stars() 함수로 별 그림 (star plot)을 그려서 보면 좋을 것 같습니다. 다음 번에는 평행 좌표 그림 (parallel coordinate plot)에 대해서 알아보겠습니다. 11.2.4 나이팅게일 차트 11.2.4.1 나이팅 게일 차트 소개 나이팅 게일의 사망원인 도표 이번 포스팅에서는 비주얼라이즈디스에서 제공하는 데이터를 가지고 스타차트, 나이팅게일 차트를 만드는 과정을 살펴보겠습니다. 먼저 R-Studio를 실행하고, 데이터를 불러오는 것으로 시작합니다. 11.2.4.2 데이터 불러오기 crime &lt;- read.csv(&quot;http://datasets.flowingdata.com/crimeRatesByState-formatted.csv&quot;) 이렇게 R-studio에서 데이터를 확인 할 수 있습니다. 11.2.4.3 데이터 전처리 다음으로는 스타차트 명령어를 사용하기 전에, 데이터를 다듬는 과정입니다. 불러온 데이터를 살펴보면 이렇게 첫 번째 열이 주의 이름이 아니라, 숫자로 설정되어 있습니다. 이를 주 이름으로 변경하도록 하겠습니다. row.names(crime) &lt;- crime$state crime &lt;- crime[,2:7] 이렇게 첫 번째 열이 원하던 대로 주 이름으로 변경되었습니다. 11.2.4.4 stars() 함수로 차트 그리기 이제 스타차트를 생성하는 명령어를 입력해봅니다. stars(crime) 스타차트의 모양새를 갖추긴 했지만, 뭔가 균형도 안맞고 복잡해 보입니다. 이를 조정하기 위해 flip.labels변수를 조정해 줍니다. stars(crime, flip.labels=FALSE) flip.labels설정을 기본값인 TRUE에서 FALSE로 변경한 결과입니다. 이전보다 확실이 안정된 느낌입니다. 그리고 key.loc=c(6, 2)를 지정해 준다. stars(crime, flip.labels=FALSE, key.loc=c(6, 2)) 그 다음 이 스타차트를 절반만 사용해서 표시하는 방법으로 full = FALSE를 지정해 준다. stars(crime, flip.labels=FALSE, key.loc=c(6, 2), full=FALSE) 이처럼 이전 명령어에서 ’full’을 FALSE로 설정해 주면 됩니다. 실행하면 plot창에서 확인 하실 수 있습니다. 그리고 그 다음으로 살펴볼 것은 ’나이팅게일 차트’입니다. 11.2.4.5 나이팅 게일 차트 그리기 지금까지 사용한 명령어에서 다른 부분을 추가하면 나이팅게일차트로 표현이 가능합니다. stars(crime, flip.labels=FALSE, key.loc=c(6, 2), draw.segments=TRUE) draw.segments 부분을 TRUE로 설정해주면 이렇게 알록달록 나이팅게일차트를 얻을 수 있습니다.^^ 만들어진 차트를 일러스트레이터를 이용해서 보정해보면 좋은 결과가 있을 것 같습니다^^. "],["평행-좌표-그림-parallel-coordinate-plot-parcoord.html", "11.3 평행 좌표 그림 (parallel coordinate plot) : parcoord()", " 11.3 평행 좌표 그림 (parallel coordinate plot) : parcoord() 이번 포스팅에서는 (3) 평행 좌표 그림 (parallel coordinate plot)에 대해서 소개하겠습니다. 11.3.1 데이터 세트 MASS Package의 parcoord() 함수를 사용하겠으며, 예제 데이터 역시 MASS Package에 내장된 Cars93 데이터 프레임의 차종(Type)별로 선모양(line type)과 색깔(color)을 달리하여 가격(Price), 고속도로연비(MPG.highway), 마력(Horsepower), 분당회전수(RPM), 길이(Length), 무게(Weight) 변수를 가지고 그래프를 그려보겠습니다. ##-------------------------------------- ## parallel coordinate plot ##-------------------------------------- library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 11.3.2 데이터 전처리 차종(Type)별로 선 모양(lty)과 선 색깔(col)을 다르게 하기 위해서 데이터 전처리를 해보겠습니다. 차종이 현재는 “Compact,” “Large” 등과 같이 character 로 되어있는데요, 1, 2, …, 6 의 numeric 으로 변환하겠습니다. # making Type_number variable to put line type and color by Car Type Cars93_1 &lt;- transform(Cars93, Type_no = ifelse(Type == &quot;Compact&quot;, 1, ifelse(Type == &quot;Large&quot;, 2, ifelse(Type == &quot;Midsize&quot;, 3, ifelse(Type == &quot;Small&quot;, 4, ifelse(Type == &quot;Sporty&quot;, 5, 6))))) ) # checking top 10 observations head(Cars93_1[,c(&quot;Type&quot;, &quot;Type_no&quot;)], n=10) ## Type Type_no ## 1 Small 4 ## 2 Midsize 3 ## 3 Compact 1 ## 4 Midsize 3 ## 5 Midsize 3 ## 6 Midsize 3 ## 7 Large 2 ## 8 Large 2 ## 9 Midsize 3 ## 10 Large 2 11.3.3 평행 좌표 그림 그리기 이제 준비가 되었네요. MASS Package의 parcoord() 함수를 사용해서 평행 좌표 그림(parallel coordinate plot)을 그려보겠습니다. Cars93_1[, c(\"MPG.highway\", \"RPM\", \"Horsepower\", \"Weight\", \"Length\", \"Price\")] 은 평행좌표그림을 그릴 대상 변수만 선별해 오는 명령문입니다. 위에서 Cars93_1 이라는 새로운 데이터 프레임에 Type_no 라는 numeric 변수를 만들었는데요, 선 유형(lty, line type)과 색깔(col, color)를 Cars93_1$Type_no 로 지정을 해줘서 차종(Type)에 따라서 선 유형과 색깔이 달라지게 했습니다. var.label = TRUE 옵션을 설정하면 각 변수별로 minimum value, maximum value 가 하단과 상단에 표기됩니다. main = \"parallel coordinate plot of Cars93 by Type\" 옵션은 그래프에 제목 넣을 때 사용합니다. 아래 그래프 상단 우측에 범례가 들어가 있는데요, legend() 함수를 사용해서 추가한 것입니다. # parallel coordinate plot library(MASS) parcoord(Cars93_1[, c(&quot;MPG.highway&quot;, &quot;RPM&quot;, &quot;Horsepower&quot;, &quot;Weight&quot;, &quot;Length&quot;, &quot;Price&quot;)], lty = Cars93_1$Type_no, col = Cars93_1$Type_no, var.label = TRUE, main = &quot;parallel coordinate plot of Cars93 by Type&quot;) # putting legend legend(&quot;topright&quot;, legend = c(&quot;Compact&quot;, &quot;Large&quot;, &quot;Midsize&quot;, &quot;Small&quot;, &quot;Sporty&quot;, &quot;Van&quot;), lty = c(1:6), col = c(1:6), lwd = 2, # line width cex = 0.7) # character size 다음번 포스팅에서는 3차원 산포도 (3 dimensional scatter plot)에 대해서 소개하도록 하겠습니다. "],["차원-산포도-3-dimensional-scatter-plot-scatterplot3d.html", "11.4 3차원 산포도 (3 dimensional scatter plot) : scatterplot3d()", " 11.4 3차원 산포도 (3 dimensional scatter plot) : scatterplot3d() 이번 포스팅에서는 (4) 3차원 산포도 (3 dimensional scatter plot)에 대해서 소개하겠습니다. 3차원 그래프를 그릴 수 있는 Package가 여러개 있는데요, 그 중에서도 3차원 scatter plot에 특화된 scatterplot3d Package 의 scatterplot3d() 함수를 설명해보겠습니다. 11.4.1 데이터 세트 예제로 사용할 데이터는 MASS Package에 내장된 Cars93 데이터 프레임의 고속도로연비(MPG.highway), 마력(Horsepower), 무게(Weight) 변수들입니다. ##---------------------------------------- ## 3 dimensional scatter plot ##---------------------------------------- library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... 11.4.2 3차원 산포도 11.4.2.1 패키지 불러오기 library(scatterplot3d)로 패키지를 로딩합니다. # install.packages(&quot;scatterplot3d&quot;) library(scatterplot3d) 11.4.2.2 scatterplot3d() 함수의 형식 scatterplot3d(x, y, z, ...)로 3차원 그래프의 x, y, z 좌표(coordinate)를 지정해줍니다. 아래 예제에서는 x축에 무게(Weight), y축에는 마력(Horsepower), z축에는 연비(MPG.highway)를 할당하였습니다. type = \"h\" 는 수직선으로 표현하라는 옵션입니다. “p”는 점으로 표현, “l”은 선으로 표현하라는 의미입니다. 아래 예시의 경우는 3차원 공간에 나타내다 보니 “p”나 “l”보다는 “h”가 점과 x, y축 기준 수직선이 함께 보여서 인지하기에 더 수월하기에 type = \"h\"로 해서 그려보았습니다. scale.y = 0.7 은 x축과 z축을 기준으로 상대적으로 y축은 0.7 배로 해서 나타내라는 뜻입니다. 아래의 프로그램을 복사한 다음에 숫자를 바꿔서 한번 그려보시면 그래프가 어떻게 바뀌는지 금방 이해하실 겁니다. angle = 50 은 x와 y축의 각도를 뜻합니다. scale.y 와 angle 옵션의 숫자를 바꿔가면서 분석가가 원하는 길이, 각도가 나올 때까지 몇 번 trial and error 로 시도를 해보시면 됩니다. highlight.3d = TRUE 옵션은 y축의 좌표를 기준으로 색깔이 달라지게 하라는 의미입니다. 아래 그래프의 경우 y축 좌표 값이 작을 수록 빨간색, y축 좌표값이 클수록 검정색으로 자동으로 바뀌었습니다. 만약 highlight.ed = FALSE 라고 지정하면 그냥 y축 좌표값이 어떻게 되던간에 모두 검정색으로 나오게 되므로 3차원의 공간감을 나타내는데 부족함이 있습니다. 따라서 highlight.3d = TRUE 옵션 사용을 권장합니다. box = TRUE 옵션은 아래에 파란색(col.axis = \"blue\")으로 표시된 부분을 그리라는 뜻입니다. default 는 box = TRUE 이므로 별도로 명기하지 않아도 되며, 표기하기 싫을 때는 box = FALSE 라고 표기해야 겠지요. grid = TRUE 는 아래의 예에서 회색(col.grid = \"gray\")으로 표시된 부분을 나타낼지 정하는 옵션입니다. 이 역시 default 는 grid = TRUE 이므로 별도로 명기하지 않아도 되며, grid 를 제외하고 싶은 때는 grid = FALSE 라고 옵션을 부여하면 됩니다. mar = c(3, 4, 4, 3) 은 아래쪽, 왼쪽, 위쪽, 오른쪽의 순서대로 margin을 부여하는 옵션입니다. margin도 숫자를 조금씩 바꿔가면서 한번 시험해보시기 바랍니다. 그래프가 margin에 따라서 조금씩 바뀌는걸 알 수 있을 겁니다. 귀찮으면 그냥 default margin c(5.1, 4.1, 4.1, 2.1) 을 사용하면 되겠습니다(mar 옵션 미사용하면 default margin 적용됨). xlab, ylab, zlab 은 x축, y축, z축에 label 부여할 때 사용하는 옵션입니다. main = “xxx”은 제목 붙이는 옵션이구요. 11.4.2.3 3차원 산포도 그리기 x &lt;- Cars93$Weight y &lt;- Cars93$Horsepower z &lt;- Cars93$MPG.highway # 3 dimensional scatter plotting Cars93_3d &lt;- scatterplot3d(x, y, z, type = &quot;h&quot;, # &quot;p&quot; for point, &quot;l&quot; for line, &quot;h&quot; for vertical lines to x-y-plane pch=16, # symbol, character scale.y = 0.7, # scale of y axis related to x- and z axis angle = 50, # angle between x and y axis highlight.3d=TRUE, # points will be drawn in different colors related to y coordinates box = TRUE, # a logical value indicating whether a box should be drawn around the plot col.axis=&quot;blue&quot;, # the color to be used for axis grid = TRUE, # a logical value indicating whether a grid should be drawn on the plot col.grid=&quot;gray&quot;, # the color to be used for grid mar = c(3, 4, 4, 3), # margin : c(bottom, left, top, right) xlab = &quot;x_Weight&quot;, # label for the x ylab = &quot;y_Horsepower&quot;, # label for the y zlab = &quot;z_MPG.highway&quot;, # label for the z main=&quot;3 dimensional scatter plot of Cars93&quot;) # main title 11.4.2.4 색상 지정 혹시 색깔을 좀더 다양하게 해보고 싶다면 아래처럼 color 옵션을 사용하면 됩니다. rainbow color를 적용해보았습니다. 저는 위에서 그린 highlight.3d = TRUE 옵션이 아래의 color = rainbowcolor 로 화려하게 그린 그래프보다 시각적으로 더 인지하기에 좋아 보이네요. 아래 그림은 좀 어지럽게 느껴지구요. # using rainbow color dim(Cars93) ## [1] 93 27 rainbowcolor &lt;- rainbow(93) # number 93 indicate 93 observations of Cars93 dataframe Cars93_3d &lt;- scatterplot3d(x, y, z, type = &quot;h&quot;, # &quot;p&quot; for point, &quot;l&quot; for line, &quot;h&quot; for vertical lines to x-y-plane pch=16, # symbol, character scale.y = 0.7, # scale of y axis related to x- and z axis angle = 50, # angle between x and y axis color = rainbowcolor, # colors of points in the plot box = TRUE, # a logical value indicating whether a box should be drawn around the plot col.axis=&quot;blue&quot;, # the color to be used for axis grid = TRUE, # a logical value indicating whether a grid should be drawn on the plot col.grid=&quot;gray&quot;, # the color to be used for grid mar = c(3, 4, 4, 3), # margin : c(bottom, left, top, right) xlab = &quot;x_Weight&quot;, # label for the x ylab = &quot;y_Horsepower&quot;, # label for the y zlab = &quot;z_MPG.highway&quot;, # label for the z main=&quot;3 dimensional scatter plot of Cars93 - using rainbow color&quot;) # main title 11.4.2.5 회귀모형 표시하기 다음으로 Cars93_lm &lt;- lm(MPG.highway ~ Weight + Horsepower) 를 사용해서 x축 무게(Weight)와 y축 마력(Horsepower)와 z축 고속도로연비(MPG.highway) 간의 회귀모형을 적합시킨 후에, 3D scatter plot에 회귀평면(regression plane)을 그려보도록 하겠습니다. 보통 2차원 산포도를 그리고 선형회귀모형을 적합시킨 후에 선형회귀선을 2차원 산포도에 추가로 그려놓고는 했었을 것입니다. 아래 예시는 z ~ x + y 로 회귀모형을 적합시켜서 3차원 그래프로 그린 것인데요, 아무래도 2차원 그래프보다는 좀 이해하기가 어렵습니다. # Adding a regression plane to the &quot;scatterplot3d&quot; attach(Cars93) ## The following object is masked _by_ .GlobalEnv: ## ## Cylinders ## The following objects are masked from Cars93 (pos = 13): ## ## AirBags, Cylinders, DriveTrain, EngineSize, Fuel.tank.capacity, ## Horsepower, Length, Luggage.room, Make, Man.trans.avail, ## Manufacturer, Max.Price, Min.Price, Model, MPG.city, MPG.highway, ## Origin, Passengers, Price, Rear.seat.room, Rev.per.mile, RPM, ## Turn.circle, Type, Weight, Wheelbase, Width Cars93_lm &lt;- lm(MPG.highway ~ Weight + Horsepower) Cars93_3d$plane3d(Cars93_lm, lty.box = &quot;solid&quot;) ## Error in segments(x, z1, x + y.max * yx.f, z2 + yz.f * y.max, lty = ltya, : plot.new has not been called yet detach(Cars93) 위의 내용은 Error 발생…. https://stackoverflow.com/questions/20448539/add-yz-and-xz-grid-to-scatterplot3d https://data-se.netlify.app/2019/10/21/some-ways-for-plotting-3d-linear-models/ 11.4.3 영화 Minority Report 만약 위의 그래프를 톰크루즈가 주연으로 나왔던 영화 minority report 처럼 3차원 그래프를 상, 하, 좌, 우로 자유자재로 돌려볼 수 있다면 아마도 좀더 데이터의 분포 형태를 좀더 인지하기가 쉬울 것입니다. 아쉽게도 scatterplot3d Package는 이 기능을 지원하지 않는데요, 혹시 이 기능을 원하신다면 3D 그래프를 회전시키면서 볼 수 있는 다른 오픈소스를 찾아보셔야 할 거예요. [ 영화 Minority Report 의 한 장면 ] Youtube 동영상 : https://youtu.be/PJqbivkm0Ms scatterplot3d Package에 대해서 좀더 알고 싶은신 분, 다른 예제를 참고하고 싶으신 분은 아래의 Reference를 참고하시기 바랍니다. [Reference]https://cran.r-project.org/web/packages/scatterplot3d/scatterplot3d.pdf "],["체르노프-얼굴그림-chernoff-faces-aplpack-package-faces-함수.html", "11.5 체르노프 얼굴그림 (Chernoff faces) : aplpack package, faces() 함수", " 11.5 체르노프 얼굴그림 (Chernoff faces) : aplpack package, faces() 함수 이번 포스팅에서는 (5) 체르노프 얼굴그림 (Chernoff faces)에 대해서 소개하겠습니다. 체르노프 얼굴그림은 다변량 변수의 속성값들을 아래의 표에 나오는 것처럼 15가지의 얼굴의 생김새(얼굴 높이, 얼굴 넓이, 입 높이, 입 넓이…등) 특성에 매핑해서 얼굴 모양이 달라지게 하는 방식입니다. 얼굴 특성 (face characteristics) 다변량 변수 (multivariate mapping) 1. 얼굴의 높이 “height of face” “Price” 2. 얼굴의 넓이 “width of face” “MPG.highway” 3. 얼굴의 구조 “structure of face” “Horsepower” 4. 입의 높이 “height of mouth” “RPM” 5. 입의 넓이 “width of mouth” “Length” 6. 웃음 “smiling” “Weight” 7. 눈의 높이 “height of eyes” “Price” 8. 눈의 넓이 “width of eyes” “MPG.highway” 9. 머리카락 높이 “height of hair” “Horsepower” 10. 머리카락 넓이 “width of hair” “RPM” 11. 헤어스타일 “style of hair” “Length” 12. 코 높이 “height of nose” “Weight” 13. 코 넓이 “width of nose” “Price” 14. 귀 넓이 “width of ear” “MPG.highway” 15. 귀 높이 “height of ear” “Horsepower” 체르노프 얼굴그림은 얼굴 모양을 가지고 데이터 관측치들의 특성을 직관적으로 파악할 수 있다는 장점이 있습니다. 다만, 각 변수가 얼굴 모양의 어느 특성에 매핑이 되었는지를 확인하고자 한다면 앞서 살펴본 레이터 차트나 별그림, 평행좌표그림 등에 비해 불편한 편이고, 왠지 official한 느낌은 덜 듭니다. 그래서 저 같은 경우는 회사에서 보고서에 체르노프 얼굴그림을 사용해본 적은 아직까지는 없습니다. ^^; 그래도 다변량 데이터를 신속하게, 직관적으로 탐색적분석 하는 용도로는 알아듬직 하므로 이번 포스팅을 이어가 보겠습니다. 11.5.1 데이터 세트 예제에 사용할 데이터는 MASS Package에 내장되어있는 Cars93 dataframe을 사용하겠으며, 전체 93개의 관측치가 있는데요, 이를 모두 그리자니 너무 많아서요, 1번째 관측치부터 20번째 관측치까지만 사용하겠습니다. 체르노프 얼굴그림 그릴 때 사용할 변수로는 가격(\"Price\"), 고속도로연비(\"MPG.highway\"), 마력(\"Horsepower\"), RPM(\"RPM\"), 차길이(\"Length\"), 차무게(\"Weight\")의 5개 만 선별해서 사용하겠습니다. 아래처럼 Cars93_1 이라는 새로운 이름의 데이터프레임을 만들었습니다. # dataset preparation library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... # sampling observations from 1st to 20th, selecting 5 variables Cars93_1 &lt;- Cars93[c(1:20),c(&quot;Price&quot;, &quot;MPG.highway&quot;, &quot;Horsepower&quot;, &quot;RPM&quot;, &quot;Length&quot;, &quot;Weight&quot;)] Cars93_1 ## Price MPG.highway Horsepower RPM Length Weight ## 1 16 31 140 6300 177 2705 ## 2 34 25 200 5500 195 3560 ## 3 29 26 172 5500 180 3375 ## 4 38 26 172 5500 193 3405 ## 5 30 30 208 5700 186 3640 ## 6 16 31 110 5200 189 2880 ## 7 21 28 170 4800 200 3470 ## 8 24 25 180 4000 216 4105 ## 9 26 27 170 4800 198 3495 ## 10 35 25 200 4100 206 3620 ## 11 40 25 295 6000 204 3935 ## 12 13 36 110 5200 182 2490 ## 13 11 34 110 5200 184 2785 ## 14 15 28 160 4600 193 3240 ## 15 16 29 110 5200 198 3195 ## 16 16 23 170 4800 178 3715 ## 17 17 20 165 4000 194 4025 ## 18 19 26 170 4200 214 3910 ## 19 38 25 300 5000 179 3380 ## 20 18 28 153 5300 203 3515 11.5.2 체로노프 얼굴그림 그리기 11.5.2.1 패키지 불러오기 체로노프 얼굴그림을 그리기 위해 R의 aplpack Package의 faces() 함수를 사용하겠습니다. install.package() 함수를 써서 설치하고, library() 함수로 호출해 보겠습니다. # install.packages(&quot;aplpack&quot;) library(aplpack) 11.5.2.2 faces() 함수의 형식 이제 faces() 함수로 체르노프 얼굴 그림을 그려보겠습니다. faces(dataset, face.type = 0/1/2, main = \"title\") 의 형식으로 사용합니다. face.type = 0 (line drawing faces)은 색깔 없이 선으로만 얼굴을 그립니다. face.type = 1 (the elements of the faces are painted)는 색깔도 같이 칠해서 얼굴을 그려줍니다. face.type = 2 (Santa Claus faces are drawn)는 산타클로스 얼굴에 색을 칠해서 그려주고요. 아래에 하나씩 예를 들어보겠습니다. 11.5.2.3 체르노프 얼굴 그림 그리기 11.5.2.3.1 face.type = 0 (line drawing faces) # face.type = 0 : line drawing faces faces(Cars93_1, face.type = 0, main = &quot;Chernoff faces: face.type = 0&quot;) ## effect of variables: ## modified item Var ## &quot;height of face &quot; &quot;Price&quot; ## &quot;width of face &quot; &quot;MPG.highway&quot; ## &quot;structure of face&quot; &quot;Horsepower&quot; ## &quot;height of mouth &quot; &quot;RPM&quot; ## &quot;width of mouth &quot; &quot;Length&quot; ## &quot;smiling &quot; &quot;Weight&quot; ## &quot;height of eyes &quot; &quot;Price&quot; ## &quot;width of eyes &quot; &quot;MPG.highway&quot; ## &quot;height of hair &quot; &quot;Horsepower&quot; ## &quot;width of hair &quot; &quot;RPM&quot; ## &quot;style of hair &quot; &quot;Length&quot; ## &quot;height of nose &quot; &quot;Weight&quot; ## &quot;width of nose &quot; &quot;Price&quot; ## &quot;width of ear &quot; &quot;MPG.highway&quot; ## &quot;height of ear &quot; &quot;Horsepower&quot; 11.5.2.3.2 face.type = 1 (the elements of the faces are painted) # face.type = 1 : the elements of the faces are painted faces(Cars93_1, face.type = 1, main = &quot;Chernoff faces: face.type = 1&quot;) ## effect of variables: ## modified item Var ## &quot;height of face &quot; &quot;Price&quot; ## &quot;width of face &quot; &quot;MPG.highway&quot; ## &quot;structure of face&quot; &quot;Horsepower&quot; ## &quot;height of mouth &quot; &quot;RPM&quot; ## &quot;width of mouth &quot; &quot;Length&quot; ## &quot;smiling &quot; &quot;Weight&quot; ## &quot;height of eyes &quot; &quot;Price&quot; ## &quot;width of eyes &quot; &quot;MPG.highway&quot; ## &quot;height of hair &quot; &quot;Horsepower&quot; ## &quot;width of hair &quot; &quot;RPM&quot; ## &quot;style of hair &quot; &quot;Length&quot; ## &quot;height of nose &quot; &quot;Weight&quot; ## &quot;width of nose &quot; &quot;Price&quot; ## &quot;width of ear &quot; &quot;MPG.highway&quot; ## &quot;height of ear &quot; &quot;Horsepower&quot; 11.5.2.3.3 face.type = 2 (Santa Claus faces are drawn) # face.type = 2 : Santa Claus faces are drawn faces(Cars93_1, face.type = 2, main = &quot;Chernoff faces: face.type = 2&quot;) ## effect of variables: ## modified item Var ## &quot;height of face &quot; &quot;Price&quot; ## &quot;width of face &quot; &quot;MPG.highway&quot; ## &quot;structure of face&quot; &quot;Horsepower&quot; ## &quot;height of mouth &quot; &quot;RPM&quot; ## &quot;width of mouth &quot; &quot;Length&quot; ## &quot;smiling &quot; &quot;Weight&quot; ## &quot;height of eyes &quot; &quot;Price&quot; ## &quot;width of eyes &quot; &quot;MPG.highway&quot; ## &quot;height of hair &quot; &quot;Horsepower&quot; ## &quot;width of hair &quot; &quot;RPM&quot; ## &quot;style of hair &quot; &quot;Length&quot; ## &quot;height of nose &quot; &quot;Weight&quot; ## &quot;width of nose &quot; &quot;Price&quot; ## &quot;width of ear &quot; &quot;MPG.highway&quot; ## &quot;height of ear &quot; &quot;Horsepower&quot; 산타클로스 얼굴은 정신이 하도 산만해서 관측치들간의 유사성이나 차이가 눈에 잘 안들어오네요. @@~ 11.5.2.3.4 체로노프 얼굴그림에 이름 추가하기 : labels = # putting labels as face names : labels faces(Cars93_1, face.type = 1, labels = Cars93[1:20,]$Model, main = &quot;putting labels as face names : labels = &quot;) ## effect of variables: ## modified item Var ## &quot;height of face &quot; &quot;Price&quot; ## &quot;width of face &quot; &quot;MPG.highway&quot; ## &quot;structure of face&quot; &quot;Horsepower&quot; ## &quot;height of mouth &quot; &quot;RPM&quot; ## &quot;width of mouth &quot; &quot;Length&quot; ## &quot;smiling &quot; &quot;Weight&quot; ## &quot;height of eyes &quot; &quot;Price&quot; ## &quot;width of eyes &quot; &quot;MPG.highway&quot; ## &quot;height of hair &quot; &quot;Horsepower&quot; ## &quot;width of hair &quot; &quot;RPM&quot; ## &quot;style of hair &quot; &quot;Length&quot; ## &quot;height of nose &quot; &quot;Weight&quot; ## &quot;width of nose &quot; &quot;Price&quot; ## &quot;width of ear &quot; &quot;MPG.highway&quot; ## &quot;height of ear &quot; &quot;Horsepower&quot; 11.5.3 산포도에 체르노프 얼굴그림 겹쳐 그르기 먼저 산포도를 plot() 함수를 사용해서 그립니다. 그 다음에 faces() 함수로 체르노프 얼굴그림을 실행시킵니다. 이때 scale = TRUE, plot = FALSE 옵션을 사용해줍니다. 그래프는 화면에 안나타나구요, (3)번 스텝에서 그래프가 그려질 수 있도록 데이터가 준비된 상태입니다. plot.faces() 함수를 사용해서 산포도 위에 (2)번에서 생성해 놓은 체르노프 얼굴그림을 겹쳐서 그려줍니다. width 와 height 는 x축과 y축의 단위를 보고서 trial &amp; error 를 해보면서 숫자를 조금씩 바꿔가면서 그려본 후에 가장 마음에 드는 걸로 선택하면 되겠습니다. 체르노프 얼굴그림을 산포도에 겹쳐서 그리니 제법 유용한 다차원 그래프이지 않은가요? ^^ # Overlapping Chernoff faces over scatter plot (MPG.highway*Weight) plot(Cars93_1[,c(&quot;MPG.highway&quot;, &quot;Weight&quot;)], bty=&quot;n&quot;, # To make a plot with no box around the plot area main = &quot;Chernoff faces of Cars93&quot;) Cars93_1_faces &lt;- faces(Cars93_1, scale = TRUE, plot=FALSE) ## effect of variables: ## modified item Var ## &quot;height of face &quot; &quot;Price&quot; ## &quot;width of face &quot; &quot;MPG.highway&quot; ## &quot;structure of face&quot; &quot;Horsepower&quot; ## &quot;height of mouth &quot; &quot;RPM&quot; ## &quot;width of mouth &quot; &quot;Length&quot; ## &quot;smiling &quot; &quot;Weight&quot; ## &quot;height of eyes &quot; &quot;Price&quot; ## &quot;width of eyes &quot; &quot;MPG.highway&quot; ## &quot;height of hair &quot; &quot;Horsepower&quot; ## &quot;width of hair &quot; &quot;RPM&quot; ## &quot;style of hair &quot; &quot;Length&quot; ## &quot;height of nose &quot; &quot;Weight&quot; ## &quot;width of nose &quot; &quot;Price&quot; ## &quot;width of ear &quot; &quot;MPG.highway&quot; ## &quot;height of ear &quot; &quot;Horsepower&quot; plot.faces(Cars93_1_faces, Cars93_1[,c(&quot;MPG.highway&quot;)], Cars93_1[,c(&quot;Weight&quot;)], width = 2, height = 250) 체르노프 얼굴그림에 대해서 좀더 알고 싶은 분은 아래의 Reference를 참고하시기 바랍니다. [ Reference ] http://www.inside-r.org/packages/cran/aplpack/docs/faces 11.5.4 pairs() 함수를 사용한 산포도 행렬 그리기 11.5.5 R 모자이크 그림: vcd패키지 mosaic() 함수 "],["r-ggplot2-연속확률분포-곡선-stat-function.html", "12 R ggplot2 연속확률분포 곡선, stat_function()", " 12 R ggplot2 연속확률분포 곡선, stat_function() 통계에서 빼놓을 수 없는 기본 개념 중의 하나가 확률입니다. 모집단에서 표본을 추출할 때 랜덤 샘플링, 층화 랜덤 샘플링 등과 같이 확률을 사용합니다. 추정과 검정에서도 확률분포를 사용합니다. 회귀분석, 판별분석 등에서도 변수가 정규분포를 따르고 있는지 검정합니다. 시뮬레이션을 할 때 모집단의 확률분포에 따라 난수를 발생시키기도 합니다. 특히, 통계를 좀 공부했던 분이라면 정규분포는 알고 있을 듯 합니다. 하지만, 그 외에 분포들은 들어는 봤어도 모양이 어떻게 생겼는지, 어떤 때 사용하는 것인지 정확히 모르고 있는 경우가 더 많을 듯 합니다. R ggplot2를 활용해서 연속확률분포 곡선을 그려보면 분포별로 모양을 이해하는데 도움이 되겠지요. 그리고 모수에 따라서 모양이 어떻게 바뀌는지도 확인해 볼 수 있겠구요. 이번 포스팅에서는 주로 ’d’로 시작하는 밀도 함수 (Density Function) 에 대해서 정규분포(norm), t-분포(t), 카이제곱분포(chisq), 지수분포(exp), F분포(f), 감마분포(gamma), 균등분포(unif) 등의 분포에 대해서 ggplot2로 그리는 방법을 소개해보겠습니다. "],["연속확률분포-함수.html", "12.1 연속확률분포 함수", " 12.1 연속확률분포 함수 [ 연속확률분포 종류별 / 함수 종류별 ggplot2 그리기 함수 종합표 ] 분포 밀도 함수d 누적분포 함수p 분위수 함수 q 난수 발생 r 정규분포 norm() dnorm() pnorm() qnorm() rnorm() t-분포 t() dt() pt() qt() rt() 카이제곱분포 chisq() dchisq() pchisq() qchisq() rchisq() 지수분포 exp() dexp() pexp() qexp() rexp() F분포 f() df() pf() qf() rf() 감마분포 gamma() dgamma() pgamma() qgamma() rgamma() 균등분포 unif() dunif() punif() qunif() runif() "],["패키지-불러오기-2.html", "패키지 불러오기", " 패키지 불러오기 ggplot2는 별도의 설치 및 호출이 필요한 패키지이므로 아래의 절차를 먼저 실행합니다. # install.packages(&quot;ggplot2&quot;) library(ggplot2) "],["정규분포-함수.html", "12.2 정규분포 함수", " 12.2 정규분포 함수 12.2.1 정규분포 확률밀도곡선 : stat_function(fun = dnorm) # 정규분포 : fun = dnorm ggplot(data.frame(x=c(-3,3)), aes(x=x)) + stat_function(fun=dnorm, colour=&quot;blue&quot;, size=1) + ggtitle(&quot;Normal Distribution&quot;) 12.2.2 정규분포의 특정 구간에만 색깔 넣기 # 함수 특정 구간에 색깔 넣기 dnorm_range &lt;- function(x) { y &lt;- dnorm(x) y[x &lt; -1 | x &gt; 2] &lt;- NA # 이 범위에는 색깔 없음 return(y) } ggplot(data.frame(x=c(-3,3)), aes(x=x)) + stat_function(fun=dnorm, colour=&quot;blue&quot;, size=1) + stat_function(fun=dnorm_range, geom=&quot;area&quot;, fill=&quot;grey&quot;, alpha=0.5) + ggtitle(&quot;Normal Distribution of x~N(0,1) with colour from -1 to 2&quot;) 12.2.3 누적정규분포 (Cummulative Normal Distribution) : stat_function(fun = pnorm) # 누적정규분포 : fun = pnorm ggplot(data.frame(x=c(-3,3)), aes(x=x)) + stat_function(fun=pnorm, colour=&quot;black&quot;, size=1.5) + ggtitle(&quot;Cumulative Normal Distribution of x~N(0,1)&quot;) 12.2.4 정규분포 : 평균과 분산 지정 # 정규분포: 평균과 분산 지정 ggplot(data.frame(x = c(-5, 5)), aes(x=x)) + stat_function(fun=dnorm, args=list(mean=2, sd=1), colour=&quot;black&quot;, size=1.5) + geom_vline(xintercept=2, colour=&quot;grey&quot;, linetype=&quot;dashed&quot;, size=1) + # 평균에 세로 직선 추가 geom_text(x=0, y=0.3, label=&quot;x = N(2, 1)&quot;) + ggtitle(&quot;Normal Distribution of x~N(2,1)&quot;) "],["t-분포-t-distribution-stat-functionfun-dt.html", "12.3 t-분포 (t-Distribution) : stat_function(fun = dt)", " 12.3 t-분포 (t-Distribution) : stat_function(fun = dt) # t-분포 : fun = dt ggplot(data.frame(x=c(-3,3)), aes(x=x)) + stat_function(fun=dt, args=list(df=2), colour=&quot;red&quot;, size=2) + ggtitle(&quot;t-Distribution of df=2&quot;) "],["카이제곱분포-확률밀도곡선-stat-functionfun-dchisq.html", "12.4 카이제곱분포 확률밀도곡선 : stat_function(fun = dchisq)", " 12.4 카이제곱분포 확률밀도곡선 : stat_function(fun = dchisq) # 카이제곱분포 : fun = dchisq ggplot(data.frame(x=c(0,10)), aes(x=x)) + stat_function(fun=dchisq, args=list(df=1), colour=&quot;black&quot;, size=1.2) + geom_text(x=0.6, y=1, label=&quot;df=1&quot;) + stat_function(fun=dchisq, args=list(df=2), colour=&quot;blue&quot;, size=1.2) + geom_text(x=0, y=0.55, label=&quot;df=2&quot;) + stat_function(fun=dchisq, args=list(df=3), colour=&quot;red&quot;, size=1.2) + geom_text(x=0.5, y=0.05, label=&quot;df=3&quot;) + ggtitle(&quot;Chisq-Distribution&quot;) "],["지수분포-exponential-distribution-stat-functionfun-dexp.html", "12.5 지수분포 (Exponential Distribution) : stat_function(fun = dexp)", " 12.5 지수분포 (Exponential Distribution) : stat_function(fun = dexp) # 지수분포 : fun = dexp ggplot(data.frame(x=c(0,10)), aes(x=x)) + stat_function(fun=dexp, colour=&quot;brown&quot;, size=1.5) + ggtitle(&quot;Exponential Distribution&quot;) "],["f-분포-f-distribution-stat-functionfun-df.html", "12.6 F 분포 (F Distribution) : stat_function(fun = df)", " 12.6 F 분포 (F Distribution) : stat_function(fun = df) # F분포 : fun = df ggplot(data.frame(x=c(0,5)), aes(x=x)) + stat_function(fun = stats::df, args=list(df1=9, df2=9), colour=&quot;blue&quot;, size=0.5) + stat_function(fun=stats::df, args=list(df1=10, df2=30), colour=&quot;red&quot;, size=0.5) + stat_function(fun=stats::df, args=list(df1=50, df2=100), colour=&quot;yellow&quot;, size=0.5) + annotate(&quot;segment&quot;, x=3, xend=3.5, y=1.4, yend=1.4, colour=&quot;blue&quot;, size=0.5) + annotate(&quot;segment&quot;, x=3, xend=3.5, y=1.2, yend=1.2, colour=&quot;red&quot;, size=0.5) + annotate(&quot;segment&quot;, x=3, xend=3.5, y=1.0, yend=1.0, colour=&quot;yellow&quot;, size=0.5) + annotate(&quot;text&quot;, x=4.3, y=1.4, label=&quot;F(df1=9, df2=9)&quot;) + annotate(&quot;text&quot;, x=4.3, y=1.2, label=&quot;F(df1=10, df2=30)&quot;) + annotate(&quot;text&quot;, x=4.3, y=1.0, label=&quot;F(df1=50, df2=100)&quot;) + ggtitle(&quot;F Distribution&quot;) "],["감마-분포-gamma-distribution-stat-functionfun-dgamma.html", "12.7 감마 분포 (Gamma Distribution) : stat_function(fun = dgamma)", " 12.7 감마 분포 (Gamma Distribution) : stat_function(fun = dgamma) # 감마 분포 : fun = dgamma ggplot(data.frame(x=c(0, 400)), aes(x=x)) + stat_function(fun=dgamma, args=list(shape=5, rate=0.05), colour=&quot;green&quot;) + ggtitle(&quot;Gamma Distribution of (shape=5, rate=0.05)&quot;) "],["일양-분포-uniform-distribution-stat-functionfun-dunif.html", "12.8 일양 분포 (Uniform Distribution) :stat_function(fun = dunif)", " 12.8 일양 분포 (Uniform Distribution) :stat_function(fun = dunif) # 균등분포 : fun = dunif ggplot(data.frame(x=c(-2,20)), aes(x=x)) + stat_function(fun=dunif, args=list(min = 0, max = 10), colour=&quot;black&quot;, size=1) + ggtitle(&quot;Uniform Distribution of (min=1, max=10)&quot;) 덤으로, 상용로그분포와 사인 함수, 코사인 함수 곡선도 그려보겠습니다. "],["상용로그-분포-common-logarithm-distribution-stat-functionfun-log10.html", "12.9 상용로그 분포 (Common Logarithm Distribution) : stat_function(fun = log10)", " 12.9 상용로그 분포 (Common Logarithm Distribution) : stat_function(fun = log10) # 상용로그분포 : fun = log10 ggplot(data.frame(x=c(0,100)), aes(x=x)) + stat_function(fun=log10, colour=&quot;black&quot;, size=1.5) + geom_vline(xintercept=10, colour=&quot;grey&quot;, linetype=&quot;dashed&quot;, size=1) + geom_vline(xintercept=100, colour=&quot;grey&quot;, linetype=&quot;dashed&quot;, size=1) + ggtitle(&quot;Common Logarithm Distribution&quot;) "],["사인-함수-곡선sine-function-curve-코사인-함수-곡선cosine-function-curve-stat-functionfun-sin-stat-fuctionfun-cos.html", "12.10 사인 함수 곡선(Sine Function Curve), 코사인 함수 곡선(Cosine Function Curve) : stat_function(fun = sin), stat_fuction(fun = cos)", " 12.10 사인 함수 곡선(Sine Function Curve), 코사인 함수 곡선(Cosine Function Curve) : stat_function(fun = sin), stat_fuction(fun = cos) # 사인 함수 : fun = sin, 코사인 함수 : fun = cos ggplot(data.frame(x=c(0,6.28)), aes(x=x)) + stat_function(fun=sin, colour=&quot;blue&quot;, size=1) + geom_text(x=0.2, y=0, label=&quot;sine curve&quot;) + stat_function(fun=cos, colour=&quot;yellow&quot;, size=1) + geom_text(x=0.2, y=1, label=&quot;cosine curve&quot;) + geom_vline(xintercept=3.14, colour=&quot;grey&quot;, linetype=&quot;dashed&quot;, size=1) + # pi값에 세로 직선 추가 geom_vline(xintercept=6.28, colour=&quot;grey&quot;, linetype=&quot;dashed&quot;, size=1) + # 2pi값에 세로 직선 추가 ggtitle(&quot;Sine(blue curve), Cosine(yellow curve) Function&quot;) "],["r-동적-그래프-interactive-plotting-in-r-with-manipulate-package-in-rstudio.html", "13 R 동적 그래프 (Interactive Plotting in R) : with manipulate package in Rstudio", " 13 R 동적 그래프 (Interactive Plotting in R) : with manipulate package in Rstudio 이번 포스팅에서는 Rstudio 에 manipulate 패키지를 설치해서 동적으로 그래프를 조작하는 방법을 소개하겠습니다. (참고로, R에는 shiny, plotly, rpivotTable 등 동적 그래프, 피봇테이블 지원하는 패키지가 여럿 있습니다) 그동안 소개했던 그래프/시각화 방법이 한번 그리고 나면 세팅이 된 상태에서 한번 그려지고 끝입니다. 옵션이나 대상 객체를 바꾸고 싶으면 프로그램 script 창으로 가서 프로그래을 손봐야 하는 번거로움이 있어야 했습니다. 하지만, 이번에 소개하는 manipulate 패키지를 활용한 Rstudio 내에서의 동적 그래프 (Interactive Plotting in Rstudio with manipulate package) 를 보시면 편하고 신기하다는 생각을 하게 될 것 같습니다. manipulate 패키지를 활용하면 동적 그래프 짜는 프로그램이 어렵지도 않습니다. 아래의 3개 유형과 이들을 조합한 4번째 예제를 순서대로 소개하겠습니다. 한국말로 번역하려니 쉽지가 않아서 영어 그대로 표기합니다. ^^; Slider Control) Picker Control) Checkbox Control) Combining Controls 이 기능을 RStudio에서 사용하려면, R 마크다운 문서를 ’Chunk Output in Console’를 선택해 주어야 한다. 그러면 Plots 창에 표시가 된다. "],["데이터-세트-14.html", "13.1 데이터 세트", " 13.1 데이터 세트 실습에 사용할 데이터는 MASS 패키지에 내장된 Cars93 데이터 프레임의 차종(Type), 가격(Price), 고속도로연비(MPG.highway), 무게(Weight) 변수를 사용하겠습니다. library(MASS) str(Cars93) ## &#39;data.frame&#39;: 93 obs. of 27 variables: ## $ Manufacturer : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ... ## $ Model : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ... ## $ Type : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ... ## $ Min.Price : num 12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ... ## $ Price : num 15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ... ## $ Max.Price : num 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ... ## $ MPG.city : int 25 18 20 19 22 22 19 16 19 16 ... ## $ MPG.highway : int 31 25 26 26 30 31 28 25 27 25 ... ## $ AirBags : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ... ## $ DriveTrain : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ... ## $ Cylinders : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ... ## $ EngineSize : num 1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ... ## $ Horsepower : int 140 200 172 172 208 110 170 180 170 200 ... ## $ RPM : int 6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ... ## $ Rev.per.mile : int 2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ... ## $ Man.trans.avail : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Fuel.tank.capacity: num 13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ... ## $ Passengers : int 5 5 5 6 4 6 6 6 5 6 ... ## $ Length : int 177 195 180 193 186 189 200 216 198 206 ... ## $ Wheelbase : int 102 115 102 106 109 105 111 116 108 114 ... ## $ Width : int 68 71 67 70 69 69 74 78 73 73 ... ## $ Turn.circle : int 37 38 37 37 39 41 42 45 41 43 ... ## $ Rear.seat.room : num 26.5 30 28 31 27 28 30.5 30.5 26.5 35 ... ## $ Luggage.room : int 11 15 14 17 13 16 17 21 14 18 ... ## $ Weight : int 2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ... ## $ Origin : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ... ## $ Make : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ... "],["패키지-불러오기-3.html", "13.2 패키지 불러오기", " 13.2 패키지 불러오기 먼저, manipulate 패키지를 별도 설치하고 호출해 보겠습니다. # install.packages(&quot;manipulate&quot;) library(manipulate) ## ## Attaching package: &#39;manipulate&#39; ## The following object is masked from &#39;package:aplpack&#39;: ## ## slider "],["slider-control.html", "13.3 Slider Control", " 13.3 Slider Control slider(start point, end point, step= , initial = ) 의 형태로 슬라이더 조작 옵션을 설정하고, 이 옵션 객체를 그래프의 조작하고자 하는 부분에 할당을 하면 됩니다. 말이 좀 어려운데요, 아래 히스토그램에서 Bin size 를 3부터 100까지의 범위 내에서 5 씩 증가하게끔 해놓고, 처음 만들어졌을 때의 디폴트는 20으로 설정한 예제입니다. 동적 그래프의 특성을 직관적으로 이해할 수 있도록 화면캡쳐와 함께 동영상 캡쳐도 해서 올립니다. 왼쪽의 슬라이드 바를 좌우로 조절할 때마다 우측 plots 창의 히스토그램이 어떻게 바뀌는지 확인해보기 바랍니다. library(MASS) ## Slider Control manipulate( hist(Cars93$Price, breaks = bin_slider), bin_slider=slider(3,100, step=5, initial = 20)) ## Error in manipulate(hist(Cars93$Price, breaks = bin_slider), bin_slider = slider(3, : The manipulate package must be run from within RStudio "],["picker-control.html", "13.4 Picker Control", " 13.4 Picker Control 히스토그램에 대상 변수를 선택할 수 있는 Picker Control 예제입니다. ## Picker Control manipulate( hist(Cars93[, continuous_variable], freq = FALSE, main = continuous_variable), continuous_variable = picker(&quot;MPG.highway&quot;, &quot;Weight&quot;, &quot;Price&quot;)) ## Error in manipulate(hist(Cars93[, continuous_variable], freq = FALSE, : The manipulate package must be run from within RStudio 산포도의 x축, 무게(Weight)과 y축, 고속도로연비(MPG.highway)은 정해져있고, 차종(Type)별로 산포도를 보고 싶을 때 차종(Type)을 왼쪽의 Picker Control 상자로 만들어서 바로 바로 차종별로 선택해 가면서 산포도를 보는 프로그램 예제입니다. manipulate( plot(MPG.highway ~ Weight, data=Cars93[Cars93$Type == Type,]), Type = picker(&quot;Compact&quot;, &quot;Large&quot;, &quot;Midsize&quot;, &quot;Small&quot;, &quot;Sporty&quot;, &quot;Van&quot;)) ## Error in manipulate(plot(MPG.highway ~ Weight, data = Cars93[Cars93$Type == : The manipulate package must be run from within RStudio "],["checkbox-control.html", "13.5 Checkbox Control", " 13.5 Checkbox Control 아래는 Box Plot 에서 IQR(Inter Quartile Range)의 1.5배 기준으로 계산된 Outlier 를 포함시켜서 제시를 할지 아니면 제외시킬지를 Checkbox 로 선택할 수 있게 한 예제입니다. ## Checkbox Control manipulate( boxplot(Price ~ Type, data = Cars93, outline = outline), outline = checkbox(FALSE, &quot;Show outliers&quot;)) ## Error in manipulate(boxplot(Price ~ Type, data = Cars93, outline = outline), : The manipulate package must be run from within RStudio "],["combining-controls.html", "13.6 Combining Controls", " 13.6 Combining Controls 이번에는 Picker Control과 Slider Control 두 개를 함께 사용해 보는 예제입니다. Picker Control 로 대상 변수를 선택할 수 있게 하였고, Slider Control 로 Histogram 의 Bin size 를 조절할 수 있도록 해보았습니다. ## Combining Controls manipulate( hist(Cars93[, continuous_variable], breaks = bin_slider, freq = FALSE, main = continuous_variable), continuous_variable = picker(&quot;MPG.highway&quot;, &quot;Weight&quot;, &quot;Price&quot;), bin_slider = slider(5,50, step=5, initial = 10) ) ## Error in manipulate(hist(Cars93[, continuous_variable], breaks = bin_slider, : The manipulate package must be run from within RStudio 참고자료 https://rfriend.tistory.com/166?category=605866 https://rfriend.tistory.com/167?category=605866 http://www.bloter.net/archives/270142 https://visualize.tistory.com/35 https://rfriend.tistory.com/168?category=605866 https://rfriend.tistory.com/169 https://rfriend.tistory.com/170 https://rfriend.tistory.com/83 https://rfriend.tistory.com/71 https://rfriend.tistory.com/95?category=605866 https://rfriend.tistory.com/97?category=605866 "],["part-5-지리공간-데이터-시각화.html", "Part 5 : 지리공간 데이터 시각화", " Part 5 : 지리공간 데이터 시각화 "],["r에서의-지리공간-데이터-조작.html", "14 R에서의 지리공간 데이터 조작 ", " 14 R에서의 지리공간 데이터 조작 "],["sf-개체-생성.html", "14.1 sf 개체 생성", " 14.1 sf 개체 생성 tidyverse 사용자에게 sf 패키지의 가장 흥미로운 측면 중 하나는 깔끔한 워크 플로우에서 지리공간 데이터로 작업 할 수 있다는 것이다. 이전 패키지 ‘sp’와 달리 ’sf’ 패키지를 사용하는 경우 지리 정보 및 속성 데이터는 개체의 도형이 특별한 리스트 열을 차지하는 공간 데이터 프레임에 함께 저장할 수 있다. 더 빠르다는 것 외에도 일반 데이터 프레임과 같은magrittr 파이프를 통해 sf 개체를 조작하거나 몇 가지 특별한 특성을 가진 하나 이상을 조작 할 수 있다. st_point() 함수, st_linestring() 함수, 그리고 st_polygon()과 같은 sf 패키지의 함수를 사용하여 자신만의sf 객체를 만들 수 있다. 그러나 대부분의 경우 기존의 공간 데이터를 읽어야만 한다. 그것은 일반적으로 st_read ()함수로 수행된다. 예제로 사용되는 shapefile은이 블로그의 관련 GitHub [repository] (https://github.com/seanangio/viz_india)에서 찾을 수 있다. 참고자료 : [india_states.shp 파일 생성하기(./World_Cities.html) "],["패키지-불러오기-4.html", "패키지 불러오기", " 패키지 불러오기 library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 -- ##  tibble 3.0.4  dplyr 1.0.2 ##  tidyr 1.1.2  stringr 1.4.0 ##  readr 1.4.0  forcats 0.5.0 ##  purrr 0.3.4 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::arrange() masks plyr::arrange() ## x purrr::compact() masks plyr::compact() ## x dplyr::count() masks plyr::count() ## x tidyr::expand() masks reshape::expand() ## x dplyr::failwith() masks plyr::failwith() ## x dplyr::filter() masks stats::filter() ## x dplyr::id() masks plyr::id() ## x dplyr::lag() masks stats::lag() ## x dplyr::mutate() masks plyr::mutate() ## x dplyr::order_by() masks doBy::order_by() ## x dplyr::recode() masks car::recode() ## x dplyr::rename() masks plyr::rename(), reshape::rename() ## x dplyr::select() masks MASS::select() ## x purrr::some() masks car::some() ## x dplyr::summarise() masks plyr::summarise() ## x dplyr::summarize() masks plyr::summarize() library(sf) ## Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1 library(rgeos) ## Loading required package: sp ## rgeos version: 0.5-5, (SVN revision 640) ## GEOS runtime version: 3.8.0-CAPI-1.13.1 ## Linking to sp version: 1.4-4 ## Polygon checking: TRUE "],["shp-파일-불러오기.html", "14.2 shp 파일 불러오기", " 14.2 shp 파일 불러오기 한국의 행정구역 지도 중 시/도 지리정보 파일인 CTPRVN.shp를 불러온다. my_KOR_sf &lt;- st_read(&quot;shapefiles/CTPRVN.shp&quot;) ## Reading layer `CTPRVN&#39; from data source `E:\\DV-2021\\bookdown\\shapefiles\\CTPRVN.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 17 features and 3 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 750000 ymin: 1500000 xmax: 1400000 ymax: 2100000 ## projected CRS: PCS_ITRF2000_TM class(my_KOR_sf) ## [1] &quot;sf&quot; &quot;data.frame&quot; my_KOR_sf ## Simple feature collection with 17 features and 3 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 750000 ymin: 1500000 xmax: 1400000 ymax: 2100000 ## projected CRS: PCS_ITRF2000_TM ## First 10 features: ## CTPRVN_CD CTP_ENG_NM ## 1 11 Seoul ## 2 26 Busan ## 3 27 Daegu ## 4 28 Incheon ## 5 29 Gwangju ## 6 30 Daejeon ## 7 31 Ulsan ## 8 36 Sejong-si ## 9 41 Gyeonggi-do ## 10 42 Gangwon-do ## CTP_KOR_NM ## 1 &lt;U+00BC&gt;&lt;U+00AD&gt;&lt;U+00BF&gt;&lt;ef&gt;&lt;U+01AF&gt;&lt;U+00BA&gt;&lt;U+00B0&gt;&lt;U+00BD&gt;&lt;c3&gt; ## 2 &lt;U+00BA&gt;λ걤&lt;U+00BF&gt;&lt;U+00AA&gt;&lt;U+00BD&gt;&lt;c3&gt; ## 3 &lt;U+00B4&gt;뱸&lt;U+00B1&gt;&lt;U+00A4&gt;&lt;U+00BF&gt;&lt;U+00AA&gt;&lt;U+00BD&gt;&lt;c3&gt; ## 4 &lt;c0&gt;&lt;ce&gt;o&lt;U+00B1&gt;&lt;U+00A4&gt;&lt;U+00BF&gt;&lt;U+00AA&gt;&lt;U+00BD&gt;&lt;c3&gt; ## 5 &lt;U+00B1&gt;&lt;U+00A4&gt;&lt;c1&gt;&lt;U+05B1&gt;&lt;U+00A4&gt;&lt;U+00BF&gt;&lt;U+00AA&gt;&lt;U+00BD&gt;&lt;c3&gt; ## 6 &lt;U+00B4&gt;&lt;eb&gt;&lt;c0&gt;&lt;fc&gt;&lt;U+00B1&gt;&lt;U+00A4&gt;&lt;U+00BF&gt;&lt;U+00AA&gt;&lt;U+00BD&gt;&lt;c3&gt; ## 7 &lt;U+00BF&gt;&lt;ef&gt;&lt;U+00BB&gt;걤&lt;U+00BF&gt;&lt;U+00AA&gt;&lt;U+00BD&gt;&lt;c3&gt; ## 8 &lt;U+00BC&gt;&lt;U+00BC&gt;&lt;U+007E&gt;&lt;U+01AF&gt;&lt;U+00BA&gt;&lt;U+00B0&gt;&lt;c0&gt;&lt;da&gt;&lt;U+0121&gt;&lt;U+00BD&gt;&lt;c3&gt; ## 9 &lt;U+00B0&gt;&lt;e6&gt;&lt;U+00B1&gt;&lt;U+2D75&gt; ## 10 &lt;U+00B0&gt;&lt;U+00AD&gt;&lt;U+00BF&gt;&lt;f8&gt;&lt;U+00B5&gt;&lt;U+00B5&gt; ## geometry ## 1 MULTIPOLYGON (((966987 1941... ## 2 MULTIPOLYGON (((1138209 167... ## 3 MULTIPOLYGON (((1107778 178... ## 4 MULTIPOLYGON (((897904 1961... ## 5 MULTIPOLYGON (((932713 1696... ## 6 MULTIPOLYGON (((990947 1832... ## 7 MULTIPOLYGON (((1167950 171... ## 8 MULTIPOLYGON (((971236 1844... ## 9 MULTIPOLYGON (((931607 1894... ## 10 MULTIPOLYGON (((1163759 190... my_KOR_sf 데이터 세트의 CTP_KOR_NM 컬럼의 코드를 UTF-8로 바꿔준다. class(my_KOR_sf) ## [1] &quot;sf&quot; &quot;data.frame&quot; my_KOR_sf$CTP_KOR_NM &lt;- iconv(my_KOR_sf$CTP_KOR_NM, from = &quot;CP949&quot;, to = &quot;UTF-8&quot;, sub = NA, mark = TRUE, toRaw = FALSE) NOTE: 모든 sf 패키지의 함수들은 사용자가 식별할 수 있도록 st_ *로 시작한다. 일반적으로 [GADM] (https://gadm.org/data.html)에서 행정 경계 데이터를 찾을 수 있다. 대부분의 국가에 대한 오픈 소스의 현행 행정 경계 데이터를 유지하고 있다. GADM 웹 사이트에서 직접 공간 데이터를 다운로드 할 수 있지만 GADMTools 패키지를 사용하면 워크 플로우를 재현 할 수 있다. level = 1을 지정하면 주 수준의 경계가 반환된다. (level = 0는 국가 수준의 경제가 반환된다.) LEARN MORE: Robin Wilson의 웹 사이트는 물리적 및 인문 지리를 모두 포함하는 훌륭한 무료 GIS 데이터 소스 목록을 제공하고 있다. "],["gadmtools-패키지의-지리공간-데이터-다운로드.html", "14.3 GADMTools 패키지의 지리공간 데이터 다운로드", " 14.3 GADMTools 패키지의 지리공간 데이터 다운로드 아래 코드는 인도 주에 대한 shapefile을 다운로드한다. 그러나 Kashmir는 인도 국경에 포함되어 있지 않으므로 저장소의 shapefile을 사용한다. 패키지 불러오기 library(GADMTools) ## Loading required package: classInt ## Loading required package: rgdal ## rgdal: version: 1.5-19, (SVN revision 1092) ## Geospatial Data Abstraction Library extensions to R successfully loaded ## Loaded GDAL runtime: GDAL 3.0.4, released 2020/01/28 ## Path to GDAL shared files: C:/Program Files/R/R-4.0.3/library/rgdal/gdal ## GDAL binary built with GEOS: TRUE ## Loaded PROJ runtime: Rel. 6.3.1, February 10th, 2020, [PJ_VERSION: 631] ## Path to PROJ shared files: C:/Program Files/R/R-4.0.3/library/rgdal/proj ## Linking to sp version:1.4-5 ## To mute warnings of possible GDAL/OSR exportToProj4() degradation, ## use options(&quot;rgdal_show_exportToProj4_warnings&quot;=&quot;none&quot;) before loading rgdal. ## ## Attaching package: &#39;GADMTools&#39; ## The following object is masked from &#39;package:utils&#39;: ## ## vignette 14.3.1 지리공간 데이터 불러오기 한국의 시도 지리공간 데이터를 다운로드 해 보자. korea_wrapper &lt;- gadm_sf.loadCountries(&quot;KOR&quot;, level = 1, basefile = &quot;./data/shape_&quot;) gadm_sf.loadCountries()의 인수 fileNames : “KOR” + “_admX.rds.” X는 level의 값. level : level = 0는 국가 수준, level = 1은 주 또는 시/도 수준. basefile : “./data/shape_”는 현재 폴더 밑에 있는 “data” 폴더에 파일 이름에 “shape_”를 접두사로 사용. 결론적으로 위의 스크립트를 실행시키면, “./data” 폴더에 “shape_KOR_adm1.rds” 파일이 생성된다. data 폴더를 확인해 보기 바란다. 이렇게 생성된 개체 korea_wrapper의 클래스를 확인해 보자. class(korea_wrapper) # gadm_sf ## [1] &quot;gadm_sf&quot; str(korea_wrapper, max.level = 2) ## List of 4 ## $ basename: chr &quot;./data/shape_&quot; ## $ sf :Classes &#39;sf&#39; and &#39;data.frame&#39;: 17 obs. of 6 variables: ## ..$ ISO : chr [1:17] &quot;KOR&quot; &quot;KOR&quot; &quot;KOR&quot; &quot;KOR&quot; ... ## ..$ NAME_0 : chr [1:17] &quot;South Korea&quot; &quot;South Korea&quot; &quot;South Korea&quot; &quot;South Korea&quot; ... ## ..$ NAME_1 : chr [1:17] &quot;Busan&quot; &quot;Chungcheongbuk-do&quot; &quot;Chungcheongnam-do&quot; &quot;Daegu&quot; ... ## ..$ TYPE_1 : chr [1:17] &quot;Gwangyeoksi&quot; &quot;Do&quot; &quot;Do&quot; &quot;Gwangyeoksi&quot; ... ## ..$ ENGTYPE_1: chr [1:17] &quot;Metropolitan City&quot; &quot;Province&quot; &quot;Province&quot; &quot;Metropolitan City&quot; ... ## ..$ geometry :sfc_MULTIPOLYGON of length 17; first list element: List of 20 ## .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## ..- attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## ..- attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA ## .. ..- attr(*, &quot;names&quot;)= chr [1:5] &quot;ISO&quot; &quot;NAME_0&quot; &quot;NAME_1&quot; &quot;TYPE_1&quot; ... ## $ level : num 1 ## $ hasBGND : logi FALSE ## - attr(*, &quot;class&quot;)= chr &quot;gadm_sf&quot; "],["sp-개체-정보의-확인.html", "14.4 sp 개체 정보의 확인", " 14.4 sp 개체 정보의 확인 이 sf 개체로 작업하기 전에 sf와 sp 패키지를 간단히 비교해 보자. 14.4.1 sf를 spatialPolygonsDataFrame (sp 클래스)로 변환하기 먼저 sf를 spatialPolygonsDataFrame(sp 패키지에 의해 정의되는 s4 클래스)로 변환한다. sf::as() 함수를 활용한다. my_KOR_spdf &lt;- as(my_KOR_sf, &quot;Spatial&quot;) ## Warning in showSRID(uprojargs, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj = ## prefer_proj): Discarded datum Unknown based on GRS80 ellipsoid in CRS definition ## Warning in showSRID(SRS_string, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj = ## prefer_proj): Discarded datum International Terrestrial Reference Frame 2000 in ## CRS definition class(my_KOR_spdf) ## [1] &quot;SpatialPolygonsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; 14.4.2 개체 데이터 확인하기 14.4.2.1 sp 개체의 구조 확인 이제 sp 개체인 SpatialPolygonsDataFrame의 구조를 간단히 확인해 볼 수 있다. 구조는 str() 함수로 확인할 수 있다. str(my_KOR_spdf, max.level = 2) ## Formal class &#39;SpatialPolygonsDataFrame&#39; [package &quot;sp&quot;] with 5 slots ## ..@ data :&#39;data.frame&#39;: 17 obs. of 3 variables: ## ..@ polygons :List of 17 ## ..@ plotOrder : int [1:17] 15 10 14 16 9 13 12 11 17 4 ... ## ..@ bbox : num [1:2, 1:2] 746110 1458754 1387950 2068444 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot 여기서 sp 개체는 5 개의 슬롯(각 슬롯은 “@” 기호로 구분됨)을 가지고 있음을 주목하기 바란다. 첫 번째 슬롯은 익숙해 보일 것이다. data 슬롯은 17개의 행과 3개의 열로 구성되는 데이터 프레임이다. 14.4.2.2 sp 개체의 데이터 확인 이 슬롯들에서 @ 기호를 이용하여 정보를 추출할 수 있다(데이터 프레임에서 $ 기호를 사용하는 것처럼). glimpse() 함수를 사용하여 슬롯 정보를 추출할 수 있다. library(tidyverse) glimpse(my_KOR_spdf@data) ## Rows: 17 ## Columns: 3 ## $ CTPRVN_CD &lt;chr&gt; &quot;11&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, &quot;29&quot;, &quot;30&quot;, &quot;31&quot;, &quot;36&quot;, &quot;41&quot;, &quot;4... ## $ CTP_ENG_NM &lt;chr&gt; &quot;Seoul&quot;, &quot;Busan&quot;, &quot;Daegu&quot;, &quot;Incheon&quot;, &quot;Gwangju&quot;, &quot;Daejeo... ## $ CTP_KOR_NM &lt;chr&gt; &quot;서울특별시&quot;, &quot;부산광역시&quot;, &quot;대구광역시&quot;, &quot;인천광역시&quot;, &quot;광주광역시&quot;, &quot;대전광역시&quot;, &quot;울... 다음 슬롯은polygons,plotOrder,bbox 및proj4string을 보유한다. 우리는 sf 개체의 범주에서 이것으로 돌아갈 것이다. 지금은 개체 기하구조의 데이터와 측면이 별도의 슬롯에 보관된다는 점에 유의하자. 이것은 우리 중 많은 사람들이 익숙한 깔끔한 스타일의 워크 플로우와 호환되지 않는다. "],["sp-개체를-다시-sf-개체로-변환하기.html", "14.5 sp 개체를 다시 sf 개체로 변환하기", " 14.5 sp 개체를 다시 sf 개체로 변환하기 이 sp 형식으로 계속 작업 할 수도 있지만 st_as_sf ()함수를 사용하여 다시 sf 객체로 변환하고 그 차이점을 살펴 보기로 한다. KOR_sf &lt;- st_as_sf(my_KOR_spdf) class(KOR_sf) ## [1] &quot;sf&quot; &quot;data.frame&quot; sp 패키지로 정의된 클래스인 이전 SpatialPolygonsDataFrame은 이제 sf와 data.frame이라는 두 개의 동시 클래스를 갖는다. 처음 몇 개의 행을 출력해 보면 개체에 대해 많은 것을 알 수 있다. KOR_sf ## Simple feature collection with 17 features and 3 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 750000 ymin: 1500000 xmax: 1400000 ymax: 2100000 ## projected CRS: PCS_ITRF2000_TM ## First 10 features: ## CTPRVN_CD CTP_ENG_NM CTP_KOR_NM geometry ## 1 11 Seoul 서울특별시 MULTIPOLYGON (((966987 1941... ## 2 26 Busan 부산광역시 MULTIPOLYGON (((1138209 167... ## 3 27 Daegu 대구광역시 MULTIPOLYGON (((1107778 178... ## 4 28 Incheon 인천광역시 MULTIPOLYGON (((897904 1961... ## 5 29 Gwangju 광주광역시 MULTIPOLYGON (((932713 1696... ## 6 30 Daejeon 대전광역시 MULTIPOLYGON (((990947 1832... ## 7 31 Ulsan 울산광역시 MULTIPOLYGON (((1167950 171... ## 8 36 Sejong-si 세종특별자치시 MULTIPOLYGON (((971236 1844... ## 9 41 Gyeonggi-do 경기도 MULTIPOLYGON (((931607 1894... ## 10 42 Gangwon-do 강원도 MULTIPOLYGON (((1163759 190... 17개의 features(출력 수에 따라 다름)와 3개의 항목(속성)가 있다. ’geometry type’은 도형이 다양한 영역의 모양을 나타내므로 다중 다각형(multipolgon)이다. 다른 일반적인 geometry type에는 점(points), 선(lines) 및 “다중-” 대응 요소가 포함된다. bbox는 개체의 경계 상자 차원을 제공한다. projected CRS : PCS_ITRF2000_TM : 투영된 CRS LEARN MORE: 좌표 참조 시스템에 대한 자세한 내용은 Geocomputation with R의 [Section 2.4] (https://geocompr.robinlovelace.net/spatial-class.html#crs-intro)를 참조하기 바란다. st_geometry_type () 함수, st_dimension () 함수, st_bbox () 함수 그리고 st_crs () 함수 등과 같은 함수를 사용하여 개체의 공간적 특징에 대한 정보에 직접 액세스 할 수 있다. 또한 데이터 프레임을 탐색하는 데 사용하는 glimpse () 함수 또는 View () 함수와 같은 익숙한 함수도sf 객체에서 작동한다. 이 개체를 자세히 살펴보면 각 주(state)에 대한 약어 및 경계 상자를 제공하는 몇 개의 속성 열이 있음을 알 수 있다. 가장 중요한 것은 마지막 열이 목록 열에 각 주의 지오메트리를 보유한다는 것이다. glimpse(KOR_sf) ## Rows: 17 ## Columns: 4 ## $ CTPRVN_CD &lt;chr&gt; &quot;11&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, &quot;29&quot;, &quot;30&quot;, &quot;31&quot;, &quot;36&quot;, &quot;41&quot;, &quot;4... ## $ CTP_ENG_NM &lt;chr&gt; &quot;Seoul&quot;, &quot;Busan&quot;, &quot;Daegu&quot;, &quot;Incheon&quot;, &quot;Gwangju&quot;, &quot;Daejeo... ## $ CTP_KOR_NM &lt;chr&gt; &quot;서울특별시&quot;, &quot;부산광역시&quot;, &quot;대구광역시&quot;, &quot;인천광역시&quot;, &quot;광주광역시&quot;, &quot;대전광역시&quot;, &quot;울... ## $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((966987 1941..., MULTIPOLYGO... "],["sf-개체-조작.html", "14.6 sf 개체 조작", " 14.6 sf 개체 조작 sf 패키지의 공간 데이터 프레임도 데이터 프레임이기 때문에 dplyr 패키지와 같은 일반 데이터 조작 도구를 사용하여 조작 할 수 있다. 여기서는 원하는 열을 선택(select)하고 이름을 변경(rename)한다. [절차] 다음의 도시들을 uts 변수에 대입하고, 새로운 컬럼으로 type 컬럼을 생성하고, CTP_KOR_NM 컬럼의 값이 uts1 ~ uts5를 기준으로 type 컬럼의 값을 “수도권,” “충청권,” “제주-전라권,” “강원권,” “경상권” 등으로 입력한다 type 컬럼을 factor 형으로 형 변화을 한다. uts1 &lt;- c(&quot;서울특별시&quot;, &quot;인천광역시&quot;, &quot;경기도&quot;) uts2 &lt;- c(&quot;충청남도&quot;, &quot;충청북도&quot;, &quot;대전광역시&quot;, &quot;세종특별자치시&quot;) uts3 &lt;- c(&quot;경상남도&quot;, &quot;경상북도&quot;, &quot;대구광역시&quot;, &quot;부산광역시&quot;, &quot;울산광역시&quot;) uts4 &lt;- c(&quot;강원도&quot;) uts5 &lt;- c(&quot;전라남도&quot;, &quot;전라북도&quot;, &quot;광주광역시&quot;, &quot;제주특별자치도&quot;) KOR_sf1 &lt;- KOR_sf %&gt;% # ind_sf1 &lt;- my_sf1 %&gt;% # dplyr::select(name, abbr) %&gt;% mutate( type = ifelse(CTP_KOR_NM %in% uts1, &quot;수도권&quot;, ifelse(CTP_KOR_NM %in% uts2, &quot;충청권&quot;, ifelse(CTP_KOR_NM %in% uts3, &quot;경상권&quot;, ifelse(CTP_KOR_NM %in% uts4, &quot;강원권&quot;, &quot;제주-전라권&quot;)))) ) # %&gt;% # rename(abb = abbr, state_ut = name) KOR_sf1$type &lt;- factor(KOR_sf1$type, levels = c(&quot;수도권&quot;, &quot;충청권&quot;, &quot;제주-전라권&quot;, &quot;강원권&quot;, &quot;경상권&quot;)) str(KOR_sf1, max.level = 1) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 17 obs. of 5 variables: ## $ CTPRVN_CD : chr &quot;11&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; ... ## $ CTP_ENG_NM: chr &quot;Seoul&quot; &quot;Busan&quot; &quot;Daegu&quot; &quot;Incheon&quot; ... ## $ CTP_KOR_NM: chr &quot;서울특별시&quot; &quot;부산광역시&quot; &quot;대구광역시&quot; &quot;인천광역시&quot; ... ## $ geometry :sfc_MULTIPOLYGON of length 17; first list element: List of 1 ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## $ type : Factor w/ 5 levels &quot;수도권&quot;,&quot;충청권&quot;,..: 1 5 5 1 3 2 5 2 1 4 ... ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA ## ..- attr(*, &quot;names&quot;)= chr [1:4] &quot;CTPRVN_CD&quot; &quot;CTP_ENG_NM&quot; &quot;CTP_KOR_NM&quot; &quot;type&quot; KOR_sf1은 기존의 컬럼과 새로 생성한 type 컬럼이 있으며, 또한 지리공간 데이터를 담고 있는 geometry 컬럼이 포함되어 있다. NOTE: 이것은 geometry 열을 명시적으로 선택하지는 않지만 sf 개체의 geometry 열은 고정적임을 알 수 있다. ind_sf %&gt;% st_set_geometry(NULL)를 사용하여 명시적으로 삭제하지 않는 한 개체에 남아 있다. 이미 tidyverse에 익숙한 사람들에게 일반 dplyr 패키지의 동사를 사용하여 sf 개체를 조작하는 것은 sf 패키지 사용의 큰 이점 중 하나이다. 이는 앞에서의 SpatialPolygonsDataFrame의 슬롯으로 작업했다면 불가능한 것이다. 또한 이러한 조작은 개체의 클래스에 어떤 방식으로도 영향을 미치지 않는다. class(KOR_sf1) ## [1] &quot;sf&quot; &quot;data.frame&quot; "],["속성-데이터-준비.html", "14.7 속성 데이터 준비", " 14.7 속성 데이터 준비 지금까지의 공간 데이터 프레임(spatial dataframe)과 함께 각 시도별 속성 데이터(attribute data)를 준비한다. 일단 속성 데이터 프레임이 준비되고 나면, 공간 데이터 프레임과 조인할 수 있고, 두 개의 새로운 컬럼을 생성할 수도 있다. 14.7.1 속성 데이터 세트 불러오기 한국의 시도별 속성 데이터 파일을 불러온다. # see prepare_data.R script in github for details of creating attributes_df KOR_attributes_df &lt;- readRDS(&quot;data/kor_attributes.rds&quot;) “지리공간 데이터” KOR_sf1과 “속성 데이터” KOR_attributes_df를 left_join() 한다. 그리고, 일인당 명목 GDP(per_capita_gdp)를 계산하여 새로운 per_capita_gdp 컬럼을 생성한다. KOR_sf2 &lt;- KOR_sf1 %&gt;% left_join(KOR_attributes_df, by = &quot;CTP_KOR_NM&quot;) %&gt;% mutate( per_capita_gdp = round(nominal_gdp_bill_won / pop_2019 * 1000, 2) ) 이 개체를 한 번 더 검사하면 모든 기대 속성 열들이 있고, 마지막 열에는 각 주의 geometry가 목록에 포함되어 있음을 알 수 있다. 개체의 경계 상자 및 ** CRS **와 관련된 동일한 공간 속성도 그대로 유지되고 있다. head(KOR_sf2, 3) ## Simple feature collection with 3 features and 12 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 940000 ymin: 1700000 xmax: 1200000 ymax: 2000000 ## projected CRS: PCS_ITRF2000_TM ## CTPRVN_CD CTP_ENG_NM CTP_KOR_NM type data_year nominal_gdp_bill_won ## 1 11 Seoul 서울특별시 수도권 2019 423742 ## 2 26 Busan 부산광역시 경상권 2019 89980 ## 3 27 Daegu 대구광역시 경상권 2019 56714 ## decadal_growth area pop_2019 pop_male_2019 pop_female_2019 ## 1 0.025 605 9729107 4744059 4985048 ## 2 0.026 770 3413841 1675417 1738424 ## 3 0.028 884 2438031 1205286 1232745 ## geometry per_capita_gdp ## 1 MULTIPOLYGON (((966987 1941... 44 ## 2 MULTIPOLYGON (((1138209 167... 26 ## 3 MULTIPOLYGON (((1107778 178... 23 "],["면적-계산.html", "14.8 면적 계산", " 14.8 면적 계산 우리의 속성 데이터에는 이미 Wikipedia에서 가져온 area 열이 있다. 그러나 이것이 사실이 아니거나 데이터를 신뢰하지 않는 경우 st_area () 함수를 사용하여 공간 데이터 프레임에서 각 관측치의 면적을 계산할 수 있다. 이 작업을 수행하는 것은 간단하지만 단위에 주의해야 한다. 이 경우 평방 미터(m^2)에서 평방 킬로미터(km^2)로 변환해야 한다. units 패키지 불러오기 library(units) ## udunits system database from C:/Program Files/R/R-4.0.3/library/units/share/udunits st_area() 함수를 이용하여 멀티 폴리곤의 면적을 계산하여, my_area 컬럼에 기록한다. 그리고 단위를 km^2으로 변경한다. 1 평방 킬로미터당 GDP밀도를 나타내는 gdp_density_km2를 구한다. [절차] 주별 면적 구하기 KOR_sf2에 있는 각 행(feature)의 면적을 구하고 my_KOR_area 컬럼을 생성하여 대입한다 면적의 단위를 km^2로 변경 my_KOR_area 컬럼의 단위를 units 패키지의 ud_units를 이용하여 면적단위를 km^2 으로 변경하고, units(KOR_sf3$my_KOR_area)로 측정단위를 설정한다. 각 지역 면적당 명목 GDP인 gdp_density_km2를 구한다. 우리나라의 시도별 면적을 구한다. # mutate area KOR_sf3 &lt;- KOR_sf2 %&gt;% mutate(my_KOR_area = st_area(.)) st_area() 참고 : Define width of a path and calculate area my_KOR_area의 단위를 m^2에서 km^2로 바꾼다. # convert units units(KOR_sf3$my_KOR_area) &lt;- with(ud_units, km^2) 1 평방 킬로미터 당 GDP 밀도로 gdp_density_km2를 구한다. # mutate gdp density KOR_sf4 &lt;- KOR_sf3 %&gt;% # mutate(gdp_density_usd_km2 = nominal_gdp_usd / my_area) mutate(gdp_density_km2 = nominal_gdp_bill_won / my_KOR_area, # 1 Km^2 당 명목 GDP sex_ratio = round(pop_male_2019 / pop_female_2019 * 100, 2), # 성비율 density_km2 = pop_2019 / my_KOR_area, decadal_growth = round(decadal_growth * 100, 2), ) # 1 km^2 당 인구수 LEARN MORE: R 에서의 단위 변환에 대한 자세한 내용은 R 벡터 측정 단위에 대한 가이드를 참조하기 바란다. 아래 출력에서 area는 단순한 숫자 클래스(numeric)이고, st_area () 함수를 사용한 면적 컬럼인 my_KOR_area는 “units” 클래스임을 유의하기 바란다. area의 데이터 형을 확인해 본다. class(KOR_sf4$area) ## [1] &quot;numeric&quot; KOR_sf3$area_km2 ## NULL st_area() 함수를 이용해 구한 my_KOR_area의 데이터 형을 확인한다. class(KOR_sf4$my_KOR_area) ## [1] &quot;units&quot; KOR_sf3$my_area ## NULL 그리고 이 컬럼의 값을 비교해 보면, 두 수치들이 비슷하지만 정확히 같지는 않다는 것을 알 수 있다. KOR_sf4[, c(&quot;CTP_KOR_NM&quot;, &quot;area&quot;, &quot;my_KOR_area&quot;)] ## Simple feature collection with 17 features and 3 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 750000 ymin: 1500000 xmax: 1400000 ymax: 2100000 ## projected CRS: PCS_ITRF2000_TM ## First 10 features: ## CTP_KOR_NM area my_KOR_area geometry ## 1 서울특별시 605 605 [km^2] MULTIPOLYGON (((966987 1941... ## 2 부산광역시 770 770 [km^2] MULTIPOLYGON (((1138209 167... ## 3 대구광역시 884 880 [km^2] MULTIPOLYGON (((1107778 178... ## 4 인천광역시 1063 1063 [km^2] MULTIPOLYGON (((897904 1961... ## 5 광주광역시 501 498 [km^2] MULTIPOLYGON (((932713 1696... ## 6 대전광역시 539 539 [km^2] MULTIPOLYGON (((990947 1832... ## 7 울산광역시 1061 1055 [km^2] MULTIPOLYGON (((1167950 171... ## 8 세종특별자치시 465 465 [km^2] MULTIPOLYGON (((971236 1844... ## 9 경기도 10183 10183 [km^2] MULTIPOLYGON (((931607 1894... ## 10 강원도 16827 16629 [km^2] MULTIPOLYGON (((1163759 190... "],["geometry-단순화.html", "14.9 geometry 단순화", " 14.9 geometry 단순화 sf 객체를 플로팅하기(다음 장의 주제) 전에 다음에서 공간 데이터 프레임에 있는 polygons를 단순화해야 한다. 단순한 지도의 경우, GADM 데이터 또는 기타 여러 지리공간 데이터 소스와 함께 제공되는 세부 수준의 세부 정보를 가질 필요가 없다. 단순화는 시각적 출력 측면에서 거의 희생하지 않으면서 메모리 요구 사항을 크게 줄일 수 있다. 다행히도 동일한 가시적 모양을 유지하면서 다각형의 정점 수를 줄이는 쉬운 프로세스가 있다. 한 가지 옵션은 sf :: st_simplify() 함수의 사용이지만, 여기서는rmapshaper 패키지의 ms_simplify() 함수를 사용하기로 한다. 아래에서는 동일한 수의 모양을 유지하면서도 오브젝트 정점의 1% 만을 유지한다. NOTE: 또 다른 유용한 함수는 sf :: st_geometry()이다. sf 객체를 전달할 때 geometry만 반환한다. 이를 통해 모든 것이 올바르게 보이는지 확인하기 위해 geometry만 빠르게 플롯할 수 있다. 또한 우리가 계산한 영역의 units 클래스는 ms_simplify()에 문제가 발생했기 때문에 제거했다. 단순화 후에 그것을 언제든지 추가 할 수 있다. 절차 : units 클래스를 제거한다. st_geometry() 함수로 geometry 만 반환한다 rmapshaper 패키지의 ms_simplify() 함수와 st_geometry() 함수를 이용하여 단순화한다. 시각화한다. 이제 우리나라의 경우에도 적용해 보기로 한다. 먼저 KOR_sf4의 컬럼 중 units 클래스인 my_KOR_area, gdp_density_km2, density_km2 등의 컬럼을 as.vector() 함수를 이용하여 벡터형으로 형 변환한다. # strip units class KOR_sf5 &lt;- KOR_sf4 %&gt;% mutate( my_KOR_area = as.vector(my_KOR_area), gdp_density_km2 = as.vector(gdp_density_km2), density_km2 = as.vector(density_km2) ) st_geometry() 함수를 이용하여 geometry 컬럼만 추출한다. original_KOR_geometry &lt;- st_geometry(KOR_sf5) rmapshaper 패키지의 ms_simplify() 함수를 이용하여 단순화한다. 이 단순화한 지리공간 데이터에서 st_geometry() 함수를 이용하여 단순화된 geometry 컬럼을 추출한다. library(rmapshaper) ## Registered S3 method overwritten by &#39;geojsonlint&#39;: ## method from ## print.location dplyr simp_KOR_sf &lt;- ms_simplify(KOR_sf5, keep = 0.01, keep_shapes = TRUE) simple_KOR_geometry &lt;- st_geometry(simp_KOR_sf) 원래의 geometry(original_KOR_geometry)와 단순화한 geometry(simple_KOR_geometry)를 시각화하여 비교한다. par(mfrow = c(1,2)) plot(original_KOR_geometry, main = &quot;Original Korean Geometry&quot;) plot(simple_KOR_geometry, main = &quot;Simplified Korean Geometry&quot;) 원래 지도인 original_KOR_geometry은 위의 그림에서 왼쪽에 있고, 단순화된 버전인 simplified_KOR_geometry은 오른쪽에 있다. 단순화된 버전은 꼭지점이 1% 밖에 없어도 원래의 지도와 다르지 않다. 사실, 경계선이 더 깔끔하게 처리되어 더 좋아 보인다. 14.9.1 개체의 용량 비교하기 library(pryr) ## Registered S3 method overwritten by &#39;pryr&#39;: ## method from ## print.bytes Rcpp ## ## Attaching package: &#39;pryr&#39; ## The following object is masked from &#39;package:GADMTools&#39;: ## ## dots ## The following objects are masked from &#39;package:purrr&#39;: ## ## compose, partial 이제 원래 geometry와 단순화된 geometry의 크기를 pryr 패키지의 object_size()` 함수를 이용해 구해 보자. object_size(original_KOR_geometry) ## 14 MB object_size(simple_KOR_geometry) ## 325 kB 단순화로 인해 geometry의 크기가 9.56MB에서 150KB로 줄어 들었다. simp_KOR_sf의 컬럼을 모두 시각화 해 보자 str(simp_KOR_sf, max.level = 1) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 17 obs. of 17 variables: ## $ CTPRVN_CD : chr &quot;11&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; ... ## $ CTP_ENG_NM : chr &quot;Seoul&quot; &quot;Busan&quot; &quot;Daegu&quot; &quot;Incheon&quot; ... ## $ CTP_KOR_NM : chr &quot;서울특별시&quot; &quot;부산광역시&quot; &quot;대구광역시&quot; &quot;인천광역시&quot; ... ## $ type : Factor w/ 5 levels &quot;수도권&quot;,&quot;충청권&quot;,..: 1 5 5 1 3 2 5 2 1 4 ... ## $ data_year : num 2019 2019 2019 2019 2019 ... ## $ nominal_gdp_bill_won: num 423742 89980 56714 88735 39805 ... ## $ decadal_growth : num 2.47 2.63 2.8 3.32 3.76 2.65 1.33 6.49 5.37 3.07 ... ## $ area : num 605 770 884 1063 501 ... ## $ pop_2019 : num 9729107 3413841 2438031 2957026 1456468 ... ## $ pop_male_2019 : num 4744059 1675417 1205286 1482249 720740 ... ## $ pop_female_2019 : num 4985048 1738424 1232745 1474777 735728 ... ## $ per_capita_gdp : num 43.5 26.4 23.3 30 27.3 ... ## $ my_KOR_area : num 605 770 880 1063 498 ... ## $ gdp_density_km2 : num 700.1 116.8 64.5 83.5 79.9 ... ## $ sex_ratio : num 95.2 96.4 97.8 100.5 98 ... ## $ density_km2 : num 16075 4431 2771 2783 2925 ... ## $ geometry :sfc_MULTIPOLYGON of length 17; first list element: List of 1 ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... ## ..- attr(*, &quot;names&quot;)= chr [1:16] &quot;CTPRVN_CD&quot; &quot;CTP_ENG_NM&quot; &quot;CTP_KOR_NM&quot; &quot;type&quot; ... plot(simp_KOR_sf[&#39;type&#39;]) # type의 시각화 plot(simp_KOR_sf[c(&#39;type&#39;,&#39;area&#39;)]) # type과 area의 시각화 plot(simp_KOR_sf, max.plot=16) # 전체 컬럼의 시각화 이제 지금까지 처리한 데이터 simp_KOR_sf를 rds 파일로 저장한다. write_rds(simp_KOR_sf, &quot;data/simp_KOR_sf.rds&quot;) LEARN MORE: ’단순화’에 대한 자세한 내용은 Geocomputation with R의 Section 5.2.1을 참조하기 바란다. "],["마지막-생각들.html", "14.10 마지막 생각들", " 14.10 마지막 생각들 R을 GIS로 사용하는 컨텍스트를 간략하게 소개 한 후, 이 장에서는 sf 패키지가 깔끔한 tidyverse 워크 플로우에 맞는 객체에 지리공간 데이터와 속성 데이터를 함께 저장하기 위한 클래스 구조를 생성하는 방법을 살펴 보았다. 익숙한 dplyr 패키지의 동사들을 사용하여 공간 데이터 프레임을 조작 할 때 이 구조의 이점을 분명히 볼 수 있다. 이제 지리 공간 데이터를 조작하는 방법을 알았으므로, 다음 단계는 시각화 또는 매핑이다. 여기에서도 ggplot2 패키지의 geom_sf ()를 사용할 수 있으므로 깔끔한 워크 플로우의 이점을 확인할 수 있다. 하지만 다음 장에서 볼 수 있듯이 ggplot2 패키지는 R에서 지리공간 데이터를 시각화 할 때 시용할 수 있는 많은 훌륭한 패키지 옵션 중 하나 일뿐이다. "],["정적-지도-생성.html", "15 정적 지도 생성", " 15 정적 지도 생성 This lesson was written by Sean Angiolillo and was last updated on 29 Jan. 2019. [이전 장] (https://atlan.com/courses/introduction-to-gis-r/lesson2-manipulating-geospatial-data/)에서는 sf 패키지에 의해 정의된 공간 데이터 프레임의 구조를 간략하게 살펴 보다. 다음 단계는 시각화로, 보다 구체적으로 지리공간 데이터의 매핑이다. 모든 종류의 데이터와 마찬가지로 시각화는 모든 종류의 통계 분석에 들어가기 전에 거쳐야 하는 중요한 단계이다. 이 장에서는 tmap 패키지 및 ggplot2 패키지와 같이 가장 잘 알려진 R 패키지를 사용하여 정적 맵을 만드는 방법을 살펴 보기로 한다. 또한 좀 더 독특한 공간 시각화를 위해 cartogram 패키지, geogrid 패ㅣ지, geofacet 패지이와 같은 몇 가지 다른 패키지를 살펴볼 것이다. 그리고(다음 장에서 애니메이션 및 대화형 지도 만들기를 다루겠다.) "],["지리공간-데이터의-시각화를-위한-자원들.html", "15.1 지리공간 데이터의 시각화를 위한 자원들", " 15.1 지리공간 데이터의 시각화를 위한 자원들 매핑을 위해 다른 R 패키지를 살펴보기 전에 시작하는 데 도움이되는 몇 가지 훌륭한 리소스를 검토해 보겠다. 다음은 데이터 시각화 원칙에 대한 두 가지 훌륭한 오픈 소스 리소스이다. 둘 다 지리 공간 데이터 시각화에 대한 장을 포함하고 있다. Kieran Healy의 [데이터 시각화 : 실제 소개] (http://socviz.co/). : 여기에는 maps에 대한 내용을 전적으로 다루고 있는 장도 포함되어 있다. Claus O. Wilke의 Fundamentals of Data Visualization. 다음은 좋은 디자인(good design)이라는 더 큰 원칙보다는 R의 매핑 메커니즘(mapping mechanism)에 더 좁게 초점을 맞춘 두 가지 리소스이다. 앞서 언급 한 Geocomputation with R의 R로지도 만들기. Bhaskar V. Karambelkar가 useR 2017에 행한 “Geospatial Data Visualization in R” 튜토리얼. "],["올바른-시각화-선택.html", "15.2 올바른 시각화 선택", " 15.2 올바른 시각화 선택 최근 소프트웨어가 발전함에 따라 단계 구분도(choropleths), 점 밀도 지도(dot density maps) 및 지도도(cartograms)와 같은 다양한 유형의 지리 공간 데이터 시각화를 쉽게 사용할 수 있게 되었다. 그러나 올바른 시각화는 보유한 데이터 유형에서 시작되는 경우가 많다. 시각화를 선택하기 전에 데이터의 특성을 확인해야 한다. 데이터가 숫자인가? 그렇다면 인구와 같은 원시 카운트인가? 아니면 인구 밀도와 같은 표준화된 데이터인가? 데이터가 숫자가 아닌 경우 언어 또는 종교 데이터와 같은 명목(nominal)(또는 범주) 데이터인가? 아니면 만족도 순위와 같은 순서형(ordinal) 데이터인가? Healy가 그의 책에서 분명하게 밝히고 있는 부분은 진정한 지리공간 시각화가 데이터에 가장 적합한 선택인지 여부를 고려하는 것이 중요하다는 것이다. 우리의 경우와 단계 구분도와 관련된 많은 경우에 데이터는 부분적으로만 지리 공간적이다. 실제로는 임의의 단위로 일부 값의 개수를 나타낸다. [이전 장] (https://atlan.com/courses/introduction-to-gis-r/lesson2-manipulating-geospatial-data/)에서 만든 공간 개체에는 인구, GDP, 성비와 같은 속성이 있다. 데이터의 지리 공간적 특성을 무시하고 막대 그래프를 통해 이 데이터를 시각화하는 것은 확실히 가능하다. 또는 지리 공간 요소를 무시하는 대신 프록시(proxy)를 통해 이 정보 중 일부를 표시 할 수도 있다. 예를 들어 지역과 같은 변수에 서로 다른 색상을 매핑 할 수 있다. 사실, 지리 공간적 요소에 초점을 맞추는 것은 인도의 주들과 마찬가지로 서로 다른 지역들과 그 지역들에 살고 있는 인구 사이의 커다란 동등하지 않은 면적 때문에 데이터를 잘못 표현할 수 있다. 주(state) 수준이 아닌 지역(district) 수준의 데이터로 작업하는 경우 단일 막대 그림에 수백 개의 막대를 표시 할 수 없기 때문에 단계구분도가 필요할 수 있다. 그럼에도 불구하고 단순성 때문에 주(state) 수준의 데이터를 사용하여 지리공간 시각화를 위한 다양한 접근 방식을 시험해 볼 것이다. 이러한 목표를 염두에 두고 다음의 시각화 중 “나쁜” 것은 없지만, 이 데이터에 대한 “최상의” 시각화인지 여부는 시각화 당시의 특정 목표에 달려있다는 것이다. "],["정적-지도.html", "15.3 정적 지도", " 15.3 정적 지도 많은 R 패키지가 매력적인 대화형 그리고 애니메이션 맵을 쉽게 만들 수 있도록 만들었지만 효과적인 정적 맵의 필요성을 없애지는 못했다. 이 장에서는 R의 base 패키지, tmap 패키지 그리고 ggplot2 패키지에서 정적 맵을 만드는 방법을 살펴 보기로 한다. Note : tmap 패키지와 ggplot2 패키지는 지도를 만드는 데 가장 많이 사용되는 두 가지 패키지이지만 유일한 옵션은 아니다. cartography 패키지는 특히 비례적인 기호에 포함된 단계 구분도와 같은 특정 종류의 지도를 위한 또 다른 흥미로운 도구이다. 패키지 vignette와 cheat sheet를 참조하기 바란다. 15.3.1 기본 플로팅 이전 장의 geometry 플롯에서 설명했듯이 sf 패키지는지리 데이터를 시각화하기 위한 **plot()** 함수를 제공한다. 개체 자체를 플로팅하면 각 속성에 대해 하나씩 faceted 플롯의 그리드가 생성될 것이다. 한 변수를 선택하면 단일 맵이 생성된다.. library(tidyverse) library(sf) 15.3.2 우리나라의 1인당 GDP와 인구수 per_capita_gdp 컬럼과 pop_2019 컬럼을 시도별로 시각화해 보자. simp_KOR_sf &lt;- readRDS(&quot;data/simp_KOR_sf.rds&quot;) plot(simp_KOR_sf[c(&#39;per_capita_gdp&#39;, &#39;pop_2019&#39;)]) 이 플롯은 기본지도를 얼마나 빠르고 쉽게 플로팅 할 수 있는지 보여 주지만 이 기본적인 구분 단계도가 효과적인 시각화가 아닐 수 있는 이유가 있다. 이 장이 끝날 무렵에 이 경우에 어떤 유형의 시각화가 더 효과이며, 그 이유를 명확히 알게 될 것이다. 15.3.3 테마형 지도 (tmap) Martijn Tennekes의 [tmap ] https://github.com/mtennekes/tmap) 패키지는 한동안 R에서 매핑을위한 표준 패키지였다. “thematic”이라는 이름에서 알 수 있듯이, 특히 단계 구분도에 적합하지만 광범위한 지리 공간 시각화를 생성 할 수 있다. 지리 공간 데이터에 맞는 ggplot2 패키지 스타일의 구문 을 제공한다. ggplot2 패키지와 마찬가지로 플롯에 순차적으로 레이어를 추가하는 것을 강조하고 있다. 공간 데이터 프레임을 tm_shape() 함수에 전달할 수 있다. 마치 데이터 프레임을 ggplot () 함수에 전달하는 것과 같다. 또한 sf 패키지의 공간 데이터 프레임도 데이터 프레임이기 때문에 특정 특징(아래의 “Andaman &amp; Nicobar Islands”와 같은)을 필터링하고 개체를 tm_shape() 체인으로 직접 파이핑할 수 있다. LEARN MORE: 지도의 다른 측면을 조정하는 방법에 대한 가이드는 여러 가이드와 vignette를 포함하는 [문서] (https://github.com/mtennekes/tmap)에서 찾을 수 있다. union 영역을 필터링 한 후 다음의 단계 구분도는 지역별 경제 활동의 척도인 인도의 GDP 밀도를 매핑하고 있다. 여기에서 평방 킬로미터 당 명목 GDP 단위로 측정한 GDP 밀도(density)는 명확한 중간 점이 없으므로 발산(diverging) 또는 범주형 색상 척도와 반대되는 순차적 색상 척도가 필요하다. library(tmap) simp_KOR_sf에 있는 지리공간 데이터와 속성 데이터를 이용하여 시각화한다. tm_shape() 함수를 기본 플롯팅을 한다. tm_fill() 함수를 이용하여 col 인수로 인구수를 나타내는 pop_2019 컬럼을 지정하고, title 인수에 범례의 제목으로 인구수(천명)을 지정한다. tm_borders() 함수를 이용하여 시도 경계선의 굵기를 정한다. tm_text로 시도별 라벨을, 그리고 tm_style() 함수로 바탕색을 지정한다. tm_layout() 함수를 이용하여 플롯의 세부 내용을 지정한다. tm_credits() 함수로 데이터 출처를 기록한다. simp_KOR_sf %&gt;% tm_shape() + tm_fill(col = &quot;pop_2019&quot;, title = &quot;인구수(백만 명)&quot;) + tm_borders(lwd = 0.3) + tm_text(&quot;CTP_KOR_NM&quot;, size = 0.55, col=&quot;black&quot;) + tm_style(&quot;gray&quot;) + tm_layout( main.title = &quot;2019년 시도별 인구&quot;, main.title.position = c(&quot;center&quot;), main.title.size = 2, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) + tm_credits(&quot;Data Source :\\nKOSIS,\\n행정구역(시군구)별,\\n성별 인구수&quot;, size=0.5, col = &quot;blue&quot;, position = c(&quot;left&quot;, &quot;bottom&quot;)) LEARN MORE: 지도를 포함하여 데이터 시각화에서 색상을 사용하는 것에 대한 많은 이론과 조언이 있다. 특히 Wilke의 책에는 색조 및 색상 함정에 대한 훌륭한 내용이 있다. 15.3.3.1 tmap개체의 정렬 tmap 패키지에는 여러 tmap 객체를 나란히 정렬하는 데 유용한 tmap_arrange() 함수도 있다. 예를 들어, 더 공정한 분포를 얻기 위해 작은 union 지역을 필터링하면 인구 증가 및 밀도의 tmap 객체를 별도로 만들 수 있다. 그런 다음 비교를 위해 나란히 배열할 수 있다. 인구 증가 및 인구 밀도와 같은 값인 GDP 밀도도 표준화된 데이터이므로 단계 구분도에 적합하다. CTP_sf : 1 평방 킬로미터 당 인구수를 구하여 density_km2 변수에 대입한다. growth_CTP : 지난 10년간(2010 ~ 2019)의 평균 인구성장률에 대한 지도정보 density_km2 : 1평방 킬로미터 당 인구밀도 growth_CTP &lt;- tm_shape(simp_KOR_sf) + tm_fill(col = &quot;decadal_growth&quot;, title = &quot;퍼센트&quot;) + tm_borders(lwd = 0.5) + tm_layout( main.title = &quot;시도별 인구 증가율 (2010-2019)&quot;, main.title.position = c(&quot;center&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) + tm_credits(&quot;Data:\\n2010-2019 Census&quot;, position = c(&quot;left&quot;, &quot;bottom&quot;)) density_CTP &lt;- tm_shape(simp_KOR_sf) + tm_fill(col = &quot;density_km2&quot;, title = &quot;1 평방킬로당 인구(명)&quot;, palette = &quot;YlGnBu&quot;) + tm_borders(lwd = 0.5) + tm_layout( main.title = &quot;시도별 인구 밀집도 (2019)&quot;, main.title.position = c(&quot;center&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) + tm_credits(&quot;Data:\\n2011 Census&quot;, position = c(&quot;left&quot;, &quot;bottom&quot;)) tmap_arrange(growth_CTP, density_CTP) 또 다른 예로, 우리나라의 시도별 명목 GDP(nominal_gdp_bill_won)와 1인당 명목 GDP(per_capita_gdp)를 시각화해 보자. gdp_KOR &lt;- tm_shape(simp_KOR_sf) + tm_fill(col = &quot;nominal_gdp_bill_won&quot;, title = &quot;GPD (10억원)&quot;) + tm_borders(lwd = 0.5) + tm_text(&quot;CTP_KOR_NM&quot;, size = 0.5, col=&quot;blue&quot;) + tm_layout( main.title = &quot;시도별 명목 GDP (2019)&quot;, main.title.position = c(&quot;center&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) + tm_credits(&quot;Data :\\nKOSIS,\\n시도별 실질 GDP&quot;, size = 0.6, position = c(&quot;left&quot;, &quot;bottom&quot;)) pcg_KOR &lt;- tm_shape(simp_KOR_sf) + tm_fill(col = &quot;per_capita_gdp&quot;, title = &quot;1인당 명목소득(백만 원) &quot;, palette = &quot;YlGnBu&quot;) + tm_borders(lwd = 0.5) + tm_text(&quot;CTP_KOR_NM&quot;, size = 0.5, col=&quot;blue&quot;) + tm_layout( main.title = &quot;1인당 명목 GDP (2019)&quot;, main.title.position = c(&quot;center&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) + tm_credits(&quot;Data:\\n2019 Census&quot;, size = 0.6, position = c(&quot;left&quot;, &quot;bottom&quot;)) tmap_arrange(gdp_KOR, pcg_KOR) LEARN MORE: Axis Maps의 지도 제작 가이드는 지리 공간 데이터와 관련된 데이터 표준화 문제를 직접적으로 다루고 있다. 15.3.4 삽입 지도(Inset Maps) tmap은 특히 주 지도에 더 넓은 지리적 컨텍스트를 제공하는 작은 창을 포함하는 삽입 지도를 만드는 데 유용하다. 첫 번째 단계는 기본(base) 또는 본(primary) 지도를 만드는 것이다. 우리는 수도권의 남녀 성비율(main_sex)을 시각화하기로 한다. NOTE : tmap_tricks() 함수의 한 가지 트릭은 팔레트 이름 앞에 -를 배치하여 색상 스케일을 반전하는 것이다. 이것은 성별 비율이 감소함에 따라 우리의 관심이 증가해야 하기 때문에 의미가 있다. 다음으로 더 넓은 지리적 컨텍스트를 제공하는 더 작은 삽입 맵을 만들었다. 작은 지도의 경우 더 큰 지도에서 수도권 지역을 부각시키기 위해 표시한다. 이를 위해 먼저 속성을 지역별(type)로 그룹화했다. 동일한 dplyr 구문을 사용하여 18개 속성을 2개 지역으로 줄일 수 있다. 이러한 2개의 지역 속성은 개별 하위 구성 요소의 “합계”를 반영하는 geometry를 갖는다. 이런 종류의 기하학적 연산은 st_unify() 함수를 사용하여 쉽게 수행할 수 있다는 것이 매우 흥미롭다. 시도별 성비율 sex_ratio 컬럼을 이용한다. 수도권 지역의 남녀 성비율 지도 정보 생성 (main_sex) main_sex &lt;- simp_KOR_sf %&gt;% filter(type == &quot;수도권&quot; ) %&gt;% # 수도권 선택 tm_shape() + tm_fill(col = &quot;sex_ratio&quot;, title = &quot;수도권 남녀 성비율&quot;, palette = &quot;-Reds&quot;) + tm_borders(lwd = 1) + tm_text(&#39;CTP_KOR_NM&#39;, size = 0.75) + tm_layout( main.title = &quot;수도권의 남녀 성비율&quot;, main.title.position = c(&quot;center&quot;), main.title.size = 1.2, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) + tm_credits(&quot;Data Source: Wikipedia&quot;, position = c(&quot;left&quot;, &quot;top&quot;)) 우리나라 전체 지도중 수도권 지역을 표시하는 지도 정보 생성 (inset_KOR) type_sf &lt;- simp_KOR_sf %&gt;% group_by(type) %&gt;% summarise(pop = sum(pop_2019)) ## `summarise()` ungrouping output (override with `.groups` argument) inset_KOR &lt;- simp_KOR_sf %&gt;% # filter(type == &quot;수도권&quot;) %&gt;% mutate(CT = ifelse(type == &quot;수도권&quot;, TRUE, FALSE)) %&gt;% tm_shape() + tm_fill(col = &quot;CT&quot;, palette = c(&quot;grey&quot;, &quot;red&quot;)) + tm_style(&quot;cobalt&quot;) + tm_legend(show = FALSE) 일단 기본 맵과 삽입 맵이 있으면 몇 가지 시행 착오를 거쳐 올바른 배치를 위해 다음 구문으로 결합할 수 있다. library(grid) main_sex print(inset_KOR, vp = viewport(0.12, 0.22, width = 0.2, height = 0.6)) 15.3.5 Faceted 지도 tmap은 패싯 맵(faceted map) 또는 작은 조각 지도들의 생성도 지원한다. 그것들은 상당히 적은 수의 수준을 갖는 속성에 유용 할 수 있다. 예를 들어 몇 년 동안의 인구 데이터가 있다면 시간에 따른 변화 추이를 보여줄 수 있다. 이 경우 region은 패싯에 유용한 변수이다. region별로 지도를 분할하면 전체 지역에 대한 하나의 이미지를 보는 것보다 잘 비교가 될 수 있다. free.coords 인수는 패싯 맵 영역만 표시할지 아니면 원본 맵에서 패싯의 위치를 강조 표시할지 여부를 제어한다. region에 내재된 순서는 없지만 순서를 부과하는 것이 유용하다. 다음에서는 “Northern”에서 시작하여 대략 시계 반대 방향으로 패싯을 정렬했다. 이렇게 하려면 먼저 region을 정렬 된 요소로 만드는 것이 도움이된다. 플롯을 만들기 전에 분포의 특성에 주의를 기울이는 것도 중요하다. 인도에서는 1 인당 GDP가 Goa 및 Delhi와 같은 이상치로 인해 크게 왜곡되었다. 이 데이터를 선형 스케일로 매핑하면 대부분의 상태가 동일한 색상이 될 수 있다. 이것은 대량의 데이터에서 중요한 차이점을 숨길 것이다. 기울어진 데이터가있는 경우 로그 변환(logarithmic transformation)을 수행하는 것이 도움이 될 수 있다. 색상 구간이 같지 않기 때문에 범례에 더 신중한 해석이 필요할 수 있지만 이렇게하면 맵에 더 큰 색상 차별화가 추가될 수 있다. LEARN MORE: 데이터 시각화 범주에서 통계적 변환에 대한 자세한 내용은 Wilke 저서의 섹션 8.2를 참조하기 바란다. 우리나라의 수도권과 지방의 1인당 GDP를 패싯 맵으로 시각화해 보자. # create custom labels for log scale : 1인당 명목 GDP 구간(6 단계) gdp_seq &lt;- 10 ^ (seq(1.34, 1.85, length.out = 7)) gdp_vec &lt;- paste(round(gdp_seq), &quot;백만원&quot;) my_labels = vector(mode = &quot;character&quot;, length = 6) for (i in seq_along(1:6)) { my_labels[i] = str_c(gdp_vec[i], &quot; ~ &quot;, gdp_vec[i + 1]) } simp_KOR_sf %&gt;% mutate( log_pc = log10(per_capita_gdp)) %&gt;% tm_shape() + # CTP_fac = factor(CTP_KOR_NM, levels = simp_KOR_sf$CTP_KOR_NM)) %&gt;% # filter(!state_ut %in% c(&quot;Andaman &amp; Nicobar Islands&quot;, # &quot;Lakshadweep&quot;)) tm_borders(lwd = 0.5, col = &quot;white&quot;) + tm_fill(col = &#39;log_pc&#39;, title = &#39;금액&#39;, palette = &quot;viridis&quot;, labels = my_labels) + tm_facets(by = &quot;type&quot;, nrow = 2, free.coords = TRUE) + tm_layout( main.title = &quot;시도별 1인당 GDP&quot;, main.title.size = 1.5, main.title.position = &quot;center&quot;, legend.outside.position = &quot;right&quot; ) 위의 예에서log10() 변환은 더 높은 수준의 차별화를 달성하였다. 예를 들어 Goa와 Delhi의 작은 밝은 노란색 점, Uttar Pradesh와 Jharkhand의 파란색, Central India와 Rajasthan의 청록색, South India의 녹색을 구분할 수 있다. NOTE : tm_facets()의 free.coords 인수는 TRUE로 설정되어 있다. 만일 ’FALSE’로 설정된 경우 인도의 전체지도가 지정된 region이 강조 표시된 각 facet에 표시된다. 15.3.6 비례 기호 지도(Proportional Symbols Maps) 지금까지 우리의 모든 맵은 단계 구분도였다. 데이터는 밀도, 백분율 또는 비율과 같은 방식으로 항상 표준화 되었기 때문에 편리했다. 그러나 단계 구분도는 원시 카운트 데이터에 적합하지 않다. 인구와 같은 카운트 데이터를 처리 할 때 비례 기호 지도(또는 ’bubble map’이라고도 한다.)가 더 효과적 일 수 있다. 운 좋게도 tmap 패키지는 이러한 유형의 시각화에도 적합하다. 여기에서 기호 (일반적으로 ‘원’)는 원래 지리 위에 묘사된 변수에 비례하여 그려진다. 이런 종류의 지도를 사용하여 인구와 명목 GDP 데이터를 모두 시각화 할 수 있다. 우리나라의 시도별 인구수와 명목 GDP를 비례 기호 지도로 시각화해보자. 먼저 인구수(pop_2019) 비례 기호 지도를 생성한다. pop_KOR_bubbles &lt;- simp_KOR_sf %&gt;% tm_shape() + tm_polygons() + tm_bubbles(col = &quot;gold&quot;, size = &quot;pop_2019&quot;, scale = 3, title.size = &quot;&quot;) + tm_text(&quot;CTP_KOR_NM&quot;, size = &quot;pop_2019&quot;, root = 5, legend.size.show = FALSE) + tm_layout( main.title = &quot;시도별 인구 (2019)&quot;, main.title.position = c(&quot;center&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) 이어서 시도별 명목 GDP(nominal_gdp_bill_won) 비례 기호 지도 정보를 생성한다. gdp_KOR_bubbles &lt;- simp_KOR_sf %&gt;% tm_shape() + tm_polygons() + tm_bubbles(col = &quot;gold&quot;, size = &quot;nominal_gdp_bill_won&quot;, scale = 3, title.size = &quot;&quot;) + tm_text(&quot;CTP_KOR_NM&quot;, size = &quot;nominal_gdp_bill_won&quot;, root = 5, legend.size.show = FALSE) + tm_layout( main.title = &quot;시도별 명목 GDP (단위 : 십억원)&quot;, main.title.position = c(&quot;center&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) 이제 생성된 2 개의 비례 기호 지도를 정렬한다. tmap_arrange(pop_KOR_bubbles, gdp_KOR_bubbles) ## Legend labels were too wide. Therefore, legend.text.size has been set to 0.46. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## The legend is too narrow to place all symbol sizes. ## Legend labels were too wide. Therefore, legend.text.size has been set to 0.38. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. ## The legend is too narrow to place all symbol sizes. 비례 기호 지도는 기호의 최상위 레이어에 의해서만 가려진 원래 지리를 유지한다. 기호는 올바른 공간 배열을 유지하며 서로 관계에서 해석하기 쉽다. 그러나 원의 면적을 판단하는 것은 막대 그래프와 같은 비공간적 표현에 비해 더 어렵다. 15.3.7 ggplot2의 geom_sf 이 예제들이 tmap이 강력한 매핑 도구임을 보여 주었으면 한다. 동시에 geom_sf의 추가로 ggplot2 패키지는 또 다른 매력적인 옵션이 되었다. ggplot2 패키지에는 tidy 데이터가 필요핟. sf 패키지에서 정의된 공간 데이터 프레임도 데이터 프레임이므로 ggplot2를 사용하여 sf 개체를 시각화할 수 있다고 예상할 수 있다. 최근 ggplot2 패키지는geom_sf () 함수로 sf 개체에 대한 지원을 추가했다. geom_sf() 함수의 주요 장점은 tidyverse 패키지 사용자가 이미 ggplot2 패키지와 더 넓은 애드온 패키지 생태계에 익숙하다는 것이다. 그러나 이것은 최근에 추가되었으므로 몇 가지 버그가 있을 수 있다. 예를 들어, 위의 facet이 있는 tmap 개체에서 free.coords = FALSE를 설정하면 전체 개체가 각 패싯에 플로팅될 수 있다. 현재,sf 기하학을 패싯화하는 것은 유사한 결과를 허용하기 위해 scales = \"free\"의 설정을 허용하지 않는 것 같다. 그럼에도 불구하고 ggplot2 패키지로 sf 개체를 시각화할 수있는 많은 이점과 사례가 있다. 예를 들어 ‘ggplot2’ 패키지 사용자는 데이터 프레임에서 aes()에 데이터를 매핑하고 플롯 위에 추가 데이터 프레임을 레이어링하는 과정에 익숙할 것이다. 동일한 워크 플로우가 sf 개체를 플로팅하는 데도 적용된다. 아래 플롯에서 주 이름 “Kerala”만을 지도에 추가하려고 한다. 우리는annotate () 함수로 이를 수행할 수 있었지만, 대신 (Kerala) 라는 주석을 달고자 하는 feature 만 포함하는 sf 객체 (데이터 프레임이기도 함)를 만들수 있었다. 그러나 이를 성공적으로 수행하려면 먼저 라벨을 표시할 지점을 알기 위해 Kerala 의 지리적 중심을 찾아야 한다. 중심, 버퍼 및 거리 계산과 같은 기하학적 연산에는 지리적 CRS(geographic CRS)가 아닌 투영된 CRS(projected CRS)가 필요하므로 아래에서st_transform ()을 사용하여 이를 수행한다. 지리적 CRS를 사용하면 st_centroid () 함수가 결과를 생성하지만 “st_centroid()가 경도/위도 데이터에 대해 정확한 중심을 제공하지 않는다”라는 경고를 생성한다. 이는 속성들이 geometry 전반에 걸쳐 일정하다고 가정하기 때문이다. 그러나 경도 사이의 거리는 주어진 위도에 따라 변경된다. (적도에서의 경도 사이의 거리와 북극에서의 경도 사이의 거리를 생각해보기 바란다.) 그러면 문제는 적절한 투영된 CRS를 선택하는 것이 된다. crs_data = rgdal :: make_EPSG()를 보면 수천 가지 옵션이 표시된다. EPSG.io에서도 ’인도’를 검색했다. 궁극적으로 우리는 UTM zone 43N이 Kerala를 포함하기 때문에 “# Kalianpur 1975 / UTM zone 43N”을 기록하는 EPSG 코드 24343의 CRS를 선택했다. (Projection Wizard도 발견할 수 있다.) 이 CRS를 사용하여 st_transform()을 사용하여 두 sf 개체를 동일한 투영된 CRS에 투영할 수 있었다. 이 작업이 완료되면 일반적으로 ggplot2 패키지에서 하는 것처럼 geom_text_repel() 함수를 사용하여 Kerala 레이블을 추가할 수 있다. library(ggplot2) library(ggrepel) 남여 성비율(sex_ratio) 지리공간 데이터를 확인해 보자. 이미 투영된 CRS를 사용하고 있음을 알 수 있다. 각 feature들의 중심 좌표를 구한다. proj_KOR_sf &lt;- simp_KOR_sf %&gt;% # st_set_crs(24343) %&gt;% # 이 부분이 누락되어 있었음 # st_transform(crs = 24343) %&gt;% mutate( CENTROID = purrr::map(geometry, st_centroid), COORDS = purrr::map(CENTROID, st_coordinates), COORDS_X = purrr::map_dbl(COORDS, 1), COORDS_Y = purrr::map_dbl(COORDS, 2) ) 대전광역시 feature 정보를 선택한다. dj &lt;- proj_KOR_sf %&gt;% filter(CTP_KOR_NM == &quot;대전광역시&quot;) 시도별 남여 성비율 지도 정보에 “대전광역시” 라벨을 출력해 보자. proj_KOR_sf %&gt;% # filter(!state_ut %in% c(&quot;Daman &amp; Diu&quot;, &quot;Dadra &amp; Nagar Haveli&quot;)) %&gt;% ggplot() + geom_sf(aes(fill = sex_ratio), lwd = 0) + geom_sf(fill = NA, color = &quot;grey&quot;, lwd = 0.5) + scale_fill_viridis_c(&quot;Sex Ratio&quot;, labels = scales::comma, option = &quot;A&quot;) + labs( title = &quot;Sex Ratio across Indian States&quot;, caption = &quot;Source: Wikipedia&quot; ) + geom_text_repel( data = dj, mapping = aes(x = COORDS_X, y = COORDS_Y, label = CTP_KOR_NM), color = &quot;blue&quot;, size = 3, nudge_x = -1.5, nudge_y = 0.5 ) + scale_y_continuous(NULL) + scale_x_continuous(NULL) + theme(plot.title = element_text(hjust = 0.5)) + # remove graticules coord_sf(datum = NA) + theme_void() 15.3.8 점 밀도 지도(Dot Density Maps) 비례 기호 지도는 원시 개수 데이터에 대한 유일한 옵션이 아니다. 점 밀도 지도는 특히 정확한 데이터 값 대신 군집 및 지역 패턴을 찾는 것이 목표인 경우 카운트 데이터를 공간적으로 시각화하는 효과적인 도구가 될 수 있다. 아래에서는 각 시도별 남성과 여성 인구를 비교하는 점 밀도 플롯을 만들었다. 이를 위해 먼저 tidy 데이터 형식과 남성인구 및 여성인구 데이터를 ‘gather ()’ 하는데서 시작한다. 그런 다음 st_sample () 함수를 사용하여 각 관측 값에 대한 시도별 남성과 여성 인구 데이터를 기반으로 샘플 포인트를 그린다. 이러한 유형의 시각화는 지구와 같은 소규모 관리 수준의 데이터가 있는 경우 훨씬 더 효과적이다. 대신, 우리는 시도 수준에서 샘플링하기 때문에 실제 인구 밀도와 반대되는 위치에 점이 배치된다. 시도별 지역명의 지리공간 데이터를 추출한다. # save geometry proj_KOR_geometry &lt;- proj_KOR_sf %&gt;% dplyr::select(CTP_KOR_NM) # 지역명의 지리공간 데이터 wide format을 long format으로 변환한다. 그리고 점 정보를 생성한다. # gather data and rejoin geometry pop_KOR_gathered &lt;- proj_KOR_sf %&gt;% st_set_geometry(NULL) %&gt;% dplyr::select(CTP_KOR_NM, pop_male_2019, pop_female_2019, pop_2019) %&gt;% gather(key = &quot;pop&quot;, value = &quot;count&quot;, -CTP_KOR_NM) %&gt;% arrange(CTP_KOR_NM) %&gt;% left_join(proj_KOR_geometry) %&gt;% st_as_sf() ## Joining, by = &quot;CTP_KOR_NM&quot; # create a list of male and female populations pop_KOR_split &lt;- pop_KOR_gathered %&gt;% split(.$pop) # draw 1 dot generate_KOR_samples &lt;- function(data) { st_sample(data, size = round(data$count / 1e5)) } # generate samples for each and combine points_KOR &lt;- map(pop_KOR_split, generate_KOR_samples) points_KOR1 &lt;- imap(points_KOR, ~st_sf(tibble( pop = rep(.y, length(.x))), geometry = .x)) points_KOR2 &lt;- do.call(rbind, points_KOR1) # group points into multipoints points_KOR3 &lt;- points_KOR2 %&gt;% group_by(pop) %&gt;% summarise() ## `summarise()` ungrouping output (override with `.groups` argument) 시각화 한다. # plot with ggplot points_KOR3 %&gt;% ggplot() + geom_sf(data = simp_KOR_sf) + geom_sf(aes(color = pop, fill = pop), size = 0.4, alpha = 0.6) + scale_fill_discrete(&quot;Population&quot;, labels = c(&quot;male&quot;, &quot;female&quot;)) + labs( title = &quot;Density of Korea&#39;s male and female Population (2011)&quot;, caption = &quot;1 dot = 1 lakh people&quot; ) + theme(plot.title = element_text(hjust = 0.5)) + coord_sf(datum = NA) + theme_void() + guides(color = FALSE) 또한 다음 장에서 볼 수 있듯이 이것은 시각화의 한 예이다. 상호 작용 기능을 추가할 수도 있다. LEARN MORE : R에서 도트 밀도 플롯을 생성하는 방법에 대한 자세한 내용은 Tarak 및 Paul Campbell의 우수한 블로그를 참조하기 바란다. "],["부분-공간-정적-표현.html", "15.4 부분 공간 정적 표현", " 15.4 부분 공간 정적 표현 이 장의 시작 부분에서 관측 단위(예 : 주)의 영역과 인구 간에 큰 차이가있을 경우 단계 구분도가 어떻게 데이터를 잘못 표현할 수있는가에 대해 논의했다. 데이터가 부분적으로만 공간적인 경우 목표에 따라 지도가 항상 최상의 시각화가 아닐 수 있다. 데이터의 완전한 공간적 표현이 필요하지 않은 경우 데이터의 일부 공간적 측면을 전달하지만 일부 측면 또는 다른 측면에서는 서로 다른 시각화 옵션이 있다. 예를 들면 cartogram, hexbin map 그리고 geofaceted map 등이 있다. 15.4.1 카토그램(Cartograms) cartogram에서 우리는 물체의 전체적인 지리 공간적 특성을 유지하지만 각 관측 단위의 면적을 왜곡하여 각 단위가 선택한 변수에 비례적으로 조정된다. 명목 GDP는 이러한 관계를 입증하는 데 유용한 변수이다. 예를 들어 매우 작은 지리적 영역과 관련하여 Delhi의 인도 GDP 기여도는 매우 높다. 전통적인 단계 구분도(왼쪽에 표시)는 이러한 구분을 하지 못한다. 카토그랩(오른쪽에 표시됨)를 사용하여 인도 GDP에 대한 기여도와 일치하도록 주별 지리적 영역을 왜곡할 수 있다. 패키지 불러오기 library(cartogram) 15.4.1.1 인접하고 있는 Cartogram 경계 계산 a rubber sheet distortion algorithm (Dougenik et al. 1985)에 의한 cartogram_cont() 함수로 연속적인 지역 카토그램을 구축한다. ## Mean size error for iteration 1: 3.84785850266859 ## Mean size error for iteration 2: 2.68193851673907 ## Mean size error for iteration 3: 2.11044828890105 ## Mean size error for iteration 4: 1.77458546097519 ## Mean size error for iteration 5: 1.56448207625474 ## Mean size error for iteration 6: 1.42533722063285 ## Mean size error for iteration 7: 1.32248889306723 ## Mean size error for iteration 8: 1.24557926073764 ## Mean size error for iteration 9: 1.18794259503048 ## Mean size error for iteration 10: 1.14473739522909 ## Mean size error for iteration 11: 1.11227847174158 ## Mean size error for iteration 12: 1.08778491880471 ## Mean size error for iteration 13: 1.06919026752683 ## Mean size error for iteration 14: 1.05497330822064 ## Mean size error for iteration 15: 1.04402090690165 15.4.1.2 지리정보를 생성한다. 왜곡된 카토그램 생성 gdp_KOR_ccart &lt;- ccart_gdp_KOR_sf %&gt;% # filter(!state_ut == &quot;Andaman &amp; Nicobar Islands&quot;) %&gt;% tm_shape() + tm_polygons(&quot;nominal_gdp_bill_won&quot;, title = &quot;명목 GDP (10억 원)&quot;, palette = &quot;Greens&quot;) + tm_layout( main.title = &quot;명목 GDP로 왜곡된 지역&quot;, main.title.position = c(&quot;left&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) 원래의 지도 생성 gdp_KOR_original &lt;- proj_KOR_sf %&gt;% # filter(!state_ut == &quot;Andaman &amp; Nicobar Islands&quot;) %&gt;% tm_shape() + tm_polygons(col = &quot;nominal_gdp_bill_won&quot;, title = &quot;명목 GDP (10억 원)&quot;, palette = &quot;Greens&quot;) + tm_layout( main.title = &quot;명목 GDP&quot;, main.title.position = c(&quot;left&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) 두 개의 지도정보를 배치하여 시각화 한다. tmap_arrange(gdp_KOR_original, gdp_KOR_ccart) 인도의 전체적인 지리적 구조를 유지하면서, 우리는 명목 GDP의 크기로 지리적 영역을 왜곡할 때 어떤 시/도가 축소되거나 확장되는지 생생하게 볼 수 있다. (위에서 설명한 것과 동일한 이유로 지리적인 CRS가 아닌 투영된 CRS를 사용해야 한다.) 위에서 우리는 cartogram_cont() 함수로 연속적인 카토그램을 만들었다. 그러나 아래와 같이 시/도별로 분리를 도입하는cartogram_ncont() 함수를 사용하여 불연속 영역 카토그램을 쉽게 선택할 수도 있고, cartogram_dorling() 함수를 사용하여 각각의 시/도를 원으로 표시하는 Dorling 카토그램을 선택할 수도 있다. 불연속 카토그램 경계 계산 ncart_gdp_KOR_sf &lt;- cartogram_ncont(proj_KOR_sf, &quot;nominal_gdp_bill_won&quot;) dorling 카토그램 계산 dorling_gdp_KOR_sf &lt;- cartogram_dorling(proj_KOR_sf, &quot;nominal_gdp_bill_won&quot;) 불연속 카토그램 지도정보 생성 gdp_KOR_ncart &lt;- ncart_gdp_KOR_sf %&gt;% # filter(!state_ut == &quot;Andaman &amp; Nicobar Islands&quot;) %&gt;% tm_shape() + tm_polygons(&quot;nominal_gdp_bill_won&quot;, title = &quot;명목 GDP (10억 원)&quot;, palette = &quot;Greens&quot;) + tm_layout( main.title = &quot;불연속 카토그램&quot;, main.title.position = c(&quot;left&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) dorling 카토그램 지도정보 생성 gdp_KOR_dorling &lt;- dorling_gdp_KOR_sf %&gt;% # filter(!state_ut == &quot;Andaman &amp; Nicobar Islands&quot;) %&gt;% tm_shape() + tm_polygons(&quot;nominal_gdp_bill_won&quot;, title = &quot;명목 GDP (10억 원)&quot;, palette = &quot;Greens&quot;) + tm_text(&quot;CTP_KOR_NM&quot;, size = 0.5) + tm_layout( main.title = &quot;Dorling Cartogram&quot;, main.title.position = c(&quot;left&quot;), main.title.size = 1.5, legend.position = c(&quot;right&quot;, &quot;bottom&quot;) ) 두 개의 지도정보를 배치하여 시각화 한다. tmap_arrange(gdp_KOR_ncart, gdp_KOR_dorling) 카토그램이 이미 실제 지리적 형태를 왜곡하고 있기 때문에 하나의 연속 단위를 유지할 필요가 없는 경우가 많다. 이러한 경우 비 연속적인 카토그램이 바람직 할 수 있다. 또는 더 추상적인 방식으로 모든 지리적 형태를 관심있는 매개 변수에 맞게 조정된 단순한 원으로 대체 할 수도 있다. NOTE : Dorling지도는 기본적으로 기본지도가 없는 비례 기호 지도이다. 15.4.2 Hexbin지도 Dorling 카토그램과 유사하게 hexbin 지도는 정확한 공간 경계를 대략적인 공간 배열로 대체한다. 그러나 관심 변수를 크기에 매핑하는 대신 색상에 매핑한다. 미국과 다른 몇몇 국가를 위한 Hexbin 그리드는 잘 확립되어 있지만 geogrid 패키지는 지리 공간 다각형 세트에 지정된 자동 hexbin을 생성하고자 하는 새로운 패키지이다. 이 패키지를 사용하면 가능한 여러 그리드를 생성하고 최상의 옵션을 선택할 수 있지만, 특정 주, 특히 북동부 및 인접하지 않은 영토를 적절하게 배치하는 지도를 생성하는 데 문제가 있었다. 그럼에도 불구하고 아래의 hexbin 지도는 지리 공간 다각형을 육각형으로 줄이는 것이 특정 경우에 원래 geometry보다 더 유용 할 수있는 이유를 보여준다. library(geogrid) # devtools::install_github(&quot;jbaileyh/geogrid&quot;) ## test possible grids before selecting seed par(mfrow = c(3, 3), mar = c(0, 0, 2, 0)) for (i in 1:9) { new_cells &lt;- calculate_grid(shape = proj_sf, grid_type = &quot;hexagonal&quot;, seed = i) plot(new_cells, main = paste(&quot;Seed&quot;, i, sep = &quot; &quot;)) } new_cells_KOR_hex &lt;- calculate_grid(shape = proj_KOR_sf, grid_type = &quot;hexagonal&quot;, seed = 1) ## Warning in showSRID(uprojargs, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj = ## prefer_proj): Discarded datum Unknown based on GRS80 ellipsoid in CRS definition ## Warning in showSRID(SRS_string, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj = ## prefer_proj): Discarded datum International Terrestrial Reference Frame 2000 in ## CRS definition ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output ## Warning in proj4string(obj): CRS object has comment, which is lost in output hex_KOR_result &lt;- assign_polygons(proj_KOR_sf, new_cells_KOR_hex) ## Warning in showSRID(uprojargs, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj = ## prefer_proj): Discarded datum Unknown based on GRS80 ellipsoid in CRS definition ## Warning in showSRID(SRS_string, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj = ## prefer_proj): Discarded datum International Terrestrial Reference Frame 2000 in ## CRS definition # assign_polygons generates V1 V2 which are center coordinates of tiles ggplot(hex_KOR_result) + geom_sf(aes(fill = per_capita_gdp)) + geom_text(aes(x = V1, y = V2, label = CTP_KOR_NM), size = 3, colour = &quot;white&quot;) + scale_fill_viridis_c(&quot;1인당 명목 GDP\\n(단위 : 백만 원)&quot;) + labs( title = &quot;1인당 명목 GDP Hexbin 지도&quot;, caption = &quot;Data Source: Wikipedia&quot; ) + coord_sf(datum = NA) + theme_void() + guides(size = FALSE) 참고 : 패키지의 [README] (https://github.com/jbaileyh/geogrid)는 sp 클래스를 사용하여 지오그리드를 생성하는 프로세스를 문서화하지만 (위에와 같이) sf 개체의 경우 더 간단하다. 이 시각화의 단점은 모든 시/도에 동일한 영역을 제공한다는 것이다. 그러나 이러한 맥락을 미리 이해한다면 인구나 지역에 관계없이 시/도별 1 인당 GDP 분포 만 원하는 경우 유용한 시각화가 될 수 있다. 15.4.3 Geofaceted Plots hexbin 지도와 유사하게 geofaceted plot은 느슨한 공간 배열을 위해 정확한 공간 특성을 희생한다. 지리 공간 표현을 명백히 희생하고, 속성 데이터의 정확한 표현을 강력하게 우선시한다. geofacet 패키지를 사용하면 사용자 지정 그리드를 쉽게 디자인하고 그리드에서 데이터를 facet하는 데 사용할 수 있다. 1.패키지를 불러온다. library(geofacet) wide form을 long form으로 변환한다. Type 컬럼에 남성 인구(pop_male_2019)와 여성 인구(pop_female_2019) 컬럼 이름을 값으로, 그리고 pop_value 컬럼에 남성 인구수와 여성 인구수를 그 값을 하여 long_form으로 변환한다. Type의 값을 “남성”과 “여성”으로 바꾼다. simp_KOR_df &lt;- simp_KOR_sf %&gt;% st_set_geometry(NULL) %&gt;% dplyr::select(CTP_ENG_NM, pop_male_2019, pop_female_2019) %&gt;% gather(Type, pop_value, -CTP_ENG_NM) %&gt;% mutate(Type = ifelse(Type == &quot;pop_male_2019&quot;, &quot;남성&quot;, &quot;여성&quot;)) 시각화 한다. facet_geo() 함수의 grid 인수는 grids: Geo Grids를 참고하였다. 한국의 시/도를 위한 grid는 현재 sk_province_grid1만이 제공되고 있다. ggplot(simp_KOR_df, aes(x = Type, y = pop_value / 1e4, fill = Type)) + geom_col() + # facet_geo(~ state_ut, grid = mygrid, label = &quot;code&quot;) + facet_geo(~ CTP_ENG_NM, grid = &quot;sk_province_grid1&quot;, label = &quot;CTP_ENG_NM&quot;) + labs( title = &quot;시도별 남성과 여성 인구 (2019)&quot;, caption = &quot;Data Source: Wikipedia&quot;, x = &quot;&quot;, y = &quot;인구 수\\n(단위 : 만명)&quot; ) + theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) ## Note: the specified label = &#39;CTP_ENG_NM&#39; does not exist in the supplied ## grid and it will be ignored. ## Some values in the specified facet_geo column &#39;CTP_ENG_NM&#39; do not match ## the &#39;name&#39; column of the specified grid and will be removed: ## Sejong-si, Jellanam-do, Jeju-do 더 이상 시도별 지도처럼 보이지는 않지만 이 시각화는 주 전체의 도시 및 농촌 인구의 막대한 차이를 생생하게 전달한다. 또한 시각화 선택이 해석에 어떤 영향을 미치는지 강조하고 있다. NOTE : 위에서 만든 점 밀도 지도는 정확히 동일한 데이터에서 생성되었다. "],["마지막-생각들-1.html", "15.5 마지막 생각들", " 15.5 마지막 생각들 패키지 tmap, ggplot2, cartogram, geogrid 그리고 geofacet 등의 도움으로 이 장에서는 R에서 구간 계급도, 점 밀도 지도 및 카토그랩 등과 같은 가장 보편적인 방법들에 대하여 소개하였다. 정적지도를 넘어 애니메이션 또는 대화형 지도의 세계를 탐험하고 싶지 않은가? 다음의 장에사 이에 대하여 살펴보겠다. "],["공간-데이터-서브세팅.html", "16 공간 데이터 서브세팅", " 16 공간 데이터 서브세팅 This lesson was written by Sean Angiolillo and was last updated on 29 Jan. 2019. So far in this GIS course, we’ve introduced the following ideas: use cases for geospatial data getting started with the sf package manipulating attributes of geospatial data in a tidy workflow visualizing geospatial data through a wide array of static, interactive and animated maps However, we’ve yet to really do anything useful with the actual geometry of our geospatial data. In this lesson, we’ll introduce spatial subsetting, an important family of operations applicable to geospatial data. "],["공간-데이터-분할spatial-subsetting이란.html", "16.1 공간 데이터 분할(Spatial Subsetting)이란?", " 16.1 공간 데이터 분할(Spatial Subsetting)이란? 우리는 일반 데이터 프레임과 마찬가지로 속성을 통해 sf 공간 데이터 프레임을 조작하는 방법에 대하여 살펴 보았다. 예를 들어 dplyr를 사용하면 공간 데이터 프레임을 필터링하여 특정 factor 수준과 일치하거나 특정 임계 값보다 높거나 낮은 숫자 변수를 갖는 관측치 만을 유지할 수 있다. 마찬가지로 지리 공간 데이터의 geometry 열을 사용하여 관측치(행)을 필터링 할 수도 있다. Geocomputation with R에 정의 된 바와 같이, \"공간데이터 서브세팅은 공간에서 어떤 방식으로든 다른 객체와 관련이 되느냐에 따라서 공간 개체의 features들을 선택하는 과정이다. / LEARN MORE : Geocomputation with R의 제4장, “공간 데이터 연산”은 R의 공간데이터 서브세팅을 학습할 때 도움이 된다. 앞의 예에서, 충청북도와 경계를 공유하는 시/도들만을 필터링할 수 있다. 또는 시/도와 같은 속성으로 필터링하는 대신에 특정 지점에서 특정 거리 내에 있는 시 또는 도 지역에만 관심이 있을 수 있다. 공간데이터 서브세팅 연산은 이러한 종류의 조작을 수행 할 수 있게 해준다. "],["위상-관계.html", "16.2 위상 관계", " 16.2 위상 관계 다양한 유형의 공간데이터 서브세팅 연산이 가능하다. 다양한 유형의 공간 관계를 보다 공식적으로는 위상 관계(topological relations) 라고 한다. 위에 주어진 두 가지 예는 서로 다른 위상 관계를 설명한다. 전자는 공통 경계 또는 “접촉” 영역을 찾는 것이고, 반면에 후자는 다른 영역 “내” 영역을 찾는 것이다. sf 패키지에서 구현된대로 st_intersects() 함수, st_disjoint() 함수, st_within() 함수, st_contains() 함수, st_touches() 함수, st_crosses() 함수 등의 함수로 이러한 연산을 수행하게 된다. 이러한 기능에 대한 설명서에 이들 함수의 전체 목록이 수록되어 있다. 이러한 함수에는 sf geometry 세트의 쌍(대상 개체 및 선택 개체)이 필요하다. 특정 구문에 대해 알아보기 전에 먼저 이러한 관계가 어떻게 정의되는지 살펴 보기로 한다. 가장 간단한 것은 st_intersects()와 그 반대 st_disjoint()이다. 두 개의 sf 개체를 st_intersects()에 주면 어떤 방식 으로든 서로 교차하는 모든 관측 값이 반환된다. 반대로st_disjoint ()는 교차되지 않는 관측 값을 반환한다. 또 다른 연산자 쌍은 st_within() 및 st_contains() 함수들이다. 이 두 연산은 모두 한 객체 또는 다른 객체 내에 있는 관측값 만을 반환한다. “x”와 “y” 인수의 지정은 st_within() 함수 또는 st_contains() 함수가 실제로 필요한 작업인지 여부를 결정한다. st_within() 함수는 완전히 “y”에 속하는 “x”의 관측치를 반환하고, st_contains()는 “y”를 완전히 포함하는 “x”의 관측치를 반환한다. LEARN MORE : 이러한 관계성(relationship)은 다이어그램으로 이해하기 훨씬 쉽다. GITTA는 ’위상 관계’에 대하여 각각의 벤 다이어그램을 이용하여 잘 소개하고 있다.더 많은 다이어그램은 Wikipedia에서도 확인할 수 있다. 또 다른 유용한 자료로는 관계 간의 차이를 살펴보기 위해 R 내의 장난감 데이터를 사용하는 S Ogletree의 기사가 있다. "],["데이터-준비.html", "16.3 데이터 준비", " 16.3 데이터 준비 공간 데이터 서브세팅의 구문을 살펴보기 전에 샘플 데이터가 필요하다. tidycensus 패키지와 tigris 패키지를 사용하여 인구 조사 지역 수준에서 필라델피아 대도시 지역에 대한 가계 소득 중앙값 데이터를 다운로드 할 것이다. NOTE : 미국 인구 조사 계층에서 인구 조사 지역은 카운티 아래, 블록 그룹 위r가 있다. 자세한 내용은 Kyle Walker의 tigris 슬라이드를 참조하기 바란다. LEARN MORE : 설명서는 Kyle Walker의 ‘tidycensus’ 패키지와 ‘tigris’ 패키지를 사용하기 시작하는 좋은 방법이다. 그런데, 이를 이용하기 위해서는 인구 조사국에서 API 키를 받아야 한다. 패키지 불러오기 library(tigris) ## To enable ## caching of data, set `options(tigris_use_cache = TRUE)` in your R script or .Rprofile. library(sf) library(tidycensus) library(tidyverse) library(rvest) ## Loading required package: xml2 ## ## Attaching package: &#39;rvest&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## pluck ## The following object is masked from &#39;package:readr&#39;: ## ## guess_encoding 16.3.1 옵션 설정 및 API 키 인증 options(tigris_class = &quot;sf&quot;) options(tigris_use_cache = TRUE) api_key &lt;- &quot;01e2a49615f41b5fa4f37d4ef269884826a8d7b2&quot; census_api_key(api_key) ## To install your API key for use in future sessions, run this function with `install = TRUE`. 16.3.2 공간 데이터 불러오기 tigris 패키지에는 대도시 지역의 shapefile을 다운로드하는core_based_statistical_areas()함수가 있지만, 대신에 우리가 관심을 갖는 지역을 담고 있는 카운티 테이블부터 시작하겠다. 그런 다음 공간 데이터 서브세팅을 통해 좀 더 좁은 지리적 영역을 얻는 방법에 대하여 알아 보겠다. # create df of states and counties counties &lt;- tribble( ~state, ~county, &quot;PA&quot;, &quot;Philadelphia&quot;, &quot;PA&quot;, &quot;Montgomery&quot;, &quot;PA&quot;, &quot;Bucks&quot;, &quot;PA&quot;, &quot;Delaware&quot;, &quot;NJ&quot;, &quot;Burlington&quot;, &quot;NJ&quot;, &quot;Camden&quot;, &quot;NJ&quot;, &quot;Gloucester&quot; ) # query tidycensus and combine data into one sf object raw_tracts &lt;- map2(counties$state, counties$county, function(x, y) { get_acs(geography = &quot;tract&quot;, state = x, county = y, variables = c(hhincome = &quot;B19013_001&quot;), geometry = TRUE) }) %&gt;% do.call(rbind, .) ## Getting data from the 2015-2019 5-year ACS ## Getting data from the 2015-2019 5-year ACS ## Getting data from the 2015-2019 5-year ACS ## Getting data from the 2015-2019 5-year ACS ## Getting data from the 2015-2019 5-year ACS ## Getting data from the 2015-2019 5-year ACS ## Getting data from the 2015-2019 5-year ACS glimpse(raw_tracts) ## Rows: 1,186 ## Columns: 6 ## $ GEOID &lt;chr&gt; &quot;42101014500&quot;, &quot;42101004202&quot;, &quot;42101004102&quot;, &quot;42101000804&quot;... ## $ NAME &lt;chr&gt; &quot;Census Tract 145, Philadelphia County, Pennsylvania&quot;, &quot;Ce... ## $ variable &lt;chr&gt; &quot;hhincome&quot;, &quot;hhincome&quot;, &quot;hhincome&quot;, &quot;hhincome&quot;, &quot;hhincome&quot;... ## $ estimate &lt;dbl&gt; 17991, 47935, 40958, 108293, 41545, 35591, 39394, 49906, 3... ## $ moe &lt;dbl&gt; 6274, 14670, 12742, 11643, 3413, 10534, 7829, 11268, 9285,... ## $ geometry &lt;MULTIPOLYGON [arc_degree]&gt; MULTIPOLYGON (((-75 40, -75..., MULT... 현재 필라델피아 대도시 지역을 포괄하는 1,186 개의 인구 조사 지역이 있다. 이것은 우리가 다루고자 하는 것보다 더 큰 영역이므로 관심지역의 중심 지점(이 경우 필라델피아 시청)으로부터의 거리를 기준으로 이 데이터 세트를 더 작은 영역으로 공간으로 서브세팅할 것이다. 그러나 이를 수행하기 전에 지리 공간 데이터의 좌표 참조 시스템(CRS, Coordinate Reference System)에 주의를 기울이는 것이 중요하다. 다음의 명령은 데이터에 EPSG 코드가 4269인 지리적 CRS가 있음을 보여준다. st_crs(raw_tracts) ## Coordinate Reference System: ## User input: NAD83 ## wkt: ## GEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;latitude&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;longitude&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]] ## Coordinate Reference System: ## EPSG: 4269 ## proj4string: &quot;+proj=longlat +datum=NAD83 +no_defs&quot; st_is_longlat(raw_tracts) ## [1] TRUE 공간 서브세팅 연산을 사용하려면 지리적 CRS에서 투영된 CRS로 데이터를 재투영해야 한다. 이 경우 EPSG 코드 2272를 사용하도록 선택했다. LEARN MORE: For more information on coordinate reference systems, see Chapter 2 and Chapter 6 of Geocomputation with R. proj_crs &lt;- 2272 proj_tracts &lt;- raw_tracts %&gt;% st_transform(crs = proj_crs) st_crs(proj_tracts) ## Coordinate Reference System: ## User input: EPSG:2272 ## wkt: ## PROJCRS[&quot;NAD83 / Pennsylvania South (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Pennsylvania South zone (US Survey feet)&quot;, ## METHOD[&quot;Lambert Conic Conformal (2SP)&quot;, ## ID[&quot;EPSG&quot;,9802]], ## PARAMETER[&quot;Latitude of false origin&quot;,39.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8821]], ## PARAMETER[&quot;Longitude of false origin&quot;,-77.75, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8822]], ## PARAMETER[&quot;Latitude of 1st standard parallel&quot;,40.9666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8823]], ## PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,39.9333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8824]], ## PARAMETER[&quot;Easting at false origin&quot;,1968500, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8826]], ## PARAMETER[&quot;Northing at false origin&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8827]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;USA - Pennsylvania - SPCS - S&quot;], ## BBOX[39.71,-80.53,41.18,-74.72]], ## ID[&quot;EPSG&quot;,2272]] 이제 인구 조사 지역을 투영했으므로 원을 정의하고 이를 인구 조사 지역의 서브세트를 구성하는 두 번째 geometry feature 세트로 사용한다. # choose a central long-lat point and radius to define circle city_hall_lng &lt;- -75.1657936 city_hall_lat &lt;- 39.952383 geo_crs &lt;- 4326 buffer &lt;- 55000 # ft (same units as crs) circle &lt;- st_sfc(st_point(c(city_hall_lng, city_hall_lat)), crs = geo_crs) %&gt;% st_transform(crs = proj_crs) %&gt;% st_buffer(dist = buffer) st_crs(circle) ## Coordinate Reference System: ## User input: EPSG:2272 ## wkt: ## PROJCRS[&quot;NAD83 / Pennsylvania South (ftUS)&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;SPCS83 Pennsylvania South zone (US Survey feet)&quot;, ## METHOD[&quot;Lambert Conic Conformal (2SP)&quot;, ## ID[&quot;EPSG&quot;,9802]], ## PARAMETER[&quot;Latitude of false origin&quot;,39.3333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8821]], ## PARAMETER[&quot;Longitude of false origin&quot;,-77.75, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8822]], ## PARAMETER[&quot;Latitude of 1st standard parallel&quot;,40.9666666666667, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8823]], ## PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,39.9333333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8824]], ## PARAMETER[&quot;Easting at false origin&quot;,1968500, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8826]], ## PARAMETER[&quot;Northing at false origin&quot;,0, ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219], ## ID[&quot;EPSG&quot;,8827]]], ## CS[Cartesian,2], ## AXIS[&quot;easting (X)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## AXIS[&quot;northing (Y)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;US survey foot&quot;,0.304800609601219]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;USA - Pennsylvania - SPCS - S&quot;], ## BBOX[39.71,-80.53,41.18,-74.72]], ## ID[&quot;EPSG&quot;,2272]] 아래 지도에서 볼 수 있듯이, 동일한 투영된 CRS에 있는이 두 가지 간단한 feature geometry 세트를 사용하여 공간 서브 세트가 준비되었다. [ "],["공간-서브세팅-구문.html", "16.4 공간 서브세팅 구문", " 16.4 공간 서브세팅 구문 R에는 동일한 결과를 얻을 수 있는 여러 가지 방법이 있다. 서브세팅을 위해 대괄호[를 사용하는 base R 메서드와 filter ()를 사용하는 tidyverse 메서드가 있습니다. 공간 서브 셋팅도 예외는 아니다. 두 옵션 모두 sf 패키지에서 사용할 수 있다. 대괄호 방법을 사용하면 구문이 매우 간단하다. 데이터 프레임의 대괄호 서브세팅과 매우 유사하다. 그러나 논리 표현식이 행을 필터링하는 대괄호 안에는 단순한 feature geometry (예 : 공간 데이터 프레임, ‘sfc_POLYGON’ 등)를 선택하여 입력하면 된다. 아래의 예에서 우리는 정의한 원과 교차하는 것으로 원래 1,186 개의 인구 조사 지역을 서브세팅한다. 그 결과 617 개의 관측치가 있는 새로운 ‘sf’ 공간 데이터 프레임이 생성된다. philly &lt;- proj_tracts[circle,] glimpse(philly) ## Rows: 617 ## Columns: 6 ## $ GEOID &lt;chr&gt; &quot;42101014500&quot;, &quot;42101004202&quot;, &quot;42101004102&quot;, &quot;42101000804&quot;... ## $ NAME &lt;chr&gt; &quot;Census Tract 145, Philadelphia County, Pennsylvania&quot;, &quot;Ce... ## $ variable &lt;chr&gt; &quot;hhincome&quot;, &quot;hhincome&quot;, &quot;hhincome&quot;, &quot;hhincome&quot;, &quot;hhincome&quot;... ## $ estimate &lt;dbl&gt; 17991, 47935, 40958, 108293, 41545, 35591, 39394, 49906, 3... ## $ moe &lt;dbl&gt; 6274, 14670, 12742, 11643, 3413, 10534, 7829, 11268, 9285,... ## $ geometry &lt;MULTIPOLYGON [US_survey_foot]&gt; MULTIPOLYGON (((2696699 244..., ... 기본적으로 st_intersects()는 공간 서브세팅을 위해 대괄호를 사용할 때 암묵적인 토폴로지 연산자이다. “op” 인수를 설정하면 기본st_intersects 대신 토폴로지 관계를 선택할 수 있다. 아래 예에서는st_disjoint()를 선택했다. NOTE : 교집합에서 반환된 617 개의 관측치와 st_disjoint()에서 반환된 569 개의 관측치가 합쳐져 원래의 1,186개의 관측치가 된다. philly_dj &lt;- proj_tracts[circle, , op = st_disjoint] nrow(philly_dj) ## [1] 569 ## [1] 569 두 번째 공간 서브세팅 방법은 “sgbp(sparse geometry binary predicate)” 클래스의 중간 개체를 만드는 것이다. 이는 기본적으로 대상 개체를 서브세팅할 때 사용할 수있는 일치하는 인덱스 목록이다. 이 방법에서는 “op” 인수를 설정하는 대신 ’st_ *’ 로 시작하는 다른 토폴로지 연산자를 사용한다. 또한 아래와 같이 구문에 약간 영향을 주는 sparse 또는 dense matrix을 반환하는 옵션이 있다. 이 방법은 dplyr를 사용하여 알 수 있듯이 tidy 워크 플로우에 더 쉽게 적용된다. # sgbp, sparse matrix philly_sparse &lt;- proj_tracts %&gt;% filter(lengths(st_intersects(x = ., y = circle)) &gt; 0) # sgbp, dense matrix philly_dense &lt;- proj_tracts %&gt;% filter(st_intersects(x = ., y = circle, sparse = FALSE)) 어떤 방법을 선택하든 상관없이 세 가지 방법 모두 동일한 CRS의 공간 데이터 프레임에서 동일한 수의 관측치를 반환해야 한다. 이 tidy 워크 플로의 한 가지 예를 제공하기 위해, 원래 공간 데이터 프레임으로 시작하여 공간 서브세팅(이 경우 ‘st_within’)을 수행하고, 결과를 ’ggplot2’로 직접 파이프하는 방법을 아래에서 확인하기 바란다. 우리가 예상했듯이 결과는 훨씬 더 작고 더 원 모양이 되어, 우리가 정의한 원의 경계 안에 들어 맞는다. city_hall &lt;- st_sfc( st_point(c(city_hall_lng, city_hall_lat)), crs = geo_crs) %&gt;% st_transform(crs = proj_crs) proj_tracts %&gt;% filter(st_within(x = ., y = circle, sparse = FALSE)) %&gt;% ggplot() + geom_sf() + geom_sf(data = circle, color = &quot;red&quot;, fill = NA) + geom_sf(data = city_hall, color = &quot;blue&quot;, size = 2) + labs(title = &quot;Census Tracts Within 55,000 ft of City Hall&quot;) [Census tracts within 55,000 feet of City Hall] "]]
